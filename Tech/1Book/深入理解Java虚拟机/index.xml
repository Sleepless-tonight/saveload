<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>深入理解Java虚拟机 on Save Load</title>
    <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
    <description>Recent content in 深入理解Java虚拟机 on Save Load</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E9%A2%98/</guid>
      <description> 深入理解Java虚拟机 标签：Java、基础、深入理解Java虚拟机 、源码解读、进阶、Java开源框架 时间：2020年8月3日18:13:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-358/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-358/</guid>
      <description> 第四部分　程序编译与代码优化 第10章　前端编译与优化 358 10.1　概述 358 10.2　Javac编译器 359 10.2.1　Javac的源码与调试 359 10.2.2　解析与填充符号表 362 10.2.3　注解处理器 363 10.2.4　语义分析与字节码生成 364 10.3　Java语法糖的味道 367 10.3.1　泛型 367 10.3.2　自动装箱、拆箱与遍历循环 375 10.3.3　条件编译 377 10.4　实战：插入式注解处理器 378 10.4.1　实战目标 379 10.4.2　代码实现 379 10.4.3　运行与测试 385 10.4.4　其他应用案例 386 10.5　本章小结 386 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-388/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-388/</guid>
      <description> 第11章　后端编译与优化 388 11.1　概述 388 11.2　即时编译器 389 11.2.1　解释器与编译器 389 11.2.2　编译对象与触发条件 392 11.2.3　编译过程 397 11.2.4　实战：查看及分析即时编译结果 398 11.3　提前编译器 404 11.3.1　提前编译的优劣得失 405 11.3.2　实战：Jaotc的提前编译 408 11.4　编译器优化技术 411 11.4.1　优化技术概览 411 11.4.2　方法内联 415 11.4.3　逃逸分析 417 11.4.4　公共子表达式消除 420 11.4.5　数组边界检查消除 421 11.5　实战：深入理解Graal编译器 423 11.5.1　历史背景 423 11.5.2　构建编译调试环境 424 11.5.3　JVMCI编译器接口 426 11.5.4　代码中间表示 429 11.5.5　代码优化与生成 432 11.6　本章小结 436 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-438/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-438/</guid>
      <description> 第五部分　高效并发 第12章　Java内存模型与线程 438 12.1　概述 438 12.2　硬件的效率与一致性 439 12.3　Java内存模型 440 12.3.1　主内存与工作内存 441 12.3.2　内存间交互操作 442 12.3.3　对于volatile型变量的特殊规则 444 12.3.4　针对long和double型变量的特殊规则 450 12.3.5　原子性、可见性与有序性 450 12.3.6　先行发生原则 452 12.4　Java与线程 455 12.4.1　线程的实现 455 12.4.2　Java线程调度 458 12.4.3　状态转换 460 12.5　Java与协程 461 12.5.1　内核线程的局限 461 12.5.2　协程的复苏 462 12.5.3　Java的解决方案 464 12.6　本章小结 465 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96-466/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96-466/</guid>
      <description> 第13章　线程安全与锁优化 466 13.1　概述 466 13.2　线程安全 466 13.2.1　Java语言中的线程安全 467 13.2.2　线程安全的实现方法 471 13.3　锁优化 479 13.3.1　自旋锁与自适应自旋 479 13.3.2　锁消除 480 13.3.3　锁粗化 481 13.3.4　轻量级锁 481 13.3.5　偏向锁 483 13.4　本章小结 485 附录A　在Windows系统下编译OpenJDK 6 486 附录B　展望Java技术的未来（2013年版） 493 附录C　虚拟机字节码指令表 499 附录D　对象查询语言（OQL）简介 506 附录E　JDK历史版本轨迹 512 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%91Java-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%91Java-2/</guid>
      <description>前言 致谢 第一部分　走近Java 第1章　走近Java 2 世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过 程。
1.1　概述 当我们在使用一门技术时，不再依赖书本和他人就能得到这些问题的答案，那才算升华到了“不 惑”的境界。
1.2　Java技术体系 从广义上讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序 都属于Java技术体系中的一员。如果仅从传统意义上来看，JCP官方[1]所定义的Java技术体系包括了以 下几个组成部分：
·Java程序设计语言 ·各种硬件平台上的Java虚拟机实现 ·Class文件格式 ·Java类库API ·来自商业机构和开源社区的第三方Java类库 我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境，本书中为行文方便，在不产生歧义的地方常以JDK 来代指整个Java技术体系[2]。可以把Java类库API中的Java SE API子集[3]和Java虚拟机这两部分统称为 JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。
1.3　Java发展史 1998年12月4日，JDK迎来了一个里程碑式的重要版本：工程代号为Playground（竞技场）的JDK 1.2，Sun在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。在这个版本中出现的代表性技术非常多，如EJB、Java Plug-in、Java IDL、Swing等，并且这个版本中Java虚拟机第一次内置了JIT（Just InTime）即时编译器（JDK 1.2中曾并存过三个虚拟机，Classic VM、HotSpot VM和Exact VM，其中Exact VM只在Solaris平台出现过；后面两款虚拟机都是内置了JIT即时编译器的，而之前版本所带的Classic VM只能以外挂的形式使用即时编译器）。在语言和API层面上，Java添加了strictfp关键字，Java类库添加了现在Java编码之中极为常用一系列Collections集合类等。在1999年3月和7月，分别有JDK 1.2.1和JDK 1.2.2两个小升级版本发布。
1999年4月27日，HotSpot 虚拟机诞生。HotSpot最初由一家名为“Longview Techno-logies”的小公司开发，由于HotSpot的优异表现，这家公司在1997年被Sun公司收购。Hot-Spot虚拟机刚发布时是作为JDK 1.2的附加程序提供的，后来它成为JDK 1.3及之后所有JDK版本的默认Java虚拟机。
2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布。相对于JDK 1.2，JDK 1.3的改进主要体现在Java类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始被作为一项平台级服务提供（以前JNDI仅仅是一项扩展服务），使用CORBA IIOP来实现RMI的通信协议，等等。这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且新添加了JavaSound类库。JDK1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8-42/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8-42/</guid>
      <description>第二部分　自动内存管理 第2章　Java内存区域与内存溢出异常 42 2.1　概述 42 本章是第二部分的第1章，笔者将从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作 用、服务对象以及其中可能产生的问题，这也是翻越虚拟机内存管理这堵围墙的第一步。
2.2　运行时数据区域 42 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域 有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是 依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存 将会包括以下几个运行时数据区域，如图2-1所示。
2.2.1　程序计数器 43 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里[1]，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。
2.2.2　Java虚拟机栈 43 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。
局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。
这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。
在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。
[1] 栈帧是方法运行期很重要的基础数据结构，在本书的第8章中还会对帧进行详细讲解。 [2] HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。 2.2.3　本地方法栈 44 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。
2.2.4　Java堆 44 对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配[1]”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换[2]优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。
Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”[3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。
如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。
根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。
Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。
[1] 《Java虚拟机规范》中的原文：The heap is the runtime data area from which memory for all class instances and arrays is allocated。 [2] 逃逸分析与标量替换的相关内容，请参见第11章的相关内容。 [3] 指新生代（其中又包含一个Eden和两个Survivor）、老年代这种划分，源自UC Berkeley在20世纪80代中期开发的Berkeley Smalltalk。历史上有多款虚拟机采用了这种设计，包括HotSpot和它的前身Self 和Strongtalk虚拟机（见第1章），原始论文是：https://dl.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-67/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-67/</guid>
      <description>第3章　垃圾收集器与内存分配策略 67 3.1　概述 67 3.2　对象已死？ 68 3.2.1　引用计数算法 68 3.2.2　可达性分析算法 70 3.2.3　再谈引用 71 3.2.4　生存还是死亡？ 72 3.2.5　回收方法区 74 3.3　垃圾收集算法 75 3.3.1　分代收集理论 75 3.3.2　标记-清除算法 77 3.3.3　标记-复制算法 78 3.3.4　标记-整理算法 79 3.4　HotSpot的算法细节实现 81 3.4.1　根节点枚举 81 3.4.2　安全点 82 3.4.3　安全区域 83 3.4.4　记忆集与卡表 84 3.4.5　写屏障 85 3.4.6　并发的可达性分析 87 3.5　经典垃圾收集器 89 3.5.1　Serial收集器 90 3.5.2　ParNew收集器 92 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-138/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-138/</guid>
      <description> 第4章　虚拟机性能监控、故障处理工具 138 4.1　概述 138 4.2　基础故障处理工具 138 4.2.1　jps：虚拟机进程状况工具 141 4.2.2　jstat：虚拟机统计信息监视工具 142 4.2.3　jinfo：Java配置信息工具 143 4.2.4　jmap：Java内存映像工具 144 4.2.5　jhat：虚拟机堆转储快照分析工具 145 4.2.6　jstack：Java堆栈跟踪工具 146 4.2.7　基础工具总结 148 4.3　可视化故障处理工具 151 4.3.1　JHSDB：基于服务性代理的调试工具 152 4.3.2　JConsole：Java监视与管理控制台 157 4.3.3　VisualVM：多合-故障处理工具 164 4.3.4　Java Mission Control：可持续在线的监控工具 171 4.4　HotSpot虚拟机插件及工具 175 4.5　本章小结 180 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-181/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-181/</guid>
      <description> 第5章　调优案例分析与实战 181 5.1　概述 181 5.2　案例分析 181 5.2.1　大内存硬件上的程序部署策略 182 5.2.2　集群间同步导致的内存溢出 184 5.2.3　堆外内存导致的溢出错误 185 5.2.4　外部命令导致系统缓慢 187 5.2.5　服务器虚拟机进程崩溃 187 5.2.6　不恰当数据结构导致内存占用过大 188 5.2.7　由Windows虚拟内存导致的长时间停顿 189 5.2.8　由安全点导致长时间停顿 190 5.3　实战：Eclipse运行速度调优 192 5.3.1　调优前的程序运行状态 193 5.3.2　升级JDK版本的性能变化及兼容问题 196 5.3.3　编译时间和类加载时间的优化 200 5.3.4　调整内存设置控制垃圾收集频率 203 5.3.5　选择收集器降低延迟 206 5.4　本章小结 209 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-212/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-212/</guid>
      <description>第三部分　虚拟机执行子系统 第6章　类文件结构 212 6.1　概述 212 6.2　无关性的基石 212 6.3　Class类文件的结构 214 6.3.1　魔数与Class文件的版本 215 6.3.2　常量池 218 6.3.3　访问标志 224 6.3.4　类索引、父类索引与接口索引集合 225 6.3.5　字段表集合 226 6.3.6　方法表集合 229 6.3.7　属性表集合 230 6.4　字节码指令简介 251 6.4.1　字节码与数据类型 251 6.4.2　加载和存储指令 253 6.4.3　运算指令 254 6.4.4　类型转换指令 255 6.4.5　对象创建与访问指令 256 6.4.6　操作数栈管理指令 256 6.4.7　控制转移指令 257 6.4.8　方法调用和返回指令 257 6.4.9　异常处理指令 258 6.4.10　同步指令 258 6.5　公有设计，私有实现 259 6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-262/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-262/</guid>
      <description> 第7章　虚拟机类加载机制 262 7.1　概述 262 7.2　类加载的时机 263 7.3　类加载的过程 267 7.3.1　加载 267 7.3.2　验证 268 7.3.3　准备 271 7.3.4　解析 272 7.3.5　初始化 277 7.4　类加载器 279 7.4.1　类与类加载器 280 7.4.2　双亲委派模型 281 7.4.3　破坏双亲委派模型 285 7.5　Java模块化系统 287 7.5.1　模块的兼容性 288 7.5.2　模块化下的类加载器 290 7.6　本章小结 292 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-293/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-293/</guid>
      <description> 第8章　虚拟机字节码执行引擎 293 8.1　概述 293 8.2　运行时栈帧结构 294 8.2.1　局部变量表 294 8.2.2　操作数栈 299 8.2.3　动态连接 300 8.2.4　方法返回地址 300 8.2.5　附加信息 301 8.3　方法调用 301 8.3.1　解析 301 8.3.2　分派 303 8.4　动态类型语言支持 315 8.4.1　动态类型语言 316 8.4.2　Java与动态类型 317 8.4.3　java.lang.invoke包 318 8.4.4　invokedynamic指令 321 8.4.5　实战：掌控方法分派规则 324 8.5　基于栈的字节码解释执行引擎 326 8.5.1　解释执行 327 8.5.2　基于栈的指令集与基于寄存器的指令集 328 8.5.3　基于栈的解释器执行过程 329 8.6　本章小结 334 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC9%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98-335/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC9%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98-335/</guid>
      <description> 第9章　类加载及执行子系统的案例与实战 335 9.1　概述 335 9.2　案例分析 335 9.2.1　Tomcat：正统的类加载器架构 335 9.2.2　OSGi：灵活的类加载器架构 338 9.2.3　字节码生成技术与动态代理的实现 341 9.2.4　Backport工具：Java的时光机器 345 9.3　实战：自己动手实现远程执行功能 348 9.3.1　目标 348 9.3.2　思路 349 9.3.3　实现 350 9.3.4　验证 355 9.4　本章小结 356 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>深入理解Java虚拟机 标签：Java、基础、深入理解Java虚拟机 、源码解读、进阶、Java开源框架 时间：2020年8月3日18:13:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 致谢 第一部分　走近Java 第1章　走近Java 2 1.1　概述 2 1.2　Java技术体系 3 1.3　Java发展史 4 1.4　Java虚拟机家族 12 1.4.1　虚拟机始祖：Sun Classic/Exact VM 12 1.4.2　武林盟主：HotSpot VM 13 1.4.3　小家碧玉：Mobile/Embedded VM 14 1.4.4　天下第二：BEA JRockit/IBM J9 VM 15 1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16 1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17 1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18 1.4.8　百家争鸣 19 1.5　展望Java技术的未来 21 1.5.1　无语言倾向 21 1.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Thinking In Java on Save Load</title>
    <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/</link>
    <description>Recent content in Thinking In Java on Save Load</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.saveload.cn/Tech/1Book/Thinking-In-Java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC10%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC10%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F/</guid>
      <description>第10章 Java IO系统 由于存在大量不同的设计方案，所以该任务的困难性是很容易证明的。其中最大的挑战似乎是如何覆盖所有可能的因素。不仅有三种不同的种类的IO需要考虑（文件、控制台、网络连接），而且需要通过大量不同的方式与它们通信（顺序、随机访问、二进制、字符、按行、按字等等）。
Java库的设计者通过创建大量类来攻克这个难题。事实上，Java的IO系统采用了如此多的类，以致刚开始会产生不知从何处入手的感觉（具有讽刺意味的是，Java的IO设计初衷实际要求避免过多的类）。从Java 1.0升级到Java 1.1后，IO库的设计也发生了显著的变化。此时并非简单地用新库替换旧库，Sun的设计人员对原来的库进行了大手笔的扩展，添加了大量新的内容。因此，我们有时不得不混合使用新库与旧库，产生令人无奈的复杂代码。
10.1 输入和输出 装饰者模式，处理不同来源的输入和输出。 直接总结：
1、能读取文件、写入文件、复制文件、利用缓冲区就行。
2、知道完成这些操作有那些步骤就行。
可将Java库的IO类分割为输入与输出两个部分，这一点在用Web浏览器阅读联机Java类文档时便可知道。通过继承，从InputStream（输入流）衍生的所有类都拥有名为read()的基本方法，用于读取单个字节或者字节数组。类似地，从OutputStream衍生的所有类都拥有基本方法write()，用于写入单个字节或者字节数组。然而，我们通常不会用到这些方法；它们之所以存在，是因为更复杂的类可以利用它们，以便提供一个更有用的接口。因此，我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供自己期望的功能。我们之所以感到Java的流库（Stream Library）异常复杂，正是由于为了创建单独一个结果流，却需要创建多个对象的缘故。
很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都从InputStream继承，而与输出有关的所有类都从OutputStream继承。
10.1.1 InputStream的类型 InputStream的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream子类）：
(1) 字节数组 (2) String对象 (3) 文件 (4) “管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。 (5) 一系列其他流，以便我们将其统一收集到单独一个流内。 (6) 其他起源地，如Internet连接等（将在本书后面的部分讲述）。 除此以外，FilterInputStream也属于InputStream的一种类型，用它可为“破坏器”类提供一个基础类，以便将属性或者有用的接口同输入流连接到一起。 具体哪种类型有何特性，自己查找API吧。
10.1.2 OutputStream的类型 具体哪种类型有何特性，自己查找API吧。
10.2 增添属性和有用的接口 利用层次化对象动态和透明地添加单个对象的能力的做法叫作“装饰器”（Decorator）方案——“方案”属于本书第16章的主题（注释①）。装饰器方案规定封装于初始化对象中的所有对象都拥有相同的接口，以便利用装饰器的“透明”性质——我们将相同的消息发给一个对象，无论它是否已被“装饰”。这正是在Java IO库里存在“过滤器”（Filter）类的原因：抽象的“过滤器”类是所有装饰器的基础类（装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中）。
子类处理要求大量子类对每种可能的组合提供支持时，便经常会用到装饰器——由于组合形式太多，造成子类处理变得不切实际。Java IO库要求许多不同的特性组合方案，这正是装饰器方案显得特别有用的原因。但是，装饰器方案也有自己的一个缺点。在我们写一个程序的时候，装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于Java IO库操作不便，我们必须创建许多类——“核心”IO类型加上所有装饰器——才能得到自己希望的单个IO对象。
FilterInputStream和FilteOutputStream分别是过滤输入流和过滤输出流,他们的作用是为基础流提供一些额外的功能
FilterInputStream和FilterOutputStream（这两个名字不十分直观）提供了相应的装饰器接口，用于控制一个特定的输入流（InputStream）或者输出流（OutputStream）。它们分别是从InputStream和OutputStream衍生出来的。此外，它们都属于抽象类，在理论上为我们与一个流的不同通信手段都提供了一个通用的接口。事实上，FilterInputStream和FilterOutputStream只是简单地模仿了自己的基础类，它们是一个装饰器的基本要求。
10.2.1 通过FilterInputStream从InputStream里读入数据 FilterInputStream类要完成两件全然不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，比如readByte()，readFloat()等等）。伴随对应的DataOutputStream，我们可通过数据“流”将基本类型的数据从一个地方搬到另一个地方。这些“地方”是由表10.1总结的那些类决定的。若读取块内的数据，并自己进行解析，就不需要用到DataInputStream。但在其他许多情况下，我们一般都想用它对自己读入的数据进行自动格式化。 剩下的类用于修改InputStream的内部行为方式：是否进行缓冲，是否跟踪自己读入的数据行，以及是否能够推回一个字符等等。后两种类看起来特别象提供对构建一个编译器的支持（换言之，添加它们为了支持Java编译器的构建），所以在常规编程中一般都用不着它们。
也许几乎每次都要缓冲自己的输入，无论连接的是哪个IO设备。所以IO库最明智的做法就是将未缓冲输入作为一种特殊情况处理，同时将缓冲输入接纳为标准做法。
10.2.2 通过FilterOutputStream向OutputStream里写入数据 与DataInputStream对应的是DataOutputStream，后者对各个基本数据类型以及String对象进行格式化，并将其置入一个数据“流”中，以便任何机器上的DataInputStream都能正常地读取它们。所有方法都以“wirte”开头，例如writeByte()，writeFloat()等等。
若想进行一些真正的格式化输出，比如输出到控制台，请使用PrintStream。利用它可以打印出所有基本数据类型以及String对象，并可采用一种易于查看的格式。这与DataOutputStream正好相反，后者的目标是将那些数据置入一个数据流中，以便DataInputStream能够方便地重新构造它们。System.out静态对象是一个PrintStream。
PrintStream内两个重要的方法是print()和println()。它们已进行了覆盖处理，可打印出所有数据类型。print()和println()之间的差异是后者在操作完毕后会自动添加一个新行。
BufferedOutputStream属于一种“修改器”，用于指示数据流使用缓冲技术，使自己不必每次都向流内物理性地写入数据。通常都应将它应用于文件处理和控制器IO。 表10.4 FilterOutputStream的类型
10.3 本身的缺陷：RandomAccessFile RandomAccessFile用于包含了已知长度记录的文件，以便我们能用seek()从一条记录移至另一条；然后读取或修改那些记录。各记录的长度并不一定相同；只要知道它们有多大以及置于文件何处即可。
首先，我们有点难以相信RandomAccessFile不属于InputStream或者OutputStream分层结构的一部分。除了恰巧实现了DataInput以及DataOutput（这两者亦由DataInputStream和DataOutputStream实现）接口之外，它们与那些分层结构并无什么关系。它甚至没有用到现有InputStream或OutputStream类的功能——采用的是一个完全不相干的类。该类属于全新的设计，含有自己的全部（大多数为固有）方法。之所以要这样做，是因为RandomAccessFile拥有与其他IO类型完全不同的行为，因为我们可在一个文件里向前或向后移动。不管在哪种情况下，它都是独立运作的，作为Object的一个“直接继承人”使用。
从根本上说，RandomAccessFile类似DataInputStream和DataOutputStream的联合使用。其中，getFilePointer()用于了解当前在文件的什么地方，seek()用于移至文件内的一个新地点，而length()用于判断文件的最大长度。此外，构建器要求使用另一个自变量（与C的fopen()完全一样），指出自己只是随机读（&amp;ldquo;r&amp;rdquo;），还是读写兼施（&amp;ldquo;rw&amp;rdquo;）。这里没有提供对“只写文件”的支持。也就是说，假如是从DataInputStream继承的，那么RandomAccessFile也有可能能很好地工作。
还有更难对付的。很容易想象我们有时要在其他类型的数据流中搜索，比如一个ByteArrayInputStream，但搜索方法只有RandomAccessFile才会提供。而后者只能针对文件才能操作，不能针对数据流操作。此时，BufferedInputStream确实允许我们标记一个位置（使用mark()，它的值容纳于单个内部变量中），并用reset()重设那个位置。但这些做法都存在限制，并不是特别有用。
10.4 File类 File类有一个欺骗性的名字——通常会认为它对付的是一个文件，但实情并非如此。它既代表一个特定文件的名字，也代表目录内一系列文件的名字。若代表一个文件集，便可用list()方法查询这个集，返回的是一个字串数组。之所以要返回一个数组，而非某个灵活的集合类，是因为元素的数量是固定的。而且若想得到一个不同的目录列表，只需创建一个不同的File对象即可。事实上，“FilePath”（文件路径）似乎是一个更好的名字。本节将向大家完整地例示如何使用这个类，其中包括相关的FilenameFilter（文件名过滤器）接口。
10.4.1 目录列表器 现在假设我们想观看一个目录列表。可用两种方式列出File对象。若在不含自变量（参数）的情况下调用list()，会获得File对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择File对象来完成显示。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC11%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC11%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/</guid>
      <description>第11章 运行期类型鉴定 总结:
其实 thinking in java 虽然将 RTTI 和 反射分开讲解，其实本质上我们看Java语言提供的功能：
利用 instanceof 来在运行期检出 对象 的类型 利用 Class.forName() 方法去获得一个未 import 对象的 Class 类 利用 java.lang.reflect.* 来获得对象的 对象信息（接口、属性、方法、修饰符） 本质上是在说明一件事：Java 提供了在运行期 完整且成系统的 创建和利用类和对象。能了解这一点并能利用使程序在运行的过程中能正确的动态的构建对象创建对象就可以了。 另需要知道的一件事是：想在运行期搞这些事情，离不开 Class 对象。因为 Java 是用 Class 对象 表示 在运行期 的 类型信息 .class 文件 ==》 JVM Class 对象 ==》 JVM new()对象 运行期类型鉴定（RTTI）的概念初看非常简单——手上只有基础类型的一个句柄时，利用它判断一个对象的正确类型。 然而，对RTTI的需要暴露出了面向对象设计许多有趣（而且经常是令人困惑的）的问题，并把程序的构造问题正式摆上了桌面。 本章将讨论如何利用Java在运行期间查找对象和类信息。这主要采取两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可在运行期独立查找类信息。首先讨论“传统”的RTTI，再讨论反射问题。
11.1 对RTTI的需要 请考虑下面这个熟悉的类结构例子，它利用了多形性。常规类型是Shape类，而特别衍生出来的类型是Circle，Square和Triangle。
这是一个典型的类结构示意图，基础类位于顶部，衍生类向下延展。面向对象编程的基本目标是用大量代码控制基础类型（这里是Shape）的句柄，所以假如决定添加一个新类（比如Rhomboid，从Shape衍生），从而对程序进行扩展，那么不会影响到原来的代码。在这个例子中，Shape接口中的动态绑定方法是draw()，所以客户程序员要做的是通过一个普通Shape句柄调用draw()。draw()在所有衍生类里都会被覆盖。而且由于它是一个动态绑定方法，所以即使通过一个普通的Shape句柄调用它，也有表现出正确的行为。这正是多形性的作用。
所以，我们一般创建一个特定的对象（Circle，Square，或者Triangle），把它上溯造型到一个Shape（忽略对象的特殊类型），以后便在程序的剩余部分使用匿名Shape句柄。
作为对多形性和上溯造型的一个简要回顾，可以象下面这样为上述例子编码（若执行这个程序时出现困难，请参考第3章3.1.2小节“赋值”）：
//: Shapes.java package c11; import java.util.*; interface Shape { void draw(); } class Circle implements Shape { public void draw() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC12%E7%AB%A0-%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC12%E7%AB%A0-%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</guid>
      <description>第12章 传递和返回对象 到目前为止，读者应对对象的“传递”有了一个较为深刻的认识，记住实际传递的只是一个句柄。
在许多程序设计语言中，我们可用语言的“普通”方式到处传递对象，而且大多数时候都不会遇到问题。但有些时候却不得不采取一些非常做法，使得情况突然变得稍微复杂起来（在C++中则是变得非常复杂）。Java亦不例外，我们十分有必要准确认识在对象传递和赋值时所发生的一切。这正是本章的宗旨。
若读者是从某些特殊的程序设计环境中转移过来的，那么一般都会问到：“Java有指针吗？”有些人认为指针的操作很困难，而且十分危险，所以一厢情愿地认为它没有好处。同时由于Java有如此好的口碑，所以应该很轻易地免除自己以前编程中的麻烦，其中不可能夹带有指针这样的“危险品”。然而准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有“戒心”，运行期系统也不例外。或者换从另一个角度说，Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做“句柄”，但你可以把它想像成“安全指针”。和预备学校为学生提供的安全剪刀类似——除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。
12.1 传递句柄 将句柄传递进入一个方法时，指向的仍然是相同的对象。
可以在调用方法前和在方法中打印对象，可以看出是一个对象。
12.1.1 别名问题 “别名”意味着多个句柄都试图指向同一个对象，就象前面的例子展示的那样。若有人向那个对象里写入一点什么东西，就会产生别名问题。若其他句柄的所有者不希望那个对象改变，恐怕就要失望了。
此时最直接的一个解决办法就是干脆不这样做：不要有意将多个句柄指向同一个作用域内的同一个对象。这样做可使代码更易理解和调试。然而，一旦准备将句柄作为一个自变量或参数传递——这是Java设想的正常方法——别名问题就会自动出现，因为创建的本地句柄可能修改“外部对象”（在方法作用域之外创建的对象）。
方法改变了自己的参数——外部对象。一旦遇到这种情况，必须判断它是否合理，用户是否愿意这样，以及是不是会造成问题。 通常，我们调用一个方法是为了产生返回值，或者用它改变为其调用方法的那个对象的状态（方法其实就是我们向那个对象“发一条消息”的方式）。很少需要调用一个方法来处理它的参数；这叫作利用方法的“副作用”（Side Effect）。所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。 若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。
12.2 制作本地副本 Java中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，实际传递的只是指向位于方法外部的那个对象的“一个句柄”。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：
■参数传递过程中会自动产生别名问题 ■不存在本地对象，只有本地句柄 ■句柄有自己的作用域，而对象没有 ■对象的“存在时间”在Java里不是个问题 ■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用） 若只是从对象中读取信息，而不修改它，传递句柄便是自变量传递中最有效的一种形式。 这种做非常恰当；默认的方法一般也是最有效的方法。然而，有时仍需将对象当作“本地的”对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响。许多程序设计语言都支持在方法内自动生成外部对象的一个本地副本（注释①）。尽管Java不具备这种能力，但允许我们达到同样的效果。
①：在C语言中，通常控制的是少量数据位，默认操作是按值传递。C++也必须遵照这一形式，但按值传递对象并非肯定是一种有效的方式。此外，在C++中用于支持按值传递的代码也较难编写，是件让人头痛的事情。
12.2.1 按值传递 首先要解决术语的问题，最适合“按值传递”的看起来是自变量。“按值传递”以及它的含义取决于如何理解程序的运行方式。最常见的意思是获得要传递的任何东西的一个本地副本，但这里真正的问题是如何看待自己准备传递的东西。对于“按值传递”的含义，目前存在两种存在明显区别的见解：
(1) Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。但若将一个句柄传递进入方法，得到的是句柄的副本。所以人们认为“一切”都按值传递。当然，这种说法也有一个前提：句柄肯定也会被传递。但Java的设计方案似乎有些超前，允许我们忽略（大多数时候）自己处理的是一个句柄。也就是说，它允许我们将句柄假想成“对象”，因为在发出方法调用时，系统会自动照管两者间的差异。 (2) Java主要按值传递（无自变量），但对象却是按引用传递的。得到这个结论的前提是句柄只是对象的一个“别名”，所以不考虑传递句柄的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它“保留但未实现”的关键字之一便是byvalue（按值）。但没人知道那个关键字什么时候可以发挥作用。 尽管存在两种不同的见解，但其间的分歧归根到底是由于对“句柄”的不同解释造成的。我打算在本书剩下的部分里回避这个问题。大家不久就会知道，这个问题争论下去其实是没有意义的——最重要的是理解一个句柄的传递会使调用者的对象发生意外的改变。 12.2.2 克隆对象 若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用clone()方法即可。Clone是“克隆”的意思，即制作完全一模一样的副本。这个方法在基础类Object中定义成“protected”（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为“public”模式。例如，标准库类Vector覆盖了clone()，所以能为Vector调用clone()，
clone()方法产生了一个Object，后者必须立即重新造型为正确类型。这个例子指出Vector的clone()方法不能自动尝试克隆Vector内包含的每个对象——由于别名问题，老的Vector和克隆的Vector都包含了相同的对象。我们通常把这种情况叫作“简单复制”或者“浅层复制”，因为它只复制了一个对象的“表面”部分。实际对象除包含这个“表面”以外，还包括句柄指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是“对象网”或“对象关系网”的由来。若能复制下所有这张网，便叫作“全面复制”或者“深层复制”。
一般来说，由于不敢保证Vector里包含的对象是“可以克隆”（注释②）的，所以最好不要试图克隆那些对象。
②：“可以克隆”用英语讲是cloneable，请留意Java库中专门保留了这样的一个关键字。
12.2.3 使类具有克隆能力 尽管克隆方法是在所有类最基本的Object中定义的，但克隆仍然不会在每个类里自动进行。这似乎有些不可思议，因为基础类方法在衍生类里是肯定能用的。但Java确实有点儿反其道而行之；如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行。
使用protected时的技巧 为避免我们创建的每个类都默认具有克隆能力，clone()方法在基础类Object里得到了“保留”（设为protected）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用clone()（尽管那样做在某些情况下特别有用，比如用多形性的方式克隆一系列对象）。在编译期的时候，这实际是通知我们对象不可克隆的一种方式——而且最奇怪的是，Java库中的大多数类都不能克隆。因此，假如我们执行下述代码： Integer x = new Integer(l); x = x.clone(); 那么在编译期，就有一条讨厌的错误消息弹出，告诉我们不可访问clone()——因为Integer并没有覆盖它，而且它对protected版本来说是默认的）。 但是，假若我们是在一个从Object衍生出来的类中（所有类都是从Object衍生的），就有权调用Object.clone()，因为它是“protected”，而且我们在一个继承器中。基础类clone()提供了一个有用的功能——它进行的是对衍生类对象的真正“按位”复制，所以相当于标准的克隆行动。然而，我们随后需要将自己的克隆操作设为public，否则无法访问。总之，克隆时要注意的两个关键问题是：几乎肯定要调用super.clone()，以及注意将克隆设为public。 有时还想在更深层的衍生类中覆盖clone()，否则就直接使用我们的clone()（现在已成为public），而那并不一定是我们所希望的（然而，由于Object.clone()已制作了实际对象的一个副本，所以也有可能允许这种情况）。protected的技巧在这里只能用一次：首次从一个不具备克隆能力的类继承，而且想使一个类变成“能够克隆”。而在从我们的类继承的任何场合，clone()方法都是可以使用的，因为Java不可能在衍生之后反而缩小方法的访问范围。换言之，一旦对象变得可以克隆，从它衍生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其“关闭”克隆能力。
实现Cloneable接口 为使一个对象的克隆能力功成圆满，还需要做另一件事情：实现Cloneable接口。这个接口使人稍觉奇怪，因为它是空的！ interface Cloneable {} 之所以要实现这个空接口，显然不是因为我们准备上溯造型成一个Cloneable，以及调用它的某个方法。有些人认为在这里使用接口属于一种“欺骗”行为，因为它使用的特性打的是别的主意，而非原来的意思。Cloneable interface的实现扮演了一个标记的角色，封装到类的类型中。 两方面的原因促成了Cloneable interface的存在。首先，可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用instanceof关键字（第11章有介绍）调查句柄是否确实同一个能克隆的对象连接： if(myHandle instanceof Cloneable) // &amp;hellip; 第二个原因是考虑到我们可能不愿所有对象类型都能克隆。所以Object.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC13%E7%AB%A0-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC13%E7%AB%A0-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%89%87/</guid>
      <description> 第13章 创建窗口和程序片 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>第14章 多线程 利用对象，可将一个程序分割成相互独立的区域。我们通常也需要将一个程序转换成多个独立运行的子任务。
象这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。
这时理解一些定义对以后的学习狠有帮助。“进程”是指一种“自包容”的运行程序，有自己的地址空间。“多任务”操作系统能同时运行多个进程（程序）——但实际是由于CPU分时机制的作用，使每个进程都能循环获得自己的CPU时间片。但由于轮换速度非常快，使得所有程序好象是在“同时”运行一样。“线程”是进程内部单一的一个顺序控制流。因此，一个进程可能容纳了多个同时执行的线程。
多线程的应用范围很广。但在一般情况下，程序的一些部分同特定的事件或资源联系在一起，同时又不想为它而暂停程序其他部分的执行。这样一来，就可考虑创建一个线程，令其与那个事件或资源关联到一起，并让它独立于主程序运行。一个很好的例子便是“Quit”或“退出”按钮——我们并不希望在程序的每一部分代码中都轮询这个按钮，同时又希望该按钮能及时地作出响应（使程序看起来似乎经常都在轮询它）。事实上，多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。
14.1 反应灵敏的用户界面 作为我们的起点，请思考一个需要执行某些CPU密集型计算的程序。由于CPU“全心全意”为那些计算服务，所以对用户的输入十分迟钝，几乎没有什么反应。在这里，我们用一个合成的applet/application（程序片／应用程序）来简单显示出一个计数器的结果：
//: Counter1.java // A non-responsive user interface package c14; import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter1 extends Applet { private int count = 0; private Button onOff = new Button(&amp;#34;Toggle&amp;#34;), start = new Button(&amp;#34;Start&amp;#34;); private TextField t = new TextField(10); private boolean runFlag = true; public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } public void go() { while (true) { try { Thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>第15章 网络编程 历史上的网络编程都倾向于困难、复杂，而且极易出错。
程序员必须掌握与网络有关的大量细节，有时甚至要对硬件有深刻的认识。一般地，我们需要理解连网协议中不同的“层”（Layer）。而且对于每个连网库，一般都包含了数量众多的函数，分别涉及信息块的连接、打包和拆包；这些块的来回运输；以及握手等等。这是一项令人痛苦的工作。
但是，连网本身的概念并不是很难。我们想获得位于其他地方某台机器上的信息，并把它们移到这儿；或者相反。这与读写文件非常相似，只是文件存在于远程机器上，而且远程机器有权决定如何处理我们请求或者发送的数据。
Java最出色的一个地方就是它的“无痛苦连网”概念。有关连网的基层细节已被尽可能地提取出去，并隐藏在JVM以及Java的本机安装系统里进行控制。我们使用的编程模型是一个文件的模型；事实上，网络连接（一个“套接字”）已被封装到系统对象里，所以可象对其他数据流那样采用同样的方法调用。除此以外，在我们处理另一个连网问题——同时控制多个网络连接——的时候，Java内建的多线程机制也是十分方便的。
本章将用一系列易懂的例子解释Java的连网支持。
15.1 机器的标识 当然，为了分辨来自别处的一台机器，以及为了保证自己连接的是希望的那台机器，必须有一种机制能独一无二地标识出网络内的每台机器。早期网络只解决了如何在本地网络环境中为机器提供唯一的名字。但Java面向的是整个因特网，这要求用一种机制对来自世界各地的机器进行标识。为达到这个目的，我们采用了IP（互联网地址）的概念。IP以两种形式存在着：
(1) 大家最熟悉的DNS（域名服务）形式。我自己的域名是bruceeckel.com。所以假定我在自己的域内有一台名为Opus的计算机，它的域名就可以是Opus.bruceeckel.com。这正是大家向其他人发送电子函件时采用的名字，而且通常集成到一个万维网（WWW）地址里。
(2) 此外，亦可采用“四点”格式，亦即由点号（.）分隔的四组数字，比如202.98.32.111。 不管哪种情况，IP地址在内部都表达成一个由32个二进制位（bit）构成的数字（注释①），所以IP地址的每一组数字都不能超过255。利用由java.net提供的static InetAddress.getByName()，我们可以让一个特定的Java对象表达上述任何一种形式的数字。结果是类型为InetAddress的一个对象，可用它构成一个“套接字”（Socket），大家在后面会见到这一点。
①：这意味着最多只能得到40亿左右的数字组合，全世界的人很快就会把它用光。但根据目前正在研究的新IP编址方案，它将采用128 bit的数字，这样得到的唯一性IP地址也许在几百年的时间里都不会用完。
作为运用InetAddress.getByName()一个简单的例子，请考虑假设自己有一家拨号连接因特网服务提供者（ISP），那么会发生什么情况。每次拨号连接的时候，都会分配得到一个临时IP地址。但在连接期间，那个IP地址拥有与因特网上其他IP地址一样的有效性。如果有人按照你的IP地址连接你的机器，他们就有可能使用在你机器上运行的Web或者FTP服务器程序。当然这有个前提，对方必须准确地知道你目前分配到的IP。由于每次拨号连接获得的IP都是随机的，怎样才能准确地掌握你的IP呢？ 下面这个程序利用InetAddress.getByName()来产生你的IP地址。为了让它运行起来，事先必须知道计算机的名字。该程序只在Windows 95中进行了测试，但大家可以依次进入自己的“开始”、“设置”、“控制面板”、“网络”，然后进入“标识”卡片。其中，“计算机名称”就是应在命令行输入的内容。
//: WhoAmI.java // Finds out your network address when you&amp;#39;re // connected to the Internet. package c15; import java.net.*; public class WhoAmI { public static void main(String[] args) throws Exception { if(args.length != 1) { System.err.println( &amp;#34;Usage: WhoAmI MachineName&amp;#34;); System.exit(1); } InetAddress a = InetAddress.getByName(args[0]); System.out.println(a); } } ///:~ 就我自己的情况来说，机器的名字叫作“Colossus”（来自同名电影，“巨人”的意思。我在这台机器上有一个很大的硬盘）。所以一旦连通我的ISP，就象下面这样执行程序：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC16%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC16%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</guid>
      <description>第16章 设计范式 16.1 范式的概念 将保持不变的东西身上发生的变化孤立出来
设计范式：可以说对问题不变的地方抽象总结
变化的影响隔离出来
在最开始，可将范式想象成一种特别聪明、能够自我适应的手法，它可以解决特定类型的问题。也就是说，它类似一些需要全面认识某个问题的人。在了解了问题的方方面面以后，最后提出一套最通用、最灵活的解决方案。具体问题或许是以前见到并解决过的。然而，从前的方案也许并不是最完善的，大家会看到它如何在一个范式里具体表达出来。
尽管我们称之为“设计范式”，但它们实际上并不局限于设计领域。思考“范式”时，应脱离传统意义上分析、设计以及实施的思考方式。相反，“范式”是在一个程序里具体表达一套完整的思想，所以它有时可能出现在分析阶段或者高级设计阶段。这一点是非常有趣的，因为范式具有以代码形式直接实现的形式，所以可能不希望它在低级设计或者具体实施以前显露出来（而且事实上，除非真正进入那些阶段，否则一般意识不到自己需要一个范式来解决问题）。
范式的基本概念亦可看成是程序设计的基本概念：添加一层新的抽象！只要我们抽象了某些东西，就相当于隔离了特定的细节。而且这后面最引人注目的动机就是“将保持不变的东西身上发生的变化孤立出来”。这样做的另一个原因是一旦发现程序的某部分由于这样或那样的原因可能发生变化，我们一般都想防止那些改变在代码内部繁衍出其他变化。这样做不仅可以降低代码的维护代价，也更便于我们理解（结果同样是降低开销）。
为设计出功能强大且易于维护的应用项目，通常最困难的部分就是找出我称之为“领头变化”的东西。这意味着需要找出造成系统改变的最重要的东西，或者换一个角度，找出付出代价最高、开销最大的那一部分。一旦发现了“领头变化”，就可以为自己定下一个焦点，围绕它展开自己的设计。
所以设计范式的最终目标就是将代码中变化的内容隔离开。如果从这个角度观察，就会发现本书实际已采用了一些设计范式。举个例子来说，继承可以想象成一种设计范式（类似一个由编译器实现的）。在都拥有同样接口（即保持不变的东西）的对象内部，它允许我们表达行为上的差异（即发生变化的东西）。合成亦可想象成一种范式，因为它允许我们修改——动态或静态——用于实现类的对象，所以也能修改类的运作方式。
在《Design Patterns》一书中，大家还能看到另一种范式：“继承器”（即Iterator，Java 1.0和1.1不负责任地把它叫作Enumeration，即“枚举”；Java1.2的集合则改回了“继承器”的称呼）。当我们在集合里遍历，逐个选择不同的元素时，继承器可将集合的实施细节有效地隐藏起来。利用继承器，可以编写出通用的代码，以便对一个序列里的所有元素采取某种操作，同时不必关心这个序列是如何构建的。这样一来，我们的通用代码即可伴随任何能产生继承器的集合使用。
16.1.1 单子 单例模式 枚举 是实现单例模式的最佳方法。它不仅能避免多线程同步问题，它更简洁，自动支持序列化机制，绝对防止多次实例化。
或许最简单的设计范式就是“单子”（Singleton），它能提供对象的一个（而且只有一个）实例。单子在Java库中得到了应用，但下面这个例子显得更直接一些：
//: SingletonPattern.java // The Singleton design pattern: you can // never instantiate more than one. package c16; // Since this isn&amp;#39;t inherited from a Cloneable // base class and cloneability isn&amp;#39;t added, // making it final prevents cloneability from // being added in any derived classes: final class Singleton { private static Singleton s = new Singleton(47); private int i; private Singleton(int x) { i = x; } public static Singleton getHandle() { return s; } public int getValue() { return i; } public void setValue(int x) { i = x; } } public class SingletonPattern { public static void main(String[] args) { Singleton s = Singleton.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC17%E7%AB%A0-%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC17%E7%AB%A0-%E9%A1%B9%E7%9B%AE/</guid>
      <description>第17章 项目 17.1 文字处理 17.2 方法查找工具 17.3 复杂性理论 17.4 总结 17.5 练习 附录A 使用非JAVA代码 附录B 对比C++和Java 附录C Java编程规则 附录D 性能 附录E 关于垃圾收集的一些话 附录F 推荐读物 (9) 第9章：违例差错控制 (10) 第10章：Java IO系统 (11) 第11章：运行期类型鉴定 (12) 第12章：传递和返回对象 (13) 第13章：创建窗口和程序片 (14) 第14章：多线程 (15) 第15章 网络编程 (16) 第16章 设计范式 (17) 第17章 项目 (18) 附录A：使用非Java代码 (19) 附录B：对比C++和Java (20) 附录C：Java编程规则 (21) 附录D：性能 (22) 附录E：关于垃圾收集的一些话 (23) 附录F：推荐读物</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/</guid>
      <description>第 1 章：对象入门 面向对象编程（OOP）
1.1 抽象的进步 所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。
1.2 对象的接口 我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做哪些事情。
1.3 实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员。
1.4 方案的重复使用 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。
新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。
轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。
1.5 继承：重新使用接口 在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。
1.5.1 改善基础类 改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。
继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；
1.6 多形对象的互换使用 通常，继承最终会以创建一系列类收场，所有类都建立在统一的基础接口上。
对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。
把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。
1.6.1 动态绑定 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）（多态性）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。
1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。
亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。
interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。
备注：这是一段个人的总结：interface（接口）更倾向于表明这个类是能干什么事，也就是说这类的类实现了哪些方法及继承与此接口的类必需要实现哪些方法；接口更像一个规范文件(协议)。abstract（抽象）更倾向于表明一类类的共有特性，由基础类或一个接口衍生的一系列类的共有特性，所以不仅仅表明这个类能干哪些事。也就是说 interface（接口）的方法都可以在接口中无实现，只规定了子类必须需要实现哪些方法，而 abstract（抽象）可以把子类相同实现的方法在抽象类里实现，子类各自特别且必须的方法用抽象方法规定然后在子类里各自实现。abstract（抽象）可以看为一种跟 public、static 同级别的修饰符（修饰了类（class）和方法），而 interface（接口）可以看为一种跟 class 同级别的修饰符，标志着质的改变。interface（接口）可以说是对 abstract（抽象）的抽象。interface（接口）帮助了对象的分层，各组件之间的松耦合。interface 语法要求：1、接口可以包含：静态常量、方法（抽象）、内部类（接口、枚举）、默认方法（类方法）2、接口只可以继承多个父接口（之间用英文逗号“,”隔开），不能继承类。3、接口修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有相同包结构下才可以访问该接口。4、接口内的所有成员都是 public 访问权限，可省略，如果指定则只可使用 public 访问修饰符。5、接口的成员变量均为静态常量，不管是否使用 public static final 修饰符都认为只可做如此修饰。6、接口的方法只能是抽象、类方法、默认方法，如果不是默认方法，系统将自动为普通方法增加 public abstract 修饰符，且不能有方法实现（方法体），类方法、默认方法必须有方法实现（方法体）。7、定义默认方法，需要用 default 修饰且默认添加 public 修饰 ，默认方法不能用 static 修饰，所以不能直接用接口来调用默认方法，由接口的实现类的实例来调用这些默认方法。8、类方法需用 static 修饰 ，可用接口直接调用。9、接口的内部类（接口、枚举）默认采用 public static 修饰符。10、接口可看做为特殊的类，受限于一个源文件只能有一个 public 修饰。11、接口不能创建实例，作为声明引用类型变量时此接口必须有其实现类。abstract 语法要求：1、有抽象方法的类只能是抽象类2、抽象类里可没有抽象方法有普通方法3、抽象类不能被实例化4、抽象类可以包含：成员变量、方法（普通、抽象）、构造器、初始化快、内部类（接口、枚举）、抽象类的构造器不能用于创造实列，主要用于被其子类调用5、抽象不能修饰变量（成员、局部），不能修饰构造器，抽象类里的构造器只能是普通的构造器。总结如下：1、抽象类与普通类相比“一得一失”：1、“得”可包含抽象方法。2、“失”无法被实列化。2、抽象类是用来被它的子类继承的，方法由子类实现。而 final 修饰的类不能被继承， final 修饰的方法不能被重写，所以 final 和 abstract 是互斥的。3、static 修饰方法是属于这个类本身的（类Class和实列Object的区别），如果该方法被定义成抽象方法，通过类调用的时候也会出错，因为调用了一个没有方法实体的方法，所以 static 和 abstract 是互斥的（非绝对，可以同时修饰内部类）。4、abstract 修饰的方法必须被之类重写才有意义，因此 abstract 方法不能是私有的，所以 private 和 abstract 是互斥的。 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</guid>
      <description>第 2 章：一切都是对象 Java语言首先便假定了我们只希望进行面向对象的程序设计。
2.1 用句柄操纵对象 将一切都“看作”对象，操纵的 标识符 实际是指向一个对象的“句柄”（Handle）。
创建一个String句柄：String s;这里创建的只是句柄，并不是对象。s实际并未与任何东西连接（即“没有实体”）。一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：String s = &amp;#34;asdf&amp;#34;;总结：句柄指向对象，通过句柄操作对象，句柄是句柄，对象是对象。 2.2 所有对象都必须创建 创建句柄时，我们希望它同一个新对象连接。通常用 new 关键字达到这一目的。。new的意思是：“把我变成这些对象的一种新实体”。
2.2.1 保存到什么地方 程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：
在Java中是不可能得到真正的内存地址的，也不会提供直接操作“内存地址”的方式。
Java中堆是由JVM管理的不能直接操作。
(1) 寄存器： 位于处理器内部。这是最快的保存区域。 以寄存器是根据需要由编译器分配。 我们对此没有直接的控制权。 (2) 堆栈（stack）： 驻留于常规RAM（随机访问存储器）区域，这是一种特别快、特别有效的数据保存方式，仅次于寄存器。 创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性。 有些Java数据要保存在堆栈里——基本类型数据、对象句柄，但Java对象并不放到其中。 每个线程都有自己独立的栈。 (3) 堆（Heap）： 一种常规用途的内存池（也在RAM区域），在堆里分配存储空间时会花掉更长的时间！ 编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。 保存了Java对象。 堆在整个JVM中只有一个（所以堆中的数据可被多个线程共享），堆里面的内存空间由GC来负责回收。 (4) 静态存储 ： 这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。 程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。 Java对象本身永远都不会置入静态存储空间。 (5) 常数存储 ： 常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。 (6) 非RAM存储 ： 若数据完全独立于一个程序之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。 2.2.2 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用new创建对象（特别是小的、简单的变量）并不是非常有效，因为new将对象置于“堆”里。对于这些类型，Java采纳了与C和C++相同的方法。也就是说，不是用new创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，并置于堆栈中，能够更高效地存取。
Java决定了每种主要类型的大小。(8bit=1byte)
主类型 大小 封装器类型 boolean 1-bit Boolean byte 8-bit Byte[11] char 16-bit Character short 16-bit Short int 32-bit Integer long 64-bit Long float 32-bit Float double 64-bit Double 注意：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC3%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC3%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/</guid>
      <description>第3章 控制程序流程 程序必须能操纵自己的世界，在执行过程中作出判断与选择。
3.1 使用Java运算符 几乎所有运算符都只能操作“主类型”（Primitives）（基本类型）。唯一的例外是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。除此以外，String类支持“+”和“+=”。
3.1.1 优先级 运算符的优先级决定了存在多个运算符时一个表达式各部分的计算顺序。
3.1.2 赋值 赋值是用等号运算符（=）进行的。它的意思是“取得右边的值，把它复制到左边”。
右边的值可以是任何常数、变量或者表达式，只要能产生一个值就行。但左边的值必须是一个明确的、已命名的变量。
对主数据类型的赋值是非常直接的。由于主类型容纳了实际的值，而且并非指向一个对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。
但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向最初只有D才指向的那个对象。
3.1.3 算术运算符 Java的基本算术运算符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及模数（%，从整数除法中获得余数）。整数除法会直接砍掉小数，而不是进位。
一元加、减运算符 一元减号（-）和一元加号（+）与二元加号和减号都是相同的运算符。
例如： x = -a; 一元减号得到的运算对象的负值。一元加号的含义与一元减号相反，虽然它实际并不做任何事情。
3.1.4 自动递增和递减 两种很不错的快捷运算方式是递增和递减运算符（常称作“自动递增”和“自动递减”运算符）。其中，递减运算符是“&amp;ndash;”，意为“减少一个单位”；递增运算符是“++”，意为“增加一个单位”。举个例子来说，假设A是一个int（整数）值，则表达式++A就等价于（A = A + 1）。
对每种类型的运算符，都有两个版本可供选用；通常将其称为“前缀版”和“后缀版”。。对于前递增和前递减（如++A或&amp;ndash;A），会先执行运算，再生成值。而对于后递增和后递减（如A++或A&amp;ndash;），会先生成值，再执行运算。
3.1.5 关系运算符 关系运算符生成的是一个“布尔”（Boolean）结果。它们评价的是运算对象值之间的关系。若关系是真实的，关系表达式会生成 true（真）；若关系不真实，则生成 false（假）。关系运算符包括小于（&amp;lt;）、大于（&amp;gt;）、小于或等于（&amp;lt;=）、大于或等于（&amp;gt;=）、等于（==）以及不等于（!=）。等于和不等于适用于所有内建的数据类型，但其他比较不适用于 boolean 类型。
1、检查对象是否相等 关系运算符==和!=也适用于所有对象。 ==和!=比较的就是对象句柄。 若想对比两个对象的实际内容是否相同？此时，必须使用所有对象都适用的特殊方法equals()。 于 equals()的默认行为是比较句柄。 多数Java类库都实现了equals()，所以它实际比较的是对象的内容，而非它们的句柄。 3.1.6 逻辑运算符 逻辑运算符AND（&amp;amp;&amp;amp;）、OR（||）以及NOT（!）能生成一个布尔值（true或false）。
短路 操作逻辑运算符时，我们会遇到一种名为“短路”的情况。这意味着只有明确得出整个表达式真或假的结论，才会对表达式进行逻辑求值。因此，一个逻辑表达式的所有部分都有可能不进行求值。
短路就是说，当逻辑运算表达式的结果已经得出，剩余的逻辑表达式将不会得到执行。）
3.1.7 按位运算符 二进制下用 1 表示真，0 表示假
按位运算符允许我们操作一个整数主数据类型中的单个“比特”，即二进制位。按位运算符会对两个自变量中对应的位执行布尔代数，并最终生成一个结果。
若两个输入位都是1，则按位AND运算符（&amp;amp;）在输出位里生成一个1；否则生成0。
1 &amp;amp; 1 = 1 0 &amp;amp; 1 = 0 1 &amp;amp; 0 = 0 0 &amp;amp; 0 = 0 若两个输入位里至少有一个是1，则按位OR运算符（|）在输出位里生成一个1；只有在两个输入位都是0的情况下，它才会生成一个0。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC4%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC4%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/</guid>
      <description>第4章 初始化和清除 “随着计算机的进步，‘不安全’的程序设计已成为造成编程代价高昂的罪魁祸首之一。”
“初始化”和“清除”是这些安全问题的其中两个。
C++为我们引入了“构建器”的概念。这是一种特殊的方法，在一个对象创建之后自动调用。Java也沿用了这个概念，但新增了自己的“垃圾收集器”，能在资源不再需要的时候自动释放它们。本章将讨论初始化和清除的问题，以及Java如何提供它们的支持。
4.1 用构建器自动初始化 对于方法的创建，可将其想象成为自己写的每个类都调用一次initialize()。这个名字提醒我们在使用对象之前，应首先进行这样的调用。但不幸的是，这也意味着用户必须记住调用方法。在Java中，由于提供了名为“构建器”的一种特殊方法，所以类的设计者可担保每个对象都会得到正确的初始化。若某个类有一个构建器，那么在创建对象时，Java会自动调用那个构建器——甚至在用户毫不知觉的情况下。所以说这是可以担保的！（也叫：构造器）
构建器的名字与类名相同。这样一来，可保证象这样的一个方法会在初始化期间自动调用。
一旦创建一个对象：
new Rock(); 就会分配相应的存储空间，并调用构建器。请注意所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 和其他任何方法一样，构建器也能使用自变量。
利用构建器的自变量，我们可为一个对象的初始化设定相应的参数。
构建器属于一种较特殊的方法类型，因为它没有返回值。这与 void 返回值存在着明显的区别。对于void返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。
4.2 方法过载（overload，也翻译成重载） 我们创建一个对象时，会分配一个名字代表这个类。我们用名字引用或描述所有对象与方法。
在日常生活中，我们用相同的词表达多种不同的含义——即词的“过载”。
大多数程序设计语言（特别是C）要求我们为每个函数都设定一个独一无二的标识符。在Java里，允许方法名出现过载情况。
4.2.1 区分过载方法 规则：每个过载的方法都必须采取独一无二的自变量类型列表。
4.2.2 主类型的过载 主（数据）类型能从一个“较小”的类型自动转变成一个“较大”的类型。涉及过载问题时，这会稍微造成一些混乱。
分两种情况： 1、若我们的数据类型“小于”方法中使用的自变量类型，就会对那种数据类型进行“转型”处理。 2、若我们的数据类型.“大于”过载方法期望的自变量类型，就必须用括号中的类型名将其“强转”处理。这是一种缩小转换”。也就是说，在造型或转型过程中可能丢失一些信息。 4.2.3 返回值过载 我们也可能调用一个方法，同时忽略返回值；
例如： f(); void f() {} int f() {} 所以不能根据返回值类型来区分过载的方法。
4.2.4 默认构建器 创建一个没有构建器的类，则编译程序会帮我们自动创建一个默认无参的构建器，如果已经定义了一个构建器（无论是否有自变量），编译程序都不会帮我们自动合成一个。
4.2.5 this关键字 假定我们在一个方法的内部，并希望获得当前对象的句柄。由于那个句柄是由编译器“秘密”传递的，所以没有标识符可用。然而，针对这一目的有个专用的关键字：this。this关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。
1、在构建器里调用构建器
若为一个类写了多个构建器，那么经常都需要在一个构建器里调用另一个构建器，以避免写重复的代码。可用this关键字做到这一点。
例如： public class Test { private int petalCount = 0; private String s = new String(&amp;#34;null&amp;#34;); Test(int petals) { petalCount = petals; System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC5%E7%AB%A0-%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC5%E7%AB%A0-%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>第 5 章 隐藏实施过程 “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。”
这一点对于库来说是特别重要的。那个库的用户（客户程序员）必须能依赖自己使用的那一部分，并知道一旦新版本的库出台，自己不需要改写代码。而与此相反，库的创建者必须能自由地进行修改与改进，同时保证客户程序员代码不会受到那些变动的影响。
为达到这个目的，需遵守一定的约定或规则。例如，库程序员在修改库内的一个类时，必须保证不删除已有的方法，因为那样做会造成客户程序员代码出现断点。然而，相反的情况却是令人痛苦的。对于一个数据成员，库的创建者怎样才能知道哪些数据成员已受到客户程序员的访问呢？若方法属于某个类唯一的一部分，而且并不一定由客户程序员直接使用，那么这种痛苦的情况同样是真实的。如果库的创建者想删除一种旧有的实施方案，并置入新代码，此时又该怎么办呢？对那些成员进行的任何改动都可能中断客户程序员的代码。所以库创建者处在一个尴尬的境地，似乎根本动弹不得。
为解决这个问题，Java推出了“访问指示符”的概念，允许库创建者声明哪些东西是客户程序员可以使用的，哪些是不可使用的。这种访问控制的级别在“最大访问”和“最小访问”的范围之间，分别包括：public，“友好的”（无关键字），protected以及private。根据前一段的描述，大家或许已总结出作为一名库设计者，应将所有东西都尽可能保持为“private”（私有），并只展示出那些想让客户程序员使用的方法。这种思路是完全正确的，尽管它有点儿违背那些用其他语言（特别是C）编程的人的直觉，那些人习惯于在没有任何限制的情况下访问所有东西。到这一章结束时，大家应该可以深刻体会到Java访问控制的价值。
然而，组件库以及控制谁能访问那个库的组件的概念现在仍不是完整的。仍存在这样一个问题：如何将组件绑定到单独一个统一的库单元里。这是通过Java的package（打包）关键字来实现的，而且访问指示符要受到类在相同的包还是在不同的包里的影响。所以在本章的开头，大家首先要学习库组件如何置入包里。这样才能理解访问指示符的完整含义。
5.1 包：库单元 我们用import关键字导入一个完整的库时，就会获得“包”（Package）。例如：
import java.util.*; 它的作用是导入完整的实用工具（Utility）库，该库属于标准Java开发工具包的一部分。由于Vector位于java.util里，所以现在要么指定完整名称“java.util.Vector”（可省略import语句），要么简单地指定一个“Vector”（因为import是默认的）。
若想导入单独一个类，可在import语句里指定那个类的名字：
import java.util.Vector; 之所以要进行这样的导入，是为了提供一种特殊的机制，以便管理“命名空间”（Name Space）。我们所有类成员的名字相互间都会隔离起来。位于类A内的一个方法f()不会与位于类B内的、拥有相同“签名”（自变量列表）的f()发生冲突。但类名会不会冲突呢？假设创建一个stack类，将它安装到已有一个stack类（由其他人编写）的机器上，这时会出现什么情况呢？对于因特网中的Java应用，这种情况会在用户毫不知晓的时候发生，因为类会在运行一个Java程序的时候自动下载。
正是由于存在名字潜在的冲突，所以特别有必要对Java中的命名空间进行完整的控制，而且需要创建一个完全独一无二的名字，无论因特网存在什么样的限制
迄今为止，本书的大多数例子都仅存在于单个文件中，而且设计成局部（本地）使用，没有同包名发生冲突（在这种情况下，类名置于“默认包”内）。这是一种有效的做法，而且考虑到问题的简化，本书剩下的部分也将尽可能地采用它。然而，若计划创建一个“对因特网友好”或者说“适合在因特网使用”的程序，必须考虑如何防止类名的重复。 为Java创建一个源码文件的时候，它通常叫作一个“编辑单元”（有时也叫作“翻译单元”）。每个编译单元都必须有一个以.java结尾的名字。而且在编译单元的内部，可以有一个公共（public）类，它必须拥有与文件相同的名字（包括大小写形式，但排除.java文件扩展名）。如果不这样做，编译器就会报告出错。每个编译单元内都只能有一个public类（同样地，否则编译器会报告出错）。那个编译单元剩下的类（如果有的话）可在那个包外面的世界面前隐藏起来，因为它们并非“公共”的（非public），而且它们由用于主public类的“支撑”类组成。
编译一个.java文件时，我们会获得一个名字完全相同的输出文件；但对于.java文件中的每个类，它们都有一个.class扩展名。因此，我们最终从少量的.java文件里有可能获得数量众多的.class文件。如以前用一种汇编语言写过程序，那么可能已习惯编译器先分割出一种过渡形式（通常是一个.obj文件），再用一个链接器将其与其他东西封装到一起（生成一个可执行文件），或者与一个库封装到一起（生成一个库）。但那并不是Java的工作方式。一个有效的程序就是一系列.class文件，它们可以封装和压缩到一个JAR文件里（使用Java 1.1提供的jar工具）。Java解释器负责对这些文件的寻找、装载和解释（注释①）。
①：Java并没有强制一定要使用解释器。一些固有代码的Java编译器可生成单独的可执行文件。
class 文件径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。
当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的“机器语言”。
与普通程序不同的是，Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。
在cmd下使用javac 编译某一java文件则会产生.class文件,用java +类名运行。
“库”也由一系列类文件构成。每个文件都有一个public类（并没强迫使用一个public类，但这种情况最很典型的），所以每个文件都有一个组件。如果想将所有这些组件（它们在各自独立的.java和.class文件里）都归纳到一起，那么package关键字就可以发挥作用）。
若在一个文件的开头使用下述代码：
package mypackage; 那么 package 语句必须作为文件的第一个非注释语句出现。该语句的作用是指出这个编译单元属于名为mypackage的一个库的一部分。或者换句话说，它表明这个编译单元内的public类名位于mypackage这个名字的下面。如果其他人想使用这个名字，要么指出完整的名字，要么与mypackage联合使用import关键字（使用前面给出的选项）。注意根据Java包（封装）的约定，名字内的所有字母都应小写，甚至那些中间单词亦要如此。
每个 .java 文件中只能有一个 public类
现在，如果有人想使用 MyClass，或者想使用 mypackage 内的其他任何 public类，他们必须用 import关键字激活 mypackage内的名字，使它们能够使用。另一个办法则是指定完整的名称：
mypackage.MyClass m = new mypackage.MyClass(); 或者
import mypackage.*; // . . . MyClass m = new MyClass(); 一定要记住 package 和 import 关键字允许我们做的事情就是分割单个全局命名空间，保证我们不会遇到名字的冲突——无论有多少人使用因特网，也无论多少人用Java编写自己的类。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E5%86%8D%E7%94%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E5%86%8D%E7%94%9F/</guid>
      <description>第 6 章 类再生 代码的重复使用
第一个最简单：在新类里简单地创建原有类的对象。我们把这种方法叫作“合成”，因为新类由现有类的对象合并而成。我们只是简单地重复利用代码的功能，而不是采用它的形式。 第二种方法则显得稍微有些技巧。它创建一个新类，将其作为现有类的一个“类型”。我们可以原样采取现有类的形式，并在其中加入新代码，同时不会对现有的类产生影响。这种魔术般的行为叫作“继承”（Inheritance），涉及的大多数工作都是由编译器完成的。对于面向对象的程序设计，“继承”是最重要的基础概念之一。 6.1 合成的语法 为进行合成，我们只需在新类里简单地置入对象句柄即可。对于非基本类型的对象来说，只需将句柄置于新类即可；而对于基本数据类型来说，则需在自己的类中定义它们。
每种非基本类型的对象都有一个toString()方法。若编译器本来希望一个String，但却获得某个这样的对象，就会调用这个方法（意思是说，把对象当 String 用的时候就会调用这个方法）。
在类内作为字段使用的基本数据会初始化成零，就象第2章指出的那样。但对象句柄会初始化成null。而且假若试图为它们中的任何一个调用方法，就会产生一次“违例”。这种结果实际是相当好的（而且很有用），我们可在不丢弃一次违例的前提下，仍然把它们打印出来。
编译器并不只是为每个句柄创建一个默认对象，因为那样会在许多情况下招致不必要的开销。如希望句柄得到初始化，可在下面这些地方进行： 在对象定义的时候。这意味着它们在构建器调用之前肯定能得到初始化。 在那个类的构建器中。 紧靠在要求实际使用那个对象之前。这样做可减少不必要的开销——假如对象并不需要创建的话。 下面向大家展示了所有这三种方法： //: Bath.java // Constructor initialization with composition class Soap { private String s; Soap() { System.out.println(&amp;#34;Soap()&amp;#34;); s = new String(&amp;#34;Constructed&amp;#34;); } public String toString() { return s; } } public class Bath { private String // Initializing at point of definition: s1 = new String(&amp;#34;Happy&amp;#34;), s2 = &amp;#34;Happy&amp;#34;, s3, s4; Soap castille; int i; float toy; Bath() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC7%E7%AB%A0-%E5%A4%9A%E5%BD%A2%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC7%E7%AB%A0-%E5%A4%9A%E5%BD%A2%E6%80%A7/</guid>
      <description>第7章 多形性 “对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。”
“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。
通过合并各种特征与行为，封装技术可创建出新的数据类型。通过对具体实施细节的隐藏，可将接口与实施细节分离，使所有细节成为“private”（私有）。这种组织方式使那些有程序化编程背景人感觉颇为舒适。但多形性却涉及对“类型”的分解。通过上一章的学习，大家已知道通过继承可将一个对象当作它自己的类型或者它自己的基础类型对待。这种能力是十分重要的，因为多个类型（从相同的基础类型中衍生出来）可被当作同一种类型对待。而且只需一段代码，即可对所有不同的类型进行同样的处理。利用具有多形性的方法调用，一种类型可将自己与另一种相似的类型区分开，只要它们都是从相同的基础类型中衍生出来的。这种区分是通过各种方法在行为上的差异实现的，可通过基础类实现对那些方法的调用。
在这一章中，大家要由浅入深地学习有关多形性的问题（也叫作动态绑定、推迟绑定或者运行期绑定）。同时举一些简单的例子，其中所有无关的部分都已剥除，只保留与多形性有关的代码。
7.1 上溯造型 在第 6 章，大家已知道可将一个对象作为它自己的类型使用，或者作为它的基础类型的一个对象使用。取得一个对象句柄，并将其作为基础类型句柄使用的行为就叫作“上溯造型”——因为继承树的画法是基础类位于最上方。
7.1.1 为什么要上溯造型 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。这样就不比为每种衍生类都制作对应的方法，节省大量工作。
这正是“多形性”大显身手的地方。
7.2 深入理解 此处有个问题：基于上溯造型，用基础类做方法 自变量时，真正调用方法时传入的自变量类型为基础类的衍生类时。它接收 基础类 句柄。所以在这种情况下，编译器怎样才能知道 基础类 句柄指向的是一个真正的 衍生类，而不是一个其他衍生类呢？编译器无从得知。为了深入了理解这个问题，我们有必要探讨一下“绑定”这个主题。
7.2.1 方法调用的绑定 将一个方法调用 同一个方法主体 连接到一起就称为“绑定”（Binding）。若在程序运行以前执行绑定（由编译器和链接程序，如果有的话），就叫作“早期绑定”。大家以前或许从未听说过这个术语，因为它在任何程序化语言里都是不可能的。C编译器只有一种方法调用，那就是“早期绑定”。
上述程序最令人迷惑不解的地方全与早期绑定有关，因为在只有一个 基础类 句柄的前提下，编译器不知道具体该调用哪个方法。
解决的方法就是“后期绑定”，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。
Java中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。
为什么要把一个方法声明成final呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final方法调用生成效率更高的代码。
7.2.2 产生正确的行为 知道Java里绑定的所有方法都通过后期绑定具有多形性以后，就可以相应地编写自己的代码，令其与基础类沟通。此时，所有的衍生类都保证能用相同的代码正常地工作。或者换用另一种方法，我们可以“将一条消息发给一个对象，让对象自行判断要做什么事情。”
在面向对象的程序设计中，有一个经典的“形状”例子。由于它很容易用可视化的形式表现出来，所以经常都用它说明问题。但很不幸的是，它可能误导初学者认为OOP只是为图形化编程设计的，这种认识当然是错误的。
形状例子有一个基础类，名为Shape；另外还有大量衍生类型：Circle（圆形），Square（方形），Triangle（三角形）等等。大家之所以喜欢这个例子，因为很容易理解“圆属于形状的一种类型”等概念。下面这幅继承图向我们展示了它们的关系：
上溯造型可用下面这个语句简单地表现出来：
Shape s = new Circle(); 当我们调用其中一个基础类方法时（已在衍生类里覆盖）：
s.draw(); 此时实际调用的是Circle.draw()，因为后期绑定已经介入（多形性）。
//: Shapes.java // Polymorphism in Java class Shape { void draw() {} void erase() {} } class Circle extends Shape { void draw() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/</guid>
      <description>第8章 对象的容纳 “如果一个程序只含有数量固定的对象，而且已知它们的存在时间，那么这个程序可以说是相当简单的。”
通常，我们的程序需要根据程序运行时才知道的一些标准创建新对象。若非程序正式运行，否则我们根本不知道自己到底需要多少数量的对象，甚至不知道它们的准确类型。为了满足常规编程的需要，我们要求能在任何时候、任何地点创建任意数量的对象。所以不可依赖一个已命名的句柄来容纳自己的每一个对象， 因为根本不知道自己实际需要多少这样的东西。
为解决这个非常关键的问题，Java提供了容纳对象（或者对象的句柄）的多种方式。其中内建的类型是数组，我们之前已讨论过它，本章准备加深大家对它的认识。此外，Java的工具（实用程序）库提供了一些“集合类”（亦称作“容器类”，但该术语已由AWT使用，所以这里仍采用“集合”这一称呼）。利用这些集合类，我们可以容纳乃至操纵自己的对象。本章的剩余部分会就此进行详细讨论。
8.1 数组 数组只是容纳对象的一种方式。但由于还有其他大量方法可容纳数组，所以是哪些地方使数组显得如此特别呢？ 有两方面的问题将数组与其他集合类型区分开来：效率和类型。对于Java来说，为保存和访问一系列对象（实际是对象的句柄）数组，最有效的方法莫过于数组。数组实际代表一个简单的线性序列，它使得元素的访问速度非常快，但我们却要为这种速度付出代价：创建一个数组对象时，它的大小是固定的，而且不可在那个数组对象的“存在时间”内发生改变。可创建特定大小的一个数组，然后假如用光了存储空间，就再创建一个新数组，将所有句柄从旧数组移到新数组。这属于“矢量”（Vector）类的行为，本章稍后还会详细讨论它。然而，由于为这种大小的灵活性要付出较大的代价，所以我们认为矢量的效率并没有数组高。
C++的矢量类知道自己容纳的是什么类型的对象，但同Java的数组相比，它却有一个明显的缺点：C++矢量类的operator[]不能进行范围检查，所以很容易超出边界（然而，它可以查询vector有多大，而且at()方法确实能进行范围检查）。在Java中，无论使用的是数组还是集合，都会进行范围检查——若超过边界，就会获得一个RuntimeException（运行期违例）错误。正如大家在第9章会学到的那样，这类违例指出的是一个程序员错误，所以不需要在代码中检查它。在另一方面，由于C++的vector不进行范围检查，所以访问速度较快——在Java中，由于对数组和集合都要进行范围检查，所以对性能有一定的影响。
本章还要学习另外几种常见的集合类：Vector（矢量）、Stack（堆栈）以及Hashtable（散列表）。这些类都涉及对对象的处理——好象它们没有特定的类型。换言之，它们将其当作Object类型处理（Object类型是Java中所有类的“根”类）。从某个角度看，这种处理方法是非常合理的：我们仅需构建一个集合，然后任何Java对象都可以进入那个集合（除基本数据类型外——可用Java的基本类型封装类将其作为常数置入集合，或者将其封装到自己的类内，作为可以变化的值使用）。这再一次反映了数组优于常规集合：创建一个数组时，可令其容纳一种特定的类型。这意味着可进行编译期类型检查，预防自己设置了错误的类型，或者错误指定了准备提取的类型。当然，在编译期或者运行期，Java会防止我们将不当的消息发给一个对象。所以我们不必考虑自己的哪种做法更加危险，只要编译器能及时地指出错误，同时在运行期间加快速度，目的也就达到了。此外，用户很少会对一次违例事件感到非常惊讶的。
考虑到执行效率和类型检查，应尽可能地采用数组。然而，当我们试图解决一个更常规的问题时，数组的局限也可能显得非常明显。在研究过数组以后，本章剩余的部分将把重点放到Java提供的集合类身上。
8.1.1 数组和第一类对象 无论使用的数组属于什么类型，数组标识符实际都是指向真实对象的一个句柄。那些对象本身是在内存“堆”里创建的。堆对象既可“隐式”创建（即默认产生），亦可“显式”创建（即明确指定，用一个new表达式）。堆对象的一部分（实际是我们能访问的唯一字段或方法）是只读的length（长度）成员，它告诉我们那个数组对象里最多能容纳多少元素。对于数组对象，“[]”语法是我们能采用的唯一另类访问方法。
下面这个例子展示了对数组进行初始化的不同方式，以及如何将数组句柄分配给不同的数组对象。它也揭示出对象数组和基本数据类型数组在使用方法上几乎是完全一致的。唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体的数值（若在执行此程序时遇到困难，请参考第3章的“赋值”小节）：
length只告诉我们可将多少元素置入那个数组。换言之，我们只知道数组对象的大小或容量，不知其实际容纳了多少个元素。 尽管如此，由于数组对象在创建之初会自动初始化成null，所以可检查它是否为null，判断一个特定的数组“空位”是否容纳一个对象。类似地，由基本数据类型构成的数组会自动初始化成零（针对数值类型）、null（字符类型）或者false（布尔类型）。
Java 1.1加入了一种新的数组初始化语法，可将其想象成“动态集合初始化”。
hide(new Weeble[] {new Weeble(), new Weeble() }); 对于由基本数据类型构成的数组，它们的运作方式与对象数组极为相似，只是前者直接包容了基本类型的数据值。
集合类只能容纳对象句柄。但对一个数组，却既可令其直接容纳基本类型的数据，亦可容纳指向对象的句柄。
创建和访问一个基本数据类型数组，那么比起访问一个封装数据的集合，前者的效率会高出许多。
当然，假如准备一种基本数据类型，同时又想要集合的灵活性（在需要的时候可自动扩展，腾出更多的空间），就不宜使用数组，必须使用由封装的数据构成的一个集合。大家或许认为针对每种基本数据类型，都应有一种特殊类型的Vector。但Java并未提供这一特性。某些形式的建模机制或许会在某一天帮助Java更好地解决这个问题（注释①）。
①：这儿是C++比Java做得好的一个地方，因为C++通过template关键字提供了对“参数化类型”的支持。
8.1.2 数组的返回 假定我们现在想写一个方法，同时不希望它仅仅返回一样东西，而是想返回一系列东西。此时，象C和C++这样的语言会使问题复杂化，因为我们不能返回一个数组，只能返回指向数组的一个指针。这样就非常麻烦，因为很难控制数组的“存在时间”，它很容易造成内存“漏洞”的出现。
Java采用的是类似的方法，但我们能“返回一个数组”。当然，此时返回的实际仍是指向数组的指针。但在Java里，我们永远不必担心那个数组的是否可用——只要需要，它就会自动存在。而且垃圾收集器会在我们完成后自动将其清除。
返回数组与返回其他任何对象没什么区别——最终返回的都是一个句柄。
8.2 集合 为容纳一组对象，最适宜的选择应当是数组。而且假如容纳的是一系列基本数据类型，更是必须采用数组。
Java提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。与拥有集合功能的其他语言相比，尽管这儿的数量显得相当少，但仍然能用它们解决数量惊人的实际问题。
这些集合类具有形形色色的特征。例如，Stack实现了一个LIFO（先入先出）序列，而Hashtable是一种“关联数组”，允许我们将任何对象关联起来。除此以外，所有Java集合类都能自动改变自身的大小。所以，我们在编程时可使用数量众多的对象，同时不必担心会将集合弄得有多大。
8.2.1 缺点：类型未知 使用Java集合的“缺点”是在将对象置入一个集合时丢失了类型信息。之所以会发生这种情况，是由于当初编写集合时，那个集合的程序员根本不知道用户到底想把什么类型置入集合。若指示某个集合只允许特定的类型，会妨碍它成为一个“常规用途”的工具，为用户带来麻烦。为解决这个问题，集合实际容纳的是类型为Object的一些对象的句柄。这种类型当然代表Java中的所有对象，因为它是所有类的根。当然，也要注意这并不包括基本数据类型，因为它们并不是从“任何东西”继承来的。这是一个很好的方案，只是不适用下述场合：
(1) 将一个对象句柄置入集合时，由于类型信息会被抛弃，所以任何类型的对象都可进入我们的集合——即便特别指示它只能容纳特定类型的对象。举个例子来说，虽然指示它只能容纳猫，但事实上任何人都可以把一条狗扔进来。 (2) 由于类型信息不复存在，所以集合能肯定的唯一事情就是自己容纳的是指向一个对象的句柄。正式使用它之前，必须对其进行造型，使其具有正确的类型。 值得欣慰的是，Java不允许人们滥用置入集合的对象。假如将一条狗扔进一个猫的集合，那么仍会将集合内的所有东西都看作猫，所以在使用那条狗时会得到一个“违例”错误。在同样的意义上，假若试图将一条狗的句柄“造型”到一只猫，那么运行期间仍会得到一个“违例”错误。
这些处理的意义都非常深远。尽管显得有些麻烦，但却获得了安全上的保证。我们从此再难偶然造成一些隐藏得深的错误。若程序的一个部分（或几个部分）将对象插入一个集合，但我们只是通过一次违例在程序的某个部分发现一个错误的对象置入了集合，就必须找出插入错误的位置。当然，可通过检查代码达到这个目的，但这或许是最笨的调试工具。另一方面，我们可从一些标准化的集合类开始自己的编程。尽管它们在功能上存在一些不足，且显得有些笨拙，但却能保证没有隐藏的错误。
错误有时并不显露出来 在某些情况下，程序似乎正确地工作，不造型回我们原来的类型。第一种情况是相当特殊的：String类从编译器获得了额外的帮助，使其能够正常工作。只要编译器期待的是一个String对象，但它没有得到一个，就会自动调用在Object里定义、并且能够由任何Java类覆盖的toString()方法。这个方法能生成满足要求的String对象，然后在我们需要的时候使用。
参数化类型 这类问题并不是孤立的——我们许多时候都要在其他类型的基础上创建新类型。此时，在编译期间拥有特定的类型信息是非常有帮助的。这便是“参数化类型”的概念。在C++中，它由语言通过“模板”获得了直接支持。至少，Java保留了关键字generic，期望有一天能够支持参数化类型。但我们现在无法确定这一天何时会来临。
8.3 枚举器（迭代器） 在任何集合类中，必须通过某种方法在其中置入对象，再用另一种方法从中取得对象。毕竟，容纳各种各样的对象正是集合的首要任务。在Vector中，addElement()便是我们插入对象采用的方法，而elementAt()是提取对象的唯一方法。Vector非常灵活，我们可在任何时候选择任何东西，并可使用不同的索引选择多个元素。
若从更高的角度看这个问题，就会发现它的一个缺陷：需要事先知道集合的准确类型，否则无法使用。乍看来，这一点似乎没什么关系。但假若最开始决定使用Vector，后来在程序中又决定（考虑执行效率的原因）改变成一个List（属于Java1.2集合库的一部分），这时又该如何做呢？ 可利用“反复器”（Iterator）的概念达到这个目的。它可以是一个对象，作用是遍历一系列对象，并选择那个序列中的每个对象，同时不让客户程序员知道或关注那个序列的基础结构。此外，我们通常认为反复器是一种“轻量级”对象；也就是说，创建它只需付出极少的代价。但也正是由于这个原因，我们常发现反复器存在一些似乎很奇怪的限制。例如，有些反复器只能朝一个方向移动。 Java的Enumeration（枚举，注释②）便是具有这些限制的一个反复器的例子。除下面这些外，不可再用它做其他任何事情：
(1) 用一个名为elements()的方法要求集合为我们提供一个Enumeration。我们首次调用它的nextElement()时，这个Enumeration会返回序列中的第一个元素。
(2) 用nextElement()获得下一个对象。
(3) 用hasMoreElements()检查序列中是否还有更多的对象。
②：“反复器”这个词在C++和OOP的其他地方是经常出现的，所以很难确定为什么Java的开发者采用了这样一个奇怪的名字。Java 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC9%E7%AB%A0-%E8%BF%9D%E4%BE%8B%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC9%E7%AB%A0-%E8%BF%9D%E4%BE%8B%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</guid>
      <description>第9章 违例差错控制 通过先进的错误纠正与恢复机制，我们可以有效地增强代码的健壮程度。对我们编写的每个程序来说，错误恢复都属于一个基本的考虑目标。它在Java中显得尤为重要，因为该语言的一个目标就是创建不同的程序组件，以便其他用户（客户程序员）使用。为构建一套健壮的系统，每个组件都必须非常健壮。 在Java里，违例控制的目的是使用尽可能精简的代码创建大型、可靠的应用程序，同时排除程序里那些不能控制的错误。 违例的概念很难掌握。但只有很好地运用它，才可使自己的项目立即获得显著的收益。Java强迫遵守违例所有方面的问题，所以无论库设计者还是客户程序员，都能够连续一致地使用它。
9.1 基本违例 在违例条件的情况下，却无法继续下去，因为当地没有提供解决问题所需的足够多的信息。此时，我们能做的唯一事情就是跳出当地环境，将那个问题委托给一个更高级的负责人。这便是出现违例时出现的情况。
9.1.1 违例自变量 关键字throw
9.2 违例的捕获 为理解违例是如何捕获的，首先必须掌握“警戒区”的概念。它代表一个特殊的代码区域，有可能产生违例，并在后面跟随用于控制那些违例的代码。
9.2.1 try块 可在那个方法内部设置一个特殊的代码块，用它捕获违例。这就叫作“try块”，因为要在这个地方“尝试”各种方法调用。try块属于一种普通的作用域，用一个try关键字开头：
try {// 可能产生违例的代码} 若用一种不支持违例控制的编程语言全面检查错误，必须用设置和错误检测代码将每个方法都包围起来——即便多次调用相同的方法。而在使用了违例控制技术后，可将所有东西都置入一个try块内，在同一地点捕获所有违例。这样便可极大简化我们的代码，并使其更易辨读，因为代码本身要达到的目标再也不会与繁复的错误检查混淆。
9.2.2 违例控制器 当然，生成的违例必须在某个地方中止。这个“地方”便是违例控制器或者违例控制模块。而且针对想捕获的每种违例类型，都必须有一个相应的违例控制器。违例控制器紧接在try块后面，且用catch（捕获）关键字标记。如下所示：
try {// Code that might generate exceptions} catch(Type1 id1) {// Handle exceptions of Type1} catch(Type2 id2) {// Handle exceptions of Type2} catch(Type3 id3) {// Handle exceptions of Type3} 每个catch从句——即违例控制器——都类似一个小型方法，它需要采用一个（而且只有一个）特定类型的自变量。可在控制器内部使用标识符（id1，id2等等），就象一个普通的方法自变量那样。我们有时也根本不使用标识符，因为违例类型已提供了足够的信息，可有效处理违例。但即使不用，标识符也必须就位。 控制器必须“紧接”在try块后面。若“掷”出一个违例，违例控制机制就会搜寻自变量与违例类型相符的第一个控制器。随后，它会进入那个catch从句，并认为违例已得到控制（一旦catch从句结束，对控制器的搜索也会停止）。只有相符的catch从句才会得到执行；它与switch语句不同，后者在每个case后都需要一个break命令，防止误执行其他语句。 在try块内部，请注意大量不同的方法调用可能生成相同的违例，但只需要一个控制器。
中断与恢复 在违例控制理论中，共存在两种基本方法。在“中断”方法中（Java和C++提供了对这种方法的支持），我们假定错误非常关键，没有办法返回违例发生的地方。无论谁只要“掷”出一个违例，就表明没有办法补救错误，而且也不希望再回来。 另一种方法叫作“恢复”。它意味着违例控制器有责任来纠正当前的状况，然后取得出错的方法，假定下一次会成功执行。若使用恢复，意味着在违例得到控制以后仍然想继续执行。在这种情况下，我们的违例更象一个方法调用——我们用它在Java中设置各种各样特殊的环境，产生类似于“恢复”的行为（换言之，此时不是“掷”出一个违例，而是调用一个用于解决问题的方法）。另外，也可以将自己的try块置入一个while循环里，用它不断进入try块，直到结果满意时为止。 从历史的角度看，若程序员使用的操作系统支持可恢复的违例控制，最终都会用到类似于中断的代码，并跳过恢复进程。所以尽管“恢复”表面上十分不错，但在实际应用中却显得困难重重。其中决定性的原因可能是：我们的控制模块必须随时留意是否产生了违例，以及是否包含了由产生位置专用的代码。这便使代码很难编写和维护——大型系统尤其如此，因为违例可能在多个位置产生。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java/</guid>
      <description>Thinking In Java 标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 第 1 章：对象入门 面向对象编程（OOP）
1.1 抽象的进步 所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。
1.2 对象的接口 我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做哪些事情。
1.3 实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员。
1.4 方案的重复使用 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。
新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。
轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。
1.5 继承：重新使用接口 在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。
1.5.1 改善基础类 改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。
继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；
1.6 多形对象的互换使用 通常，继承最终会以创建一系列类收场，所有类都建立在统一的基础接口上。
对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。
把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。
1.6.1 动态绑定 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）（多态性）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。
1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。
亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。
interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。
备注：这是一段个人的总结：interface（接口）更倾向于表明这个类是能干什么事，也就是说这类的类实现了哪些方法及继承与此接口的类必需要实现哪些方法；接口更像一个规范文件(协议)。abstract（抽象）更倾向于表明一类类的共有特性，由基础类或一个接口衍生的一系列类的共有特性，所以不仅仅表明这个类能干哪些事。也就是说 interface（接口）的方法都可以在接口中无实现，只规定了子类必须需要实现哪些方法，而 abstract（抽象）可以把子类相同实现的方法在抽象类里实现，子类各自特别且必须的方法用抽象方法规定然后在子类里各自实现。abstract（抽象）可以看为一种跟 public、static 同级别的修饰符（修饰了类（class）和方法），而 interface（接口）可以看为一种跟 class 同级别的修饰符，标志着质的改变。interface（接口）可以说是对 abstract（抽象）的抽象。interface（接口）帮助了对象的分层，各组件之间的松耦合。interface 语法要求：1、接口可以包含：静态常量、方法（抽象）、内部类（接口、枚举）、默认方法（类方法）2、接口只可以继承多个父接口（之间用英文逗号“,”隔开），不能继承类。3、接口修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有相同包结构下才可以访问该接口。4、接口内的所有成员都是 public 访问权限，可省略，如果指定则只可使用 public 访问修饰符。5、接口的成员变量均为静态常量，不管是否使用 public static final 修饰符都认为只可做如此修饰。6、接口的方法只能是抽象、类方法、默认方法，如果不是默认方法，系统将自动为普通方法增加 public abstract 修饰符，且不能有方法实现（方法体），类方法、默认方法必须有方法实现（方法体）。7、定义默认方法，需要用 default 修饰且默认添加 public 修饰 ，默认方法不能用 static 修饰，所以不能直接用接口来调用默认方法，由接口的实现类的实例来调用这些默认方法。8、类方法需用 static 修饰 ，可用接口直接调用。9、接口的内部类（接口、枚举）默认采用 public static 修饰符。10、接口可看做为特殊的类，受限于一个源文件只能有一个 public 修饰。11、接口不能创建实例，作为声明引用类型变量时此接口必须有其实现类。abstract 语法要求：1、有抽象方法的类只能是抽象类2、抽象类里可没有抽象方法有普通方法3、抽象类不能被实例化4、抽象类可以包含：成员变量、方法（普通、抽象）、构造器、初始化快、内部类（接口、枚举）、抽象类的构造器不能用于创造实列，主要用于被其子类调用5、抽象不能修饰变量（成员、局部），不能修饰构造器，抽象类里的构造器只能是普通的构造器。总结如下：1、抽象类与普通类相比“一得一失”：1、“得”可包含抽象方法。2、“失”无法被实列化。2、抽象类是用来被它的子类继承的，方法由子类实现。而 final 修饰的类不能被继承， final 修饰的方法不能被重写，所以 final 和 abstract 是互斥的。3、static 修饰方法是属于这个类本身的（类Class和实列Object的区别），如果该方法被定义成抽象方法，通过类调用的时候也会出错，因为调用了一个没有方法实体的方法，所以 static 和 abstract 是互斥的（非绝对，可以同时修饰内部类）。4、abstract 修饰的方法必须被之类重写才有意义，因此 abstract 方法不能是私有的，所以 private 和 abstract 是互斥的。 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/%E6%A0%87%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/%E6%A0%87%E9%A2%98/</guid>
      <description> Thinking In Java 标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk </description>
    </item>
    
  </channel>
</rss>

[{"id":0,"href":"/Life/1Book/Book/","title":"Book","parent":"1、Book","content":"Book\n"},{"id":1,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%B8%B8%E8%A4%92%E7%A6%85%E5%B1%B1%E8%AE%B0/","title":"《游褒禅山记》","parent":"-随笔","content":"王安石的《游褒禅山记》中学应该都学过。我记得好像还要求全文背诵。这篇文字并不艰深，里面讲的道理也并不复杂。如果你当年一直把这个道理记在心里，可能现在有些事会不同：\n夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。\n"},{"id":2,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%B8%80%E7%94%9F%E5%9B%9B%E8%AF%8D/","title":"一生四词","parent":"-随笔","content":"一生四词：虚掷，空投，蹉跎，错付。\n"},{"id":3,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/tombkeeper/2005-10-02-tombkeeper/","title":"2005 10 02 Tombkeeper","parent":"tombkeeper","content":"tombkeeper 2005.10.02\n这两天论坛上又有人开始抱怨世风日下，大家都现实了，都不开放了，不交流了。对这种“月经贴”，我基本上已经习惯了，不过因为吃了粉皮炖鸡，心情比较好，于是就说了两句。\n三四年前，当时我对人性的看法还不像现在这样。有几个人加了我的QQ，说想学Windows，我居然就好为人师起来，自不量力地教人学Windows。我很天真地把自己的经验告诉他们：\n一、先把Windows的帮助文件从头到尾看一遍。\n二、在Windows目录下搜索*.txt、.htm?、.log、*.ini，把每一个文件内容都看一遍。\n三、把注册表浏览一遍。\n没有诀窍，也不用花钱买书。任何人把这三步做完之后，只要不是傻子，在Windows应用方面都可以非常熟练。并且如果想进一步学，也自然知道应该去看什么了。\n结果甚至没有一个人能看完Windows帮助文件，看完三分之一的都没有，都说看不下去。我很奇怪，我看Windows的帮助文件就像看金庸小说一样愉快，怎么会有人觉得辛苦？\n后来我想明白了：因为我爱她，而他们不爱她，只是想占有她而已。\n他们要的不是交流，不是开放，甚至也不是想找个人“拜师”，他们想要的不是郭靖遇到的洪七公，而是虚竹遇到的无涯子。\n再后来，一个偶然的机会，我看到了小四同学写的那篇《你尽力了么？》，才知道原来这不只是我一个人的看法。\n这两天在家，在笔记本上折腾Linux，遇到了很多问题，我就把内核每一个编译选项的说明都细细看了一遍，反复编译上二十多遍——然后，所有问题的答案都找到了。显然，学Linux和学Windows的方法并没有什么不同。\n"},{"id":4,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E8%BF%99%E5%87%A0%E5%A4%A9%E5%81%9A%E5%B0%81%E9%97%AD%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%87%E8%91%A9%E4%BA%8B%E5%84%BF%E8%B7%9F%E4%BD%A0%E4%BB%AC%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/","title":"《这几天做封闭规划的奇葩事儿跟你们总结一下》","parent":"他人存档","content":"这几天做封闭规划的奇葩事儿跟你们总结一下：\n1、这些人坚信现在的f腐是zz斗争，是铲除异己。\n2、觉得现在是倒退，无限怀念hw十年。我一脸好奇：“你们说得对，那十年确实很好，就跟飞国际航线的机组，觉得三十年前好一样，他们从外国飞回来的时候，可以带洋货回来，自用也可以买卖赚钱，在国际航线机组人员看，我国其实不是倒退十年，而是倒退三十年，是不是这个意思？”专家：“那话不能这么说。”“那该怎么说？您教我一下？”\n3、坚信票选制是好的，因为全世界有更多国家在用这种方式。我：“可是这里大部分是失败的国家。”专家：“那也不可否认的是更多人在用这种模式，更多人用一定有他合理的一面。”我：“所以制度的目的不是为了结果，而是为了制度本身？那你们坐在这里那么辛苦干活为了啥？是为了工作本身而不是为了报酬？那干嘛不打报告给人力说下个月义务干活，别发工资了？”\n4、做宏观研究也很从众，把市场上的普遍观点，比如把各路券商的研报，收拢在一起，然后东拼西凑后，搞出一份报告。\n5、问他们知道不知道mz与zy其实概念上矛盾的，西方人的mz是多数人暴z的意思，所以制度建设上要千方百计预防这种倾向，他们一脸懵逼。“你们知道托克维尔就很反这种mz吗？等等，我还是不难为您了，这个问题你们别回答了，换一个，您知道托克维尔是哪个国家的吗？代表作有哪些？”\n6、他们无法理解“西方如果有主义的话，归根到底只有一种，就是zy主义”。跟他们说“你们最向往的美国，其实政治制度是很反mz的”，他们不信，甚至连什么是选举人团都不知道。“你们知道你们欣赏的美国国父们设计制度的时候，也千方百计预防你们欣赏的mz吗？他们称之为民粹。你们看过《联邦党人文集》、《联邦论》还有《汉密尔顿传》吗？什么？没有看过？那我跟你们说不上话了。”\n7、他们不知道西式zy主义所推崇的个人主义，本质是对千年zj压迫的反抗。提到zj，他们的第一反应是中国人没信仰。\n8、他们不知道美国的关税历史，不知道美国退出国联、割裂世界贸易体系，间接导致了二战；不知道美国在欧洲战场上，其实是下山摘桃子的；不知道直至1950年前，美国一直都是高关税壁垒、高贸易壁垒，所以不懂得“孤立主义”。我笑了。\n9、他们坚定地捍卫比自己更富上百倍万倍的人的财富，认为这是他们的奋斗所得。同时认为咱们国家应该像美国一样征收遗产税。我：“美国的遗产税其实有很成熟的避税方式，其实这个制度并不管用。”行研员：“那起码有一套这样的制度啊，如果连制度都没有如何避免阶层固化？”他似乎忘了前面还挺热衷捍卫富人的财富。\n10、他们觉得如果我们和美国打战，应该是先上常规武器的，无法理解我这种上来就要甩30个氢弹是什么意思。“为什么上来就要核武器？至于到那一步吗？”他们无法理解大国战争是你死我活的，就该上手甩氢弹甚至连美国已经没有现役氢弹都不知道。\n11、行研员觉得扶贫是违背市场规律的，如果赚钱的话，市场自然会去扶贫。如果市场不扶贫，那么扶贫就是错的。行研员是湖南农村出身，和这群专家一样，都有农村生活经历，但现在坚信市场是对的，然后急切想抛弃他们的农村老乡。\n12、我跟他们讲商品和货币的关系时，他们下意识地认为这是马列主义的观点，是洗脑。我只能微笑地告诉他们，“不，这是市场经济鼻祖亚当斯密的观点，是美国经济学家、诺贝尔奖获得者弗里德曼的观点”。这些人连《国富论》这类经典都没通读过，就可以服服帖帖地崇拜市场；同样，连马列主义经典都不知悉，就有勇气抨击别人是被洗脑了，也不知道谁的脑子被洗了。连亚当斯密和弗里德曼的思想都打不过，怎么就敢叫阵马列？无知者无畏？\n13、他们抨击红x代，但无视美国子承父业当总统、妻承夫业选总统，还觉得那是美国人民自己的选择。\n14、崇尚西式zy的他们，却连个车胎都不会自己换，这种人如果在美国广袤的中部开车爆胎，该如何实现自己自己的zy？而且只许他们zy，却不许森林的树木zy。 专家：“瑞士的森林可好了，很美，很整齐，你看我们山上那些树长得乱糟糟的。” 我；“瑞士海拔高、纬度高，气温低，森林树种的多样性较低，树种少，藤本、草本少，大型裸子植物多，自然看起来整齐。深圳更温暖，森林树种的多样性更高，看起来乱也很正常，而且多样性高的森林，其实有更强的抗病能力和稳定性。”\n15、动不动就怪gcd，比如说自己没做好风控的情况下，逆周期扩张，吃了一波坏账，怪gcd体制，可是你们都是一个自诩为市场化金融机构的风控人员诶，甩锅姿势不能这么优雅的。\n16、安排工作后，属下交差，原稿不满意，提了新要求，发回重改，然后看了修改稿之后发现把原稿的内容改没了，就来一句“我让他改东西，他就把原来有用的全改了，唉，中国人容易走极端”。话说自己工作没沟通好，是可以甩锅中国人的？欧洲那种不是无政府就是法西斯，看来还真是中庸极了。\n17、群里分享明年基建计划，一阵预期明年经济差，政府在兜底。我：“巴菲特抄底美股和美油，是嗅觉敏锐而不是资金自救，而我国在低成本时搞基建扩张，就是被迫刺激经济？为什么双重标准？”\n18、另外一个差别是，他们都是gcd员，而我是d外人士。[微笑][微笑][微笑]\n附：鉴于60后、70后、80后抗议，我改一下第18条。有人质疑我为什么不讲道理，任意拉黑，拜托，讲道理是双向的。还有人在这个吐槽贴上寻找什么成体系的逻辑，你们该去找老师上课，而不是看我吐槽。mmp，睡觉去。\n"},{"id":5,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%AA%E5%8A%9B/","title":"为什么努力","parent":"他人存档","content":"有时候别人会问，你为什么要这么拼呢？平平淡淡的日子不也是一生吗？ 对不起，我不想和无知庸碌的人为伍，我不愿跟审美低下的人同行，我不能与道德缺失的人作伴。 所以，就得往上冲。 盘古开天的时候，清而轻者上升为天，浊而拙者下沉为地。 美好在上面，不美好在下面。 为什么一定要去一线城市啊，为什么去北上广深啊，因为我想撞的是山，不想撞的是墙。\n"},{"id":6,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89/","title":"人生的意义","parent":"他人存档","content":" 作者：AI Fuzz 链接：https://www.zhihu.com/question/20518940/answer/233132972 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n人生的意义\n因为意义是外物赋予的，而人生的本质，不能由他人决定，也不由物化的标准评判。人并不是某种标签或者集合，主体的每一种行为，无一不昭示其本质，故其不籍意义而存在。\n我不为什么东西而生，也不为什么东西而死，不需要任何标签化的认同，不作为什么而存在，不需要任何标签化的定义，不需要任何标签化的解释。\n不自信的一个特点是：被看低、嘲讽，拒绝后内心会非常抵触和敏感、沮丧。\n喜欢就改变它，仇恨就超越它\n（改变他的原因是他不可能完全符合内心的标准？还是因为自私？当时很理解这句话，现在有点不理解了。。。 ）\n"},{"id":7,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%BD%95%E4%BB%A5%E8%90%A7%E5%A3%B0%E9%BB%98/","title":"何以萧声默","parent":"他人存档","content":"首先我没有看过电视剧也未曾看过原著，纯粹是吐槽来着，玻璃心退避。不是顺口就好了啊，不是对偶就好了，只求对偶那是对联啊，这是这句东西犯的错：孤平仄、半文半白（既然是现代汉语用法啊！）、虚词多余实词、形容词强行做动词，你考虑过人家“默”的感受么？意向强行组合、，还有这么多乐器我都没见过真的，其实我真是一个没见过世面的逗比。大众文学么、矫情么，网文么，不能要求太多，毕竟谁没个青春啊，谁没点情怀啊（我确定罗永浩是个SB）。我不是对它要求太对，是社交平台被刷屏（长期）不爽啊，好烦这种存在感太强的东西。琼瑶奶奶都不敢拽古文，现在这些小屁孩哪来的胆子啊，无知者无畏啊？我是不是要鼓励这种二x精神啊。文法、对偶、格、律、音律。还不如：不悔梦归处，只恨太匆匆。以下还有我整理的网友吐槽。如果说平仄，（仄平平仄仄，平仄平平仄—不是律句，连靠近点古风平仄都不能！）今天天气真好啊。周杰伦当年感觉水平一般还能拽出几句古文来，好像有一句rap；胡言岂一派，风生谈笑中。竟然感觉甩这这感觉甩这几条街了，（不要提许嵩，提它我会疯）、天王盖地虎，宝塔镇河妖也比这强啊。1既然牙已洗，何以又吃馍？2、天网恢恢，地塞米松， 寻道南山，盘尼西林。\n安非他命，如是我闻，\n镜花水月，诺氟沙星。3既然琴瑟起，何以笙萧默？\n感觉文学界，还要学习个。\n人生的经验，作为一长者；\n西方的国家，哪个没去过？\n我和华莱士，谈笑在美国！\n就有一个好，你们这作者；\n但是编口号，图样图森破。\n是什么意思，你们来问我；\n我的解释权，也很重要的！4、当郭德纲那首著名的诗\n一去残冬晓日红，三杯泪酒奠苍穹。\n鸡肠曲曲今何在，始信人间报应灵。\n被网民们称作打油诗的时候，我有一位慧眼爱德纲的学妹义愤填膺地指出，\n“那些说它是打油诗的长眼了么，这明明是首七绝”。\n向来热爱学妹和祖国花朵的我忍不住想要端正一下学妹的语文基础常识，劝她道，\n“其实吧，管它叫打油诗已经算是给面子了，因为打油诗都要求第二、四句押韵呢。至于七绝，不是我说啊，格律实在是太严格了，咱还是不高攀这名号了吧。”\n学妹说。。。。\n“呵呵哒。”\n然后把我拖黑了。\n“哎学妹，等等啊学妹！学长改答案还不行么？”\n"},{"id":8,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%81%B6%E5%BE%97/","title":"偶得","parent":"他人存档","content":"偶得\n卧病所感 \u0026ndash;还是暴躁 今卧病于寒屋，腹中空无宿谷。 瑟缩如卧檀木，室困若沉西湖。 幻视如食菌菇，万物尽若虚无。 捕阳羲于倏忽，囫囵吞之入腹。 举目唯吾与狸奴，存于乱世相倚负。 抬手欲探阑珊处，惊觉西风调碧树。 尘道浮华如云雾，此间脉脉同谁诉。 只道闲愁是极苦，梦回烟柳断肠处。\n高柳乱蝉嘶\n高柳乱蝉嘶，声声苦且悲。忆我怜君意，娉婷年少时。 春风一相逢，回眸两心知。缠绵诉花下，缱绻照清溪。 有情成眷属，鸳鸯结同栖。白手筑巢暖，更添娇女啼。 愿与君偕老，举案与眉齐。君有凌云志，奋举冲天翼。 携家向南方，热土寻绮丽。辛苦重打拚，风雨同舟辑。 雅园居室香，阔道芳车系。亲朋相与趋，君已踞高位。 相夫与教女，我守娴且慧。人生复何求？但期长此继。 萧萧世风吹，灼灼幻彩迷。君道事务多，忙碌长晚归。 管弦醉歌舞，孤月转窗帷。无言对朝暮，君心渐迷离。 回思来时路，独自不胜悲。春花飘零去，秋叶年年衰。 今夜风雨逼，盼君至窗白。电话响惊心，一聆天地坼。 君已遭押羁，贪贿有巨额。言能得归还，或可减刑责。 祸降带云雾，所贪在何处？我无缚鸡力，凭何救囹圄？ 丈夫风流事，为妻最后悟：家中少眷亲，家外多温存。 今朝伴红粉，昨日携绿裙。红粉绿裙娇，贻养需万缗。 怜我梦似锦，乱石碾碎玉。怜我半世情，一朝换耻辱。 纵有千般善，怎抵万种欲？休矣泣今生，欢娱将不复。 囚中他安否，铁窗多冷酷？哀我天真女，无言泪簌簌。 雏燕未飞翔，居巢已倾覆。肠断无所依，惨淡日向西。 无边落叶下，我欲何所之？心有万箭攒，高柳乱蝉嘶。\n《挫骨扬灰辞》 \u0026ndash;汪精卫 我今挫其骨，又复扬其灰。 一生被尔误，一恨何如兹！ 对镜照端倪，原来皮相寄存之。 眼中生万象，受思判云泥。 足下世间路，骨生血肉肌。 春来荣万物，秋去枯于斯。 此物原来非不朽，亦随形态转轮司。 春秋荣枯异，生死换他衣。 是衣敝矣皆可弃，萌新敝旧实相欺。 衣中着竖子，竖子被尔误成痴！ 衣中着道义，所欲随心子仲尼！ 堪笑此衣吾假耳，却不知此物本可相剥离！ 我来之时赤裸裸，今亦不愿挂一丝。 着衣已久矣！ 每不能合于寒暑变相移。 吾二自然矣！ 只缘贪恋此囊皮。 此皮无甚好，我意已觉知。 夺此世间器，还他清净枝。 是以扬灰挫其骨，是以灭迹毁其尸。 尸迹尽皆去，吾亦不居骨和灰！\n"},{"id":9,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%85%B8%E5%9E%8B%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF/","title":"典型逻辑错误","parent":"他人存档","content":"微博上出现最多的典型逻辑错误\n不管你罗列什么逻辑，它们都必须遵循自身的规律。违反者有二：一，逻辑思维不清晰。二，有意而为。它在不同的时间与空间里，能产生核聚，亦能发生核爆。这些错误包括：偷换概念、偷换论题、自相矛盾、模棱两可、循环定义、同语反复、概念不当并列、因果倒置、循环论证、难于推理其逻辑思维等。如：排中律的逻辑要求是：对于是非问题必须作出明确而肯定的回答。否定了其中的一个，就必须肯定另一个。否则要犯“两不可”的逻辑错误。但当下人们并不在意这些错误，因为这些错误在特定的条件下，会带来难于估量的利润和不可多得的利益。\n让我们来看看而写错误的本质是什么吧。\n1.同语反复 例如：乐观主义者就是乐观地对待生活的人。\n2.循环定义\n例如：如果把丈夫定义为妻子的爱人，那么，妻子就是丈夫的爱人。\n3.概念不当并列\n例如：音乐分为古典音乐、乡村音乐、流行音乐和民族音乐等。\n4.偷换概念\n例如：司马光说：“我要去看花灯。”\n司马光夫人说：“家中这么多灯，何必去看？”\n司马光夫人说：“我要去看游人。”\n司马光说：\u0026lsquo;家中这么多人，何必出去看？\u0026rsquo;\n5.转移论题\n例如：“我以为中学生没有必要学习地理。整个国家的地形和位置完全可以和这个国家的历史同时学习。我主张可以把历史课和地理课合并，这样对学生是方便的。”\n6.自相矛盾\n例如：“这件事情我没有问过，只是侧面了解一下情况，提点意见，仅供参考。”\n7.两不可\n例如：“这篇文章的观点不能说是全面的，也不能说是片面的。”\n8.以偏概全\n这是不正确构造简单枚举归纳推理时出现的逻辑错误。\n9.循环论证\n这种错误发生在一个论证中，论据的证明需要依赖前提的情况。\n10.倒置因果\n例如：为了加快我国的发展，必须大力发展航天工业。因为在发达国家，航天工业发展很快。\n常见逻辑错误例析\n摘要：逻辑有其自身的规律，如果违反其规律,人们的思维就会出现错误.常见的逻辑错误有偷换概念、偷换论题、自相矛盾、模棱两可、循环定义、同语反复、概念不当并列、因果倒置、循环论证、推不出等。\n逻辑的规律：\n逻辑有其自身的规律，不管使用什么概念和命题，进行何种推理和论证,都必须遵守最基本的逻辑规律.\n否则，人们的思维就会出现错误。常见的逻辑错误有偷换概念、偷换论题、自相矛盾、模棱两可、循环定义、同语反复、概念不当并列、因果倒置、循环论证、推不出等。\n一、偷换概念、偷换论题\n在同一思维过程中，每一个思想必须与其自身保持同一，这是同一律的要求。可用公式表示：A是A，A表示 一个概念或命题。一个概念反映什么对象就反映什么对象，在同一语言环境中，它不能既反映这类对象，又反映彼类对象。在概念上有意识地违背同一律的要求而出现的逻辑错误,逻辑上称之为“偷换概念”.\n其特点是有意不明确某个概念的含义，进而在这个概念中塞进新的含义。商家“买一赠一”的促销广告，玩的就是“偷换概念”的把戏。两个“一”的概念内涵大不相同，“买一”的\n存储设备上的逻辑错误：\n“一”是你要买的东西，比如：一件西服，“赠一”的“一”，如果你也理解成一件西服，那就太幼稚了。这个“一” 有可能是一根领带或一个精美的袋子而已，决不会是一件西服。\n在概念的运用方面，有的人是不了解某个概念的确切含义，以至在后面运用这一概念时改变了这一概念的含义。这种错误叫做\u0026rsquo;混淆概念\u0026rsquo;。\n同一律还要求，在同一思维过程中一个命题肯定什么就肯定什么，否定什么就否定什么。一个命题必须具有确定的“真”、“假”意义。我们把不自觉地违背同一律的逻辑错误称为“转移论题”。其表现为在说话或论述中，把所要说明或论证的问题无意识地变成了另外的问题。比如小孩子讲话，前言不搭后语，即属于此。\n对于在命题上有意识地违背同一律的要求而出现的逻辑错误，逻辑上称之为“偷换论题”。其表现是有意识地改变论题内容，偷梁换柱，从而达到某种目的。例如清朝时，某一书生坐于高台之上读书,台高风大,吹得书页哗哗乱翻，书生随口吟出两句诗：“清风不识字，何故乱翻书？”居心叵测之人有意歪曲“清”字的含义，诬陷书生讽刺清廷没文化，犯了大不敬罪。\n二、自相矛盾\n在同一思维过程中，两个互相矛盾或互相反对的思想不能都是真的，其中必有一个是假的，这是矛盾律的要求。可用公式表示：A不是非A，A表示一个概念或一个命题。一个概念不能既是它，又不是它，就好像一个人，不能既是人又不是人；一个命题不能既肯定某一对象又否定这一对象。违反矛盾律的要求而出现的逻辑错误，称之为“自相矛盾”。比如那个著名的卖矛与盾的楚人的笑话：他夸口自己的盾非常坚实，任何东西都不能穿过；又夸口自己的矛锐利无比，能刺穿任何东西。他犯的错误就是典型的自相矛盾。再如有人说“一个月来，这个问题时刻缠绕着我，而在非常繁忙或心情非常好的时候，我又暂时抛开了这一问题，顾不上去想它了。”既是“时刻缠绕着我”,就不会出现“顾不上去想它”的情况说话人也犯了“自相矛盾”的错误。\n三、模棱两可\n两个相互矛盾的思想不能都是假的，其中必有一个是真的，这是排中律的要求。可用公式表示：A或者非A，A表示一个概念或一个命题。在同一思维过程中，如果A不反映某一对象，那么非A便反映这个对象。比如这个人是学生，他要么属于“中专生”，要么属于“非中专生”，二者必居其一，不能同假。\n任何命题或者肯定某对象具有某种情况，或者否定某对象具有这种情况，二者必居其一，两个相互矛盾的命题不能同假。它要求在两个相互矛盾的思想中，必须旗帜鲜明地承认一个是真的。如果违背了这一要求，既不承认这个，又不承认那个，含混模糊，那就犯了“模棱两可”的逻辑错误。由于这种逻辑错误的特征是对两个相互矛盾的思想都予以否定，因此，又有人把这种错误称为“模棱两不可”。\n楚人夸口自己的矛与盾，当别人反问他：用你的矛穿你的盾如何时，他既没有做出“我的矛能穿过我的盾”的回答，也没有回答“我的矛不能穿过我的盾”，这就表示他既否定了A又否定了非A，从逻辑上讲，他的沉默就违反了排中律。也就是说，楚人回答任何一句都违反了矛盾律，一句不回答又违反了排中律。 当人们对一组矛盾的命题缺乏足够的认识时，不能明确地肯定什么或否定什么，这种情况不能诊断为违背了排中律。比如“火星上有生命”，“火星上没有生命”，这是一组矛盾命题。虽然其中必有一真，但人们却不能明确表态。另外，对于不是矛盾关系的概念或命题，都加以否定，也不是违反了排中律。如“今天不会下雨也不会下雪”。“下雨”或“下雪”不具有矛盾关系，所以可以同时否定。\n四、循环定义、同语反复\n定义是揭示概念内涵的逻辑方法，就是用简明的语句概括地说明对象的本质属性。定义由被定义项、定义项和定义联项三部分组成。被定义项就是通过定义来揭示其内涵的概念；定义项就是用来揭示被定义项内涵的概念；联结被定义项和定义项组成定义的概念是定义联项。下定义有一定的规则，它要求定义项不能直接或间接地包含被定义项。如果直接包含被定义项，那就犯了“同语反复”的逻辑错误；如果间接包含被定义项，那就犯了“循环定义”的逻辑错误。例如“顶针就是一种运用顶针手法的修辞格”。用“顶针手法”去说明“顶针”，这等于什么也没有说。这一定义就犯了“同语反复”的错误。再如“如果把‘奇数’定义为‘偶数加一’，那么‘偶数’是‘奇数加一’得到的数”。用“偶数”解释“奇数”，用“奇数”解释“偶数”，这一定义就犯了“循环定义”的错误。\n五、概念不当并列\n概念并列问题属于概念划分的范围。所谓划分，是明确概念外延的逻辑方法，即依据某一概念，把一个属概念分为若干子概念。划分由三部分组成，即划分的母项、划分的子项和划分的标准。其中，被划分的对象称为划分的母项；从母项中划分出来的概念，称为划分的子项；划分的依据通常是事物的某一属性，称为划分的标准。在对一个属概念进行划分时，可以把划分后得到的子概念作为母项再进行划分，这称之为“连续划分”。不管把一个概念划分成多少层次，每一次划分都必须遵循划分规则，即在一次划分中必须遵循同一个标准。根据不同标准划分的概念不可以并列，如果在同一次划分中并列了不同层次的概念，就会犯“概念不当并列”的逻辑错误。例如“我喜欢读外国作品、古典作品、小说、散文、唐诗等”。这句话对作品的分类用了多个标准，它把用不同标准划分的概念并列在了一起，犯了“概念不当并列”的错误。\n六、因果倒置\n因果关系是事物之间普遍联系的一种方式。如果一个现象的存在必然引起另一种现象发生，那么这两个现象就具有因果关系，其中，引起某一种现象产生的现象叫做原因，被引起的现象叫做结果。原因和结果在因果链中是相对的，此事的结果可能是彼事的原因，但就这一对因果来说，它又是绝对的，原因就是原因，结果就是结果，既不能倒因为果，也不能倒果为因。例如，19世纪英国有一位改革家发现,每个勤劳的农夫,都至少拥有两头牛；那些没有牛的，通常是些好吃懒做的人。因此，他的改革方式便是国家给每一个没有牛的农夫两头牛，这样，整个国家就没有好吃懒做的人了。这位改革家就犯了因果倒置的错误。农夫因勤劳才拥有两头牛，不是因拥有两头牛而变得勤劳。这种改革的结果自然还是勤者自勤，懒者亦懒。\n七、循环论证\n论证就是用几个真实命题确定另一命题真实性的过程。论证有一条重要原则，\n避免组策略逻辑错误\n即论据的真实性不应依赖论题的真实性。论题能否确立依赖论据的真实性来论证，如果论据的真实性反过来以论题的真实性为依据，那就等于什么也没有论证。违反这一规则所犯的逻辑错误，称为“循环论证”。例如，曾经有人反对哥白尼的太阳中心说，他们认为宇宙是有限的。其论据是宇宙在一昼夜之间绕地球一周，而论据的真实性又依赖“宇宙是有限的”这一论题（因为如果宇宙是无限的，就不能理解为什么无限的宇宙能在一昼夜之间绕自己的中心——地球运转一周）。这就犯了“循环论证”的错误。\n八、推不出\n论证的另一条重要规则是要求从论据出发能合乎逻辑地推出论题，即论据和论题之间要有必然的联系。\n违反这条规则就会犯“推不出”的逻辑错误。有以下几种常见的情况：\n1.推理形式不正确\n从论据不能必然地推出论题。例如：“他近视得很厉害，一定很聪明。”“近视”跟“聪明”之间没 有必然的联系，我们不能以近视为依据，证明他是否聪明。这个论证实际上运用了如下推理：\n所有的聪明人都是近视眼，\n他近视得很厉害，\n所以，他一定很聪明。\n这一推理违反了三段论的推理规则：中项至少要周延一次。两个前提中的“近视”，表述方式都是肯 定的，均不周延，所以这个推理形式是无效的。\n2.论据和论题毫不相干\n即论据和论题在内容上毫无关系。例如：“他学习不用功。因为，只有学习用功，才能考上大学。”在 这个论证中，论据“没有考上大学”是真实的，但论据和论题没有逻辑上的必然联系，所以从此论据出发是 推不出“他学习不用功”的结论的。\n3.论据不足\n即所引用的论据对于确定论题的真实性而言是必要的，但不是充分的。例如“如果天下雨,地就会湿. 现在地湿了，因此，一定是下雨了”。“下雨”是“地湿”的充分条件，但“地湿”不是“下雨”的充分条件，不能依据“地湿”这个条件，推出“下雨”的结论。\n4.理由虚假\n论证论题的理由虽摆出来了，但是虚假的。例如：《狼和小羊》这则寓言故事,狼要吃小羊的理由是, 小羊站在下游喝水污染了它在上游的水。这个理由显然是站不住脚的\n24种常见的逻辑错误\n1.稻草人\n即歪曲了别人的观点,使自己能够更加轻松地攻击别人。\n例子:小明说国家应该向教育投入更多的预算。小红回复道:“想不到你这么不爱国,居然想减少国防开支,让外国列强有机可乘。”\n2.错误归因\n即从两个事物可能存在相关性,就得出一个事物是造成另一个事物的原因。\n例子:小红指出,过去几个世纪全球海盗数量减少,全球温度在升高,从而认为海盗的数量的减少造成了气候变化。\n3.诉诸情感\n即试图通过操作别人的感情来取代一个有力的论述。\n例子:小红在饭店看到小明吃狗肉,于是上前训斥:“你怎么可以吃狗肉,小狗多么可爱,就像小朋友一样,你忍心伤害小朋友吗?”\n4.从论证到结论\n即看到别人的论述水平很低,或者别人的论述里面有谬误,就认为别人的观点一定是错误的。\n例子:一个人在电视上发表了很荒唐的言论来推广健康饮食理念,小红看后觉得健康饮食就是骗人的,于是开始每天暴饮暴食。\n5.滑坡谬误\n即搞得好像如果A发生了,那么Z也一定会发生,以此来表示A不应该发生。例子:小红反对同性恋婚姻,因为她认为如果我们允许同性恋结婚,那么就会有人想要和桌子结婚。\n6.人身攻击\n即讨论时针对对方的人格、动机或处境等,进行攻击或评论,并以此当作提出了理据去驳斥对方的论证或去支持自己的论点。\n例子:当小明提出了一个合理提议的时候,小红说她不相信小明的话,因为小明不爱国。\n7.诉诸虚伪\n即不正面回应别人对自己的批评,而是用批评别人作为回复。\n例子:小明指出小红犯了谬误,小红回应:“你之前也犯了谬误。”\n8.个人怀疑\n即因为自己不明白,就认为一个事物是假的。\n例子:小红指着石头说:“你说进化论是真的,那你让这块石头进化给我看看。”\n9.片面谬误\n即当观点被证明是错误的时候,用特例来给自己开脱。\n例子:小红说自己能算出未出生小孩的性别,但是孩子生下来后发现猜错了,于是她就说是算命的人缺乏信仰。\n10.诱导性问题\n即在提出问题的时候加入了诱导的成分,使得对方只能按着诱导来回答。\n例子:小红怀疑自己的丈夫和A搞外遇,于是就问他:“A屁股上有胎记吗?”\n11.举证责任\n即认为举证责任不在提出观点的人,而在于质疑观点的人。\n例子:小红说他相信宇宙是全能神创造的,因为没有人能证明全能神不存在,所以它是存在的。\n12.语义模糊\n即用双关语或者意思存有歧义的语言来歪曲事实。\n例子:地上一个猴,树上qi个猴,一共几个猴?\n13.赌徒谬误\n即认为随机事物的发生和之前发生的事情是有相关性的。\n例子:抛硬币时,如果前面连着五个正面,就认为下一个肯定是反面。\n14.乐队花车\n即试图说明因为很多人都在做同一件事情/相信同一件事物,这件事情就是对的。例子:看到《货币战争》那么畅销,小红相信一定是罗斯柴尔德和共济会在背后操纵着整个世界。\n15.诉诸权威\n即利用一个权威人物/机构的观点来取代一个有力的论述。\n例子:小红不知道怎么反驳进化论,于是就说:“我老公是大科学家,他觉得进化论是错的。”\n16.合成谬误\n即认为一个总体的组成部分所具有的特性,对于这个总体的其它部分也是普适的。例子:小红看到自行车车座是人造革,就觉得自行车其它部位也是人造革的。 17.没有真正的苏格兰人\n即提出了一个观点,并受到了别人的批评,试图用“诉诸纯洁”的方式来捍卫自己的观点。\n例子:小红认为所有的河南人都喜欢喝胡辣汤,但作为河南人的孙越不喜欢喝,小红就说只有“真正的”河南人才喜欢喝胡辣汤。\n18.基因谬误\n即通过一个事物的出身来判断它的好坏。\n例子:孙越说自己不喜欢喝胡辣汤,小红说:“你是河南人,怎么会不喜欢喝胡辣汤?”\n19.非黑即白\n即把黑和白作为仅有的可能,却忽略了其它可能性的存在。\n例子:在谈到反恐战争时,总统说如果你不支持反恐战争,你就是支持恐怖分子。\n20.循环论证\n即采用循环论证的方法来证明一个被包含在前提里面的观点。\n例子:KengDie教的经文《KengDie Sutra》里面说的东西都是真理,因为《KengDie Sutra》第一章第二段提到了“KengDie所述都是真理”。\n21.诉诸自然\n即认为一个事物是“自然”的,所以必然是更好的。\n例子:小红认为吃草药肯定比吃人工制造的药有效,因为草药更加“自然”。\n22.轶事证据\n即试图用个人经验或个案来取代逻辑论述或者有力的证据。\n例子:小红爷爷是个30年的老烟枪,现在80多岁身体还很健康,小红因此得出吸烟对身体无害的结论。\n23.德克萨斯神枪手\n即在大量的数据/证据中小心地挑选出对自己的观点有利的证据,而不使用那些对自己不利的数据/证据。\n例子:红X字会为了证明自己尽到了职责,到处宣传自己拨出了XXXX的善款,却只字不提自己公款消费的奢侈无度。\n24.中间立场\n即觉得两个极端观点的妥协肯定是对的。\n例子:小红认为疫苗会造成儿童自闭症,孙越持相反观点,小明认为两者观点的妥协才是正确的。\n谬误(Fallacies)，有广义和狭义之分。广义上是指一切与事实或真理不相符合的、虚假、错误、荒谬的认识。狭义上仅指在论证和辩说过程中，违反思维规律或规则、不合逻辑的推断和主张。\n谬误分为形式谬误(Formal Fallacy)和非形式谬误(Informal Fallacy)两种。\n所谓形式谬误，是指违反推理规则所犯的逻辑错误。一般而言，每一种有效的推理形式都有与之对应的违反这种推理规则而产生的谬误。\n所谓非形式谬误，是指结论不是依据某种推理、论证的形式从前提中得出，而是依赖语言和心理等方面的因素从前提中得到的，其谬误是有关推论的内容和实质的。非形式谬误的种类很多，很难对其进行全面而准确的分类。从上述导致谬误的两个重要因素，一般把非形式谬误分为语言歧义性谬误、相关性谬误（不相干谬误）和论据不足型谬误（弱归纳谬误）。\nInformal Fallacies\n一、心理相关性谬误（关联性谬误）不相干谬误\n诉诸权力（Appeal to Force）：以权势或武力服人。 （1）诉诸后果（Appeal to Consequences）：以讨好或不讨好的结果让人接受某个结论。\n（2）诉诸恐吓或威胁（Appeal to Threat）：“因为如果A你将陷入悲惨境地，所以非A。”\n都是父母常用的要求孩子服从的说法\n诉诸大众（Appeal to the Public）：以被公众广泛接纳为理由服人。 论证诉诸援引众人信念，也叫“以众取证”。 其形式是：\n因为众人都认为A（是对的好的美的/不对的不好的不美的）\n所以，A（是对的好的美的/不对的不好的不美的）\n例：《韩非子八经》中说：“言之为物也以多信，不然之物，十人云疑，百人然乎，千人不可解也。”\n比如强迫左撇子用右手，反对同性恋，认为人就该结婚生子\n人身攻击（Arguments Against the Person/Attacking the Person）：多发生在反驳别人观点时。 一种是攻击对方的长相、衣着、智力、品德和人格等。\nA断定P。\nA有缺陷S、M等。\n所以，P是假的（不可信的）。\n另一种是借助于攻击对方的处境，间接人身攻击，进而攻击别人的主张。\nA断定P。\nA处于某种特定环境。\n所以，P是假的（不可信的）。\n错谬〔一〕：以攻击发言人代替攻击其论点（因人废言）。\n错谬〔二〕：由回应论点改变为攻击论点发起人的处境。\n错谬〔三〕：提出「你也是！」的不恰当反问作论据。\n你我皆错（two wrongs make a right）\n比较典型的就是网暴了，键盘侠（无脑的喷子）\n诉诸怜悯（Appeal to Pity）：诉诸情感中的一种。以别人的同情心服人。 典型形式：“因为A很可怜，所以A的所作所为没有错。”\n饭圈行为，“哥哥已经很努力了”\n诉诸无知（Appeal to Ignorance）：因为不能否定，所以必然肯定，反之亦然。断定一件事物是正确，只是因为它未被证明是错误；或断定一件事物是错误，只因为它未被证明是正确。 典型形式：因为没有人能证明是A真的，所以是A假的。反之亦然。\n比如最近的清华学姐，还有《让子弹飞》中六子的悲惨遭遇，比如张玉环\n诉诸传统(Appeal to Tradition):以传统习俗等为据。 比如男女之间，子女的孝顺\n诉诸传说/谣言(Appeal to Rumor)：以听来的传言为据。 当今社会更为明显，网络谣言。\n诉诸想象/虚构(Appeal to Imagination)：以想象和虚构为据。 这个例子很多\n诉诸投射(Appeal to Projection)：如所谓的“换位思考”。典型的形式是：如果你处在他那个位置。 但实际上换位思考很难，做不到\n稻草人谬误（Straw man）：指借由曲解对方的论点，再针对曲解后的论点（替身稻草人）攻击，以达到批评对方原来的论点不合理的目的。 饭圈也有\n扯开话题（Red herring）：辩者改变话题，以分散注意力而提出的不相干事实或论点。或者说，是用与本论证无关的事情来转移论证本身争议的焦点。 又称歪曲论题、逃避话题、混淆/转移论题或红鲱鱼。是扭曲论证对象、转移讨论焦点的一种谬误，诡辩者常常借此浑水摸鱼。此谬误典型形式很多，下面只举一个。\n典型形式之一：“如果A则B，如果C则D；因为C；所以B。”（B与D往往很容易让人混淆，故诡辩者可以借此偷梁换柱。）\n二、弱归纳谬误（论据不足型谬误）\n诉诸权威（Appeal to Authority） 信仰权威使人们最自然的心理倾向，因而在日常论证中，人民广泛借用权威来论证。\n典型形式：“专家A在领域B所说的一切都是正确的，专家A在领域C说了D观点，所以D观点是正确的。”\n错谬〔一〕：诉诸所讨论的范畴以外的权威人士。\n错谬〔二〕：诉诸权威人士的个人意见。\n现实中资本的力量啊\n滑坡谬误（Slippery Slope）：不合理使用一连串因果关系。 一种将“可能性”转化为“必然性”的逻辑谬误。\n使用滑坡谬误的诡辩者，往往使用很长的一串级联在一起的推理。而这些推理中，很多都只是概率性的（甚至会是小到可以忽略的概率），而诡辩者故意说成是必然性的，于是可以从一件事最终“推理”出几乎毫无联系的结果。\n无害的第一步——（连锁反应，其实不太可能发生）——灾难性的后果\n“买日货就是帮日本侵略中国”：买日货—日本赚钱—日本有钱发展军事—日本侵略中国\n轻率概括（Hasty Generalization）：用作归纳总体性结论的样本太少。 小众统计（statistics of small numbers）\n偶性谬误（Fallacy of Accident）：以概括情况加诸应有的例外情况。 一般规则——（误用）——特殊事例。\n相反的例外（Converse Accident）：以例外情况加诸应有的概括情况。\n因果的谬误（Causal Fallacies）\n巧合谬误（Coincidental Correlation）：以个别情况肯定某种因果关系。\n无足轻重（Genuine but Insignificant Cause）：举出无足轻重的次要原因论证，遗漏真正的主因。\n倒果为因（Wrong Direction）：颠倒事件的因果关系。\n复合原因（Complex Cause）：只指出多个原因中的其中一个为事件主因。\n后此谬误（在此之后，所以，因此之故）：仅仅因为A事件先于B事件发生，就断定A事件是B事件的原因。\n合成谬误（Fallacy of Composition）：以总体的某部份符合某条件推断总体均符合某条件。以偏概全的一种， 将个体具有的某种性质，当成包含该个体的群体具有的普遍性质。\n分解谬误(Fallacy of Division) ：与合成谬误相反，它论证说：如果整体或集合具有某种性质，则它的每一部分或元素也具有此种性质。又称以全概偏，是一种在分析统计资料时常犯的错误。该谬误从群体具有的普遍性质，推出该群体中的任何个体必然具备该性质。\n强词夺理：无理强辩。因为强词夺理，所以可以为一切错误的论题辩护，也可以反对一切。诡辩者即如此，可以为相反的论点论证。\n一厢情愿（Wishful Thinking）：以自己单方面的想法作为论证根据。\n赌徒谬误（Gambler\u0026rsquo;s Fallacy）亦称为蒙地卡罗谬误，是一种错误的信念，以为随机序列中一个事件发生的机会率与之前发生的事件有关，即其发生的机会率会随着之前没有发生该事件的次数而上升。\n类比失当（Weak Analogy）：不当类比\n乞求论题（Begging the Question）：循环论证的一种，以待证的论题做论据。\n复杂问句（Complex Question）：一个问题包含着可能错误的预设。\n错误两难（False Dilemma）,又称虚假二分：为多於一个答案的问题提供不足（通常两个）的选择，而忽略了其他的选择，最典型的表现是非黑即白观点\n"},{"id":10,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%86%99%E4%BA%86%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%AA%81%E7%84%B6%E6%83%B3%E8%B5%B7%E6%9D%A5%E9%9C%8D%E9%87%91%E8%B5%B0%E4%BA%86/","title":"写了几行代码突然想起来霍金走了","parent":"他人存档","content":"写了几行代码突然想起来霍金走了。\n当然这没什么特别伤感的，他不是我爹我也不特别崇拜他。伤感是因为他是那个旧时代的东西。\n旧时代是什么意思呢？就是互联网的信息革命还没有开始。那时候人活的，相对现在这个时代而言，可能相对无聊一些；因为没有智能手机，没有朋友圈和微博，没有Google搜索，Youtube，没有吃鸡游戏或者吃其他什么。\n那时候人的时间都挺多的，但堪称珍贵的信息很少，可能是一本逻辑学，一本罪与罚，一本罗马帝国衰亡史，一本APUE或者龙书，一本艺术哲学，诸如此类；就是说这些书也是那些旧时代的有很多时间的人，很专注的思考和写作的；后面的人同样专注的看。\n你想霍金有那么不错的成就，一定程度上是因为他不能动弹，只好锻炼他的脑袋打发时间，认真思考了很多问题，当然不是所有的残疾人都成了物理学家，但那个旧时代，信息还是稀有品的时代，人们普遍的value它。\n在90年代的互联网诞生的时候，求知若渴的人们有着非常好的愿景；信息将会自由流动了，似乎很快世界上人人都很容易成为大师——你不再会因为找不到一本书而埋没你的才华。\n互联网20多年过去了。信息泛滥了，贬值到一钱不值——只剩一些骗子们在向傻子们兜售付费阅读。\n但同时人们的时间突然都没了，忙着刷微博和朋友圈，前端后端一个月开五场会，唉，哪有时间坐下来看看离散数学；春天秋天要郊游了，不能辜负性爱和美食。\n我曾经想是不是因为世界大了，人们突然变得挑剔了，所以看不见大师了；但是感觉不是，那些在旧时代里如笋生三年一般积淀下来的人在越来越少，一个个的离去，剩下的张牙舞爪的人们，跟你我一样普通。\n岁月浓缩的精品，是无可替代的。互联网正在让社会和它的缔造者的愿景背道而驰。一个新文盲时代在蓬勃兴起，各行各业，你再难看到那些勤学苦练至高山仰止的人。\n上帝和人类开了一个玩笑。他就知道人类从来不会懂得珍惜。\n"},{"id":11,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%8F%A4%E4%B9%9D%E5%8F%A4%E5%8D%81-%E7%8E%AF%E4%BF%9D%E4%B8%BB%E4%B9%89%E7%AC%A6%E5%90%88%E5%AE%97%E6%95%99%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E7%89%B9%E5%BE%81/","title":"古九古十 环保主义符合宗教的每一项特征","parent":"他人存档","content":"环保主义符合宗教的每一项特征\n古九古十 2022-12-06 18:03 发表于广东 以下文章来源于漫天霹雳 ，作者漫天雪798\n米塞斯说：“宗教的典型特征是：面对事实不为所动。”\n当今世界最大的宗教有两种，它们既不是基督教，也不是伊斯兰教，更不是佛教，而是环保教和拜国家教。\n所有宗教都是人为制造的。并不是神创造人，而是人创造了神。人们不愿意相信科学、将自己无法解释的事情归结为神秘的力量，更不愿意相信巧合，以及心灵上的嫉妒和苦楚无法宣泄，于是有些人抓住了这些特点，用自相矛盾的解释吸引信众，由此成了宗教领袖。他们并不是为了宗教而成为领袖，而是为了成为领袖而创造宗教。\n先有权力，后有宗教——真正意义的现代宗教，不同于古代人们的迷信和神秘信仰。\n注意，自相矛盾对于宗教来讲并非坏事，反而是它的必备特征。越是含混的反而越好，必须自相矛盾，才能让人们相信神秘的力量，才能增强其神秘感，独占其解释权。信者恒信，哪怕这些矛盾是多么荒谬。\n他们只需要做一件事，将那些怀疑它自相矛盾的人视为异教徒、打为异端、送上火刑架即可。\n毕竟，逻辑推理和科学验证，并不是宗教的强项，也不可能为宗教所采纳。科学与宗教是一对死敌。科学讲究理性，而宗教极端反感理性思维，因为理性思维就是对宗教的反动。\n宗教，不需要你的思考，信就行了。\n《理性乐观派》的作者马特·里德利在他的另一部著作《自下而上》——你看他这书的名字，就知道他在赞美什么反对什么了。当然是在赞美市场的自愿秩序，反对自上而下的人为设计——为我们展示了环保主义的宗教特征：\n环保主义者告诉我们，我们正在犯下罪过（排放二氧化碳），我们有原罪（人类的贪婪），我们被逐出了伊甸园（前工业化时代），我们必须忏悔（谴责不负责任的消费主义），必须赎罪（缴纳碳税），悔改（坚持让政治家喋喋不休地就气候变化提出警告），寻求救赎（可持续性）。有钱人可以购买赎罪券（碳补偿），留下自己的私人飞机，但任何人都不得背叛《圣经》（政府间气候变化专门委员会公布的报告）里规定的（对二氧化碳的）信仰。谴责异端（不信神的人）、尊崇圣人（阿尔·戈尔）、听奉先知（政府间气候变化专门委员会）是所有人的责任。如果我们不这样做，审判日（不可逆转的临界点）定会降临，届时，我们会感受到来自地狱的火焰（未来的热浪），体验到神祇的愤怒（更强烈的暴风雨）。幸运的是，上帝已经为我们送来了牺牲献祭的征兆，风力发电厂看起来是那么的像耶稣受难地。\n你看，跟宗教的叙事一模一样；在现实中跟宗教的手法也一模一样：谁要是不按他们的宗教戒律（限制二氧化碳排放，防止气候变暖和地球毁灭）办事，就是异教徒，必须受到惩罚，由此，每个人都必须按照他们的戒律行事，让它侵入你的私有财产，改变你的自由选择，因为那实际上就是你上交的赎罪券。\n推行他们所谓的环保政策，冻死饿死了无数人，在他们看来也无关紧要，那都是为信仰而必须做出的牺牲，就如同十字军东征中的杀人与被杀一样。\n尽管无数科学家已经用无可辩驳的研究成果表明，气候变化主要是地球轨道运动引起，与人类活动的关系微乎其微。在遥远的间冰期，二氧化碳含量比现在高，然而那时候并没有人类活动；20世纪全球气温上升仅为0.6℃；以及气候变化是自然的进程，也没有什么大不了，温度上升并非什么坏事……\n不论你拿出多少证据，都无法让他们改变信仰，一句我不听我不听我不听、顾左右而言他、描绘出一副未来的想象中的可怖景象、或者认为你是个不可理喻的顽固分子，就结束了这场辩论。\n然后继续捍卫他们的宗教，具体做法是：去卢浮宫泼油漆、开着大排量汽车反对尾气排放、睡在沥青路面上反对石油制品，坐着波音747开气候变化大会，关掉火力发电厂冻死人或者让人们承受更高的能源价格，让一个10来岁的、患有严重妄想症和精神分裂症的“环保少女”格雷塔·通贝里去拯救已经45亿岁高龄的地球，以及，对牛放屁征税……\n他们从来不会认为自己精神分裂，而是认为自己虔诚。\n当然，那些虔诚虔诚都是装出来的，就像装神弄鬼的太平天国领袖，目的不过是权力和金钱。而且这的确是来钱的快速途径。\n他们并非不知道相关关系与因果关系的区别。他们只是需要一个理由，一个在他们看来看似“科学”的理由，以推进他们的议程。这个理由到底与气候变化有无关系，其实并不是他们关心的。与他们推动的环保产业进程相关，才是最重要的。他们是先找目标，后找因果关系的，是先打枪再画靶子的。\n每年每个国家数亿美元的环保专项资金，环保产业集团为了垄断而给他们的赞助，源源不断地流入了他们的所谓基金会。他们用人们缴纳的税金全球旅游，出席各种名流宴会，收取高额的演讲、出场费、游说经费，制造无数垃圾论文，养活了无数寄生虫，数钱数到手发软，还能树立热爱地球和人类的人设，做梦都没有这么好骗钱的事情。\n当初的教士阶层，不就过的是这样的生活吗？他们有高高在上的地位、有高人一等的特权、有信众们的捐献供他们挥霍、还可以去性侵女教徒，以及变态地玩起恋童癖。这种事情至今不衰，看看2016年奥斯卡金像奖最佳影片《聚焦》，就知道了，那是一篇新闻报道改编的，也就是说，那电影讲的是真事。\n环保教是席卷全球的最大宗教，它是超越国界的最具破坏力的宗教。其目的与他们宣称的保护自然恰恰相反，那就是改变亘古不变的自然规律和人类社会的基本法则，让所有人对他们俯首称臣。\n能够与这个宗教相媲美的，还有一种全球性宗教：“拜国家教”。\n人们相信一个人只因为具备了某种特殊身份就立即变成天使，相信某种机构具有比上帝还强大的伟力，它不但可以提供安全，还可以提供幸福，提供衣食住行等人们需要的一切东西，不论它干了多少坏事情，人们都相信它是善良和正义的化身，不论你拜的是英国教、美国教还是德国教，它们共同的名字都叫“国家”。这是一个“宗教连锁店”，只要你的地球上，你就逃不掉。\n多么匪夷所思的事情啊，人们希望一个劫掠他钱财的人给他幸福；希望从事各种如果个人去干就是严重刑事犯罪的事情的集团，去保证他们的安全。跟所有宗教一样，它同样来历不明，明明来自于征服与没收，然而人们相信它来自于神秘的“社会契约”。任何精神正常的人都不会认为他曾经签过这样愚蠢的契约：让人随时拿走它的钱财乃至生命。\n然而人们就是信。\n"},{"id":12,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%96%84%E7%9A%84%E6%A6%82%E5%BF%B5/","title":"善的概念","parent":"他人存档","content":"善恶以或然性的因果关系为前提\n不论是善是恶，都以或然性的因果关系为前提。以从一对互为相反的选项里做出抉择为前提。\n善恶从一对正相反的选项里通过抉择来成就。没有“选项”，没有“抉择”，就无从谈及善恶。\n评判善恶“以自身为衡量的标尺”。即，衡量是否愿意将“作出的那个选项”降临到自己。如果我希望这个选项降临到自己，我又选择这个选项，使这个选项降临到别人，这就是为善。如果我不希望这个选项降临到自己，但我也还是选择这个选项，使这个选项降临到别人，这就是为恶。\n一个人,在有了一定的生活阅历,有了一定的经验和知识后,会产生欲求。清楚自己希望什么，躲避什么。对外部对象有了喜厌好恶。这就是“以自身为衡量的标尺”。如果他在与外界发生关系时，很清楚一个对象是自己喜欢、爱好的东西，但他还是把这个对象加到外界去，这就是善；如果他在与外界发生关系时，很清楚一个对象是自己嫌弃、憎恶的东西，但他也还是把这个对象加到外界去，这就是恶。\n恶，在本质上，是自主抉择时违背了矛盾律。抉择出的那个选项与自己的喜厌好恶相矛盾。\n关于善恶产生的条件：\n一、具有抉择能力。\n二、具有一定的个人喜好及相应欲求。\n三、在做出抉择时以矛盾律为依据（相符或是相违）。\n对善恶的评判，仅适用于人与人（或人与动物甚或其他一切事物）具有直接或间接关系的事件上。\n对善恶的评判只应以事前的自主抉择的目的为依据，而与此事的具体结果无关。\n对善恶评判应就事论事：这个人，在这件事里，是善还是恶；在那件事里，是善还是恶。一个人在他自己的生命里，作出的抉择很多，有时是善，有时是恶，有时既不是善也不是恶。所以，不能简单地对一个人下结论判断他是善还是恶。\n"},{"id":13,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E7%AE%80%E6%98%8E%E7%AC%94%E8%AE%B0/","title":"存在主义简明笔记","parent":"他人存档","content":"存在主义简明笔记\n作者：子小孙 江左乱弹 2020-02-23 17:38\n链接：https://mp.weixin.qq.com/s?__biz=MzI2MzA2NDUwNQ==\u0026amp;mid=2649195026\u0026amp;idx=1\u0026amp;sn=4662ddd24d89a1d6a6c6cadaa9611caa\u0026amp;chksm=f252bcc4c52535d2b9c553b36dc8d94496eaf849f2b7f4890719e64246a4a241ac571865f7b7\u0026amp;scene=21#wechat_redirect\n来源：微信公众号\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n01 存在先于本质 先有存在，后有意义。在事物存在之前，并没有一个它应该存在的意义。意义是被后天赋予的。抽象来说，实然之前，并无应然。\n02 上帝死了 在人类存在之前，并无存在一个先验的绝对的永恒的意义。人类存在的意义是自己赋予的，而非上帝。上帝无法定义人类是什么，无法指导或规定人类应该做什么。因为对于人类而言先有自己的存在，而后才有上帝的概念。是人创造了上帝，而非上帝创造了人类。\n此处的上帝可解释为“一切所谓的应然之物”：道德、伦理、规范、制度、法律等等。先有人类，后有道德。当两者冲突时，遵循人性，摒弃道德。最本能的，最道德，最人性。\n03 道德就是偏好 通俗的讲，你喜欢一个人，先有了你喜欢ta这一事实，而后才有你喜欢ta的各种理由。这些理由是你用来说服自己，以使得自己喜欢这一事实有理有据。\n道德亦然。你认为它是道德的，是因为它符合你的价值观和逻辑链，或者说“偏好”。\n尼采：不存在道德现象，只存在对现象的道德解释。\n04 人是自由的 既然上帝死了，道德只是偏好，那么人就是自由的。没有什么是应该做的，也没有什么是不应该做的。\n陀思妥耶夫斯基：一切都是被允许的。\n尼采：在任何情况下都不存在什么必须要去做的事。\n05 自由就是选择 自由不是绝对的。人的自由是选择的自由。人不能选择自己的出身，但是可以选择自己的活法；人不能改变必死的结局，但可以选择以怎样的态度来面对死神。\n《黑客帝国》neo：这是我的选择。\n《哈利波特》邓皇：定义我们的不是我们是谁，而是我们的选择。\n06 人对自己负责 人有选择的自由，不同的选择会导向不同的结果，因此人要对自己负责。假设人没有自由，或者说人的选择对最终的结局没有任何影响，那么人就不对这结局负有责任。因为他对最终结果无能为力。\n反过来说，如果一个人知道自己清楚地知道自己在选择什么，且明白该选择可能导致的结果，并且愿意去承担这个结果，那么他做何种选择都是可以理解的。因为这时的他是自由的。该选择可以是先放鸡蛋还是番茄等无关紧要的问题（我为什么要举这个例子？），也可以是反社会反人类的选择。\n07 焦虑的本质 人有不同的的选择，不同选择会导向不同的结果，并要对最终结果承担责任，所以人是焦虑的。焦虑，可视为选择恐惧症。\n尼布尔祈祷文：赐我平静，去接受我无能力的；赐我勇气，去改变我能改变的；最后赐我智慧，去识别两者的区别。\n08 世界是荒诞的 既然存在先于本质，那么意义就是一种人造之物。所有维系人类发展的使命感、荣誉、爱都是人类用来自欺欺人的发明。人类社会是空中楼阁，它唯一的支点在于信仰。宗教是信仰，政治、经济、文化也是信仰。货币是信用。国家和人民的概念建立在讲好故事的基础上。\n无意义才是人生的本质。无意义，也就是无根据，荒诞。\n加缪所说的唯一严肃的哲学问题，其实应该解释为：在认识人生的荒诞和无意义后，如何重新确立信仰，以自欺欺人地活下去。\n尼采：重估一切价值\n09 天上天下，唯我独尊 重估一切价值，这事我觉得王阳明做过。史称“守仁格竹”。格竹时的王阳明尚未通透，观花时的他倒通透了：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。两者的区别只在于“有我与无我”之境。万物皆备于我。\n释尊诞生时，向四方行七步，举右手而唱咏之偈句：天上天下唯我独尊，今兹而往生分已尽。\n重估一切价值的标准，只在于我而已。人类存在，上帝就死了；我一存在，人类就死了。万物必须通过我的意志来对我产生作用。\n人生并不是网游，而是一场单机游戏。只有我一人是玩家，其他都是NPC。\n10 世界是意志的 《不能承受之轻》中有这样一句问答：muss es sein? es muss sein.\n非此不可吗？非此不可。\n既然“尼采说在任何情况下都不存在什么必须要去做的事”，那又为什么非做不可呢？既然去做一件事情没有意义，没有必须去做的依据，为什么偏偏又去做了呢？世间的很多事情其实都处于可作不做之间；许多事情你去追问一句为什么，会发现其实并没有为什么。你做了，只是因为你乐意。俗话说“千金难买我乐意”。\n没有值不值得，只有愿不愿意；没有可不可以，只有想不想要。（如果你一定要说，我想要啊，但是我买不起啊。请参见“人的自由是选择的自由”）\n这个我乐意，就是叔本华和尼采说的“意志”。所有的一切都是意志的具象化。\n11 自我和本我 既然重估一切价值的标准只在于我的意志，那么加缪的哲学问题是否就迎刃而解了呢？其实难题才刚刚开始。\n认识你自己，本身就是个大难题。\n什么是我？哪个是我？人是否具有自由意志？\n自我？本我？超我？\n后面的还没整理好，今天先到这里吧。\n因为意义是外物赋予的，而人生的本质，不能由他人决定，也不由物化的标准评判。人并不是某种标签或者集合，主体的每一种行为，无一不昭示其本质，故其不籍意义而存在。\n我不为什么东西而生，也不为什么东西而死，不需要任何标签化的认同，不作为什么而存在，不需要任何标签化的定义，不需要任何标签化的解释。\n"},{"id":14,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%BE%88%E5%A4%9A%E5%B9%B4%E5%89%8D%E6%88%91%E5%AF%B9%E7%84%A6%E8%99%91%E7%97%87%E7%9A%84%E7%97%87%E7%8A%B6%E6%8F%8F%E8%BF%B0/","title":"很多年前我对焦虑症的症状描述","parent":"他人存档","content":"2018/12/15 17:00\n第一组：头晕，出虚汗，心悸，心跳过速，大脑昏沉，会以为是心脏病发作。 第二组：头疼，胃疼，特定部分疼痛，部分肢体颤抖。 第三组：失眠，反复失眠，基本上废了一两个小时刚睡着，然后一睁眼，刚睡了一小时，人整个都要疯掉了。 第四组：失去时间感官，开始有“不真实的感觉”，一夜过后没有“睡了一觉的感觉”。 第五组：会突然暴躁，\n"},{"id":15,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E6%88%91%E7%88%B8%E5%AF%B9%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A1%8C%E4%B8%9A%E7%9A%84%E7%9C%8B%E6%B3%95%E6%98%AF%E5%90%A6%E5%87%86%E7%A1%AE/","title":"我爸对计算机行业的看法，是否准确？","parent":"他人存档","content":"现在有很多人想当码农，他们都很努力，无论是刷题，还是加班，看上去内卷的很厉害。我看见他们这种状态，觉得自己也非学计算机不可，而且也必须很拼。我问了我爸的意见，我爸跟我说：“无论你从事什么行业，首先要对市场有概念。你选择了一个行业，首先要去想怎么切入市场。对于计算机行业而言，市场被大公司所占据，对于个人而言，切入市场的方式就是迎合这些公司的招聘要求，这相当于从被动的角度去解决问题。但是如果你有自己的爱好，对这个爱好能保持长期的热情，并且这个爱好也可以切入市场，这时候，你可以选择去迎合大公司，但是同样，你也可以从社会的供需关系来切入市场，从最底层来塑造一个模式，利用复利的原理来扩大这个模式。这个模式，很可能不是技术书、面试题所能衡量的，它可能并不是高科技，也不漂亮，但是你的目的是让它增长，然后再复制这个模式。如果你的兴趣就在这里，那你就仔细思考思考这个社会的经济形势和人与人之间的利益关系，想明白之后，塑造你的产品，为别人创造价值。慢慢你会发现，你自己有一个小圈子，在这个圈子里，你了解其中的一切，你明白游戏规则，这里的一切你做主。相反，如果你只知道学技术，刷题，即便你的技术再好，内心深处仍然会有被别人支配的恐惧感。而且，你时常会疑问，技术到底学多少，才能没有恐惧感？答案是，越学技术，很可能你会越质疑自己。因为你在一个无比复杂的圈子里，但是很难塑造自己的圈子，就是那个你自己做主的圈子”\n"},{"id":16,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E7%88%B1%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88-/","title":"爱到底是什么 ？","parent":"他人存档","content":"作者：adg9q 链接：https://www.zhihu.com/question/444126370/answer/1743255025 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n作者：知乎用户\r链接：https://www.zhihu.com/question/444126370/answer/1743255025\r来源：知乎\r著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r#爱#\r今天追本溯源的说一下爱这个概念。如果你有英语基础，对深入的理解这个概念会大有好处。\r下面是拉丁文版本、英王钦定本和中文和合本的对照。这三个版本本身有无数的小版本差异，我们这里不去打这个口舌官司，只看最显然的大局。\r为什么要选Bible？因为我们现在在东亚所谈的这个“爱”的概念，不是一个本来直接存在于东亚文化里的原生概念，\r为什么选择这三个版本？\r这个拉丁文版本，是基督教被立为罗马国教后确立的正典版本。\r带着你们一个词一个词的过一过。我先说明一下——我并不专精拉丁文，也并不主张你们以这里的答案为标准答案，因为与其说断言文字的原意就是如此，不如说这些是我个人的理解。\rCaritas patiens est, benigna est.\rCharity suffereth long, and is kind.\r爱是恒久忍耐，又有恩慈。\rpatiens。这是“病人”吗？这是耐心。专指忍耐痛苦的耐心。也因此，会将忍耐病痛的人称为patient。\rsuffereth - surffers - 受苦\rCaritas non aemulatur,\rcharity envieth not;\r爱是不嫉妒\renvieth - envy - 嫉妒\rnon agit perperam,\rcharity vaunteth not itself,\r不自夸\rnon inflatur.\ris not puffed up.\r不张狂\rinflatur - inflate - 膨胀，给轮胎充气。\r5 non est ambitiosa,\rdoth not behave itself unseemly,\r爱是不做害羞的事\rambitiosa - ambition - 野心\r爱没有野心。\r这句被英王钦定版翻成了doth not behave itself unseemly。\r拉丁文版是由修士一天祈祷几个小时，然后在精神和肉体的巅峰提笔抄几个词在羊皮卷上，这样抄若干年才出一本的东西。是给各个教区座堂的镇殿之宝。\r詹姆士王版本是印刷机像印报纸一样印了准备发给基本不识字、只会说英文白话的老百姓当报纸读的通俗读物。英王钦定本和莎士比亚作品一起奠定了现代英语的根基——实际上前者的作用更为根本。但这也带来了一个非常致命的问题——它导致圣经的原意被英语文化的语境迁移了。\r比如这句至关重要的“爱无野心”，被迁移成了“爱是不做害羞的事”。但微妙的是，何谓理应“害羞”的事，何谓unseemly，却是一件“皇家御准事业”。这一句转译，其实将原文的解释权轻轻巧巧的从教会的大公会议上转移到了国王御案上。\rnon quaerit quae sua sunt,\rseeketh not her own,\r爱是不求自己的益处\rSeeketh - seeks - 寻求\rnon irritatur,\ris not easily provoked,\r爱是不轻易发怒\rirritatur - irritate - 被激怒\rprovoked - 被挑衅\r爱不受挑衅。\rnon cogitat malum,\rthinketh no evil;\r爱是不计较人的恶\r这实际上是——爱不想象恶，不向恶思索，爱不以恶意揣测人。\r爱不思恶。\r6 non gaudet super iniquitate,\rrejoiceth not in iniquity,\r不喜欢不义\riniquity 敌意的行为、恶意的行为\r中文翻译成不喜欢不义，实际上是指不喜欢任何对ta人含有恶意、冀望人受损的行为。\rcongaudet autem veritati:\rbut rejoiceth in the truth;\r只喜欢真理\r无论一个幻觉让你如何享受，一个事实让你如何折磨，得以明了事实、摆脱幻觉，都是一件值得庆贺和欣喜的事。\r爱之中根植了“事实自身永远是善”的价值观。\r爱以真实为乐。\r7 omnia suffert,\rbeareth all things,\r凡事包容\rsuffert - 忍耐\romnia - 全向的、全部的。omni light，就是指全向射灯，一个向所有方向发射光的的灯，如同太阳那样。\rbeareth - bears - 忍受\r这其实应该译作“凡事忍受”。但是很显然中文译者意识得到在中文语境中说“凡事忍受”恐怕因为文化心理隔阂造成极大的信仰障碍，所以他们转了个身，翻译成了包容、宽容。\r但其实在拉丁文中其实就是“忍饥挨饿”那样性质的忍受。\r爱以忍受包容一切。\romnia credit,\rbelieveth all things,\r凡事相信\r这又是一个至关重要的迁移\r就我个人理解，credit不是“相信”，而是“授信”。“相信”涉及到了信仰，是指“认信为真”，而credit，“授信”，是指“以真视之”。\rcredit card 信用卡，是对你的授信，是指首先假定你是真的，等你违信了再作反应。\r而believe，则是认定你为真，这意味着当出现暗示你为假的迹象时，believer有拒绝采纳为证据、拒绝转为不信的义务，即坚信的义务。没有这种“对怀疑的免疫力”，是不成其为believe的，只可以称为credit。\r所以，这句按拉丁文，实际上应该译为“凡事授信”，即对一切人的声称，首先当作真实的诚实的来对待，直到看到事实与此相悖。\romnia sperat,\rhopeth all things,\r凡事盼望\rhopeth - hopes - 希望、期盼\r对一切都寄予希望。也就是永远无所谓“我对你绝望了”，或者“我对这事绝望了”。\r你可以决定以其他的任何理由来停止投入某事或者停止服务某人，但这不可以是因为“绝望”。\r因为作为不能预测未来、不能决定历史的人类，没有逻辑上有效的能力来做出“绝望”的结论。\romnia sustinet.\rendureth all things.\r凡事忍耐\rsustinet。现在有个很流行的概念，叫做sustainability——可持续性。sustinet，应该译为持续、坚持。\r在英文里翻译为了endureth，这是一种“硬挺着直到灾难过去”的意思，其实也适合翻译为“凡事坚持”。\r8 Caritas numquam excidit\rCharity never faileth\r爱是永不止息\rnumquam excidit，从不失败\rnever fail，从不失败\r爱从不失败。\r爱既然从不失败，爱自然从不认输，于是中文翻成了——\r爱永不止息。\r这个源头，无论是拉丁文版，还是英王钦定本，都没有将这里的“爱”对应为Love，而是caritas，charity。\rLove是什么？Love是盎格鲁撒克逊语系的原生词，lubo / Liubi / Lieber / lob / lof / liob / lien 表示“快乐”、“赞美”。它是指向“快乐的情绪”，指“使人快乐”。\r因为英国的崛起而导致的从拉丁文的“Caritas / 慈善”向盎格鲁撒克逊语的“Love / 使人快乐”的迁移，是“爱”这个概念的一次至关重要的异变。\r真正令人叹息的，是“欲使人快乐的东西”并不能使人快乐。是Caritas使人真正的平安喜乐。\rLove，并不能真的替代caritas作为“爱”的对位表述。\r记住：\r爱不是“love”，爱是caritas，爱是慈善。\r一种行为，若不是慈善，则不成其为爱。\r爱不是你侬我侬，耳鬓厮磨，缠绵悱恻，更不是寤寐思服、辗转反侧——根本就不是这种东西。\r爱是caritas，不是love。\rCaritas / 慈善，无虑性别，无虑种族、无虑阶级、无虑意识形态。\r它不自夸，不膨胀，无野心，不想象恶，甘愿受苦，信奉真理，凡事授信，永不绝望。\r它永不认输。\r爱是人类借以穿透一切兽性、消解一切恶念，最终战胜一切罪恶的神性内核。\r是人所能行最近于神的事。 "},{"id":17,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E7%8B%B8%E5%8F%91%E8%B4%A2-%E6%B5%85%E8%B0%88%E7%88%B1%E6%83%85/","title":"狸发财 浅谈爱情","parent":"他人存档","content":"原创 狸发财 狸发财 2022-09-19 10:18 发表于湖北\n谈个屁，我也不懂。\n我只知道爱情对我来说出现的概率太低，我这个人普通但刁钻。我之前的恋爱都是在对方对我好的前提让我去习惯从而产生依赖，但那就是爱了吗？显然不是。感觉每次分开所产生的难过只不过是为接下来的生活都要自己一个抗了哦而感到不爽。我哪有什么爱情，我是一个没有感情的生物，我对人类的身体亲密接触有一种天然的抵触，我很难去跟人牵手接吻，因为这个原因，我前任都怀疑我不爱他，不在乎他。这么仔细想来，他说得也有道理。但我很需要人跟我讲话，跟我聊天，听我那不切实际的幻想。我的幻想世界很想要别人的加入，因为我从小到大就喜欢和人分享，这个毛病导致于我长这么大了还是没办法吃独食。只要家里有维修师傅或者钟点工阿姨我就不吃东西，再饿都不吃，因为我没法吃独食，也不喜欢跟陌生人一起吃东西，所以我只能饿肚子。\n你要问我爱情是什么，我也不知道。我总感觉我还没有长大到能拥有这个东西，因为我幼稚且无知，还拥有无穷无尽的幻想。我对两个人的开心不建立在大众标准中，当然高端的大众标准能给人带来一些虚荣感的满足。比如对方多帅多有钱多拿得出手。但那就是爱了吗？显然不是。\n我非常记得《我爱上的人是奇葩》里面女主坐在大导演家的浴缸里给男主打电话聊了好久好久的天。我当时看到这一场景的时候，就觉得这是爱情吧？我觉得爱情没什么其他的，就是两个人每天都能聊天，有个人陪自己做一些奇怪的事情，然后疯狂做爱。性器官匹配确实是爱情缺一不少的条件，有些人一年半载才搞一次的是纯爱吗？应该不是吧。\n有些人真的会谈非常非常多的恋爱，多到你不知道他谈那么多爱有什么用，是集满就获得一个传说吗？还有一些人一些恋爱谈很多很多年再分手，想分手谈那么久干什么，能颁奖吗？\n你看感情就是如此让人摸不着头脑。\n我对爱情有很多很多的疑惑，所以我感觉我不会结婚，我无法维持长久关系，但如果结婚能收不少份子钱的话，我还是会选择结。因为这个东西对我来说不重要，我没什么道德感，我也并不认为结几次婚有什么说法，但如果你结了十三次婚自然可以收获我一句“牛逼，收了不少份子钱吧。”\n我真的是一个很没有道德感的小混蛋，爱情根本不是婚姻可以理解的，感觉婚姻只是为了社会关系的稳定。我今天爱你，明天遇到了他可能就爱他了。所以“我今天还爱着你”这句话可比“我永远爱你”这句承诺来得动听。\n当然我非常反对出轨这件事情，倒不是我道德感有多强，我在好几年前特别小的时候也出过轨，我出得还特别坦然自若。直接告诉对方，并让对方看着办。只要把问题抛给对方，我就不用解决问题。我不建议大家都这么干，我当时能这么干，是因为那时候的我们年纪都小得可怕，可怕到做一些匪夷所思的事情也是可以理解的。\n我觉得隐瞒性出轨这件事说白了，就是你这个人没种。你又压不住自己的欲望，你又没有勇气去坦白。偷偷摸摸享受两个人的爱恋，感觉也很辛苦吧，一句话要讲两遍。但迟早有翻船的一天，建议坦白从宽抗拒从严。我觉得被出轨的人真的要硬气一点，我看过好多对方出轨了，但依旧念念不忘委曲求全的人，看着真可怜。\n希望无论男女，面对配偶出轨，都可以直接嫣然一笑，转头就走，一句话都不要讲。让对方懵逼到自我否认：“怎么出轨都不跟我吵，是不是不在乎我，是不是不爱我”。真的，一旦你这样，没人能伤害你。虽然戴绿帽子肯定不好受，但戴了绿帽子还要在大庭广众之下跟人打一架更不好看。世界上真没那么多人关心你的情感情绪问题，大家都只是单纯想吃点瓜，单纯找点乐子，千万别让自己的痛苦成为他人的笑柄。被出轨的人听我一句劝，咱们默默找个没人的地方把绿帽子摘下就得了，摘完还是一条好汉。\n真的很奇怪，我明明是想讲爱情，莫名其妙在末尾就变成了绿帽子。我怀疑我思维方式很有问题，我好像一直都如此不清白。所以也不要听我乱讲了，直接点击下面得了。\n文章已于2022-09-19修改\n"},{"id":18,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B3%E4%BA%8E%E9%98%B6%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98-%E9%B2%B8%E4%B9%A6/","title":"说一下关于阶级的问题 鲸书","parent":"他人存档","content":"前一阵儿有一位导演请我看剧本，有个情节是主人公爱看一个破烂的小建筑，终于他的困境解决了，那个破楼突然也修好了，有点呼应感。导演却担心：主角是个农村穷孩子，就图挣钱，怎么可能关注到一个小破楼，还拿赏花赏月的闲情关心它呢？\n我一听就有点堵得慌，除去戏剧创作的逻辑，其实是下意识生气了，不好发作，也就没立刻接话。\n一旁的@文正北 却说，没有啊，你看下雪了，春天桃花开了，那些清洁工嬢嬢也会拍拍发朋友圈的，爱美的心是人都有的。\n我心想，是啊，人家刚毕业小朋友都能明白的理，到你这就怎么顺不通呢？但我也理解这位导演，他毕竟读了太多社会学的书了。\n现在特别流行阶级分析论，能套一切文本，万精油，超越思聪逃离北上广凤凰男去哪过春节装腔指南降PU找一个布男北京女子图鉴金融街没有爱情……一切都能用阶级那一套分析。\n也对，毕竟这可能是我们这个时代最大的痛点了。谁不焦虑呢？天花板是透明的，好像离得也不远，谁踩你头上也看得清清楚楚，好像也没比我厉害多少啊，可这个天花板钢筋铁打的一样，头破血流，跳不上去了。\n为什么明星类真人秀受限，不止是娱乐化不爱国的问题，更是“阶级差异视觉化”的问题，黄圣依为了不露富，特意买一座2000W别墅录节目，以为可以避险就可见一斑了。明明大家都该活得养猪场似的，你的床上却是天鹅绒，凭啥啊？\n这些都对。\n但是阶级之外，买买买之外，甚至人类生活之外，还有一个更广博高远的世界。再极端的国家也没有不允许人看花，也没有任何一条法律能阻止人相爱，养猪场里也有闻一闻春天的风的自由。\n得从焦躁的精准的阶级自我定位里跳出来，叉死房间里的大象，烧了社会学的书，体会一下纯然为人的快乐吧。✌️\n"},{"id":19,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E9%BA%A6%E5%87%AF%E6%81%A9%E4%B9%8B%E6%AD%BB%E4%B8%8E%E8%BF%99%E4%B8%AA%E8%87%AA%E6%81%8B%E7%9A%84%E6%97%B6%E4%BB%A3/","title":"麦凯恩之死与这个自恋的时代","parent":"他人存档","content":"麦凯恩之死与这个自恋的时代 Death in the Age of Narcissism 弗兰克·布鲁尼 2018年8月28日\nJust before and after John McCain’s death on Saturday, I read many tweets, Facebook posts and essays that beautifully captured his importance. 就在约翰·麦凯恩(John McCain)上周六去世前后，我阅读了许多推文、Facebook帖子和各种文章，它们都很好地说明了麦凯恩的重要性。 I read many that were equally concerned with the importance of their authors: 我还读到，许多文字同样旨在彰显说话者自身何其重要： Here’s how much time I spent around McCain. I’m also close to his daughter Meghan. This is the compliment he once gave me. This is what I said back. I voted for him this many times. I agreed with him on these issues but not those. It’s difficult to describe how pained I am. Here’s a photo of me looking mournful. 看看我有多少时间是跟麦凯恩一起度过的。我跟他的女儿梅根关系也很好。他曾经这样夸奖我。我是这么回应的。我多次投票给他。我同意他在这些问题上的看法，但在那些问题上，我保留自己的意见。我的痛苦难以形容。这张照片里，我的样子很悲痛。 Were these hymns to McCain or arias of self-congratulation? The line blurred as the focus swerved from the celebrated to the celebrator. 这些究竟是对麦凯恩的赞美诗，还是自鸣得意的咏叹调？当焦点从被赞美者转向赞美者的时候，界限变得模糊。 A measure of this is inevitable and even right. One of the best ways to convey someone’s impact on the world is to demonstrate and universalize his or her effect on us, and our own stories and memories are our inimitable additions to the conversation. 这在一定程度上是不可避免的，甚至是正确的。表达一个人对世界有何种影响的最佳方式之一，就是将他或者她对我们的影响告知世人，而我们自己的故事和记忆对讨论的贡献是别人无法模仿的。 But a little of the first-person singular goes a long way. 但是，本应起到点缀作用的第一人称叙述，变得喧宾夺主。 Did you hear Donald Trump on the day Aretha Franklin died? In the first sentence out of his mouth, he defined her as “a person I knew well.” In the second, he alluded to a few of her performances in hotels that he owned by saying, “She worked for me.” The remark was classic Trump in its offensiveness. But it also reflected a more widespread conflation of eulogy and personal P.R. 你注意到唐纳德·特朗普在阿丽莎·富兰克林(Aretha Franklin)去世那天说什么了吗？从他嘴里出来的第一句话，把她定义为“一个我很熟悉的人”。在第二句话里，提到了她在自己的酒店里的一些表演，说“她为我工作”。这是特朗普一贯的无礼风格，但也反映出悼词和个人公关之间更为常见的一种融合。 Did you see Madonna at MTV’s Video Music Awards? She stepped up to the microphone, began to memorialize Franklin and mused at great length about the raw ambition, relentless rise and gritty resilience of … Madonna! “So you are probably all wondering why I am telling you this story,” she finally added, stirring from her solipsistic stupor. 你看麦当娜出席MTV台音乐录音带大奖了吗？她走到麦克风前，开始纪念富兰克林，若有所思地絮叨着原始的野心、无情的崛起和坚韧不拔不屈不挠的……麦当娜！“所以，你们可能都想知道我为什么要跟你们说这个故事，”她最后从自我陶醉中醒过来，补充道。 麦当娜在MTV音乐录影带大奖上谈论阿丽莎·富兰克林，以及她自己。 麦当娜在MTV音乐录影带大奖上谈论阿丽莎·富兰克林，以及她自己。 LUCAS JACKSON/REUTERS No, we weren’t “wondering why.” We were “appalled that.” As Stuart Heritage of The Guardian wrote, “Madonna took Franklin’s legacy and forced it through a prism so utterly self-regarding that even the jazzed-up kids in the audience looked like they were losing the will to live.” But while her indulgence was extreme, it was also emblematic. 不，我们并不“想知道”。我们对此“感到震惊”。正如《卫报》(The Guardian)的斯图尔特·赫里蒂奇(Stuart Heritage)写的那样：“麦当娜继承了富兰克林的遗产，强行用一个完全以自我为中心的棱镜加以折射，以至于观众中哪怕是那些最兴奋的孩子，看上去也像是失去了活下去的盼头。”虽然她的这种肆意妄为是极端的例子，但也是具有象征性的。 The rest of us have neither the megaphones nor megalomania of Trump and Madonna, but we have some of the same impulses when weighing in on famous people’s deaths. We find the one point where we intersected with them. We wedge in our own biographies. We flaunt our own résumés. 我们其他人既没有特朗普和麦当娜面前的扩音器，也不是他们那样的自大狂，但当我们就名人之死发表看法时，也会有着同样的冲动。我们找到与他们相交的那个点，把自己的传记楔入进去。我们炫耀的是自己的履历。 We assert our character through our grief — or our lack of it. (No shortage of cranks on Twitter deemed this past weekend an appropriate occasion to revel in their distaste for McCain.) It’s classic virtue signaling, gauchely timed and in need of a more specific phrase. Virtue grieving? Obituary opportunism? 我们通过悲伤或者缺乏悲伤来主张自己的性格。（Twitter上不乏怪人，他们认为上周末是享受自己对麦凯恩厌恶的好时候）这是典型的道德炫耀，时机很不得体，而且需要一个更为契合的表达。美德哀悼？讣文投机主义？ To wade through reactions to the losses of McCain, Franklin and other public figures who have died this year is to wallow in anecdotes, information and statements of principle that are obliquely or clumsily attached to the sadness at hand. 我把这归咎于社交媒体，它可以立即做出某种反应，看上去几乎是强制性的，就像家庭作业一样。它承诺“喜欢”和“分享”，成了误判的助产士，自恋的扩大器。 I blame social media, which can make some kind of immediate response seem almost compulsory, like a homework assignment. It’s a midwife to bad judgment and a narcissism multiplier, with its promise of likes and shares. 我还怪新闻业，这个行业目前正处于这样一个阶段，鼓励其从业者将重大事件视为塑造品牌的机会，在他人的叙事中刻画我们自己的小环境，要成为剧中人和向导。要做到这一点同时不流露出沾沾自喜是很难的，而且我们当中有很多人都会在这方面失误，所以我也不打算在本专栏中特意指出任何人了。出于类似的原因，我不会指责那些从麦凯恩笨拙地转向他们自己小世界的政客和助手。 I also blame journalism, which is in a phase that encourages its practitioners to treat big developments as branding opportunities, carve our own niches in others’ narratives and become characters as well as guides. Doing that without preening is tricky business, and so many of us bungle it that I’m not going to single out anyone in this column. For similar reasons, I’m not going to point fingers at the politicians and aides who pivoted so awkwardly from McCain to their own navels. 六年前诺拉·埃芙隆(Nora Ephron)去世时，我一眼注意到了一些充满自夸的奇怪悼词。似乎好莱坞、纽约和华盛顿的所有人都认识她。也许确实如此：她精力极为充沛，有联络人脉的天分。在我当时写的东西里，我对自己和她的关系写得太过清楚了。现在我回头看它，感到很难堪。 I first noticed a surfeit of oddly boastful eulogies when Nora Ephron died six years ago. It seemed that everyone in Hollywood, New York and Washington knew her. Maybe everyone did: She had tremendous energy and a talent for connection. I made my own connection to her much too clear in something that I wrote then. I look back at it and cringe. 我们当中许多人并不完全欣赏我们正在做的这种事，而对于其他很多人来说，这是一个对之更加关注的极好理由。它破坏了我们本来应有的目标，也就是将其他人置于聚光灯下。如果我们自己挤满了舞台，就无法做到这一点。 Many of us don’t fully appreciate what we’re doing, and that’s a damned good reason, among plenty of others, to pay closer attention to it. It undermines what should be our goal, which is to put someone else in the spotlight. We can’t do that if we’re crowding the stage. 说到舞台，“旅程”(Journey)乐队最近演出时，在他们背后的屏幕播放了富兰克林的照片作为纪念。一位乐评人在评论中称赞了这件事。然后，“旅程”的吉他手尼尔·朔恩(Neal Schon)及其公关人员联系了他，希望对文章进行修正，用公关的话说，要指出这个致敬并不是乐队的安排，而是“由尼尔独自完成的”。 Speaking of stages, a screen behind one on which the band Journey recently performed showed pictures, in memoriam, of Franklin. A music critic made positive note of that in his review. He was then contacted by Journey’s guitarist, Neal Schon, and his publicist, who wanted the review corrected to specify, in the publicist’s words, that the tribute was not arranged by the whole band but “was done solo by Neal himself.” 这下澄清了。同样清楚的，还有他真正迷恋的对象是谁。\n"},{"id":20,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BD%93%E9%87%8D%E8%AE%B0%E5%BD%95/","title":"体重记录","parent":"-随笔","content":"体重记录： 2017、9、20 早餐前：84.9kg 早餐后：85.6kg 午餐前: 午餐后： 晚餐前： 晚餐后： 睡前\n体重记录： 2017、9、21 早餐前： 早餐后：86.3kg 午餐前: 午餐后： 晚餐前： 晚餐后： 睡前 理论上当热量缺口累计到达7700kcal时，人体就会减少1kg的脂肪。\n7700 / 7 = 1100 kcal\n我的基础代谢率（BMR） 为 1772.25 千卡 / 天\n公式： 1 千焦=238.9 卡(卡路里)\n1千卡=1大卡=1000卡=1000卡路里 =4184焦耳=4.184千焦\n2022年10月9日 早餐： 豆腐脑 192 kcal 蒸饺 454 kcal 646 大卡\n午餐： 160g * 1065/100 = 1704 千焦 三明治 140g * 1287/100 = 1801.8 千焦 鸡肉卷\n午餐热量计算： 3505.8 千焦 837535.62 卡路里 837.53562 大卡\n"},{"id":21,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BD%9C%E4%B8%BA%E8%81%8C%E4%B8%9A%E5%AF%B9%E6%AF%94%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C%E5%85%AC%E5%8A%A1%E5%91%98/","title":"作为职业对比程序员和公务员","parent":"-随笔","content":"中国公务员有两种统计口径。狭义的公务员是指,各级行政机关工作人员,数量为500万人;宽义的公务员是指,行政机关、政党机关和社会团体的工作人员,数量为1053万人。”\n中国公务员总数为716万人，中国的县处级以上干部60多万人。中国的厅局级干部有5万多人。中国的省部级干部大约有3000多人。不包括国有企事业单位的干部。北京市拥有1.3万多名正处级以上的干部。我们中国公务员和事业编加起来5600万人。\n程序员，2019年9月初，有600w上下。\n入行难度： 素质要求： 吃苦耐劳、自律、自学、专注、抗压能力 工资： 工资多少 福利： 休假、奖金、工作环境 发展前景： 1、阶级跃升的概率 稳定性： 岗位数量： 流动性： 工作强度： 社会地位： 人脉关系： 努力、运气、贵人 对个人轨迹的影响：能不能接受 努力 没用？ 工资高、流动性好：那么就会有无数的新驴入行，把前浪拍死在沙滩上。卷疯（程序员） 工资高、流动性差：潜规则就容易多。（教师、医生、公务员）\n"},{"id":22,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E5%87%8F%E8%82%A5%E5%81%A5%E8%BA%AB/","title":"减肥、健身","parent":"-随笔","content":" 减肥、健身 基础代谢率（BMR） 基础代谢率是指人体维持心跳、呼吸等基本生理活动所消耗的热量。 基础代谢率（Basal Metabolic Rate，BMR）是指在自然温度（18 ~ 25℃）环境中，清醒、静卧、空腹、思想放松状态下，维持生命（心跳、呼吸、腺体分泌、肾脏过滤排泄、解毒等）所需消耗的最低能量。 这里采用与实测相差最小的 Mifflin-St 公式为计算方法\nMifflin-St Jeor公式如下所示：\r对于女性：（10×体重公斤）+（6.25×身高厘米）−（5×年龄岁）− 161\r对于男性：（10×体重（kg））+（6.25×身高（cm））−（5×年龄（岁））+ 5\r86.0 * 10 + 6.25 * 169 - 5 * 30 + 5 = 1771.25\r860 + 1056.25 - 150 + 5 = 1771.25\r1771.25 * 1.2 = 2125.5\r1771.25 * 1.375 = 2435.46\r1771.25 * 1.55 = 2745.43\r1771.25 * 1.725 = 3055.40 该公式还考虑了您的身体活动，因此您需要将结果乘以一定的数字：\n如果您没有进行任何体育锻炼，而您必须花费大量的时间坐下来，则将结果乘以1.2。 如果您每周进行少量运动或进行1-3次运动，则将结果乘以1.375。 如果您每周进行3-5次中等运动，则将卡路里数乘以1.55。 如果您每周进行6-7次完整锻炼，则需要将该数字乘以1.725。 最后，如果您的工作与体育锻炼有关，并且每周至少运动两次，则需要将结果乘以1.9。\n"},{"id":23,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E5%BE%AE%E5%8D%9A/","title":"微博","parent":"-随笔","content":"微博\n2022-8-3\n我在想，如果中国面临韩信的问题怎么办？只能无限、无限的无限相信自己，才能支持自己跪着走过去，才能越过眼前的黑暗，考验自信的时候到了。\n2022-8-3\n其实还是那个问题，我不上清华是因为我不想吗？收复湾湾必然史册留名，他是因为不想吗？（另，合格基本要求就是不能被感情来趋使）。\n2022-8-1\n我知道我的性格中有非常原始幼稚的一部分，以前都是在小心隐藏，唯恐暴露，也有自欺欺人，不去正视。 但是现在我的态度却另有变化：我不再强行扭曲自己幼稚的部分，幼稚就由着这种幼稚驱使，在不伤害他人的情况下顺从着幼稚，如果机缘巧合，我看了某本书，遇到了某件事，甚至仅仅是因为某个动念，我那幼稚的部分，成熟了，那就顺其自然的改变\n2022-7-25\n人们已经处在一个不同时代的时代。\n2022-7-23\n我这个年纪，不想再费力地取悦谁了，如果同路，就一起相伴着走一场吧。\n2022-7-21\n我有几节废旧电池，随我在北京搬了几次家，因为我怕直接丢垃圾桶会污染环境[悲伤]，又是拖延症患者，没行动力去找专门回收的地方。\n2022-7-19\n今天看《明朝的那些事》讲到魏忠贤，说他是个混混，特点是：要面子，不要脸。（要脸：自己对自己约束；面子：他人对你的虚荣的满足）。\n2022-7-15\n相对于现在这个“政治正确极化”的世界，我还是更喜欢那个多元化的世界。我们对太多相对正确的问题给出了“绝对正确”的答案。\n"},{"id":24,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%84%8F%E4%B9%89%E4%B8%8D%E6%98%8E%E7%9A%84%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD-%E4%B8%8D%E6%88%90%E7%AB%A0%E5%8F%A5/","title":"意义不明的只言片语 不成章句","parent":"-随笔","content":"意义不明的只言片语-不成章句\n沉沦超拔，进入超越。\n热气球，铁路，九天空轨；\n骚扰电话自动应答机器人；（自动设置应答后通话时间，自动设置应答语音语色，离线运行、语义分析、陌生号码自动应答，通话录音，数据收集）；\n听出 不了情\n极品音乐音乐论坛。\n大眼睛，希望工程。\n广告：香奈儿，我永远添加\n"},{"id":25,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2%E4%BB%8E%E5%8A%A8%E7%89%A9%E5%88%B0%E4%B8%8A%E5%B8%9D-%E7%AC%AC12%E7%AB%A0-%E5%AE%97%E6%95%99%E7%9A%84%E6%B3%95%E5%88%99/","title":"《人类简史：从动物到上帝》 第12章 宗教的法则","parent":"我的","content":"简单做下笔记：\n最开始是泛灵信仰，万物有灵，万物与人是平等关系。\n后面是多神教，希腊神话，罗马的万神殿就是典型，对泛灵论者来说，人类只是地球上众多生物的一种。但对多神论者来说，整个世界就像是反映了神和人类的关系（例如智慧、战神、幸运），多神教提高的除了神的地位，更有人的地位。多神教让羔羊变得沉默：掌管生育、掌管气候、掌管医药的各种神灵，好替人类和这些沉默的动植物沟通协商。这是一种契约，在这份契约中，人类承诺会永远崇敬某些神灵，以换取人类对其他动植物的控制权。\n在公元1世纪的时候，单一神教开始强盛，不论在何处，多神教都不断衍生出各种一神论宗教，这是由于这些宗教无法放下唯我独尊的欲望，多神论本质上是思想开明的，很少迫害异教徒。但显然，一神教徒比多神教徒更为狂热、更热衷传教，一神教通常认为自己信奉的就是唯一的神，也认为只有自己看到了完整的真相，自然就会批评其他所有宗教都不可信。一神论者多次发动以暴力消灭其他宗教的战争。事实证明这很有效。一神教几乎完全消灭了多神教（并不是一神教更有助于人类，仅仅是因为一神教相比于多神教，像一个更强势的病毒）。\n最后，新的宗教： 科学的发展让新的宗教完全放弃了：对世界构成解释的欲望，也让新的宗教完全放弃对死亡的关注。多数旧的宗教以死亡作为生命意义的主要来源，而从18世纪开始的宗教和意识形态，如资本主义、社会主义、女权主义，消费主义、自由主义就已经对来世完全失去兴趣。\n最后的最后，有的学者认为，宗教就像是精神感染或寄生虫，而人类就是毫不知情的宿主。寄生虫或病毒就是这样住在宿主体内，繁殖、传播。\n"},{"id":26,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%98%8E%E6%9C%9D%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E8%AF%BB%E5%90%8E%E6%84%9F/","title":"《明朝的那些事》读后感","parent":"我的","content":"《明朝的那些事》读后感\n2022年7月24日\n今天终于将《明朝的那些事》看完，这书我之前看了不下五次，之前每回都是在明朝山河日下，所有坚持、执着都难以如愿时脱坑，我都一如既往的缺乏勇气，难以直面结果，心智如同逃兵一样偷偷的自欺欺人，蒙骗自己，选择放弃。 我好像走了很远的路，很幸运，一路上解决了很多很多简单且基础的问题，如何生存，如何像一个成熟的大人，如何与孤独相处，如何处理温柔、感伤，涌动的情绪，我开始有了一些自由的时间，自由的空间，新的问题是：什么在阻碍我利用这些时间。我该如何利用这些时间。新的目标是：去做一个自己喜欢的人，而要达成此目标，我现在了解到的唯一方法是，做自己喜欢的事，做自己喜欢的选择。 坚持自己选择和执着，不为有利可图，不为道德，不为放纵的欲望，选择相信，选择爱，选择直面自己的欲望，选择正视自己的缺点，选择永远不放弃去修改自己的缺点，选择了解自己的身心，这些选择，它们无高下之分，只是我相信的选择，选择的相信。 当年明月在最后一段，写的是徐宏祖，写了这句：“成功只有一个——按照自己的方式，去度过人生。”是完美的结束语。深以为然，希望我可以努力践行。\n"},{"id":27,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%9E%AA%E7%82%AE%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90%E8%AF%BB%E5%90%8E%E6%84%9F/","title":"《枪炮、病菌与钢铁：人类社会的命运》读后感","parent":"我的","content":"《枪炮、病菌与钢铁：人类社会的命运》读后感\n2022年8月12日\n此书大约是在上周末读完，这两周状态不好就没有写读后感，今天工作告一段落又是周五就开始摸鱼了。\n我早就听闻此书大名，但是这些年一直没有读严肃一点文学作品的想法，很多久闻大名的书都一直在书架呆着。\n这次再次回到微信读书的主要原因是：之前在与一位微信群的陌生人争论时，突然意识到，争论完全不会有共识，此前我之前一直避免在网络上与人争论，更多的原因是：“歧义和重点难以精确传达”，通常都是各说各的，而此次不同，此次我清晰的感受到，要想有共识，对方必须要多读一些书，能以更复杂更全面的角度去看待问题才有可能，但很明显，很多人在脱离教育阶段后，就再也没有认真的阅读过严肃一点的文学作品了，他们的一切相应积累都来源于曾经教材中的只言片语、各种帖子和一些碎片化的信息，我也意识到，我也接近这样了。另外你不可能直接的向对方建议：“你应该多读一些书”，这是赤裸裸的冒犯，而且也很容易被反诘：“你读了多少书”，虽然罗素在西方哲学简史中说过：“我的浅薄不是我应该谨守缄默的充分理由”，但这个反诘通常会被对方当作有力的回击，我又不能把读的书背下来，这时候微信读书全面的阅读时间统计就派上用场了（其实不会，只是 nerd 的脑子幻想）。这次应该会在微信读书停留许久。\n我很久没有去读不是很喜欢的书了，因为容易出现智慧退避，大脑拒绝接收和处理这些信息，导致视而不见，进不去脑子的情况，也不会引起思维火花。本书就是一本我不是很喜欢的书，全书风格类似数学应用题描述，作者：我观察到了***，我了解到***，我有一些数据***，我的结论是***，表述技巧几等于冇，而我倾向于更能引动情绪的表述。\n很久前，我就意识到，人与周遭环境有非常紧密的互相联系，但仅仅是一个模糊的概念，并不了作用方式和范围。本书通过作者广泛的研究和事实逻辑，回答了一些关键的问题：”是什么塑造了这样的一个现代世界？为什么有的国家富裕有的国家贫穷？为什么有的民族创造了灿烂的文明？为什么是欧洲人征服了新大陆而不是新大陆的人登陆欧洲？是什么对文明发展、技术传播、传染病、社会演化带来了决定性影响？“作者给出一个令人信服的结论：“环境——\u0026gt;食物的生产是终极因，各种近因（技术、病菌、文化、政治组织制度、钢铁等）都是从终极因发展而来”，本书的作者在书中罗列了大量的事实和逻辑分析证明了，近因是因终极因的演化而成，与人种无关，不已个人意志而转移，环境决定各大陆各民族的命运。\n另：作者在罗列的事实中写到了孤岛的文明退化的现象，让我想到：“桃花源是不存在的，文明与病毒一样，是栖息于人群之上的，失去人群，失去文明。”\n另：作者写到，技术的发明虽然重要，但在时间长河中终归是会被反复发明出来，但是技术的传播更重要，过少的人口，技术传播的损耗大于新技术的发明，会导致文明退化。\n"},{"id":28,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/","title":"一些计算机\u0026互联网的自问自答","parent":"我的","content":"一些计算机\u0026amp;互联网的自问自答\n2021/10/13\n0、SQL、EL、正则三个表达式的本质都是：从数据源获得数据\n1、信息技术是研究如何获取信息、处理信息、传输信息和使用信息的技术\n2、什么是计算机：仅仅从辅助计算方面看，计算机本质上和算盘区别不大，都是抽象计算复杂度，降低处理计算的难度，完成计算得到结果。（计算机和算盘一样，都是根据规则，由处理已知信息，得到未知信息。）。\n3、什么是程序：先看大家都比较熟悉的数学计算公式，数学计算表达式（公式），主要分为：数据和数据操作符，程序也是如此，由数据和操作数据的指令组成，程序可以指挥计算机完成指定的任务，通常是信息处理任务，（信息就是数据，数据就是信息，）例如：我现在做的订单管理，20万订单，即使人工一秒钟处理一单，一天24小时也只能处理不到9万单（获得客户买了哪个商品，要发哪去，扣减库存，发货，同步发货信息），而程序处理就极快了。程序和数学的函数差别不大，都是根据已知信息，处理信息，得到未知信息。\n4、什么是互联网：网络和共享（主要是信息共享）。资源更高效和更容易的分配和利用，这个时代，信息本身也是一种资源：影视、音乐、电子游戏、软件、文章。\n5、关于编程行业：有无数聪明的大脑投入其中，使其上限足够高，有明确的路径和阶梯，不像“寿司之神”卷到头了，提升变成了玄学（握十万次饭团的技艺，比九万次的技艺更好？）。也不像很多工作，在技艺上差别不大，开始内卷其它与技艺不相关的事务，比如接人待物，计算机很大程度上你只需要专注技艺就可以（为邋遢找的借口）（代价是献祭头发）。另一个是计算机编程行业是“有标准”、“有门槛”、“有正确”，是的，很多行业是没有客观标准、客观门槛和客观正确的，比如编剧、绘画、它们看起来好像有手就行，它们的“评价标准”、“结果”相对来说，主观的影响更大，甚至是运气。而计算机编程行业“伪科学”和“民科”显而易见，程序能跑就是能跑，不能跑就是不能跑，能跑，大家都能得到正确相同的圆周率的第十万位，不以个人意志而转移。\n6、关于程序员：众所周知的高工资、秃头，其实还有的是面对无数挫折、失败、挫败感继续坚持下去的努力。现实世界中最接近魔法或者武功的就是编程技术，每一个程序员都是魔法师，编程语言就是咒文，各种程序就是咒语，比如抖音的变美换头魔法，比如时空变换，千里眼与顺风耳的实现。\n7、关于骇客和安全：如果程序、电脑和网络是植物与农场，那么普通程序员就是农民与建筑工人和工程师是生产者，那么骇客就是侠客和卫兵、土匪、强盗。任何计算机都是不安全的，每个人的手机和电脑都是可以被攻破，被洗劫的，需要权衡的无外乎是成本和价值，而我们安全的一个主要原因是：以现在的网民数量和网络设备数量，针对个人的侵害来说，坏人的数量不够用（傻子太多，坏人不够用也发生在网络上，很多人不被欺骗的原因不是够聪明，够谨慎，仅仅是没有遇到骗子），在网络上我们芸芸众生如滴水入海。\n8、最后，程序不是万能的，解释与描述已知的可以用逻辑，解释与描述已知与未知之间的可以用哲学，解释与描述彻底未知的可以用神学。计算机只能处理部分已知的。\n9、信息与决策与自动化：未来的社会必定是高度自动化的社会，而要想自动完成某些工作，必须充分的获得信息，获得大量信息（全知则全能），以及对信息处理，进而产生决策，决策驱动自动化。\n这是不能拒绝的未来啊。“信息、决策、自动化：未来的社会必定是高度自动化的社会，而要想自动完成某些工作，必须充分的获得信息，获得大量信息（全知则全能），以及对信息处理，进而利用信息产生决策，决策驱动自动化。”（无论是互联网对信息的共享，物联网对信息的获取，人工智能、机器学习对信息的识别和处理，Hadoop等技术对信息的加工和储存）；未来的社会必将是更加导致个人信息暴露的社会，古代你完全不知道几百公里外的人任何信息，现在你可以看到他（她）（它（二次元））在对着你笑，这是一条没有回头的路，只会愈演愈烈。\n10月2号 到 3号早 北京到无锡 10月4号 晚 到连云港 10月5日 下午 回北京\n"},{"id":29,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%A5%E9%87%8D%E8%B6%85%E6%A0%87%E7%9A%84%E4%B8%80%E5%A4%A9/","title":"不确定性严重超标的一天","parent":"我的","content":" 劳动节假期后的第一天 NoFashion\n2022-05-06 14:49\n不确定性严重超标的一天\n昨天因为某些不确定的原因（据说是核酸检测次数不足），导致北京健康宝出现【弹窗④】，因为前一天未弹窗，因为前一天有做核酸，所以直到在公司楼下才发现这个问题，我站在公司楼下，顶着太阳，感觉自己正慢慢裂开。\n经过咨询行政同事，我需要先做核酸，再请假，我先挂了上地医院的核酸检测的预约，等我蹬自行车到了，被告知，不能给健康宝有弹窗的做核酸，建议去其它几个医院做，在不久前我还在庆幸，我挂上了唯一剩下的一个预约名额，现在我望着核酸检测窗口，看着手中的预约二维码，感觉自己正慢慢裂开。\n其实这个时候我有点想笑，因为少做核酸，所以弹窗，因为弹窗，所以不给做核酸，但是我止住了我笑意，去旁边买了瓶肥宅快乐水，补充了一下快乐，（这个时候我运动轨迹是：从家跑到公司，从公司跑到家，从家再跑到附近的上地医院）。\n整理收拾了一下心情，在小区的买菜群，公司的外卖红包点点群，继续收集着信息。这时一个同事说：西苑医院给【弹窗④】做核酸，得，跑，我将自行车丢在了最近的地铁口，下地铁，到了西苑医院，排着一个未见过的长队，顶着太阳，队伍好久冇动，从前前后后的交谈中得知，队伍已经一个小时未动，据说医生去吃午饭了，已经中午了，是该吃饭了，我看了看了看队伍左手边的两个厕所和一个垃圾堆，感觉自己正慢慢裂开。\n这时，我得到了另外一条消息，一些自费的核酸检测机构的检测点，给出现【弹窗④】的做核酸，另外一个同事说，公司附近的一个医院中午一直在做核酸，我想了一下，这面排着队伍的长度 and 医生剩余的午休时间，我决定一面要在自费的检测机构先挂上预约，一面去另外一个医院看看，去到另外的一个医院，先本能的排队，这时候，我在西苑医院的小伙伴说，医生加班了，队伍在飞速前进，正排着的时候，在小区的买菜群里刷到消息，之前是禁止弹窗人员检测核酸的，小区的临时核酸检测点，在13:30 到 15:30 会有弹窗专场，可以允许弹窗人员进行检测，我看了下时间：13:00，回村时间约 30 分钟，今天已经确定无法上班了，再次放弃排队，等我到小区排起队伍（此时 13:30），在西苑医院的小伙伴跟我说，他已经检测好了。呜呜呜，在这两难的坏与更坏的选择中，我选到了更坏的，不过大约 20 分钟后我也顺利的检测到了核酸。\n按照得到消息：“如果今天核酸的检测结果在 24 点前顺利上传，将会在 24 点后解除弹窗”，虽然我刷了一下午的核酸检测结果，但显然我这行为对核酸检测结果上传进度没有影响，在 24 点我未在北京健康宝上查到今天的核酸检测记录，白天的东奔西走、可能不如预期了。\n在新的一天的 1:30 我看着北京健康宝的弹窗，我觉得我要继续准备请假了，我控制了一下去开了一瓶冷藏的之前屯的肥宅快乐水的冲动（实在是有点晚），再次收拾精神，我不能放弃，还有个渠道是在北京12345上面民意直通上面申诉一下，崩溃的是这个网站一直在崩溃，它跟我一起崩溃，又经过了半个多小时，我在反复的崩溃中提交了申诉。看了下天气，明天会下雨，我的自行车还孤独的在某个地铁口，“对不起，我的车车。”\n作为一个焦虑患者，我经常在不确定性面前溃不成军，辗转反侧，失去控制，今天的“不确定性”已经严重超标，之前囤积的野格、RIO 还没有喝完，但是，哒咩，该睡觉了，应该去睡觉了，去睡觉了。\n5月6日早上，弹窗消失，拎起我的电脑包，出发，去搬砖啦！\n"},{"id":30,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%9C%E5%8C%97%E8%80%81%E5%AE%B6/","title":"东北老家","parent":"我的","content":"17/10/19 05:01\n前段时间我回了趟东北老家，上次回去还是过15年春节的时候，大略有三年没有回去了，那是个只有两个区两个县的一个非常小的市下面的一个非常小的小山村。城市是个在半丘陵地带的资源型城市，不过煤在好多年前就挖光了，我去市区里看到最高的大楼还是一九九八年建的那个，不过大楼上的广告牌显示不是原先的那家公司了。老家和大部分东北农村一样，村里都是老人和小孩、不愿出去打工的中年人（会搞养殖和种地）和二流子，这两年老家村里主要有两件大事：其一是路修的更好了，村里通了更宽的沥青路，水泥路则修到了每户的门口，路边有修垃圾站，是一种三面用水泥墙围起来大约三四平米的非常简易的一种，据说垃圾站点之间有大的塑料的垃圾桶的，但是我村的我没有看见，被偷走了，据说放了两次都被偷走了，垃圾站也被秸秆堆满，没办法用了。另一件事是：试行打地归大户，打地就是丈量土地，算下每户实际上有多少地，然后土地入股，整村整体出租，由个人或者企业经营，每户每年按入股土地多少分钱，这样再加上春秋农忙时打工会比以前种地能略多一点点，还不用操心。我一个亲戚包了几百亩地给他儿子种，亲戚他自己养猪，平时在栏500头左右，去年据说利润就有150多万。跪👻……我回老家时去他家吃饭喝酒，他说现在村里空的厉害，没以前人多了，好多人家都空了，我说村里的人还是多，东北的人也还是多，国家要脱贫，耕地就那么多，一亩地一年也就六七百块的利，现在这么多人一家也就能分个二三十亩地，把人固定在这里种地效率太低了，以后归大户的方式肯定会越来越多，那样的话村里大概有三种角色，大户，失地农民和像你这样搞养猪、或者养牛养鹿、人参养殖这些搞特种经营的，但搞养殖是做生意，不是每个人都有条件的，也不是有条件的就能做成的，要看天赋和运气，你们大户站到了改革的风口还好过些，失地农民就不那么好过了，头几年他们还会给你们打工，再过几年他们就会发现南方工厂打工更轻松赚的更多，老人也许喜欢老家不会去南方，年轻人如果在南方干个十几年就不会回来了，到时见你们只能上机械化了，一般去流水线训练个几个星期，完全就可以参与到工厂生产了，他们的劳动附加值就跟产品和工厂跟相关了，算是工业人口了。这个过程肯定有不能顺利适应转变的，这就要看命了。大体方向就是农业人口变为工业人口和服务业人口。\n"},{"id":31,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%BA%E5%95%A5%E8%A6%81%E5%9C%A8%E7%A9%BA%E9%97%B4%E5%8F%91%E5%B9%BF%E5%91%8A%E5%95%8A/","title":"为啥要在空间发广告啊？","parent":"我的","content":"2017/09/18 17:40\n为啥要在空间发广告啊？想赚零花钱么？其实根本是赔本啊（为啥赔本后面说），有时间看看书，学习学习比这个好多了啊，即使不能学习，去学个乐器（最近我就对吉他有点感兴趣，就是手太笨、、、摔！） 跑个步也很好啊。钱不是那么好赚的，要想赚钱：本质上都要有自己一套完整的运作体系和优势，产品研发（需求：技术）、货源把控（需求：渠道人脉 例如：我有个当官的叔叔，那我可以拿到市政工程，或者我在行业内用心工作十几年，掌握并维护了大量的一级供应商，这些都是渠道）、{产品推广、客源开拓、客户维护、售后服务}（需求：体力 和 时间 还有 技能工具，学习的本质是让我们能掌握更高等的技能工具比如电脑、汽车，可以在出同等力气的情况下获得更多的收益）等环节在内的一套完整的运营系统，每个环节环环相扣，任何一个环节拿出来都是庞杂的，想过怎么运营一个项目么？有没有独立或者合作运营过一个项目没？没有系统学习过商业运作的知识，没有任何的行业经验，只会发广告。软文不会编，文案不会写，自嗨交易收益和PS的截图（别告诉我说你发的截图都是真的，我是你哥。。。。。。捂脸⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄），就能赚钱？想过怎么开发客户么？那些是潜在客户需要开发，那些是绝缘客户只需要基本的覆盖，不需要浪费精力努力开发，旧有客户如何维护？整么让客户保持忠心，如何让客户排斥其他家产品？竞品对手的产品优势是什么？自己产品区别于同类产品的核心竞争力是什么？为什么别人要买你的东西？你的客户定位在哪类群体身上？他们有什么特征？适合做什么类型的推广？你怎么去开拓新客源和维护好老顾客？怎么去培养用户推广自己的产品？即使这些都不考虑，你有想过你选的代理产品有没有特征和优势？是不是三无产品，用了会不会生病？会不会有法律风险，需不需要缴税，现在国家对虚拟商城（及网络贩售）的政策是什么样的？即使！！！你想说我就是只想利用点时间从 朋友亲戚！！！ 口袋里赚点买零食的钱，我也想告诉你你付出了什么，才换到了这点钱，（呼应开头的赔本）（道德的事我不想说，每个人有自己的道德标准），第一：那么任何行业都是有门槛的！！有！门！槛！的！（代价一：你想好了被人屏蔽，还在朋友圈落得一个刷屏做微商的笑柄，以后别人一问，啊某某某，原来你还做过微商，被人轻慢的代价了么？？？）第二：任何商业收益都是有成本的！！！有！成！本！的！（代价二：任何只依靠人情做的买卖，本质上都是在透支自己朋友圈的额度（朋友是相互的，当你索取却没有付出的时候，很快就不会再是朋友了。）。朋友不是赚零花钱的工具，他是你分享快乐，抚慰忧伤，互相竞争成长的有限宝贵资源，你确定，你的朋友就要这么消耗掉了么？备注：这个代价太大了，要留心体会朋友的珍贵，当然越老越会感受到朋友的珍贵，比如我这老家伙\u0026hellip;.摔。。。/(ㄒoㄒ)/~~）\t综上所述：这是个完全不可行的赔本买卖，不值当投入精力与金钱！！！（特别是金钱，精力换教训。）\t如果你真想做，学着去做陌生人的生意，自己去做个自媒体，去圈粉，如果连吸引粉丝他人关注的能力都没有，说明你真的不适合做这个，，还是适合老老实实的去打工去学习，毕竟这个社会就是绝大多数人在给极小部分人打工（你看人家刘备虽然不能打，但是粉丝多啊。。。）\t最后，梦想总是要有的，前提是先好好学习（不是要赌那万一实现了的几率）。\t————————————周末码代码期间的唠叨，未经过认真校验，所以就不要关注错别字啦。\n"},{"id":32,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BB%8A%E6%97%A5%E6%8A%84%E6%96%B0%E9%97%BB%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E5%90%91%E9%9D%9E%E6%B4%B2%E6%8F%90%E4%BE%9B600%E4%BA%BF%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%80%E7%82%B9%E8%A7%81%E8%A7%A3/","title":"今日抄新闻：关于《中国向非洲提供600亿支持》的一点见解","parent":"我的","content":"2018/08/04 13:58\n今日抄新闻：关于《中国向非洲提供600亿支持》的一点见解：第一：专款专用，贷出去的钱，有严格的使用要求，钱其实不是直接给外头，而是让国内公司去那边接活儿，然后钱还是给国内公司。本质上其实是用国内过剩的基建能力去那边换东西，也就是去产能，举个例子：尼日尔阿泽里克铀矿，中国两家企业共持股 62%，尼日尔政府持股 33%；纳米比亚的哈萨博铀矿，中国企业持股 90%，纳米比亚政府持股 10% ；如果还不明白给你再举个例子，光绪年间，英国人瞒着清政府自己掏钱给中国建了吴淞铁路。当时大清还有点银子，自己买下来又给拆了。\n至于可以不可以把钱投给买房者，复习下高中政治：商品的价值是由生产这种商品所耗费的社会必要劳动时间决定，商品价格是商品价值的货币表现形态。商品的价值不能自我表现，一个商品的价值必须由另一个商品来表现，并且只能在同另外一个商品相交换时才能实现。而这个“另一个商品”通常为一般等价物，也就是货币。货币作为商品的一种也是受供需关系和买卖意愿影响，举个例子：市场有1W个房子和1W个需要买房子的个体，每个个体有1W货币，当有人向每个个体发放1W货币的时候，在自由的市场，第二天房子就会有原先的1W/栋变为2W/栋达到新的平衡，只要市场中的提供者和需求者没有发生变化，货币的多少变化毫无意义，央行通过不断的印货币，和不断的通过无形有型的资产吸收货币，来维护货币的价值，当然我们是社会主义国家，并不全是自由市场，也有反例，比如火车票，节假日一票难求，因为供需关系和买卖意愿（供应方只能提供有限的产品，需求方需求巨大），且价格锁定，照成买票基本是靠运气，反过来说也就是个人努力照成的影响不大，你并不会因为更努力而变得更容易买到票（当然，真实的现实并不是绝对的随机，有各种路子走动），不知道大家更喜欢哪一种？这些例子比比皆是，比如摇号机动车牌照，深圳的摇号买房，因为后两种不像火车票一样拒绝私人交易，买到就是赚到，转手一买就是血赚一笔，前段时间有个专家说：火车票之所以难买，就是因为太便宜。结果被骂的狗血淋头，嘿嘿嘿，这专家是忘了我们是人民民主专政国家了吧。\n"},{"id":33,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BB%A3%E8%A1%A8%E6%9C%88%E4%BA%AE%E8%AF%85%E5%92%92%E4%BD%A0%E5%AF%B9%E4%BA%8E%E6%84%9A%E8%A1%8C%E7%9A%84%E4%B8%8D%E5%BF%8D%E8%A7%81/","title":"代表月亮诅咒你————对于愚行的不忍见","parent":"我的","content":"代表月亮诅咒你\n我就不会简单的诅咒，他的所行，暴露了他的愚蠢和嫉妒，如果不出大的意外，他将永难获得幸福，他将在愚蠢与嫉妒的地狱里挣扎，这世间所有好人对他的厌弃，就是他的诅咒，我，在这里，代表这世间好的人们，对你审批，为你定罪，告知你，你的所行，被我们所有人厌弃，从此，你将远离真诚，即使对最爱的人，从此，你讲背负阴暗，即使在阳光下，从此你将有一处被人唾弃。\n"},{"id":34,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BD%A0%E5%BA%94%E6%98%AF%E4%BC%9A%E9%94%99%E6%88%91%E6%84%8F%E4%BA%86/","title":"你应是会错我意了","parent":"我的","content":"2015/07/06 09:33\n你应是会错我意了，我是在有感而发，不是在单指你发的这个。 我之前说的：坦诚面对自己太难了，就如同我之前有说过，忠于自己太难了一样，我们本身都有着贪念，偏爱，欲望，懦弱，羞耻，这都是我们的本性，就如也拥有，爱、勇气（不是好勇斗狠，那不是勇气）、责任、善良、信任这些一样，但是我们更喜欢欺骗自己让自己相信自己没有贪念、欲望。 加之外部环境的无常和扭曲，我们必然需要靠谎言来重新解析、扭曲这个世界，使之能为我们接受，好让自己不去撞的头破血流。（谎言让世界变的更美好，谎言真好） 谎言变成了习惯和本能。 可我们还有更深的不接受谎言的本能。 所以我们想要坦诚的面对自己。 离题万里，举不恰当例子二三来说坦诚以待太难了。 比如说： 男朋友出轨了，无论精神还是肉体上，只要他有过那么想过：他要娶别人为妻子，他有那么一瞬间确定自己对另一个人的爱比对自己的女友要多，就是！接下来就是要去分析问题的 严重程度和如何处理了，如果男朋友出轨了，无非就是决然离开或者给他一次机会或者放任自流三种选择，普通女生表现就是一直在一二之间徘徊犹豫不决。为什么不去认可这个事实呢，要找些：他喝酒了，他还是更爱我多的（爱这么一种极度自私的也是可以分享的么）他一时鬼迷心窍了，他寂寞了，我对他的关心不够，我胖了对他的吸引力不够，我跟他吵架让他压力大，他没地方倾诉，我也是有不对的地方。为什么要找理由去欺骗自己呢，为什么不敢相信，我那个一直爱着的他变了，他没那么爱我了，我的爱情已经被破坏被摧毁被撕裂了，我那个一次恋爱直到结婚的童话再也不会在我身上实现了。为什么啊？无非是一些面子（不甘心、不服气、不认可自己输了，不承认失败），还有些不舍和怀念，不舍什么？不舍自己的付出，（情感、心力、心思、时间、青春、金钱）怀念什么？他的好（温柔、体贴、照顾依赖、甚至也有金钱房子）。第一种选择太痛太决绝了，好多人选择第二种，关键你能做到么？爱情需要平等、尊严的，他出轨了你怎么平等啊，他践踏了你的爱情你还跟他哪有尊严呢，以后你能做到不去介怀这事么，你能做到不再去怀疑么，你能做到一如既往的信任么？你能忍受住他出轨对自己每时每刻带来的屈辱和痛苦而不因此改变对他的态度么？能不会在吵架、心情低落、崩溃边缘不去拿这个他曾经的错误来攻击他么？等等 等等，有一点不能，只会越来越痛苦。所以纠结个屁啊，就是抬头挺胸，连痂带脓的揭掉，大步向前走。 例如 一个男生在跟一个他有认同有欣赏的单身的非其女朋友认识的女生频繁上接触沟通，这是友谊么？这是简单的友谊么？如果他再遮掩这个女生的存在，遮掩她女朋友的存在，阻挠他的女友和其的接触，这种行为正常么？他为什么会用一些，这只是普通朋友，红颜知己这类理由来掩盖着他贪婪的本性呢？他出轨了么？没有吧，他背叛了么，也没有吧，他意识到这是个危险、难以控制、不普通的关系没？我想 心里有感觉，心里是会明白的。但是他能拒绝这种关系么？他能在跟女朋友关系紧张结果不明的时候还能控制住自己么？另，我不否定男女间纯洁的友谊的存在，但我否定男女间简单友谊的存在。\n"},{"id":35,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E6%88%90%E5%B9%B4%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/","title":"关于成年后继续学习的一些事","parent":"我的","content":"2021/08/09\n关于成年后继续学习的一些事：\n1、时间：时间永远不够，要上班、要玩游戏、要刷微博、要刷抖音、要社交，这些有些是你无法拒绝且必要必须的，有些是精心设计利用你人性弱点，让你不知不觉难以抗拒的。\n（这点我还好：1、我不在手机上下游戏已经好多年了而且对此没什么感觉。2、我告诫过自己少刷抖音，然后轻松做到一两周不打开抖音APP，而且也对此没什么感觉，3、唯一的是对微博\u0026amp;微信感觉难以脱离，我怀疑我有一种类似信息成瘾的疾病。）\n2、精力：是的，”成年人是这样的“。每天工作挤地铁，你的大脑已经在拒绝工作，就是想做一些简单点、快乐点、放松点的东西。\n3、路径\u0026amp;目标：目标，要说定目标是最简单的事了，没人反对吧！路径，本没有路，走的人多了，就成了路，别人的路径和计划不一定适合自己，而要想找到自己的路就是要多走。\n4、坚持\u0026amp;面对挫折：放弃和定目标一样简单，过程中还会有很多干扰，而且学习某些情况是走出舒适区，会有很多挫折、会有很多碰壁，会无数次反问自己这样值不值，如果不能消化挫折，很难坚持下去。\n5、选择：成年人需要做的事情太多了，能学想学的东西也太多了，要做抉择排序。\n能有计划、长期的学习，我做起来很难，很多次放弃，得过且过。但是我却不是很能”甘心“的人，不甘心常常回绕，如火在烧，使我的心境得不到宁静，至死方休。\n"},{"id":36,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E4%BA%8E%E7%9C%9F%E5%AE%9E%E7%89%A9%E8%B4%A8%E4%B8%96%E7%95%8C%E4%B9%8B%E4%B8%8A%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%96%E7%95%8C/","title":"关于抽象于真实物质世界之上的概念世界","parent":"我的","content":"2022年3月15日\n之前，博主@闪光少女斯斯 的一场直播：#女生之间存在真友谊#的微博下我评论到： “歪个题，男女之间存在真友谊么？我的答案是：存在，至少在某个时刻，某段时期，是存在的，不掺杂其它欲望。 唯心有物，很多东西你认为它存在，它就存在，你不相信它，它就不存在。友谊、爱情、上帝、国界等，这些抽象于真实之上的，如果用“它们可以对真实物质世界产生影响”来定义“存在”，那么它们都是是真实不虚的。 （继续歪个题：我个人认为，友谊、友情，真的很珍贵，不次于爱情，不要因为对方是异性就混杂了友情。） 继续歪题，我想到，“唯心有物”是心学的句教，但我之前了解到的搞名相是大和尚啊，例如：“不是风动，不是幡动，仁者心动”、“身是菩提树，心如明镜台。时时勤拂拭，勿使惹尘埃”、“菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！” 《王阳明四句教》 无善无恶心之体，有善有恶意之动， 知善知恶是良知，为善去恶是格物。\n有心俱是实，无心俱是幻； 有心俱是幻，无心俱是实。\n心学：有心俱是实，无心俱是幻； 禅宗：有心俱是幻，无心俱是实。 心学：心为实本 禅宗：心为空幻 心学：致良知 禅宗：一切有为法，如梦幻泡影，如露亦如电，应作如是观。 禅宗：凡所有相，皆是虚妄;若见诸相非相，即见如来。 禅宗：所有皆是名相。名相，耳可闻者曰名，眼可见者曰相。 超验 和 康德的“人类无法精确认知事物”\n一切唯心造 缘起性空 金刚经以名相喻空，心经更进一步，舍利子，色不异空，空不异色，色即是空，空即是色。受想行识，亦复如是。\n受想行识：感受、想法、行为、见识\n有些困难，科学可以解决，生老病死，科学暂时不能解决，宗教可以。\n有些时候不能从正面描述，只能从反面描述，比如“无为”不好描述，就描述“有为”。 真心和妄心、本心和本性。 知行合一，禅宗多是知，近于空幻虚妄，心学：传习录里，阳明完善了心学的功夫体系，首先立圣贤之志，然后慎独、克制省察，私欲日减，回归到先天的未发之中。 《传习录》是心学的最重要经典，阳明心学是围绕大学中庸展开论述的，没有儒家四书的基础，是根本读不懂《传习录》的。 易中天曾经总结过，禅宗是以有为求无为；孔子是以有为求有为；庄子是以无为求无为；老子是以无为求有为。\n心学继承儒家道统。是以有为求有为的路子\n心迷法华转，心悟转法华 相由心生，境随心转，心生万物 应观法界性，一切唯心造。 明心见性，直指本心\n这不是孤立和偶然，当人类文明发展到一定程度，会抽象出大量的于真实物质世界之上的概念。如何理解这些概念，这些抽象于真实物质世界之上的概念与物质世界的关系，甚至，这些“抽象于真实物质世界之上的概念”会侵蚀真实的物质世界，会重构我们对真实物质世界的理解，这些都是必然发生的，可惜我没看完罗素的《哲学简史》，在西方哲学和宗教的源流发展中一定也会有相应的概念。但是，在中西方的同时期，先秦诸子和希腊先哲，同时创建出了大量的灿烂思辩火花，我没有证据，但我个人认为，他们是重构了对真实物质世界的理解，几千年前的人们，他们眼中的世界轰然崩塌，又重组成为了一个新的世界。\n过了好久我才明白：我需要一个我爱的人来注视我\n我们公司有个要求是：“每年必须提供20小时的社会公益活动时间”，通常都是去做志愿者啥的。有一年是去给烈士陵园献花，陵园中有一个影壁上面记录了一些烈士的信息：有十几岁就已经参军几年后牺牲的，有兄弟三人先后牺牲的，有年纪轻轻的连长牺牲的，有无名无姓牺牲的，当时的一个比较被触动的点是，大多数战士牺牲时年龄比我现在还小，有些人的年龄甚至在我眼里就是个小孩。天灾人祸，好似疫情，你没的选。\n因为反对既非共和制、又不民主的法兰西第二帝国政权，维克多·雨果被迫流亡海峡群岛，他于1861年11月25日在流放途中写下了这封信，“但我要抗议，而且我感谢你给我提供了这样一个机会。统治者犯的罪并不是被统治者的错，政府有时会成为强盗，但人民永远也不会。”\n实际上我认为网络空间有多少能认真讨论交流的可能，比如我说上帝是存在的，你会认为我可能时一个有神论者，实际上需要先定义“存在”，如果用“它们可以对真实物质世界产生影响”来定义“存在”，无需置疑，上帝、国界、爱情、忠诚，这些抽象于真实世界物质之上的都是存在的，所以，稍微的想要认真点交流就需要先确定语义，大家基于一些恒定的概念进行讨论，而很明显，三次握手在日常网络聊天里并不可能。\n"},{"id":37,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E7%BB%8F%E9%AA%8C%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"关于知识和经验的笔记","parent":"我的","content":"2022年3月25日\n对于具备能力的人来说，经验更重要（经验是能力的另一种形式）；对于不具备能力的人来说，知识更重要（学习知识是形成能力的载体）。\n（知识是固化的成果，经验是运动的信息）。\n一个是客观世界，一个是主观世界。\n对于未知的问题，知识更重要。 知识和经验的问题， 例如：”保持平衡“是知识，骑自行车是能力和经验，如果学会了骑自行车，即使十年没骑，再次遇到也会，这就是经验转为能力。对于具备能力的人来说，经验更重要（经验是能力的另一种形式）；对于不具备能力的人来说，知识更重要（学习知识是形成能力的载体）。（知识是固化的成果，经验是运动的信息）。\n"},{"id":38,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E8%8F%A9%E8%90%A8/","title":"关于菩萨","parent":"我的","content":"A: 你一定得尝试身心投入的喜欢一个人\nA: 有点上瘾。\nsky: 我知道\nA: 我喜欢上了我单位的一个男同事。\nA: 我只是喜欢的，不是想睡他。\nA: 我不睡他，我心里也很舒服\nA: 我也不想打扰他。\nA: 我也不在意他喜不喜欢我。\nA: 实际上他对我还挺好的。但是他做啥说啥无所谓\nA: 我自己喜欢我自己的。\nA: 跟别人没关系。\nA: 就好像他只是个寄托\nA: 放在那里，让我自律\nA: 真的是痴迷。\nA: 而且我也不跟他聊天，我也没啥，我感觉我每天在脑袋里就能聊\nA: 自己跟自己想象中的他聊。\nA: 一来一往。\nA: 就是每个问题他大概的答案我都知道。\nA: 或者就算我不知道\nsky: 是存在于精神世界\nA: 我可以推算出各种可能性来延伸每个分叉\nA: 这样\nA: 就是我除了睡觉的时候\nA: 都在想他。跟他聊天。\nA: 但是他毫不知情，也不用他知情。\nA: 我也不找他。我现在也不想做爱睡觉什么的。\nA: 我感觉我可能净化了一下我自己\nA: 无欲无求，就是痴想。\nA: 这种想，让我的上班路下班路即使不听音乐，也变得无比轻松\nA: 我在想念这件事上很容易投入，所以走路一个小时我根本不知道路边是啥，凭直觉就到了我要去的地方，甚至觉得路短。\nA: 就是啥都不耽误\nsky: 一种寄托\nA: 总之是好的影响。\nA: 不是坏的。\nA: 就是我走路一含胸驼背，我一想到他，我自觉就抬头收腹挺胸了。\nA: 我一吃很不健康的食物，我一想到他，我就觉得健康的食物挺好\nsky: 有点类似：“偶像的力量”\nA: 我因为不跟他聊天，所以我下班把家里忙完孩子哄睡，我也立刻心无旁骛的去睡觉\nA: 睡眠质量也挺好。\nA: 是“无形的督促”，是“为了让自己更爱自己”\nA: 连耐心都变得特别好。\nA: 就是整个人其实很温柔。\nA: 遇到烦的工作也不烦\nA: 孩子调皮也不那么生气\nA: 总觉得要是他，他会怎么处理，我就立刻怎么处理。\nA: 这一切都只在我自己的世界里发生。\nsky: 你见到了菩萨！！！\nsky: 他。\nsky: 得见诸菩萨，能解一切苦。\nA: 其实我想，只是我想象里的他很完美，\nA: 实际啥样我并不知道\nA: 我不掌握事实\nA: 也不好奇事实\nA: 但是他确实给我的影响太大了。\nA: 然后他其实啥都没做\nA: 他只是存在。\nsky: 我是过了好久我才明白：我需要一个我爱的人来注视我\n"},{"id":39,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E9%80%89%E6%8B%A9/","title":"关于选择","parent":"我的","content":"好像是这几年吧，哎，也不是这两年，是这几年我的一个主要的对自己的改变就是：用“无差”的角度去看很多事情。 很多事情在我眼里已经没有了，好坏和高下和正确与否的区别了。 他们全都变成了选择都不同而已。 「用“无差”的角度去看很多事情，知道找到辨出什么是自己喜欢偏爱的」，与你用什么方式来应对这个世界不冲突，明白自己的偏爱和倾向，和有能力去“入世”。 选择想做就做，选择三思而后行。 “入世”是指这“世间”的倾向和角度。\n选择与过去的自己和解，选择永不原谅自己。 选择相信爱情，选择带着镣铐起舞，选择自我约束，相信自由只有存在约束才有意义。 选择丁克，选择沉默，选择不解释，选择放弃，选择坚持，选择忠诚，，选择相信金钱，选择价值博弈体系解释一切，选择相信在价值博弈体系之外还有感情体系。选择相信有纯粹的男女友谊，选择相信男女之间不可能有纯粹的友谊。\n不知道我什么变成这样，可能是因为一句鸡汤：“选择决定了我们成为什么样的人”。 或者是我察觉到在漫漫人生路中能自我做出的选择太少也太珍贵了。\n2021/11/08\n最近无数次在脑海里回荡：“选择决定你成为何人“，但是过去种种，不知选择标准，被欲望、短视、惰性影响做出了错误选择，而更多时候是冇的选择，就这样，我做一些我不认可的选择，成为了一个我自己不喜欢的人。 最近这些年做的比较正确的选择有两个，第一个：早些年猛贷款，在房价不太离谱的时候上了车。第二个：换行半路出家的做了程序员。做对了两个正确的选择让我现在好似不是那么窘迫，但是也做了很多错误的选择，比如没有减肥、没有早点用心护肤、没有学习英语、没有提升学历、在没结果的（错误的）感情上不知回头，这些错误的选择在现在，在未来会逐渐对我饱以老拳给我教训。早些年常常在脑海中回荡的一个词是：”囿于“，外部的限制和内心限制，让人在想前行时举步维艰。那时候在脑海里回荡的是：“虽然不知道想去哪儿，但是不想在这”。 2022/01/04 11:38 前两天跟朋友吃饭聊到单身问题，朋友说：“如果 你是女生或者你的女儿，你会喜欢一个你这样的人么？”我：“这个问题我早有答案。 附上一个很久之前的自言自语【“最近无数次在 脑海里回荡：“选择决定你成为何人“，但是过去种种，不知选择标准，被欲望、短视、惰性影响 做出了错误选择，而更多时候是存的选择，就这样，我做一些我不认可的选择，成为了一个我自己不喜欢的人。 最近这些年做的比较正确的选择有两个，第一个：早些年猛货款，在房价不太离谱的时候上了车。第二个：换行半路出家的做了程序员。做对了两个正确的选择让我现在好似不是那么窘迫，但是也做了很多错误的选择，比如没有减肥、没有早点用心护肤、没有学习英语、没有提升学历、在没结果的（错误的）感情上不知回头，这些错误的选择在现在，在未来会逐渐对我饱以老拳给我教训。早些年常常在脑海中回荡的一个词 是：”国于“，外部的限制和内心限制，让人在想 前行时举步维艰。那时候在脑海里回荡的是：“虽然不知道想去哪儿，但是不想在这”。】 如果一个不喜欢、不认可的人是你的同事、同学甚至是亲戚，你都有办法远离，但这个不认 可、不喜欢的人是你自己本身呢？\n"},{"id":40,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%BE%88%E5%A4%9A%E5%B9%B4%E5%89%8D%E5%9B%9E%E5%A4%8D%E6%9C%8B%E5%8F%8B%E7%96%91%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A7%E5%A4%B1%E8%A1%A8%E8%BE%BE%E6%AC%B2%E4%BA%86/","title":"很多年前回复朋友疑问：“为什么丧失表达欲了”","parent":"我的","content":"从几个方面说吧：有一种可能是生活变的枯燥，或者机械忙碌而导致心灵麻木了。我记得我小时候有极其旺盛的好奇心，好奇新发下的书里面写有什么，好奇收音机、好奇电视天线、好奇磁铁为什么会吸引铁，即使对着一块磁铁玩一天，也毫无枯燥，会引发无穷无尽的幻想。前段时间我在路过一个地铁站的时候，看见地铁工作人员打开一个门，后面是个长长的走廊，我突然意识到，我对这些门及门后的世界不是那么好奇了，也不会迸发出无穷无尽的幻想了，像失去了看《哈利波特》第一集时那种每个门后都有一个无限新奇世界的幻想了。我不知道是每天的机械忙碌，还是日益繁杂的世界，还是被不断刺激变高的阈值，或者是被这个社会物化或者异化，我的好奇心丢掉了很多。我认为只有有着敏锐的好奇心，才会被轻易的挑动大脑神经，让你文思泉涌，喷薄而出。 第二就是要有时间、精力和日常积累，每次想BBB都要赶紧记下来。 还有个就是，我现在很少写（自由而无用）东西的一个原因是，大多数时间都是在写读书笔记、技术文档之类的（有用）东西，现在记忆里是真的不行了，看个书必须要做笔记，反复看，反复总结，耗费了大量的时间。我知道不应该把时间过多的分配给这些（有用）的东西，但是怎么说呢，技术文档还是很好玩，偏心啊。 最后：我认为“我想对这个世界说点什么”，这是本能，\n"},{"id":41,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%80%A7%E5%88%AB%E6%80%A7%E6%80%A7%E8%A1%8C%E4%B8%BA%E7%88%B1/","title":"性别、性、性行为、爱","parent":"我的","content":"性别、性、性行为的一些问题和答案（自问自答）\n问题1：性欲 与其它欲望的差别？ 性欲与食欲应该是一样的本能欲望，激素波动。\n问题2：性行为 与其它行为的区别？ 第一是：健康应该是第一要务。 第二是：性行为是“亲密行为”的一种。接下来是关于”亲密行为“的认知和发生的标准的选择，属于选择问题：与选择忠诚和自由，应没有差别，没有高低之分。（自由派在嘲笑忠诚派愚蠢的放弃人的部分权力甘心成为奴隶，忠诚派在嘲笑自由派不知道献祭、牺牲、信仰、真诚的价值？）。\n问题2.1：性行为 的标准？ 自由、健康、平等、安全（甚至都不包含私密，我真是混乱邪恶）\n问题3：对异性的认知？ 女性如何看男性，男性如何看女性？ 跟 问题7 合并\n问题4：性教育和自我保护？ 在 问题2 基础上需要注意的孩子的保护和教育：私密空间、混乱场所、夜晚，不要对任何可发生性侵害的人有任何基于身份的信任，保持警惕。\n问题5：性 魅力与祛魅？\n性冲动和性器官相关的东西是否低俗？ 人类低俗的欲望？享乐的欲望？自私的欲望？这些欲望是否是“坏”的东西？ “荤段子”是否【全部】是暗示了色情？物化和亵渎女性？可以是仅仅是拉近关系的行为？ 大姨妈、蛋疼、逼、操是否要直接映射到性映射到“低俗”、“坏”，进而是需要避讳的言语？ （个人结论是：这些“映射”不是必然的，有些类似：“人渣是男人，男人是人渣”，有过不好性经历或者性教育认知的过往，羞耻、痛苦与性夹杂在一起，打破扭转这种本能映射更难（人有很多本能的感性映射，锋利的刀尖逼近就感觉到恐惧，慈眉善目衣着华丽就本能信任，而因为某些的经历，再次见到类似因素，就映射到痛苦，这是本能的自我保护，但是因为一些经历就放弃一些东西，我总有点儿不服气。） 问题6：对自我的性欲和性冲动与异性的性欲和性冲动的客观认知？\n如果鄙夷他人、异性的性冲动和性欲，也会鄙夷自己的性冲动和性欲。 骚、发情、性欲涌动应该中性的。（欲望涌动是本能的，应该是中性的，欲望涌动改变自己的行为应该也是中性的，我只对因为欲望涌动而破坏自己的原则认为是负面的，是不好的。） 问题7：男性女性的认知？ 1、我们都是人 2、我们有相似的认知和情感（关于真诚、真挚、责任、爱） 3、性别的生理差异，会带来自我认知和限制的差异 4、传统文化对性别认知的塑造，带来的进一步的自我认知差异 5、社会的性别的区别的对待，带来的进一步的自我认知差异 6、正视性别差异带了的利益的差异 7、关注仅仅因为性别不同带来的权力和义务的利益差异\n问题8：物化男性女性？ 男性不过是“人形自走炮机”？\n问题9：对另一半过去的性经历的看法？ 可以跟 问题10 合并。\n问题10：应该是没有爱的性行为更“可怖”一些？ 我个人的选择是不支持仅仅因为生理欲望去发生性行为，因为“爱”而发生性行为更被我接受，逻辑是：性行为是亲密行为，亲密行为是在精神足够亲密的情况下才可以发生。（我们应该像保护身体一样保护我们的精神，有选择的允许什么”信息“进入我们的大脑）\n问题11：异性朋友的可能？ 先说个人答案是:可能。可以是因为外貌、性格而有异性朋友的，不一定是一定有“潜在想法”，不要“恶意”揣度别人，但需要保护好自己。\n问题12：性行为与自尊和自爱、自律？ 好像与暴饮暴食没啥区别，没啥特别影响。\n问题13：色情信息带入周围认识的异性及各种性癖？ 性癖是平等的，（坏事论迹，好事论心）。\n问题14：强奸是因为更强烈的性冲动？ 不尊重女性，不克制自己，自私的因素更大，而不是“更强烈的性冲动”，即使不是“性冲动”，这种人也会在方方面面，不同的方式，不同的行为，去不尊重他人，不尊重女性。\n最后： 要尊重强烈的情感，性欲与其它人的生理上的“低俗”欲望可以是单纯而美好的，不要异化和扭曲，夹杂太多“后天社会价值“的东西去扭曲它。\n"},{"id":42,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%83%B3%E8%B7%9F%E6%88%91%E6%9C%8B%E5%8F%8B%E8%AF%B4%E8%AF%B4%E8%BF%91%E5%86%B5/","title":"想跟我朋友说说近况","parent":"我的","content":"想跟我朋友说说近况，从四年前说起吧，那个时候家里在装修，每天跟装修公司斗智斗勇，因为需要在不是自己擅长熟悉的， 时常有身在激流中，身不由己\n"},{"id":43,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%9C%89%E8%AF%9D%E4%B8%8D%E7%9B%B4%E8%AF%B4/","title":"有话不直说？","parent":"我的","content":"有话不直说？\n2022年8月10日\n我还真想过这个问题：\n1、没办法直接表述：比如：没办法描述什么是“空”，佛经里就墨迹一万遍说什么不是“空”，比如：无法直接描述什么是“无限”就描述什么是“有限”。 2、语言是阶层和身份的的一种体现，古今中外，某些“阶层”的人都喜欢说让普罗大众听不懂的“黑话”，例如：在大厂的用“抓手”、“闭环”，留学的用“中英夹杂”，某XXX，用增强“四个意识”，坚定“四个自信”，做到“两个维护”，在古文用之乎者也，大家说英文，某群体人使用拉丁文。 3、“专业术语”，特定行业是为了更精确简练的描述、更高的沟通效率而在特定行业约定出特定词语，例如：鲁棒性、幂等、单例、递归。（专业术语与黑话是不同的。） 4、炫技和习俗、文化。 5、纯纯九漏鱼，水平不行，说话颠三倒四没有逻辑。（充斥网络） "},{"id":44,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%88%E6%88%91%E5%B0%B1-30-%E5%91%A8%E5%B2%81%E4%BA%86/","title":"还有一个月我就 30 周岁了","parent":"我的","content":" 还有一个月我就 30 周岁了。 我小的时候是在村里，初中时在乡里，高中在县里，大学去了一个小城市，毕业后去了一个大一点的城市，几年后稳定了一点，又去了北京。这二十多年，我好像一本三流的网络小说，一直在不停的升级换地图（这给了我很多错觉、幻觉）。 好像不知不觉中选了离开家乡的一条路，故乡不断远去，却又未与周遭建立联系，融入进去，时代的巨轮缓缓碾过，似身在激流中，似无根的浮萍，怕未留下痕迹，怕被遗弃，怕丢掉自认为重要且珍贵的东西。自在的乡村，格格不入，摩擦不断茫然的新生活。 初高中毕业，我觉得我那时候，更多一点的是一种扬帆出海的心情，大学毕业更像梦醒、梦碎，被身不由己的往前推着走了一步，步入一个被厚重迷雾笼罩的梦境。 很长一段时间都不能接受自己是个色批和性欲。 有过几次幡然悔悟：“我觉得这是一种没有结果的梦。”有点类似：“然后突然有一天就不爱了，完全不爱了。” 感觉年龄越大越难以接受其他人，建立信任，互相融入生活，了解过去，了解想法习惯倾向，大家都有了一些堆积的过去，愈发变的奇形怪状，顽固难改，仿佛走入了一个越发偏僻的小径，更难遇到同路的人，也没有年轻的时候的冲动，想想都觉得好麻烦。 精神ED了，啥都觉得烦。 小时候的我，一定认不出来，也理解不了，现在的我，想不到30岁的我是这样的石某人。 偶尔会有一种：“我怎么就这样了？”的疑问。 有过随波逐流，有过放纵堕落，有过一些羞耻到想杀了当时的那位自己的事（面对自己的不堪真的是太难了。 前段时间尝试 咖啡 + 牛奶 ，试过之后的结论是：我还是喜欢单纯的咖啡那复杂的苦味，加了牛奶就会被柔和掉所有细节。小的时候的我应该会对一个人会喜欢“复杂的苦味”嗤之以鼻。 缺乏勇气，我害怕面对结果，很多事，觉得自己还没有准备好，不敢面对接受结果，将很多事置于悬而未决的状态。错过很多。 我觉得，我现在活到30了，还是需要找点东西深入一下，否则人变得空心了，我怕空心的自己会随意堕落。 小的时候我就知道我是个懒鬼，就知道我不是个很主动积极的人，也不是一个爱主动积极的人 ，不过是我比较能委屈自己，知道取悦迎合而已。 "},{"id":45,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%93%94%E5%93%94%E5%93%94/","title":"最近一段时间哔哔哔","parent":"-随笔","content":"给支援女医生剃头这事就是侵犯人权，有辱尊严，无论是给男医生还是女医生。但我们的“人权”和“尊严”的基准是随时代、社会、科技、物质水平在变化的，虽然“集体主意”是要“个人”“牺牲”个人权利，而无疑我们渴望得到更多的“个人”权利和尊严，我们的政治正确是什么？集体利益至上。之前我说人类社会要正常运转，就是要一定比例去种地，就是要一定比例去做理发厨师服务员，就是要定比例的人去做重复且枯燥的劳动，蓝星就这科技水平，道德也一样，法律是道德的底线，那么整个社会的道德底线都低，而你自认为的道德底线比其高的时候，法律看起来就像是在保护恶人。 在网络上经常会忍不住吐槽到：“这个人怎么不讲道理呢”。要理解你有你的利益和道理，我有我的利益和道理，有些你认为是真理的东西可能另一个人都没听过。即使是客观存在，每个人的角度位置不同，看到再描述出来可能完全不像一个东西。所以有些时候 圣经 论语 宗教是有益的，你遵从圣经我也遵从，述说一样的道理有一样的是非好坏认知。对了，网络在加剧这种隔空观念冲突，毕竟地球村了么。 我这辈子遇到过的最多的SB就是在初高中的时候，一堆男生以古惑仔为人生楷模，渴望着混社会，无端的欺凌别人，以好勇斗狠为政治正确。以 你不和我们玩就是不合群就是SB为准绳，现在这群人长大了，以你不同意我的观点，那你一定是SB来继续东征西讨。我相当长的时间的人生目标就是逃离这些SB，这几年又有一个目标就是想办法帮助一些人成为更好的人，也远离这些SB。 我很小的时候就知道，我虽然羡慕大侠，但我自己是做不成大侠了，大侠老是打坏桌子，而做一个桌子是很难很辛苦的。 我也遇到过类似于强按着给你剃头的事，我都快三十了这份耻辱感也还在回荡难以平息。\n2018/12/29 11:37\n最近一段时间的BBB：这些年互联网行业的发展兴起主要的一个影响因子就是移动通讯的兴起，过于珍贵的带宽和流量是无法支撑庞大智能机终端也无法建造丰富多彩的网络世界，从最开始的 博客+天涯时代主流的互联网内容是文字，后面的微信、微博、Facebook，主流已经变成图片了，到再后面的抖音 是短视频的时代，抖音的一大作用是降低了视频加工制作的门槛，现代社会的一个缺点就是无尽的机会无法及时抓住的痛苦，互联网的信息革命之前信息是珍贵的，而现在，信息泛滥了，贬值到一钱不值，无尽的信息在向所有人倾泻，阻塞着每个人接收信息的接口，现在的问题是如何发声才能在信息洪流中让适当的人接收到你信息（有个方式是蹭热点，因为注意力倾斜，让更多的人看到你的信息），互联网某种程度将人类集合成了一个社群，人类从来没建造过如此之大的社群，如何快速的获得信息是个问题，标签化是解决这种问题的一种方式，带来了明星的人设、各种地域歧视，标签 本身没有好坏之分，精简抽象了复杂的信息，抖音通过背景音乐、特定的滤镜、拼贴剪辑手法，定向且标签化的传递信息（表达作者想传递的观点）。如此多的信息在网络里流转，相应的大数据，云计算，人工智能也得到了发展，5G会进一步降低带宽和流量的成本，可以让更多的现实世界的角色进入到网络，IoT就是一个大家明确会发生的风口。\n2021/01/19\n有些问题科学或正确方式解决：比如亩产 500 增加到 1000。 有些问题是没有科学方式的解决的：比如生老病死，怨憎会，爱别离，求不得。 有些问题是有正确答案和执行方法的：比如很多考试考卷的标准。 有些问题是没有正确答案和执行方法的：比如人生的很多选择。\n比如李子柒的视频确实好看，无论运镜还是取景，但是我对她表现的“田园生活”没有任何向往，因为我小的时候就在山上放过牛，田里河边放过鸭子，我知道隐藏在镜头下的工作量和各种琐碎麻烦，一点美化的滤镜也无。\n"},{"id":46,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%94%BE%E4%B8%8B/","title":"真正的放下","parent":"-随笔","content":"真正的放下：就是不会再去幻想未来的跟你的无数可能性。\n我曾经浓烈地，独一无二地，像献祭一般地爱过你，在我的世界里，你就像神一样，后来发现自己像个猴子。\n委屈不会对你讲，快乐也不会对你分享。\n我想念着你，却装作普通朋友一样去看你。\n"},{"id":47,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%85%B8%E6%96%87%E5%AD%A6/","title":"经典文学","parent":"-随笔","content":"定规矩、判高下、分黑白、辨好坏。 日本大文豪：夏目漱石。福泽谕吉。井上靖。\n阅读托克维尔的书、寻找那个逝去的时代\n眼前的书架上有： 历史的观念，柯林伍德 植物的欲望，迈克尔波伦 单行道，本雅明 探索真理的指导原则，笛卡尔 梦书，费里尼 黑羊，蒙特罗索 百年孤独，马尔克斯 幻想图书馆，寺山修司 罪与罚，陀思妥耶夫斯基 卡拉马佐夫兄弟，陀思妥耶夫斯基 地下室手记，陀思妥耶夫斯基 浮士德，歌德 启蒙辩证法，霍克海默 我心中尚未崩坏的部分，白石一文 新恋爱讲座，三岛由纪夫 悉达多，黑塞 论人类不平等的起源，卢梭 宽容，房龙 文化理论与大众文化导论，斯道雷 西方哲学简史，赵敦华 寂静的春天，卡森 中国历史研究法，钱穆 四书章句集注，朱熹 葫芦兄弟\n"},{"id":48,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E8%8D%AF%E7%89%A9/","title":"药物","parent":"-随笔","content":"丙戊酸钠\n丁螺环酮\n安非他酮\n曲唑酮\n"},{"id":49,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E8%A7%82%E5%AF%9F%E8%AE%B0%E5%BD%95%E5%90%90%E6%A7%BD/","title":"观察、记录、吐槽","parent":"-随笔","content":"观察、记录、吐槽\n2023 年 5 月 22 日\n结婚后，丈夫是老婆的第一责任人，先有小家才有大家。你可以去看看，老公出事，第一签字人是老婆，老婆有事，第一签字人是老公。 结婚，就要有营造一个小家庭的样子。\n2023年5月17日\n婚姻是否会获得快乐？ 真诚回答，我个人认为这完全是没有标准答案的，依据我个人来说，我会获得快乐的，多数人的一个本性是：主动强加给你倾向于拒绝病痛苦，轻易得来的不会珍惜，只有艰辛获取的，收获后才会得到最大的快乐。通常来说，婚姻生活，养育子女，从理性和他人客观的角度来看，肯定会很辛苦的付出，但只要有点收获，你的感性就会让你获得非常大的快乐，而人是感性的奴隶。 据说一个很多人的调查，在他们人生的下半场最有成就和幸福快乐的事是什么，多数人都会选择的一个答案是，他们的后代，即使那只是一个非常普通的后代，你可以说他们被沉没成本绑架了，也可以说他们失去了自我，但是那种快乐的感受对他们来说完全是真实的。 很久前有个小伙伴问我：“爱是什么感觉”，我的回复是：如果通过行为来描述的话，唯有献祭与爱最像了。单方面的对某个神灵献祭，渴望神灵能回应你的愿望，都有着自我牺牲，都有着单方面的付出，都是不确定的回报，\n我小的时候在小山村里，放牛或者放鸭子的时候就在想，如果可以走街串巷卖个糖葫芦收个破烂应该也好过种地。 后面大了一点，大概是初高中的时候，感觉去烧烤店打工或者去学学理发也挺不错，就是有点担心理发和烧烤店打工的小孩好像都是“小流氓”，怕挨欺负。 高中毕业的时候父母托人找了个城里烧烤店的活，每天快中午时起床开始穿串，开业到凌晨，有时下班了还去上会网吧，或去隔壁超市买瓶可乐，其实是想跟上夜班的超市收银妹妹聊天。 后面大学的时候，也发过传单，有一年打暑假工去过一个黑工厂，没合同，没五险一金啥的。也去过正规工厂流水线。还有刚毕业那会儿，因为南南北北的到处跑找工作，兜里没钱了，还临时去一个工厂流水线抬板子，每天下班后衣服缝合线的地方都是白色的盐。再后面，找了个靠谱的工作，工作了几年，觉得无聊，攒了些钱后，找了个培训班，跑来北京开始写上代码了。\n而且我回忆起来，有很多次，很多次，很多很多次，就此停留在某个阶段（烧烤店、工厂），我属于运气好的了。\n2023年4月3日\n一个观点是：穷人的唯一优势就是违法犯罪和放弃道德（因为这些规则的制定通常是有利于***，只要你遵守规则，大概率当牛做马，）但你一旦要往上走，这些曾经放弃和违背的东西，你都要加倍的偿还。\n2023年2月14日\n世间事，可以大体上分为三种，第一种：有绝对正确的结果，例如：数学、光速；第二种：只有相对正确的结果，例如：道德、幸福、真诚、爱情；第三种：连相对正确的结果都没有，只能依靠信仰来相信这种选择事正确的。科学在解决第一种问题，哲学在解决第二种问题，信仰、宗教在解决第三种问题。\n2023 年 02 月 27 日 两个问题： 1、受害者有罪论，受害者有罪么？在微博上，“受害者有罪”是及其不政治正确的言论，是个人都可以谴责一番。但是在宗教里：佛教：受害者有罪（即使可能是前世的罪。在基督教：每个人都有原罪。我更倾向于理论上受害者无罪。 2、人可以脱离低级趣味么？我个人观点：偶尔会，仅仅偶尔。\n2023年02月01日 我在2022年上半年临近生日的时候，有一种惊觉自己竟然已经 30 岁了的错位感，下半年的过完生日，更清晰的意识到：“有些我不接受的事，现在不去做他，可能永远不会再去做了，甚至再也没有机会去做了。”（比如我不接受我是个肥肥，我不接收自己英语很差）在内心中不断打告诉自己：“如果不做，可能这辈子都不会去做了”。临近的年底的时候，愈发的意识到：“很多事，要么不做，要么做绝”这不是一种偏激，而是：很多事要成事千难万难，而要放弃失败却又千万个理由，而我已经不是可以顺手洒下一些种子，就可以期待郁郁葱葱的时候了，时不我待、时不我待、时不我待。 2023年02月01日 我觉得我“老了”的表现主要有两个方面，一个是：不再对“其它”抱有旺盛的好奇心（新世界大门后的一切与我无关），一个是：对很多问题有了固执的“成见”，一方面这让我感到了我的枯竭和死亡，一方面这让我感到了安宁，我不会再有强烈的情绪，不会再轻易的爱恨，我可以笃定的说我喜欢什么和我所爱。 2022年10月12日 小的时候，听到过很多大名鼎鼎的人，他们在这个世界上留下了许多痕迹，小的时候最羡慕城市的地方就是城市有图书馆，现在好像终于有些时间精力了。\n2022年9月20日 节约也是好的对的，健身也是好的对的，多读书也是好的对的，但是都是相对的“更好”而不是绝对的正确，但是两个人在一起是包容成长，互相改变，而不是分高下对错\n2022年6月17日 关于超限拥挤状态挤地铁 俺不行，在特别拥挤的环境，会特别特别焦躁，看书看不进去，听歌也完全感受不到节奏，只会感受到嘈杂。。。整个大脑处于一种拒绝服务状态。。。\n2022年7月18日 向下俯视的人，必定会像上摇尾巴，因为在他的眼里，世界是个阶梯，与此同时，他也物化和羞辱了自己，不在眼前，就在它处，因为在他眼里的世界是个阶梯。\n2022年8月1日 “文明国家”血腥的殖民行为被温情的全球化所代替，当地人在田野里大汗淋漓的劳作被外包的工厂和客服中心所取代，异域既不是完全原始的，又不是彻底城市化的。\n最近看了两条微博，有些要忍不住吐槽，一条是：“长期从事重复性而非创造性的体力或脑力劳动，是对自己的一种犯罪……”，另一条大体是：“我受过高等教育，做着人类精英的工作，过所谓top5的生活，闻得出别人身上地铁站的味道了！为什么我还和蟑螂一样搋马桶”。一个评论是：“是普通劳动人民的重复劳动解放了你们这些精英，所以你们这些精英必须通过创新来解放和补偿他们。”我完全同意这个观点。一个时代，它的科技程度，思想方式，决定了生产效率，进而也很大一部分决定了进行重复而基础工作的人和进行科学研究的人在人群中的比例，而很多人认为，那只是自己努力的成果。我鄙视那些不努力的人，但我完全不鄙视那些在劳动分工中从事比较简单基础工作的人。\n对于程序设计第一步就是划分角色！！！\n每种编程语言都有自己的特点和作用，Python 的特点就是简单，让人可以简单便捷地利用它来让电脑做一些事情，比如统计下你几年来手机里积累的一万张照片在哪一年，哪一月，哪一天拍的最多。计算机是一个智力辅助工具，增强你的记忆（用支付宝和微信，你可以知道去年的今天上午你花了多少钱买了什么。），增强你的计算能力，将复杂的问题变的简单。\n2021/07/26\n春秋无义战，那时候就会互相污蔑对方的王族血统，对方的贵族道德败坏，对方的国家危险动荡天灾人祸不断，出不义之师。那么现在世界上的国家的互相攻击行为会是“义”的么？都是互称“不义之师”。\n在几年前，我爬山爬到山顶，热的要死，忍痛在山顶上买了一个雪糕，刚扒好，还在喘粗气，一个大概五六岁（大概到我大腿高度）的小孩疯跑撞的我一趔趄，雪糕掉了，我正准备转身找这熊孩子的时候，他妈小跑过来，我以为她准备拉住小孩给叔叔道歉，结果他妈走到跟前白了我一眼，回头喊小孩：“慢点跑”就走了。我知道这样放肆下去小孩早晚要出篓子，看了看地上的雪糕，我毫无愧疚感的没有提醒这位妈妈，好多熊孩子产生原因其实是因为他父母是熊孩子长大了而已。\n前段时间，微博的王志安就一事发表看法，底下有一个人评论：“你一个文科生懂个屁啊。”王局转发评论大意是说：“第一：他（王志安）高中的时候是理科并不差；第二：“就事论事”很重要；第三：有些人一生中最辉煌的瞬间，就是在中学文理分科的时候选择了理科，这种优越感贯穿他们苍白的人生”。\n绝大多数人“自我实现需求”应该是一种刚需，且需对比才能得到，\n#童模被家长当摇钱树#，\n童模是不是童工，如果不是童工的法律依据是什么，如果是童工，劳动保障部门为什么没有任何干预？我认为童模明显违反了 中华人民共和国国务院令 第364号 《禁止使用童工规定》啊。还有可不可以引导淘宝等电商禁止使用儿童模特的服装照片？或者防止出现“凉山格斗孤儿”情况，对父母失去劳动能力的家庭进行童模时进行严格管控？（现实的一个情况是，如果初中毕业（15岁左右），无法继续上学，因为正规工厂不收童工，只能去黑作坊或者流落社会。）\n当你得知一个你认为很理性、聪明的人，粉蔡徐坤的时候，你就会有点懵逼，不知道是该改变对这种偶像崇拜的定义，还是改变对你这个朋友的认知。\n一个人发出：“阿斯顿发ID就发哦if噢爱好”，另一个人是不会也无法抄袭的，因为并没有： “”有 意义 的 信息“”供人 抄袭，但是鲁迅的：“院子中有两棵树，一颗是枣树，一颗也是枣树”，就可以被抄袭，应为文字被整理排序后具有了意义，马哲的第一章：“意识及其能动性”中认为，意识具有影响现实世界的力量，而意识影响现实的力量的主要一种就是对信息的整理，将杂乱无意义的字或者说元素，组合成有意义的信息。我认为抄袭，就是把别人基于自己的认知和经验，对元素加工后产生的信息进行抄袭。但是也有各自基于自己的认知和经验发明出相同的东西的情况，比如，大家都认可牛顿和莱布尼兹基于各自的研究同时发明了微积分，注意啊，这可是同时啊。\n正常啊，你不是最后一个，每天都会有无数人进行着这些重复的发现，别说你这些现实世界的造物，即使是想法，也会有无数重复，甚至是孤独\n我在看《心是孤独的猎手》时，清晰的感受到作者在描述一种我曾经感受过的一种孤独，\n你明白吧，完全不同时空的人会有相同的感受。\n更别说这些些灵机一动的想法及造物了。每天都有人在重复。\n对于：“你好，妹子，推动一项影响社会和行业的立法需要白左美好的初衷”；\n我：你好，“兄弟”称呼确实孟浪，无意冒犯，对不起。 我认为这议员建议类似于：“义务教育”推行至大学阶段，这种，看起来美好，但是稍微一想就知道，培育学生是需要资源，教员的工资及学校的运营也是需要资金，免费并不是真的免费，而是由国家负责管理，国家也不会生产钱，会转嫁给税收，而管理资金也是需要成本的，在管理成本及普及教育带来的效率提升之间还有复杂的博弈。\n对于：“也需要反对者提供另一个视角的损失，更需要从业人员基于专业知识提出可行性的措施。”\n我：完全同意。\n对于：“你应该也不了解一项法案从构想到投票通过(也可能通不过)最终开始实施的整个过程。”\n我：大体记不清了，忘记是历史还是政治说的：美国的好像是国会的两院。国内的当然是全国人大了。听说现在美国两党高度极化，难以妥协，否决政治成为常态，提案通过率很低，不如我们国家方便去年就修了个宪。\n天狮集团，权健集团、天士力集团、尚赫集团、「无极限」、「如新」、「完美集团」\n随着时代发展，电脑及自动化的发展，一个高能力的人创造的价值超过一条街低能力人创造的价值的时候，对于低能力的人来说，传说中不工作也会有吃喝的高福利世界就到来了，对于低能力的人来说存在也失去了价值。\n在公司的八点偶尔会出现一种幻觉，就是我梦到我八点在公司编程，然后去打开了一个QQ群。\n我记得一个访谈类电视节目，主持人还是嘉宾有个是清华还是北大的教授，一个是淘宝销量前十的卖家，他反复强调自己一年的销售额有多少。\n2018/08/26 23:47\n从92到今天已经26年了，整整一代人成为留守儿童，2010年的统计数据是6000万，两年前改了统计口径只有900万。这二十六年间前半段是农村物质极其贫乏，基层滥用暴力手段治理的时期，后半段是教育水平滑坡，消费主义盛行，奶头乐肆虐。这样一代即使犯罪率上升0.00000001，恶性治安事件频发也会是大概率 …\n为啥找不到对象呢，个人内因很多，归纳起来有三：第一，吝啬。舍不得把自己的心分给别人，哪怕不需要很多，总是活在自己的世界里，怕被别人打扰也害怕自己打扰了别人，宁可被果断的拒绝，也不想被勉强的答应。第二，怀疑。总是在想，他是真的喜欢我吗，还是在应付着呢，这不是最可怕的，最可怕的是自己也不知道自己是在应付还是真的喜欢。抱着怀疑一切的态度，当然也会怀疑所谓的爱情。第三，畏惧。怕自己有所期待，也怕被别人给予很高的期待。姚明的广告说：没有买卖就没有伤害，套过来说，没有期待就没有伤害。外部原因就是认识的人有限，文科院校文科专业，大家懂得，再加上一二三催化作用，就一直单身下去了，一个人时间久了也会有惯性的。\n优秀的代码是抽象的逻辑，逻辑的抽象。\n狼与狗的区别在与：狼能团结合作而狗不能。而团结合作的基础就是换位思考理解他人。又听说过：弱者攻歼，智者互惠。深以为然。昨天一不小心又变成了一条狗啊，没忍住叫了几声。\n2015-07-09\n初中学校里老师鱼龙混杂，上学第一天，全班大扫除，我跟一个同学疯闹，被以为在打架，我老老实实接受批评，结果被班主任打了一个大耳光，班主任教英语的，我中考英语40多，高考英语发挥失常27，高考全国卷差二本19分，初中数学老师原是校园超市老板，贿赂学校混进体制内，教我们班数学，自己不会解二元一次方程，不会sin、cos等三角函数，全班数学基本等于自学，那老师混了三年后去教务处工作不再教学，我们是唯一倒霉的一批。我人生的前半段就这样了。\n还有个应该不算毁一生的吧，就是高中九个科目唯一真心本能的喜欢的就是历史，是唯一做笔记的学科，但是谁叫理科好工作呢，于是分班就去了理科。\n如果一个男的，在知道一位女生有男朋友的话，还会故意接近，制造机会，绝对是渣男，人品有问题，道德缺失，世界观不正，因为我们是人，我们有控制自己的能力，我们知道，去拿一个不属于自己的东西是偷、是窃、是贼。一个东西曾经属于我，我还挺喜欢它，现在它不属于我了，我还可以去偷偷的占有？不能拿感情为卑鄙猥琐的行为作解释开脱，那么做是侮辱爱情！如果一个人这么干了我们有理由怀疑他以后的行为，他是没有底线的，道德原则对他是没有束缚的，女人是会老的。如果我爱一个人，我会努力使她幸福，即使不能属于我了，我也会祝她幸福，即使放不下，我也会正大光明的去争取，让她结束上一段感情后，在去做新的开始，这么做虽然不够坦荡，但也光明磊落，绝不会畏畏缩缩，偷偷摸摸的去窃，去偷。 男人不应该这样为难男人，女人也不应该这样为难女人，小三永远得不到支持，即使是因为爱情，即使那个人够好，够完美，多么偏爱他，都不应该，因为他是属于另一个女人的，是另一个女人应该享有的权利，这是原则、这是责任，这是道德底线。\n如果我喜欢一个事情，我会想去做好它，我会认真的去学习，努力的去准备，比较自己的不足，听取别人的意见，付出大量的时间、心力、情感、金钱，即使熬夜通宵，即使疲惫不堪都是值得的，因为 这是 我 想 ！是我喜欢。不是别人要求我的任务，不是我的负担和义务，即使是我为了讨好女神而去这么做，即使是我无聊为了消磨时间而这么做，即使是因为任何愚蠢聪明的原因而这么做，重要的“我想”然后我做与不做都是我自己的事，我讨厌任何违反我意志的绑架，我讨厌别人无缘的想我要去如何。\n思维一直在变化，最近由梦中另起体会。 从很小的时候我就知道自己缺乏血气之勇，虽然我很喜欢七进七出的赵云，但如果让我回到三国，我更喜欢当郭嘉。 前几日夜里不得安睡，半夜惊醒，回头巡梦，发现梦里竟把一个小时候有欺负过我的恶霸打的头破血流，也许是粉身碎骨。 我这人好像略有奇怪，就是睡觉基本都uy会做梦，并会觉了。（觉了，梦中清醒）。\n答：一命二运三风水，四积阴德五读书，六名七相八敬神，九交贵人十养生，十一择业与择偶，十二趋吉要避凶。\n2015年目标\n1、拿到二建证书 2、拿到助理工程师 3、拿到电网调度员证 4、学好英语 5、开始考自考 6、安静读三本名著并写下读书笔记 7、养成写日记习惯 8、调节好作息习惯 智商是什么东西？不过就是大脑思考的速度快慢而已。它就是一个工具！它存在的意义只有两个，一学得更快，二记得更多。没有这个学习过程，高智商文盲也还是个文盲，干不出什么好事来！所以别什么都给我往脑子上推，这就是你们偷懒不想动脑子的借口！”“所有的，抱怨脑子笨的人，都不是笨，而是懒。他们懒得思考，懒得记忆，懒得学习，懒得去适应新的环境！可实际上，许多事只要你用心你就能学会。” 你让一个智商195的三岁孩子学微积分给我看看！”\n2022年1月15日\n工程师，百度百科的解释是：将一般性规则进行专业设计以达到应用需求的人 科学家，百度百科的解释是：努力探索自然，以便发现一般性法则（General principles）。\n"},{"id":50,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E9%AA%9A%E8%AF%9D/","title":"骚话","parent":"-随笔","content":"骚话\n古有《离骚》，其意：王逸《楚辞章句·离骚序》：“离，别也；骚，愁也。” 班固《汉书·离骚赞序》：“离，犹遭也。骚，忧也“。钱澄之《屈诂》：“离为遭，骚为扰动。扰者，屈原以忠被谗，志不忘君，心烦意乱，去住不宁，故曰骚也。“\n骚话：心烦意乱，去住不宁，忧愁幽思而作，愁肠百转所作所得。\n它唯一的价值，是针对我的价值，是我写的。更公平的来讲，大部分都是狗屁不通，随便找本出版的诗集、或者其它什么书，都更有益一些。\n被过去折磨的死去活来。 这东西，信则有，不信则无，她的世界里从前也许从来没有出现过这个，现在即使出现也因为怀疑考验和她的不信而消失，二元世界观还是有道理的，世界既是物质的，也是虚无的，有太多信则有，不信则无的东西，比如上帝，即使物质世界无，但在精神世界中，它真实的影响了你的认知，你的选择，改变影响你的人生，还能说上帝是虚无的么？ 互联网的出现并没有带来更多的公平(人们所期待的那样公平，更倾向于“平等”)，那些强者会更好更有力的利用网络，更好的利用奴役计算机，但网络的出现给那些想变的更强的人带来机会，努力和智力的价值得到了提高。以前出身极大的影响了教育，但现在多了很多机会。但信息现在信息的无限泛滥，对人产生了信息的 DDoS 攻击。 不应将自己置于危险之地，无论是物理上的危险还是因为社会道德水平导致的危险。就比如不要随便穷游，单身女性深夜去偏僻地方，去见陌生人去见不了解的人。蓝星就这科技道德水平，清朝的人民国时的人现在的人都不一样。人与人之间的差距也许比人与狗都大。 当我意识到我变的笨拙，我就意识到我已经被俘虏，我已经沦陷。 dating 一个时代，它的科技程度，思想方式，决定了生产效率，进而也很大一部分决定了进行重复而基础工作的人和进行科学研究的人在人群中的比例，而很多人认为，那只是自己努力的成果。我鄙视那些不努力的人，但我完全不鄙视那些在劳动分工中从事比较简单基础工作的人。 脚趾踢到桌角够痛吧，还有个类似但更痛的，在北京的一个冬天我穿着拖鞋去阳台挂衣服，地上有冰，在我专心致志的挂衣服的时候，突然脚底向前一滑，我感觉我以一个平沙落雁式飞了起来，但最终我屁股并没有受伤，不是我扶住了哪里，在我失去控制，脚滑的尽头，在我一百六七十斤的体重即将起飞时，被我大母脚趾以撞墙的方式止住了。。。 往事不堪回首，现在更是不堪入目啊！兄弟们！！！ 写诗也是一种本能，只不过有些人要脸，把自己的屁话藏起来不说。 别再期待了，我也是烂人一个，我看见了我们之间爱情的消逝，貌似没有变化，一切都在默不作声中崩溃着。现在我的心痛和不舍都是伪善，令人绝望和脆弱不堪一击的伪善。为了避免再伤害，宁愿舍掉那一点欢愉。所以啊 不要对我有一丝丝的期待，反正 我也是个烂人 一个，伤你的时候才不敢手下留情，决绝的一丝心软都不敢有的啊。 别再期待了，我也是烂人一个，我看见了我们之间爱情的消逝，现在我的心痛和不舍都是伪善，令人绝望和脆弱不堪一击的伪善。为了避免再伤害，宁愿舍掉那一点欢愉。所以啊 不要对我有一丝丝的期待，反正 我也是个烂人 一个，伤你的时候才不敢手下留情，决绝的一丝心软都 别再期待了，我也是烂人一个，我看见了我们之间爱情的消逝，现在我的心痛和不舍都是伪善，令人绝望和脆弱不堪一击的伪善。为了避免再伤害，宁愿舍掉那一点欢愉。所以啊 不要对我有一丝丝的期待，反正 我也是个烂人 一个，伤你的时候才不敢手下留情，决绝的一丝心软都不敢有的啊。 这个，与我看到她的第一眼一样吧，仿佛天空中射下来一道光，我知道我完了，我沦陷了，我被改变了，一切都永久的改变了，周围一切那么自然，平静，但又好像每一丝都发生了变化，过去的那个我已经死了，有什么新的东西诞生了，重新跌跌撞撞在新世界中。 我看到她的第一眼，仿佛天空中射下来一道光，我知道我完了，我沦陷了，我被改变了，过去的那个我已经死了，新的我诞生了，永远也回不过去了。 我的愤怒、温柔、柔软、动情、感伤，一切的不能自已的，都倾付给艺术品，都不会轻易流露与展示、诉说。 我的愤怒、温柔、柔软、动情、感伤，一切的不能自已的，不应轻易流露、展示、诉说的。都倾付给艺术品，而在工作、生活还是要如铁石心肠。 是谁在看电影的时候偷偷哭 我并不是在替那个交警伤心，我没有那么高的道德情操和使命感，我伤心的是为什么会有那么多人在玩世不恭，那么多的人不了解什么是责任。 人们用神灵解释世界和祈求帮助，那么新世纪一定是睡眠和失眠为主神。 丰富的网络世界，侵蚀现实世界 法律是道德的底线，那整个社会都道德败坏呢？如果装傻充愣，蛮不讲理可以获得优势，那么？ 孤独是永恒的，于是我们满世界的拼命寻找那个理解、认可、关注我们的人，只为体会一种不曾体会过的温暖。 孤闷 少年，就是要驰骋啊！放飞自我，惨烈搏杀。 坚韧的灵魂，不拔的意志，忠诚的信仰， 被黑暗凝视侵染， 经历了艰难困苦反复折磨的思维改造才理解了那种美。 世界是什么样的，世界不是我爱的样子，可我还疯狂的爱它啊。 因愚昧而赤诚 很多男生在成长过程中都有所热爱，比如足球篮球网吧游戏，我发现我那时候一直没有，现在我有了，就是编程。 越老心却越柔软 我不明白我是狂热的热爱着个世界，还是充斥着疯狂的贪欲。 我们应该渴望父母的理解，但我们也应该明白不应该被这种渴望过于影响自己的选择，我暂时还没有找到调和这种痛苦的办法，只能反复告知自己是对的，让自己变得坚硬些， 有时候会有悲伤，好似什么破碎消逝的悲伤。怅然若失，一切虚无，好似梦醒了， 身心皆坏，唯皮壳支撑。 我是一个偷偷执着的人。 不自信的一个特点是：被看低、嘲讽，拒绝后内心会非常抵触和敏感、沮丧。 喜欢就改变它，仇恨就超越它 耽溺 放任自己的情绪肆无忌惮的奔驰，是一件很奢侈的事。 他伪装的太成功了，他融洽的消融在这世界里了，没有遇到过多的挫折，他不理解你的，他并不爱你， 世界不适合你深情的活，偏偏在这薄情的世界深情的活。 I’ll try anything once. 人生苦短,何妨一试。 人生苦短,何妨一试 Life is short, why not try it. 也甘愿赴汤蹈火去走它一遍 你对社会的价值越大，社会越不舍舍弃你 我为什么想入 无人之境，现实让人厌弃 性情我最爱也爱你所爱 姿势水平改变才能获得姿势，跟一个姿势水平低的人讨论进化论，量子力学，是讨论不出成果也没有逻辑的 对于那些不容易自己释怀的人来说，告别很重要 凡是不愿意跟生活和解，活的特别用力，坚信命运掌握在自己手里的人，看起来都有点蠢。 人类灵魂本真的层面不会过于受困于这个世界 试探和逃避，审视自己 忘了什么，忘了忘了什么。 不断去接受 理解 感受 很多东西 是需要去改变调整自己身心的。 话说一直不喜欢控制不住情绪的人，但又非常羡慕人家的感情充沛，热烈真挚。 前段时间心情不好，胡思乱想，到是想通了一件事，记得有一句话说：理解是非常非常困难，因为脑海里想到了100%，只能表达出50%，而表达出的，对方只能听懂50%，而对方脑海只能感受到听懂的50%。我对你的爱（感情）（这其实不是爱，只是我曾经那么认为）也一样，爱你有100分，却只能表达出50分，而我格外鲁笨，也许连20分也表达不出，我表达出的，也许连1分也难感受到，毕竟同样是电话，可能是关心，也可能是打扰，同样也是是咳嗽，可能是生病，也可能是噪音。遥遥无期，对于我，你也许不是种子，只是粒顽石，只是我不够努力，没能让顽石开出花。抱歉！制造了这么久的噪音，打扰了这么久！其实也不全是不开心的事，比如：我成功的戒了游戏啦☺️。 在铁屋里醒来，却找不到出口，同情着哪些仍在昏睡的人，但转念一想，他们比自己幸福的多，这样一来，倒宁愿自己就这样永远昏睡着了。 权利与责任 生活总是让弱者觉得无奈，让强者觉得无聊。 一种乐观主义：今天再大的困难，也不是最困难的时候。 「我登上一列露天的火车，但不是车，因为不在地上走；像筏，却又不在水上行；像飞机，却没有机舱，而且是一长列；看来像一条自动化的传送带，很长很长，两侧设有栏杆，载满乘客，在云海里驰行。」 小心翼翼又保留仁慈 我认识到我是个懦夫，如果我不是个懦夫我怎么会苟活于世间的，哦，懦夫是没有勇气自杀的。我是个贪心的人，如果不是，我怎么会总是期望用最小的代价去骗取最大的收获。我是个愚蠢的人，如果不是，怎么会经常自信满满地觉着，我不会只是因为我没有去学。 直到有一天你突然意识到 那个影响你 塑造你 使你之所以成为你的人 再也不会在你的人生 你的未来再出现了 你永远 永远的失去生命的一部分，你会慢慢的模糊她的一切存在痕迹，慢慢的化作一个符号，一种感觉，那些愧疚，自得，那些精心准备的惊喜，义无反顾的誓言，委屈，付出的温柔，心思，统统的不作数了。 聪明人也许更难变的成熟，一个人的成熟变化，会更好的适应这个世界，保护他更少受伤害。 爱情是一场前途未知的孤独冒险，赌上许多、付出许多、经受许多却不知道是否会有明天，有时侯甚至需要捂住双眼，堵上耳朵才会有继续前行的动力，爱情是勇敢者的游戏，爱情里需要智慧却排斥聪明，爱情是两个人在黑暗的孤独中踯躅前行，半途中遇到任何意外都需要努力才可能有相遇的机会。 一次买几样酒，每样喝一口。度数越高越好喝。 那么，祝你幸福，那么恭喜你了。 因为敏感所以痛苦多。 爱情是一场赌博，是互相吐露真诚，不断加码，当一个人不加码的时候，不是她不想玩儿了，就是在她那里你就值她投入这么多。 我现在喜欢那些说话看起来很不正经的人，大大咧咧老是开玩笑，很玩世不恭的样子。其实真正了解他们的心，你才会发现，他们活的比谁都认真，比谁都敏感。只是怎么说呢，人生不如意才是十之八九。任何事摊开了揉碎了说，都透着一股悲凉。珍惜你身边每个逗逼吧，他们只是用幽默感努力对抗世界巨大的荒芜。(后来我背弃了这种观点) 垃圾书顺从你，好书是需要你准备（顺从、改变）自己。 无论如何，孤独逃不脱。 学着放过自己。但凡所发之事，一定有解，时间机缘而已。对着电话里的怒吼也好，争辩罢好，平心静气。（2016/01/20 15:27） 罗曼.罗兰说：“人生是艰苦的。对不甘于平庸凡俗的人那是一场无日无夜的斗争，往往是悲惨的、没有光华的、没有幸福的，在孤独与静寂中展开的斗争。……他们只能依靠自己，可是有时连最强的人都不免于在苦难中蹉跎”。 过去的岁月也并非没有意义，这是人生旅程中最重要的一站，解决了温饱，锻炼了解决复杂问题的能力，宏观看事微观待物，思维缜密，抗压。这些都是生存的基础。 昨晚梦里，得到了好久想要的，得到了想要的不想要的，奇怪，每次释怀都是梦中因由。 聚散都由不得自己 一种是能一直保持单纯的，一种是看过太多经历太多最后回到单纯的；前者是上帝的宠儿，后者是精神世界的君王 逝波光阴，红尘磨折 眷顾 简单的快乐，愚蠢的笑容 我对你的爱是给你自由，你对我的爱是对我占有。 要怎样才能做到能明晰正视认知到自己的行为原因及意义。 有些道理有人天生就懂，有人吃尽苦头方懂，有些人说了也不会懂。 有些别人天生就知道的道理，有些人却需要反复的碰撞曲折才能理解，有些人甚至注定了无法理解。 现在的我有能力表现出足够的亲密，足够的爱，但却没有了青涩时鲁莽、盲目的赤诚。 你是我不敢直面的过去，永远接不上的对白。 如果一个人的行为能用“坏”来解释，那我就绝不会用“蠢”。 从今天起始，我决定要装成一个深沉的人，要一本正经地扯着蛋。 如何懂世故而不世故？ 大家吃着 聊着 笑着多开心，最角落的我笑的多合群。 有些时候解释就是在折辱自己，值得吗（值得解释么？）？ 所有的记忆聚散了，又都化作风。 胸襟气度、才情天分。 胸襟气度、天分才情（我的都是洼中洼）。 有些人 血里有风 是注定漂泊一生。 每个人都在这世上漂泊、即使偶遇一人也想能够彼此慰籍，但冰冷现实让我们学会了冷酷外壳，让我们小心翼翼又满怀期待。这世上最重要的就是爱与勇气！ 阿波罗的静穆与狄俄尼索斯的狂欢。 接近你的借口有千言万种，却只有一种理由，我喜欢你。 现实分外残忍在于，一旦走过便无法回去，所以回忆 好失败、面对理想、让步现实。 对于未来我上面都不再奢求，只希望别再失去更多。 当年的单纯时光，是快乐的天堂。 曾经沧海难为水，除却巫山不是云。取次花丛懒回顾，半缘修道半缘君。 爱一个人是什么感觉。好像突然有了软肋，也突然有了铠甲。2014-3-7 \u0026ldquo;眼泪这东西啊，是流出来就能把辛酸和悲伤都冲走的好东西。可等你们长大成人了就会明白，人生还有眼泪也冲刷不干净的巨大悲伤，还有难忘的痛苦让你们即使想哭也不能流泪，所以真正坚强的人，都是越想哭反而笑的越大声，怀揣着痛苦和悲伤，即使如此也要带上他们笑着前行。\u0026rdquo;\u0026ndash; 银魂 被虚无感折磨时的一些废话 独自的成为自己，多个伙伴而已，多了个同伙 我确定我有爱欲，却不能确定我是否会爱，爱欲是一种冲动，爱是一种能力。 文化与病毒一样，栖息于人群之上。 我与处境的一个巨大的冲突是：我渴望真实，我无法接触到真实的世界。 尘世如舟，我们穿行而过 我理解的幽默是：通过新颖（超脱）的角度，对原先合乎情理的逻辑进行解构，使其（原先）逻辑变的荒诞可笑。重要的是：“新颖的角度解构旧有合乎情理的逻辑”，其它任何使他人合乎常理的行为变的不郑重，都有些冒犯。 向下俯视的人，必定会像上摇尾巴，因为在他的眼里，世界是个阶梯，与此同时，他也物化和羞辱了自己，不在眼前，就在它处，因为在他眼里的世界是个阶梯。 不因别人的拒绝而退缩，去反向定义自己 爱欲是刀尖之火，欲海翻波，方显英雄本色 怕老婆？因为爱所以怕，又听闻一句佛经：“由爱故生忧，由爱故生怖，若离于爱者，无忧亦无怖。 有着虽然不完美但是健康的身体，有着虽然不满意但是体面的工作。 信息时代的面对信息最大的问题是：不是没有信息，而是充斥着无尽的信息浊流，难以得到可信信息，而且，一切权威都被打倒了。 创造一些难忘的夜，你、烟花和焰火。 创造一些难忘的夜，你、鲜花和焰火。 每个人心里都有一个过不去的坎，都要有个交代，都要有个结果，都试图去证明什么 社会很残酷，而艰难是每个人的必经之途。 有些时候，有些问题，有些困难，只能自己去面对，不会因为有没有男朋友，父母爱不爱你而变的不同。 1.5 小时后有个会，做点开会必要准备工作，第一项：灌咖啡。 曾经有一个笨拙、懵懂、幼稚、原始的我，他撞了很多墙，吃了很多亏，犯了多错，有过很多愚蠢的念头，我很怀念他。“在失去的所有人中，我最想念的是自己。” 我通过：世界就是这么无常这么痛苦的，来试图合理化我的痛苦。这不是我的原因，世界本就如此。 抱玉投川 放纵恣睢 世界，喧嚣而寂寥。 自己也不知道自己在期待什么 当我意思到我的人生失去了很多可能性后，反到让我下定了很多决心 人们已经处在一个不同时代的时代。 我们开始承认我们的无知(有些人比其他人更无知) 很多人觉得我们的目标既然是正义的，那我们做的一切都是正义的。 "},{"id":51,"href":"/Life/2Diary/2018/2018716174555/","title":"2018716174555th","parent":"2018","content":"2018716174555\n2018716174555\n"},{"id":52,"href":"/Life/2Diary/2020/2020%E5%B9%B46%E6%9C%8825%E6%97%A5/","title":"2020年6月25日","parent":"2020","content":"2018.12.03 3300 小北次.中介费+定金（1800 + 1500）\n2018.12.08 5550 三个月房租+网费（1800*3=5400+150） 800 取暖费\n2019.2.20 2820 1月17天房租\n2019.4.15 300 续约中介费\n2019.6.25 5400 三个月房租\n2019.9.25 5400 三个月房租\n2019.12.25 5400 三个月房租\n2020.4.08 5400 三个月房租\n2020.7.1 5400 三个月房租\n"},{"id":53,"href":"/Life/2Diary/2021/2021%E5%B9%B410%E6%9C%8825%E6%97%A5/","title":"2021年10月25日","parent":"2021","content":"价值观或信仰总会影响理性，陷于狂信更会导致偏执和不理智，全无信仰的人对己来说容易迷茫，对他人来说往往不堪信任。有人说：对一般人来说，有信仰比无信仰要好。\n好像没主动做过什么需要长期坚持的事，都是 deadline 或者环境（学校、工作）推动自己去行动，这是不是在随波逐流得过且过呢？？？\n"},{"id":54,"href":"/Life/2Diary/2021/2021%E5%B9%B411%E6%9C%8815%E6%97%A5/","title":"2021年11月15日","parent":"2021","content":"价值观分裂：体力劳动和脑力劳动， 劳动光荣，无论体力劳动还是脑力劳动。但让人类在自然的优胜劣汰中胜出的是夸张的大脑，而体力劳动收入已经远远少于脑力劳动收入，一面：脏、累、活、不体面，一面：聪明、优雅\n多想想，你40岁，50岁想要什么样子吧。（没有目标可不行）\n但是没人care你，你就别可劲care别人了。\n老子：千里之行，始于足下。 荀子：不积跬步,无以至千里。 韩非子：千里之堤，毁于蚁穴。\n"},{"id":55,"href":"/Life/2Diary/2021/2021%E5%B9%B411%E6%9C%8830%E6%97%A5/","title":"2021年11月30日","parent":"2021","content":"我自己所拥有的时间\n要做的事进行优先级排序\n三人行，必有我师焉。择其善者而从之，其不善者而改之。\n不可与别人攀比，但可以向别人学习。\n"},{"id":56,"href":"/Life/2Diary/2021/2021%E5%B9%B412%E6%9C%882%E6%97%A5/","title":"2021年12月2日","parent":"2021","content":"我们身处的“倦怠社会”（burnout society），在这个社会中，我们因不可避免的生存需求而精疲力竭和感到沮丧。他还思考了新的娱乐形式和“心理政治”（psychopolitics）——在其中公民顺从地屈服于体制的诱惑，以及情色的消失——韩炳哲将其归咎于当前的“自恋主义”和“展示主义”（narcissism and exhibitionism）潮流。\n仪式的消失\n”仪式”（rituals）是一种支撑结构，仪式给生活带来某种稳定性，在生活中提供心灵的平静。\n手机它依靠惊喜的刺激来保持快乐。\n无法与周遭建立长久且稳定深入的情感联系。\n之前在访谈，一位受访者说：当父母离世，他无妻无子，他觉得，好像他与这个社会的最后一点关联也断了。\n我曾匆匆忙忙在一个书店里看过一本书，只是言片语便喜欢上，很多年过去了，好像只在梦中有回到过那个书店，找到过那本书。记忆中还有很多浮光掠影的映像，已经不记得是何时何地。\n你跟你老婆一起解决一些困难、分享一些快乐，一起走过一些路，这些才是更重要的。\n兄弟萌，仪式感还是很重要的，不能认为”仪式感“仅仅是”形式主义“。\nshow\n兄弟萌，仪式感还是很重要的，不能认为”仪式感“仅仅是”形式主义“。\n简单来说，发朋友圈是”仪式感“的一部分，我们需要做一点”与往日不同“的事来发朋友圈。\n现代社会的快速迭代更新，让人无法与周遭建立长久且稳定深入的情感联系 ，手机、同事、居住环境（没买房）、都在变幻。而我们通常是通过”记忆里的事“来进行自己认知，来认为”我“是一个什么样的人，我们需要”搞事情“来创造”仪式感“、通过某些很有存在感的行为来锚定“过去”，防止时间变成：\u0026ldquo;漫长而没有回忆的时光“，我们需要一个个”事“串联起来”过去“，描绘自我。读书、旅行、喝酒、见远方的朋友等等都行。 当然，也可以完全不管这些，只是会偶尔发出：”有点找不到自己了“的疑惑。\n"},{"id":57,"href":"/Life/2Diary/2021/2021%E5%B9%B412%E6%9C%888%E6%97%A5/","title":"2021年12月8日","parent":"2021","content":"不知不觉的被“成为更好的人”、被“消费主义”洗脑成功，忘我的去追逐去满足一些超过“生存需求”的欲望，不可避免的精疲力竭、沮丧、枯萎、空洞。\n"},{"id":58,"href":"/Life/2Diary/2021/%E5%81%B6%E5%B0%94/","title":"偶尔","parent":"2021","content":"春秋无义战，那时候就会互相污蔑对方的王族血统，对方的贵族道德败坏，对方的国家危险动荡天灾人祸不断，出不义之师。那么现在世界上的国家的互相攻击行为会是“义”的么？都是互称“不义之师”。\n"},{"id":59,"href":"/Life/2Diary/2021/%E7%83%AD%E5%B8%A6%E9%B1%BC/","title":"热带鱼","parent":"2021","content":" 时间线： 2021年02月26日 买鱼缸、水草、水草泥、沉木、青龙石、过滤、 ￥ 499 2021年02月26日 俪鱼鱼缸加热棒 ￥ 45 2021年03月05日 森森油膜处理过滤器 ￥ 38 2021年03月08日 硝化细菌 ￥ 97 2021年03月25日 俪鱼鱼缸变频智能加热棒 ￥ 77 2021年03月25日 鱼缸刮藻刀 ￥ 38 2021年03月29日 鱼粮 ￥ 19 2021年04月01日 红绿灯鱼 10条 ￥ 43 2021年04月04日 收鱼； 买红绿灯鱼 10 条，卖家送 1 条 共 11条； 收到时 死透 5 条，3 条游泳姿态异常，3 条游泳姿态无异常，共 6 条存活； 过水后死亡 2 条，剩余 4 条； 24 小时后 死亡 1 条，剩余 3 条游泳姿态无异常； 2021年04月05日 养鱼； 死 1 条，剩余 2 条无异常，无法确定死因，水土不服或运输问题 2021年04月05日 养鱼； 晚上，发现 1 条死亡，发现时在 森森油膜过滤器进水口与鱼缸壁之间卡着， 剩余 1 条。 2021年04月07日 买鱼； 下班后去百度地图上查的最近的花苗鱼虫市场，现场看应该是撤店很久了（现场毫无此店痕迹），发现附近的 大型地下华联超市有卖孔雀鱼，买了 3 条（￥ 10） ； 2021年04月07日 养鱼； 孔雀鱼跳缸了一条 ； 2021年04月11日 换水； 少少的换了一点水，这一夜生怕我的鱼暴毙。 ； "},{"id":60,"href":"/Life/2Diary/2022/2022%E5%B9%B41%E6%9C%8811%E6%97%A5/","title":"2022年1月11日","parent":"2022","content":"小的时候我认为我性格不会的方面有：缺乏勇气、虚荣\n2016年，想去搞编程，但是房子装修困在那走不开，痛苦； 2017年，上半年去北京找了个培训班，天天睡觉，但是了解了也学到很多；下半年找了个外包入行编程； 2018年，上份外包工作满6个月，跳槽，换了个不是外包的编程工作； 2019年，生活再次稍微的恢复了点正轨，短期外债还清，搬离通勤时间2小时的回龙观，上班通勤时间变为10分钟，极大幸福，但是之前挤了接近一年多的13号地铁，我感觉我精神受到了一些创伤。； 2020年，好像丢失的一年，我确定我确实特别喜欢宅的生活，初步确定无必要不下楼无任何不适，想明白了一些事，把想明白的事去做了； 2021年，丢失了一点的一年，可以肯定我确实特别喜欢宅的生活，这一年除非是理发、医院、上班、喝酒，丢垃圾，几乎没有下过楼，但是也逐渐感觉到人类本能约束着我，必须下楼运动、社交，被疫情影响拖延的搞牙计划正式开始，牙齿初步搞定就去搞鼻塞和耳鸣，最后去看下脑子和精神状态。 2022、2023希望两年后可以步上正规。 "},{"id":61,"href":"/Life/2Diary/2022/2022%E5%B9%B41%E6%9C%886%E6%97%A5/","title":"2022年1月6日","parent":"2022","content":"自己给自己 PUA P傻了之：现在一天如果没有学习或者搬很多的砖（工作有很大推进），就，这一天，如果没有弄点“仪式感”或者“自己认可的事”，就会有巨大的空虚感，觉得时光虚度，感觉到恐慌（我觉得有点不对劲）。\n"},{"id":62,"href":"/Life/2Diary/2022/2022%E5%B9%B43%E6%9C%8817%E6%97%A5/","title":"2022年3月17日","parent":"2022","content":"从去年开始弄牙，就一直备有鲜牛奶，前段时间我看着牛奶和咖啡，想着弄一杯手作拿铁？说干就干，很快搞好，甚至还发了朋友圈，后面一个朋友问我味道怎样，我想了想说：“偶还是喜欢黑咖啡，牛奶+咖啡，模糊了咖啡丰富复杂的苦味，过于柔和了。”\n"},{"id":63,"href":"/Life/2Diary/2022/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/","title":"2022年5月10日","parent":"2022","content":"“两年”，想起我们差不多是两年前认识的，想起当时聊天中说的一个疑问：“远方的朋友的意义是什么”，这个疑问一直在我脑中回荡，最近有所心得：先期是一句”不要在网络上建立过于亲密的关系，就像不要在空中建立楼阁“，其实是想说：\u0026ldquo;不要仅在网络上建立亲密关系\u0026rdquo;；人的精神在一个虚拟空间，网络是另一个虚拟空间，但肉体活在物质空间，三个空间互相干扰掺杂拉扯混染；远方的朋友对你物质空间几乎没有影响，但能影响精神空间。\n有句和尚的话：“心迷法华转，心悟转法华”，心迷的时候，心情随着环境变化生老病死而喜怒哀乐的流转，心悟的时候，能抽离出来以各种角度看事情，心：心情或者是关注点；法华：周遭环境，世界。\n"},{"id":64,"href":"/Life/3Music/Music/","title":"Music","parent":"3、Music","content":"Music\n"},{"id":65,"href":"/Life/%E8%A1%8C%E4%B8%BA%E8%A6%81%E7%B4%A0/","title":"行为要素","parent":"Life","content":" 行为要素 不停止对另一种人生的可能性的追寻，我究竟想要过怎样的生活，我究竟想体验怎样的人生。 人一旦意识到自己陷入停滞，可能性的消失，会有巨大的痛苦来袭，唯有将心念投入到游戏、抖音、放弃大脑，才能得到片刻喘息。\n例子： 待办事项 待办事项 待办事项 电影 待办事项 《死亡诗社》 《真爱至上》 《怦然心动》 《爱在》系列 电视剧 美剧 《生活大爆炸》 《黑吃黑》 《欲望都市》 《老友记》 《使女的故事》 动漫 日本 《派对浪客诸葛孔明》 - 2022/09/12 《鬼灭之刃》 书 书 《身份的焦虑》 阿兰德·波顿 每天 技术 每天阅读/写一篇技术博客 每月 行为 季度 行为 正骨按摩 行为要素 行为 做一本书 去东京看花火大会、北海道看雪、看一次歌剧魅影的音乐剧 颐和园七月的荷花 "},{"id":66,"href":"/Tech/10Miscellaneous/Apache_toolkit/","title":"Apache Toolkit","parent":"10、Miscellaneous","content":"toolkit 工具包\ncommons-validator（通用验证系统） 验证体系对付用户界面的用户千变万化的输入可能。\rApache ShardingSphere（分布式数据库中间件） 一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。\rApache Tika Apache Tika™工具箱可从一千多种不同的文件类型（例如PPT，XLS和PDF）中检测并提取元数据和文本。所有这些文件类型都可以通过一个界面进行解析，从而使Tika可用于搜索引擎索引，内容分析，翻译等等。\rApache Nutch Nutch是基于Lucene实现的搜索引擎。包括全文搜索和Web爬虫\rApache PDFBox® 在Apache PDFBox的®库是与PDF文档工作的一个开源的Java工具。该项目允许创建新的PDF文档，处理现有文档以及从文档中提\r取内容的能力。Apache PDFBox还包含几个命令行工具。Apache PDFBox在Apache许可证2.0版下发布。\tImageMagick® 使用ImageMagick的®创建，编辑，撰写，或转换位图图像。它可以读取和写入各种格式的图像（超过200种），包括PNG，JPEG，GIF，\rHEIC，TIFF，DPX，EXR，WebP，Postscript，PDF和SVG。使用ImageMagick调整，翻转，镜像，旋转，扭曲，剪切和变换图像，调整图像颜色，\r应用各种特殊效果，或绘制文本，线条，多边形，椭圆和贝塞尔曲线。\rBatik 是一个基于Java技术的SVG(可扩展矢量图)工具包。\rFOP FOP是由James Tauber发起的一个开源项目，原先的版本是利用xsl-fo将xml文件转换成pdf文件。\r但最新的版本它可以将xml文件转换成pdf，mif，pcl，txt等多种格式以及直接输出到打印机，并且支持使用SVG描述图形。\rXML Graphics XML Graphics：发展 XML 与图形进行转换的计划项目\raxis2c Axis2/c是一个用C语言实现的Web服务引擎，它服从可扩展的，灵活的Axis架构。Axis2/C可以用来提供web服务，\r也可以作为web服务的客户端。它可以很方便的嵌入到其他软件中，从而使该软件具有web功能。\rWSS4J WSS4J 是 Web服务安全规范 (OASIS Web Service Security , WS-Security) 的 Java 实现。WSS4J 是一个 Java 的类库用来\r对 SOAP 消息进行签名和校验，使用 Apache Axis 和 Apache XML-Security 项目。\tApache Forrest Apache Forrest是一个把来自各种不同的输入数据源转换成用一种或多种输出格式(比如HTML,PDF等)来统一显示的发布系统。它\r基于Apache Cocoon并分离了内容与内容结构,不仅可以生成静态的文档也可以当作一个动态的服务器。\rXalan xalan是一套xslt处理器（有C和JAVA语言两种版本），用来将XML文件转换为HTML,TEXT和XML等其他类型文件格式。\tAnakia Anakia 是一个XML的转化工具，它使用 JDOM 和 Velocity 来将XML文档转换成你所需要的文档格式。\r支持在 Ant 中设置转换任务以及使用 XSL 进行XML文件处理。\tRoller 是一个全功能的多用户博客平台。采用Java语言开发\tCommons-Net Commons项目中封装了各种网络协议的客户端\tSanselan 是一个纯 Java 的图形库，可以读写各种格式的图像文件，包括快速解析图片信息例如大小/颜色/icc以及元数据等\rjsoup: Java的HTML解析器\rjsoup是一个用于处理真实世界HTML的Java库。它提供了一个非常方便的API来提取和操作数据，使用最好的DOM，CSS和类似jquery的方法。\rQuartz: Java的任务调度框架\rQuartz 具有诸如 JTA 事务和集群等功能，可用于企业级应用程序的支持。\rOk HTTP： HTTP 通讯框架\rJoda Time： 作为 Java 中日期和时间类的一个很好的替代品。\rXStream 将对象序列化到 XML 中\rApache OpenNLP Apache OpenNLP软件支持最常见的NLP任务，例如标记化，句子分段，词性标记，命名实体提取，分块，解析和共指解析。这些任务通常是构建更高级的文本处理服务所必需的。OpenNLP还包括最大熵和基于感知器的机器学习。\rApache Camel 骆驼是 开源集成框架 使您能够快速轻松地集成使用或生成数据的各种系统。\r装满 数百个组件用于访问数据库，消息队列，API或基本上在阳光下的任何东西。帮助您与一切集成。\rApache Flink 流处理框架\rAxure RP Axure RP是一款专业的快速原型设计工具。\rApache Trafodion 分布式 SQL 引擎 Apache Trafodion 宣布退役\rPulsar Pulsar是一个分布式的消息发布/订阅传递平台，具有非常灵活地消息模型和一个直观的客户端API\rMFC 微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。\rPWA PWA（Progressive Web App）是一种理念，使用多种技术来增强web app的功能\rVeloren Veloren 是一款受《立方体世界》、《荒野之息》、《我的世界》等游戏启发制作的独立RPG,完全开源免费。游戏致力于打造一个明亮、绚丽、有趣的世界,可以用独特有趣的方式探索\rFinalShell 是一款免费的国产的集 SSH 工具、服务器管理、远程桌面加速的良心软件，同时支持 Windows、macOS、Linux，它不单单是一个 SSH 工具，完整的说法应该叫一体化的服务器/网络管理软件。\rApache APISIX Apache APISIX 是一个基于云原生、高速可扩展的开源微服务网关节点实现，其自身主要优势是高性能和强大的扩展性\rMeson Meson 旨在开发最具可用性和快速的构建系统。提供简单但强大的声明式语言用来描述构建。原生支持最新的工具和框架，如 Qt5 、代码覆盖率、单元测试和预编译头文件等。利用一组优化技术来快速变异代码，包括增量编译和完全编译。\rJaspersoft® Studio Jaspersoft® Studio 是世界上最受欢迎的开源报告引擎。它完全以 Java 编写，能够使用来自任何类型的数据源的数据，并生成可以各种文档格式查看、打印或导出的像素完美文档，包括 HTML、PDF、Excel、OpenOffice、MS Word 和其他文档格式。\rvert. x和reactor Excelsior JET Excelsior JET是一款有提前编译技术的Java虚拟机增强工具（非开源）。提前编译器可以将您的类文件和jars文件转化成高度优化的二进制可执行文件，能够在Intel x86平台的Microsoft Windows和 Linux系统中运行。同传统 JVM（Java虚拟机）中运行的原始类文件相比，这些经过优化的可执行文件具有更快的运行速度。另外，您的应用程序将会得到更好的保护，以防被篡改或窃 取代码。\rGodot 多平台游戏引擎 Godot Mitmproxy Mitmproxy 是一个免费开源的交互式 HTTPS 代理。它可以用来拦截、检查、修改和重放网络流量，还可以对从 HTML 到 Protobuf 的各种消息类型进行预设和解码，实时拦截特定的消息，在它们到达目的地之前对其进行修改，并在之后对客户端或服务器进行重放\rPowerToys Microsoft PowerToys 是一组实用工具，可帮助高级用户调整和简化其 Windows 体验，从而提高工作效率。\rkail_linux：\r更新源：\rvi /etc/apt/sources.list\r#中科大\rdeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\rdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\r#阿里云\r#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\r#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\r#清华大学\r#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\r#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\r#浙大\r#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free\r#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free\r#东软大学\r#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib\r#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib\r#官方源\r#deb http://http.kali.org/kali kali-rolling main non-free contrib\r#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\r#重庆大学\r#deb http://http.kali.org/kali kali-rolling main non-free contrib\r#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\r保存后之后回到命令行下执行命令：\rapt-get update \u0026amp;\u0026amp; apt-get upgrade \u0026amp;\u0026amp; apt-get dist-upgrade\rapt-get clean #删除以下载的包\rreboot #重新启动\r或者\rapt-get clean //清除缓存索引\rapt-get update //更新索引文件\rapt-get upgrade //更新实际的软件包文件\rapt-get dist-upgrade //根据依赖关系更新\r备注：\rapt-get常用命令:\rupdate – 取回更新的软件包列表信息\rupgrade – 进行一次升级\rinstall – 安装新的软件包(注：软件包名称是 libc6 而非 libc6.deb)\rremove – 卸载软件包\rpurge – 卸载并清除软件包的配置\rautoremove – 卸载所有自动安装且不再使用的软件包\rdist-upgrade – 发布版升级，见 apt-get(8)\rdselect-upgrade – 根据 dselect 的选择来进行升级\rbuild-dep – 为源码包配置所需的编译依赖关系\rclean – 删除所有已下载的包文件\rautoclean – 删除已下载的旧包文件\rcheck – 核对以确认系统的依赖关系的完整性\rsource – 下载源码包文件\rdownload – 下载指定的二进制包到当前目录\rchangelog – 下载指定软件包，并显示其changelog\t"},{"id":67,"href":"/Tech/10Miscellaneous/data_authority_managementa/","title":"Data Authority Managementa","parent":"10、Miscellaneous","content":"data_authority_managementa\n独立的数据权限控制\r访问限制、\r某些数据不允许访问\r数据清洗、\r某些数据部分返回\r业务场景和数据安全级别划分（绝密、高保密、保密、可公开，四个级别）， 主要从“高保密”等级的敏感数据，开始进行梳理。\r这里我们把敏感数据分成四个维度进行梳理，用户、商家、终端、公司。（用户、业务、公司。）（基础数据标签、业务数据标签）\r应用动态数据屏蔽有五种可能的技术：\r1、在数据库中：数据库接收SQL并将重写应用于返回的屏蔽结果集。适用于开发人员和DBA，但不适用于应用程序（因为连接池，应用\r程序缓存和数据总线会隐藏数据库中的应用程序用户身份，并且还会导致应用程序数据损坏）。\r2、应用程序和数据库之间的网络代理：捕获SQL并在select请求上应用重写。适用于具有简单'select'requests但不适用于存储过程（\r代理仅识别exec。）和应用程序的开发人员和DBA（因为连接池，应用程序缓存和数据总线隐藏了数据库中的应用程序用户身份，也可以\r导致应用程序数据损坏）。\r3、最终用户和应用程序之间的网络代理：识别文本字符串并替换它们。此方法不适用于复杂的应用程序，因为当无意中应用实时字符串替\r换时，它很容易导致损坏。\r4、应用程序和XACML中的代码更改：代码更改难以执行，无法维护且不适用于打包的应用程序。\r5、在应用程序运行时：通过检测应用程序运行时，定义策略以重写从数据源返回的结果集，同时具有对应用程序用户的完全可见性。此方法\r是动态屏蔽复杂应用程序的唯一适用方法，因为它可以控制数据请求，数据结果和用户结果。\r=================================================wota5037的博客================================ 基于资源的权限系统-设计思路 基于资源的权限系统-数据库设计\n通用权限管理设计 之 数据权限 基于资源的权限系统-设计思路 概述 权限系统提的最多的就是 RBAC（基于角色的访问控制）。 所谓角色，其实就是权限的集合，某个角色就是某几个权限的结合。其目的是为了简化授权和鉴权的过程。\n基于角色的权限控制用在简单的权限环境下没有问题，如果在权限控制比较复杂的系统中，或者说要做通用的权限系统时，基于角色的权限控制会带来以下问题：\r1、角色可以用来做功能权限，做数据权限的话，会导致角色数量非常多 比如：bug管理系统，一般有 developer, reporter, manager 等一些角色，其中，reporter 可以创建bug，developer 可以解决，回复bug，manager 可以统计bug 等等。 在这个系统中，通过设置 developer，reporter，manager 几个角色，可以使得授权，\r鉴权更加简单，直观。 但是，如果权限粒度要求更细的话，比如，某些reporter只能创建普通级别的bug，某些reporter可以创建各个级别的bug，或者有更加细粒\r度的权限要求的话，角色的数量就会激增。 到时候，管理角色本身带来的工作量反而会大于角色带来的好处。\r2、角色是一维的，不同的角色之间一般都是独立的，而人员之间一般有树状的组织关系。所以，角色就很难与已有的组织关系互相映射。 而授权的时候，经常\r是上级的组织会自动获取下级创建的数据的一些权限\r3、对于不确定的系统来说，角色不好定义。如果是bug系统，比较成熟，方便定义角色类型，如果是通用系统的话，用户其实不太容易定义好自己需要的角色。\r另一种 RBAC（resource base access control）\r基于资源的权限系统。\r术语介绍\r人员 : 实际使用系统的用户，也就是需要进行权限检查的人\r组织 : 树形结构，但是人员可以属于一个或者多个组织\r资源 : 需要授权的东西都可以认为是资源，每个功能是资源，每个接口也是资源，每条数据也是资源。 资源树 上的根就是整个系统。\r动作 : 对资源的操作，比如常用的 创建，删除，更新，查询\r权限 : 组织 + 资源 + 动作 （什么人对什么资源可以做什么动作）\r系统初始化\r权限系统本身提供一个超级用户(admin)，通过此用户来初始化最初需要的信息。\r初始信息只需要定义：\r组织的根节点：以后追加的所有人员和组织都在此节点之下（比如就是某个公司）\r资源的根节点：以后追加的所有资源都在此节点之下（比如就是需要进行权限控制的系统）\r动作：对资源可能进行的操作（一般就是CURD，增删改查）\r有了以上信息，就完成了针对某个系统和组织的权限系统的基本初始化。 基本信息初始化之后，可以导入组织/人员，以及资源信息，或者直接在权限系统提供的页面上操作。\r注意 每个资源只有一个父节点，每个组织也只有一个父组织，但是每个人员可以属于多个组织\r授权过程\r授权是权限系统中重要的步骤之一，另一个重要步骤就是鉴权。 授权有2种视图：\r人员/组织 视图 下的授权流程\r选择 资源\r选择 动作\r确认授权\r生成权限数据\r注1 前2步的选择都可以多选。\r资源 视图 下的授权流程\r选择 人员/组织\r选择 动作\r确认授权\r生成权限数据\r鉴权过程\r鉴权是使用最频繁的步骤，几乎每次请求都会有鉴权的操作。 鉴权就是判断 某人对某资源做某个动作 是否合法，所以鉴权的 input 是 人员/组织，资源，动作； output 则是是否鉴权成功。\r根据 input 的内容（人员/组织，资源，动作），查看权限表中是否有匹配的数据\r1.1 有匹配的数据，返回鉴权成功\r1.2 没有匹配的数据，查找 人员/组织 所属的父组织，再次用 （父组织，资源，动作）作为 input，查看权限表中是否有匹配的数据\r1.2.1 有匹配的数据，返回鉴权成功\r1.2.2 没有匹配的数据\r1.2.2.1 当前组织已经是 根组织，返回鉴权失败\r1.2.2.2 当前组织不是 根组织，进入步骤 1.2\r自动授权规则\r对功能权限来说，一般数据量不会太大，即使没有自动授权，手动授权也可以完成。 但是对数据权限来说，不仅数据量庞大，而且如何授权也不确定，数据的变化也可能会很频繁，手动来做几乎不可能。\r自动授权目的是将自动授权机制参数化，让用户通过设置不同的参数来生成不同的权限数据。 自动授权机制是以插件的形式加入到权限系统中的，默认可以提供几种常用的自动授权机制插件。 在授权时，也可以指定使用一种或者多种自动授权插件。\r下面以一个示例来说明插件是如何使用的。 示例插件：创建数据时自动授权插件 功能：用户A 创建数据X 后，生成如下权限数据：\r用户A 可以 修改 查询 删除 数据X\r用户A 所属组织的成员可以 查询 修改 数据X\r其他组织的成员可以 查询 数据X\r此插件参数就是3个list：自己的动作列表，同组织成员的动作列表，其他组织人员的动作列表 插件的参数是在权限系统中的插件管理功能中配置的（插件参数的设置需要用到动态表单，因为插件的参数个数，类型等都是不定的）\r使用流程如下：\r某用户创建了一条数据\r创建完数据后，调用权限系统的授权接口，在授权接口中指定使用上面的 示例插件\r权限系统的授权接口会调用上面的 示例插件 给用户，用户所属组织以及其他组织 分别授予相应的权限\r针对不同类型的系统，授权方式千差万别，将授权的实现剥离出来，是为了增加系统的通用性。\r总结\r通用权限管理的主要的功能就是 授权 和 鉴权 ，其本质都是对权限数据（什么人对什么资源可以做什么动作）的管理。 授权的难点在于给某人授与某个数据的权限之后，组织中其他关联人员\r可以计算出自己对这个数据的权限，这就是自动授权插件的意义。 鉴权的难点一是权限的数据量会比较大（如果权限粒度细的话），一是有些权限是需要计算的。\r基于角色的权限系统的核心在 角色（人员），而基于资源的权限系统核心在 资源，资源是权限系统需要保护的东西。 希望能从资源的角度来设计出更加通用的权限管理系统。\r对于不确定的系统来说，角色不好定义。如果是bug系统，比较成熟，方便定义角色类型，如果是通用系统的话，用户其实不太容易定义好自己需要的角色。\r================================================================= 基于资源的权限系统-数据库设计\n================================================================= 通用权限管理设计 之 数据权限\n权限控制可以理解，分为这几种 ： 【功能权限】：能做什么的问题，如增加产品。 【数据权限】：能看到哪些数据的问题，如查看本人的所有订单。 【字段权限】：能看到哪些信息的问题，如供应商账户，看不到角色、 部门等信息。\n几个概念 【资源】：数据权限的控制对象，业务系统中的各种资源。比如订单单据、销售单等。属于上面提到的【领域】中的一种 【主体】：用户、部门、角色等。 【条件规则】：用于检索数据的条件定义 【数据规则】：用于【数据权限】的条件规则\n【资源】 - 【主体】 - 【数据规则】\n这个方案至少需要2张表，一个是 【资源，主体，规则关系表】、一个是【数据规则表】\n=================================================wota5037的博客================================ tableName：字段等级表字段等级表 记录被控制表中的权限等级\n需求：\r基于表名、字段进行\r1）、清洗条目\r2）、字段脱敏\r用户 维度\r角色/标签 维度\r需求：\r不控制（公开）：\r所有人可看\r控制：\r1、部分人完全可看：\r2、部分人部分可看：\r1、不给某个 用户 返回 某表 的某些 条目\r2、不给某个 用户 返回 某表 的某些 字段 的部分内容\r3、不给某个 角色/标签 返回某表的某些条目\r4、不给某个 角色/标签 返回某表的某些字段的部分内容\r5、显示无权限访问数据，全部用“*”代替\r3、部分人不可看（指定人不可看）：\r"},{"id":68,"href":"/Tech/10Miscellaneous/Markdown/","title":"Markdown","parent":"10、Miscellaneous","content":" 这是标题、 这是二级标题、 这是三级标题 这是三级标题 这是三级标题 这是三级标题 引用\n嵌套引用\n三嵌套引用\n四嵌套引用\n这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 这是换行\n- - 2. 1. GitHub\n自动生成连接 http://www.github.com/\n//代码块 E = mc^2 表格：\nheader1 header2 row1col1 row1col2 row2col1 row2col2 在这里插入 HTML 内容\n目前支持的 HTML 元素有： 等 ，如：\n使用 Ctrl+Alt+Del 重启电脑\n制作待办事项 To-do Lis\n待办事项 待办事项 待办事项 待办事项 绘制：流程图、序列图、甘特图、表格\n逻辑示意图类型 流程图 graph TD;\rA--\u0026gt;B;\rA--\u0026gt;C;\rB--\u0026gt;D;\rC--\u0026gt;D; 序列图 sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u0026gt;\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail!\rJohn--\u0026gt;\u0026gt;Alice: Great!\rJohn-\u0026gt;\u0026gt;Bob: How about you?\rBob--\u0026gt;\u0026gt;John: Jolly good! 甘特图 gantt\rdateFormat YYYY-MM-DD\rtitle Adding GANTT diagram to mermaid\rexcludes weekdays 2014-01-10\rsection A section\rCompleted task :done, des1, 2014-01-06,2014-01-08\rActive task :active, des2, 2014-01-09, 3d\rFuture task : des3, after des2, 5d\rFuture task2 : des4, after des3, 5d 类图 classDiagram\rClass01 \u0026lt;|-- AveryLongClass : Cool\rClass03 *-- Class04\rClass05 o-- Class06\rClass07 .. Class08\rClass09 --\u0026gt; C2 : Where am i?\rClass09 --* C3\rClass09 --|\u0026gt; Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rClass08 \u0026lt;--\u0026gt; C2: Cool label Git - 实验性 gitGraph:\roptions\r{\r\u0026#34;nodeSpacing\u0026#34;: 150,\r\u0026#34;nodeRadius\u0026#34;: 10\r}\rend\rcommit\rbranch newbranch\rcheckout newbranch\rcommit\rcommit\rcheckout master\rcommit\rcommit\rmerge newbranch 饼图（或圆形图） pie\rtitle Key elements in Product X\r\u0026#34;Calcium\u0026#34; : 42.96\r\u0026#34;Potassium\u0026#34; : 50.05\r\u0026#34;Magnesium\u0026#34; : 10.01\r\u0026#34;Iron\u0026#34; : 5 @startuml\rstart\rif (Graphviz 已安装?) then (yes)\r:处理所有\\n绘制任务;\relse (no)\r:仅处理\r__时序图__ 和 __活动__ 图;\rendif\rstop\r@enduml "},{"id":69,"href":"/Tech/10Miscellaneous/Markdown_PlantUML/","title":"Markdown Plant Uml","parent":"10、Miscellaneous","content":"Markdown_PlantUML\n绘制：流程图、序列图、甘特图、表格 逻辑示意图类型 流程图 graph TD;\rA--\u0026gt;B;\rA--\u0026gt;C;\rB--\u0026gt;D;\rC--\u0026gt;D; 序列图 sequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u0026gt;\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail!\rJohn--\u0026gt;\u0026gt;Alice: Great!\rJohn-\u0026gt;\u0026gt;Bob: How about you?\rBob--\u0026gt;\u0026gt;John: Jolly good! 甘特图 gantt\rdateFormat YYYY-MM-DD\rtitle Adding GANTT diagram to mermaid\rexcludes weekdays 2014-01-10\rsection A section\rCompleted task :done, des1, 2014-01-06,2014-01-08\rActive task :active, des2, 2014-01-09, 3d\rFuture task : des3, after des2, 5d\rFuture task2 : des4, after des3, 5d 类图 classDiagram\rClass01 \u0026lt;|-- AveryLongClass : Cool\rClass03 *-- Class04\rClass05 o-- Class06\rClass07 .. Class08\rClass09 --\u0026gt; C2 : Where am i?\rClass09 --* C3\rClass09 --|\u0026gt; Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rClass08 \u0026lt;--\u0026gt; C2: Cool label Git - 实验性 gitGraph:\roptions\r{\r\u0026#34;nodeSpacing\u0026#34;: 150,\r\u0026#34;nodeRadius\u0026#34;: 10\r}\rend\rcommit\rbranch newbranch\rcheckout newbranch\rcommit\rcommit\rcheckout master\rcommit\rcommit\rmerge newbranch 饼图（或圆形图） pie\rtitle Key elements in Product X\r\u0026#34;Calcium\u0026#34; : 42.96\r\u0026#34;Potassium\u0026#34; : 50.05\r\u0026#34;Magnesium\u0026#34; : 10.01\r\u0026#34;Iron\u0026#34; : 5 @startuml\rstart\rif (Graphviz 已安装?) then (yes)\r:处理所有\\n绘制任务;\relse (no)\r:仅处理\r__时序图__ 和 __活动__ 图;\rendif\rstop\r@enduml "},{"id":70,"href":"/Tech/10Miscellaneous/mdBook/","title":"Md Book","parent":"10、Miscellaneous","content":"初始化图书\n.\\mdbook.exe init D:\\Projects\\GitHubProjects\\Sleepless-tonight.github.io\\my-first-book\n..\\mdbook.exe serve \u0026ndash;open\n.\\mdbook.exe init D:\\Projects\\GitHubProjects\\Sleepless-tonight.github.io\\templates\n.\\mdbook.exe build path/to/book .\\mdbook.exe build -d D:\\Projects\\GitHubProjects\\Sleepless-tonight.github.io\\templates\n"},{"id":71,"href":"/Tech/10Miscellaneous/Toolkit/1-%E8%BD%AF%E4%BB%B6/","title":"1 软件","parent":"Toolkit","content":" 1、软件 1.1、文件 1.1.1、 BitTorrent Sync Resilio Sync（前身为BitTorrent Sync） 是一款免费的文件同步软件！它不需第三方服务器即可让多台电脑之间直接互相同步和共享文件，而且全程AES加密。它采用基于类似BT下载的P2P分布式技术而来，速度快而且可通过密钥文件共享\n1.1.2、 Syncthing Syncthing 是一个免费开源的工具，它能在你的各个网络计算机间同步文件 / 文件夹，它的同步数据是直接从一个系统中直接传输到另一个系统的，并且它是安全且私密的。\n1.1.3、 CertUtil Certutil.exe是作为证书服务的一部分安装的命令行程序。 可以使用certutil.exe转储和显示证书颁发机构 (CA) 配置信息、配置证书服务、备份和还原 CA 组件，以及验证证书、密钥对和证书链。\nCertUtil -hashfile C:\\xxx.tar MD5\r1、 此命令不仅可以做MD5哈希算法校验，还支持其他的哈希算法，具体如下：\r2、 CertUtil -hashfile 文件路径 [算法]\r3、 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512 1.1.4、 Files Files 是 Windows 平台的第三方文件管理器，功能强大、设计优美且直观，包含多标签、窗格、文件预览、shell 扩展、云文件集成等功能。\n1.1.5、 Calibre 功能强大的开源电子书工具\n1.1.6、 FFmpeg FFmpeg 是领先的多媒体框架，能够解码、编码、转码、混合、解密、流媒体、过滤和播放人类和机器创造的几乎所有东西。它支持最晦涩的古老格式，直到最尖端的格式。\n1.1.7、Czkawka 是一个简单，快速和免费的应用程序，用于从计算机中删除不必要的文件。 可供使用： 重复项 - 根据文件名、大小或哈希查找重复项 空文件夹 - 借助高级算法查找空文件夹 大文件 - 查找给定位置中最大文件的提供数量 空文件 - 在驱动器中查找空文件 临时文件 - 查找临时文件 相似的图像 - 查找不完全相同的图像（不同的分辨率，水印） 相似的视频 - 寻找视觉上相似的视频 相同的音乐 - 搜索具有相同艺术家，专辑等的音乐。\n1.1.8、Bacula Bacula 是一套开源的计算机备份系统，允许系统管理员在不同种类的计算机网络中管理计算机数据的备份、恢复和验证。\n1.1.9、ShareX ShareX 是一款免费的开源程序,不仅可以截图,还可以录屏,自动添加水印和阴影,除此之外,还有很多很多,比如OCR识别、屏幕录制、颜色拾取、哈希检查、修改DNS、尺子功能、显示器测试等\n1.1.10、 Stellarium Stellarium 是一个免费开源的天文馆应用，它用 OpenGL 实时渲染逼真的天空，可用于 Linux/Unix、Windows 和 macOS。\n1.1.11、 GraalVM 高性能运行时，具有新的编译器优化，可加速 Java 应用程序性能并降低 本地和云中的基础结构成本\n1.1.12、 Rufus Rufus 是一个可以帮助格式化和创建可引导 USB 闪存盘的工具，它可以快速把 ISO 格式的系统镜像文件快速制作成可引导的 USB 启动安装盘，支持 Windows 或 Linux 启动。详情：https://rufus.ie/zh\n1.1.13、 Ventoy Ventoy 是一个制作可启动 U 盘的开源工具。详情：https://rufus.ie/zh\n1.2、开发 1.2.1、 Sublime Text Sublime Text 是一个文本编辑器，同时也是一个先进的代码编辑器\n1.2.2、 DBeaver 一种开源的数据库可视管理工具\n1.2.3、 ckeditor5 强大的富文本编辑器框架，具有模块化体系结构，现代化的集成和协作编辑等功能。\n1.2.4、 Atom Atom 是github专门为程序员推出的一个跨平台文本编辑器。。\n1.2.5、 Axure RP 是一款专业的快速原型设计工具。Axure（发音：Ack-sure）\n1.2.7、 Diagrams.net Diagrams.net 是一款简洁强大的在线绘图工具，也许读者朋友们没听过这个工具，但是可能很多都听过 draw.io，其实两个是同一个工具。draw.io 是以前的名字，在 2020 年逐渐修改为 Diagrams.net\n1.2.8、 pgAdmin pgAdmin 是 PostgreSQL 领先的开源图形化管理工具。\n1.2.9、 aria2 aria2是一款支持BT及磁力下载的免费软件\n1.2.10、 Alist 一款支持多种存储的目录文件列表程序，支持 web 浏览与 webdav，后端基于gin，前端使用react。\n1.2.11、 ArcherySQL Archery 定位于 SQL 审核查询平台，旨在提升 DBA 的工作效率，支持众多数据库的 SQL 上线和查询，同时支持丰富的 MySQL 运维管理功能，所有功能都兼容手机端操作。\n1.3、安全 1.3.1、 Radare2 是一款开放源代码的逆向工程平台，它的强大超越你的想象，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，并且可以运行在几乎所有主流的平台（GNU/Linux, .Windows *BSD, iOS, OSX, Solaris…）上。\n1.3.2、 Wireshark Wireshark 是世界上最流行的网络协议分析器。它被用于故障排除、分析、开发和教育。\n1.3.3、 binwalk 扫描能够智能的发现目标文件中包含的所有可识别的文件类型。\n1.4、文件系统 1.4.1、 SeaweedFS 分布式文件系统\n1.4.2、 BTRFS （通常念成Butter FS），由Oracle于2007年宣布并进行中的COW(copy-on-write式)文件系统。目标是取代Linuxext3文件系统，改善ext3的限制，特别是单一文件大小的限制，总文件系统大小限制以及加入文件校验和特性。加入ext3/4未支持的一些功能，例如可写的磁盘快照(snapshots)，以及支持递归的快照(snapshots of snapshots)，内建磁盘阵列（RAID）支持，支持子卷(Subvolumes)的概念，允许在线调整文件系统大小。！\n1.4.3、OpenZFS OpenZFS（原名 ZFS）是 Linux、FreeBSD 与 macOS 平台上的文件系统。\n1.4.5、EROFS文件系统 EROFS文件系统（英文名：Enhanced Read-Only File System）是一个Linux操作系统下的只读文件系统，用来在保证嵌入式设备端到端的性能下节省存储空间，尤其是Android设备。相比其他通用文件系统，它使用了减少元数据的设计，并且提供透明压缩技术给目标文件系统用户。\n1.4.6、Alipine Linux Alpine Linux是一个面向安全应用的轻量级Linux发行版。它采用了musl libc和busybox以减小系统的体积和运行时资源消耗,同时还提供了自己的包管理工具apk。\n1.5、设计 1.5.1、 UI设计常用软件：Sketch、XD、Figma、MasterGo、Pixso、即时设计 "},{"id":72,"href":"/Tech/10Miscellaneous/Toolkit/2-%E7%BB%84%E4%BB%B6/","title":"2 组件","parent":"Toolkit","content":" 2、组件 更接近 jar 的工具类\n2.1、Hugo Go 编写的静态网站生成器\n2.2、Ghost Ghost 是一个开源建站平台，可以使用它创建自己的网站，有点类似于 WordPress 。案\n2.3、Spring-Analysis 这是一个围绕 springframework 进行源码分析的项目。\n2.4、JobRunr Java的分布式作业调度程序。\n2.5、平行图分析（PGX） PGX 是用于图形分析的工具包，它支持高效的图形算法和快速的类似于SQL的图形模式匹配查询。\n2.6、WorldWind Java NASA开发的用于桌面Java的3D虚拟地球API。提供具有高分辨率地形的地理环境，用于以3D和2D可视化地理或地理位置信息。开发人员可以自定义地球的地形和图像。提供一组形状，以显示和与地理数据进行交互并表示一系列几何对象。\n2.7、Nacos Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。\n2.8、Copilot GitHub原生AI代码生成工具 Copilot\n2.9、Apache Guacamole Apache Guacamole 是一个无客户端的远程桌面网关。它支持标准协议，如 VNC、RDP 和 SSH。之所以称它为无客户端，因为它不需要插件或客户端软件。由于 HTML5 的存在，一旦 Guacamole 被安装在服务器上，你只需要一个网络浏览器就能访问你的桌面。\n2.10、Apache Flink Apache Flink 是高效和分布式的通用数据处理平台，是一个流批一体分析引擎。 Apache Flink 声明式的数据分析开源系统，结合了分布式 MapReduce 类平台的高效，灵活的编程和扩展性。同时在并行数据库发现查询优化方案\n2.11、C4-PlantUML 2.12、Linux Lab 是一套用于 Linux 内核学习、开发和测试的即时实验室，可以极速搭建和使用，功能强大，用法简单！\n2.13、Canal Canal 是一款基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库 Binlog 的方式，这样可以从底层知道是哪些数据做了修改。\n2.14、Grafana Grafana 是一个可视化工具，简单点说就是用来展示数据的。它和Zabbix、Prometheus 有本质区别，在于它不能解决监控问题，仅用于展示。也就是说，在监控领域，Grafana 需要配合 Zabbix、Prometheus 等工具一起使用，以获取数据源。\n2.15、ClickHouse ClickHouse出现了，它是俄罗斯的 Yandex 公司于 2016 年开源的列式存储数据库，使用 C++ 语言编写，专门用于 OLAP（联机分析处理），惊人的性能.\n2.16、BusyBox BusyBox 是一个集成了三百多个最常用Linux命令和工具的软件。BusyBox 包含了一些简单的工具，例如ls、cat和echo等等，还包含了一些更大、更复杂的工具，例grep、find、mount以及telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀。简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令，也包含了 Linux 系统的自带的shell。\n2.17、Redisson Redisson 这是一个 Java 编写的 Redis 客户端，具备驻内存数据网格（In-Memory Data Grid）功能，并获得了 Redis 的官方推荐。\n2.18、SystemTap SystemTap 是监控和跟踪运行中的Linux 内核的操作的动态方法。这句话的关键词是动态，因为SystemTap 没有使用工具构建一个特殊的内核，而是允许您在运行时动态地安装该工具。systemtap 是一个用于简化linux系统运行形态信息收集的开源工具。它立足于性能诊断和bug调试，消除了开发人员在收集数据时需要经历的繁琐和破坏性的工具、重新编译、安装和重新引导的过程。\n"},{"id":73,"href":"/Tech/10Miscellaneous/Toolkit/3-%E6%8A%80%E6%9C%AF/","title":"3 技术","parent":"Toolkit","content":" 3、技术 技术关键字\n3.1、网络 3.1.1、 内网穿透目前主要由 ngrok 和 frp 两种，都非常好用，国内 ngrok 免费的有 ittun、sunny 和 natapp，这三个都是免费的，前面两个可以自定义域名，后面的需要 vip 版本才可以自定义域名。 3.1.2、 使用 Excelsior JET编译java程序为.exe程序 3.1.3、 约束传播与搜索 constraint propagation and search "},{"id":74,"href":"/Tech/10Miscellaneous/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/","title":"个人知识管理","parent":"10、Miscellaneous","content":" 个人知识管理（Personal Knowledge Management） 个人知识管理（Personal Knowledge Management）的概念一般指个人通过工具建立知识体系并不断完善，进行知识的收集、消化吸收和创新的过程。\n一、学习知识 （知识来源） 知识和信息不能混为一谈，信息是免费的，但毫无目标的获取信息，就无法将信息转化为知识。因此学习必须要有目标，如果你用有限的时间去学无限的知识，你将被知识“淹没”，我们要学习那些给自己带来最大提升的知识。\n时间是一个最稀缺的资源，在学习知识的过程中，必须考虑知识获取的“成本”问题，这个成本除了金钱之外，最重要的是时间成本。因此，学习知识的工具需要满足：“花费时间较短，获得价值较高的知识”。\n二、保存知识（知识保存） 保存知识的目的是为了在使用的时候能够最快速和准确地查询到相关内容。\n三、共享知识（寻找道友） 知识共享和传播，是为了让别人知道你知道的知识，并得到信息的反馈，为什么要分享，不在于你认识什么人，而在于什么人认识你，不在于什么人影响了你，而在于你影响了什么人。因此要添加一些高质量的好友，订阅其分享内容，多争取对方的关注。\n四、使用知识（分类归纳终结查询知识） 知识的收集和积累之后，最重要的还是如何利用这些知识资料。\n个人信息管理器（通常称为PIM 工具，或者更简单地说，是 PIM）是一种作为个人组织者的应用程序软件。缩写PIM现在更常用于个人信息管理作为研究领域。 作为信息管理工具，PIM 工具的目的是便于记录、跟踪和管理某些类型的\u0026#34;个人信息\u0026#34;。\r个人信息可以包括以下任何信息：\r通讯录\r警报\r日历日期，例如：\r纪念日\r约会\r生日\r事件\r会议\r教育记录\r电子邮件地址\r传真通讯\r行程\r即时消息存档\r法律文件\r列表（如阅读列表、任务列表）)\r医疗信息，如医疗保健提供者联系信息、病史、处方\r密码和登录凭据\r个人文件收藏（数字和物理）：文档、音乐、照片、视频和类似\r个人日记/日记/备忘录/笔记\r项目管理功能\r食谱\r参考材料（包括科学参考，感兴趣的网站）\rRSS/原子源\r提醒\r语音信箱通信 日历\r日历软件\r信息管理\r密码管理器\r个人信息管理\r个人知识库\r个人维基 个人知识管理（PKM）是收集信息的过程，一个人用于收集、分类、存储、搜索、检索和分享日常活动中的知识（2007 年格兰德斯彭基斯）以及这些流程支持工作活动的方式（Wright 2005）。这是对知识工作者需要对自己成长和学习负责的想法的回应（Smedley 2009）。这是一种自下而上的知识管理方法（KM）（波拉德2008年）。 时间和任务管理\r个人层面的时间管理和任务管理都大量使用信息工具和外部信息形式，如要执行列表、日历、时间线和电子邮件交换。这些是另一种要管理的信息形式。多年来，电子邮件，特别是，已以临时的方式用于支持任务管理 内容管理（CM）是一组支持以任何形式或媒介收集、管理和发布信息的流程和技术。当通过计算机存储和访问时，这些信息可能更具体地称为数字内容，或简单地称为内容。\r数字内容可以采取文本（如电子文档）、图像、多媒体文件（如音频或视频文件）或任何其他文件类型的形式，这些文件类型遵循需要管理的内容生命周期。\r这个过程非常复杂，足以管理一些大小商业软件供应商，如Interwoven和微软提供内容管理软件，以控制和自动化内容生命周期的重要方面。 知识分类标签： "},{"id":75,"href":"/Tech/10Miscellaneous/%E5%AD%A6%E4%B9%A0And%E8%B5%84%E6%96%99/","title":"学习 And资料","parent":"10、Miscellaneous","content":"时间：2019年3月4日10:29:43\n学习：\n英语、 数学之美、 Spring Cloud、 去B站看完：计算机科学速成课、 系统的计算机科学（所有九个主题，大致按照呈现的顺序，但理想情况下两者。瞄准每个主题100-200小时的学习，在整个职业生涯中重新访问收藏夹。）：https://teachyourselfcs.com/#math、 南京大学 计算机科学与技术系 计算机系统基础 ：https://nju-ics.gitbooks.io/ics2018-programming-assignment/content/、 清华大学计算机系课程攻略：https://github.com/Trinkle23897/THU-CST-Cracker 中国科学技术大学计算机学院课程资源：https://github.com/mbinary/USTC-CS-Courses-Resource 所有算法都用Java实现：https://github.com/TheAlgorithms/Java、 用Java实现的设计模式：https://github.com/iluwatar/java-design-patterns 低级别的编程语言：https://github.com/gurugio/lowlevelprogramming-university 资料：\n带视频讲座的计算机科学课程清单：https://github.com/Developer-Y/cs-video-courses 精选的Java框架，库和软件的精选列表：https://github.com/akullpp/awesome-java 技术面试必备基础知识 ：https://github.com/CyC2018/CS-Notes 计算机学科基础知识和主流编程语言相关内容的总结：https://github.com/xuelangZF/CS_Offer 免费的编程中文书籍索引：https://github.com/justjavac/free-programming-books-zh_CN x86架构操作系统内核的实现 http://wiki.0xffffff.org/posts/hurlex-1.html\n虚拟内存探究，深入理解进程地址空间 http://blog.coderhuo.tech/2017/10/19/Virtual_Memory_summary/\n南京大学 计算机科学与技术系 计算机系统基础 课程实验 2019 https://nju-projectn.github.io/ics-pa-gitbook/ics2019/\n"},{"id":76,"href":"/Tech/10Miscellaneous/%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/","title":"批处理操作指南","parent":"10、Miscellaneous","content":"批处理操作指南\n批处理原则\n在构建批处理解决方案时，应考虑以下关键原则和注意事项。 批处理体系结构通常会影响体系结构 尽可能简化并避免在单批应用程序中构建复杂的逻辑结构 保持数据的处理和存储在物理上靠得很近（换句话说，将数据保存在处理过程中）。 最大限度地减少系统资源的使用，尤其是I / O. 在internal memory中执行尽可能多的操作。 查看应用程序I / O（分析SQL语句）以确保避免不必要的物理I / O. 特别是，需要寻找以下四个常见缺陷： 当数据可以被读取一次并缓存或保存在工作存储中时，读取每个事务的数据。 重新读取先前在同一事务中读取数据的事务的数据。 导致不必要的表或索引扫描。 未在SQL语句的WHERE子句中指定键值。 在批处理运行中不要做两次一样的事情。例如，如果需要数据汇总以用于报告目的，则应该（如果可能）在最初处理数据时递增存储的总计，因此您的报告应用程序不必重新处理相同的数据。 在批处理应用程序开始时分配足够的内存，以避免在此过程中进行耗时的重新分配。 总是假设数据完整性最差。插入适当的检查和记录验证以维护数据完整性。 尽可能实施校验和以进行内部验证。例如，对于一个文件里的数据应该有一个数据条数纪录，告诉文件中的记录总数以及关键字段的汇总。 在具有真实数据量的类似生产环境中尽早计划和执行压力测试。 在大批量系统中，数据备份可能具有挑战性，特别是如果系统以24-7在线的情况运行。数据库备份通常在在线设计中得到很好的处理，但文件备份应该被视为同样重要。如果系统依赖于文件，则文件备份过程不仅应该到位并记录在案，还应定期进行测试。 "},{"id":77,"href":"/Tech/10Miscellaneous/%E6%8B%89%E5%8D%95%E6%A8%A1%E5%9D%97%E4%B8%9A%E5%8A%A1%E8%AF%B4%E6%98%8E/","title":"拉单模块业务说明","parent":"10、Miscellaneous","content":" 简介 我其实一直想给大家做些分享，但是觉得自己技术太菜了，一直不好意思，最近觉得还是做一个经验分享，不算技术分享。\n今天分享的整体氛围是轻松，不要严肃，\r我从18年来公司，就一直是在搞API拉单，也有一些经验之谈，这个项目我大大小小零星算是不完善的重构三四次，主要目的是在业务的扩展中保持代码的可维护性和可扩展性，拒绝堆屎山了，拒绝“能跑就行”，但是维护成本越来越高。\r我了解项目的主要几个阶段： 1.0 是了解 API拉单 是个什么东西，没问题的跑起来。 1.2 是将项目改成了 redis 为核心，丢掉分布式任务管理、分布式节点管理 跑起来。 1.3 是将项目成为大益源子的一个服务，升级技术栈（比如原先是Java 1.7 和各种古老的 jar），以MQ为核心。 1.4 对API部分抽象 结果是新对接API变的简单，已对接平台升级和新对接API变的简单 1.5 对业务进行抽象 将类似的业务聚合，抽象，干掉冗余代码，\n前3次是为了项目能用，后2次是为了项目能好用\r为什么要做后两次，1、个人追求；2、作为一个工程师，要满足工程师的要求，（工程师：权衡需求和资源，给出专业可行方案）之前的，有太多不专业的地方。\n分享的目标：\n1、讲解 API拉单模块的基本概念、基础信息、基本流程的逻辑关系和实现\r2、讲解 API拉单模块的功能、实现、演化和问题（这个 拉单模块 是怎么一步一步成为现在这样的。）\r功能：\r正向订单拉单、售前退款单拉单、售后退货退款单拉单、售后仅退款单拉单、售后换货单拉单、发货、已发货订单修改物流、AG-取消发货、AG-退货入仓、正向订单修改地址、解密、锁单、SKU查询、其它订单查询（修改地址的订单列表、服务单列表）、部分其它模块对平台的 API 对接承接。\r基本概念： API 拉单模块: 假如大益源子是个城市，API 拉单模块，就是这个城市修建的高速路，是石油管道，是比较基础的需求，通过对电商平台开放API的对接，沟通电商平台和大益源子，实现各种功能，比如从平台拉取订单信息，向平台同步订单的发货物流信息。\n平台、\r各大电商平台和自建商城\r店铺、\r开在各大电商平台和自建商城上的店铺\r基本业务功能说明、\t3.1、拉单\r从平台拉取订单信息\r3.2、发货\r向平台同步订单的发货物流信息\r3.3、售后单\r从平台拉取售后单信息\r包含：售前退款单拉单、售后退货退款单拉单、售后退款单拉单、售后换货单拉单\r3.4、AG（取消发货、退货入仓）\r自助售后服务\r3.5、正向订单自助修改地址、\r未发货的订单买家自助修改地址\r3.6、订单改配\r已发货订单向平台修改发货的物流信息\r3.7、RDS、API 反向代理\r入云必须\r3.8、加解密\r订单的敏感信息加密、解密、加密字段搜索\r3.9、验签基本过程\r防止中途篡改\r3.10、异常、重试、监控、报警\r因为整个 API 拉单模块几乎都是自动化的定时任务，而且很多都是异步任务，需要监控 定时任务：\r通过定时任务，自动的从平台的订单列表中拉取订单\r为了分布式的高效的拉取订单，将任务分成了4个阶段，由不同的节点去消费执行：\r1、Create\r根据 店铺配置，创建一个：从某个时间查询区间的 不同业务的 任务\r2、Count\r根据 Create 创建的 某个店铺的 某个业务的 某个时间区间的 任务，去平台查询此时间区间的订单数量，并根据订单数量去分页去创建 Down 任务\r3、Down\r获得订单列表\r4、Info\r根据订单列表获得每个订单详情，并处理加工订单\r基本概念：串联起来就是：API拉单基本的功能就是：通过定时任务，去各大平台，查询某个时间区间的某个订单列表。（相同业务不同平台分别实现）。\r一、首先列出需求，需求约束这个项目要怎么写： 1、抓单业务： 1、基于店铺定时抓不同类型单（正向、售前、售后） 2、不同店铺不同抓单频率 3、异常任务归档、重试 4、区间补单 4.1、不指定店铺时，批量店铺时间区间补单 4.2、不指定类型时，所有类型补单 4.3、区间补单不影响定时抓单时间更新 5、指定单号补单 6、定时任务记录 7、异常需关联任务、统计和处理 7.1、异常处理： 7.1.1、自动重试 7.1.2、手动重试 7.1.3、手动关闭异常，不再重试\n8、抓单时间防止反向更新（抓单任务创建时更新店铺时间时只可扩大，不可缩小，不可反向。重新抓单需修改店铺）\r9、已经生成的执行中的任务不受后续店铺变更影响，比如已经生成店铺抓单任务，生成任务后更改了店铺配置，关闭了店铺，不中途立刻中断任务。\r10、对任务数量、店铺抓取中订单数量数量统计：\r11、每页事务隔离（Count 任务获得订单数量后，每页创建一个 Down）\r12、按单解析事务隔离、按单发送事务隔离\r13、支持 has_next 分页设置\r由于获取三个月内的订单接口是用创建时间过滤的，而创建时间是不可变的，所以从前往后翻页也不会导致漏单，因而可以省掉第一步的count(*)，而直接采用入参use_has_next=true的方式分页获取，直到返回结果中has_next=false时终止翻页。\r由于获取增量订单接口是用修改时间过滤的，而修改时间是可变的，所以需要从后往前翻页才能避免漏单。从后往前翻页必须要知道最后一页，所以必须在首次API请求时采用use_has_next=false方式统计订单总数，计算出总页数，然后再设置use_has_next=true终止订单统计，从后往前翻页。\r14、支持延迟时间抓单设置和重复时间抓单设置\r15、全量增量自动切换\r16、指定批量抓单时全量增量\r17、发货同步级别控制\r18、发货屏蔽\r无需发货的屏蔽\r1、不同步到平台的物流编码\r2、不同步到平台的商品\r1、原始单中不包含的商品：组合商品的拆分子商品、赠品\r相同请求的屏蔽\r不满足发货条件的屏蔽\r19、发货处理 赠品、组合商品、其它订单中无的商品\r20、支持配置即发即通知、某单全发后通知、合单全发后通知\r21、对可预期的固定值做枚举（平台订单状态、API订单状态、快递类型）\r2、API 需求：\rAPI 管理、配置、验签过程：\r快速的API对接：\r快速的API返回对象扭转\rAPI监控：\rAPI测试：\rAPI重试：\r令牌管理：\r流量监控：借债机制、滑动窗口算法\rAPI 授权：是否自动延长授权\r二、服务 基础服务： redis服务： 1、发货防并发平台订单号记录 2、发货结果记录 订单级 商品级 商品数量级 3、相同请求屏蔽 MQ服务： 承载、分发任务 API服务： 店铺配置服务： 任务服务： 异常服务： 查询订单数量服务： 查询订单列表服务： 查询订单详情服务： 订单字段解密服务： 店铺平台权限服务： 查询商品SKU服务： 查询卖家地址库服务： 同步发货服务： 同步AG服务：\n订单数量API服务：\r店铺累计抓取订单数量：\r店铺抓取中数量统计：\rCount 任务添加\rDown 任务减少\r形成一个 任务ID 和数量变化的表\r源子三方服务：\r店铺服务：\r三方售后服务：\r发货配置服务：\r灰名单配置服务：\rAG配置服务：\r订单中心服务：\r订单发货状态：\r日志服务：\r通知服务：\r邮件、\r短信、\r禅道、\r站内信、\r三、工具 JsonPath、 JsonConverter、 获取指定节点内容 Json 异构映射： 不同 Json 通过配置的 字段关系 映射为指定对象 HttpClientUtils、 代理、 URL加工、 请求参数检验、 请求参数封装、 网络异常自动重试、 异常指数退避、\n四、实体 ↓↓↓↓↓↓↓↓↓↓见下面【实体】↓↓↓↓↓↓↓↓↓↓\n三种： API、基于服务、店铺配置\n首先先做一个分类： 整个拉单项目分为三类实体： 1、店铺及业务实现配置实体 2、批量任务 流程、配置、处理实体 3、平台 API 接口的相关对象的 本地实体、及相关枚举、及相关验证处理对象\n重构抓单流程所需配置： 全量 增量 历史最大时间跨度 单次时间最大跨度 单页数量 是否需抓详情 是否解密 是否需补售后单/交易单 是否需推平台收货信息\n发货配置： 同步级别控制 1、订单级 2、商品级 3、商品数量级\n基于店铺创建 获得数量 获得列表 获得详情\n基础需求： 业务逻辑： 1、定时抓交易单、 2、定时抓 换货、退货退款单、 2.1、不指定售后单类型补单、 3、发货、 3.1、发货补偿抓取交易单 4、售后订单信息推送、 5、买家收货信息推送、\n总共分几个部分： core： 全局（全局性的配置） 平台全局变量： XMLConfig： 业务类型： 拉取 Pull、 批量： 全量、 交易单、 增量、 交易单、 退货退款单、 换货单、 单条： 详情、 MQ、 订单、 推送 Push、 平台： 取消订单、 取消发货、 发货信息、 同意退货、 OMS: 交易单中心、 业务阶段： Create、 Count、 Down、 Detail、 routingKey： [平台][拉取][批量][增量][订单]_[业务阶段] 异常体系Exception： 目的：对基础异常进行封装，进行相应处理\n组件（组件提供功能支持）\rMQ、\rRedis、\rMySQL、\rMongoDB、\rHttpClientUtils、\rJsonConverter、\rRequestEntityAssemble、\rURLProcessFun、\rResponseErrors、\rbusiness：\r业务（由业务逻辑代码和多个不同组件配合完成业务）：\r说明及注意：\r拉取任务：由定时任务开启，消息触发完成整个业务。\r同步任务：全程由消息触发。\r拉取单条：虽然不是业务，但也抽象出接口\r注意：对于业务来说接口的抽象及实现应该先一步基于业务。\r接口及抽象分层：\r[拉取]_[Create]\r[拉取]_[全量]_[Create]\r[拉取]_[全量]_[订单]_[Create] [拉取]_[增量]_[Create]\r[拉取]_[增量]_[订单]_[Create] [拉取]_[增量]_[退货退款单]_[Create]\r[拉取]_[增量]_[换货单]_[Create]\r实体： 1、字典项： 1、拉单平台 2、参数类型 1、基础参数 2、业务参数 3、业务 正向订单拉单、售前退款单拉单、售后退货退款单拉单、售后退款单拉单、售后换货单拉单、发货、已发货订单修改物流、AG-取消发货、AG-退货入仓、正向订单修改地址、解密、锁单、SKU查询、其它订单查询（修改地址的订单列表、服务单列表）、验签、\n2、参数key表：\r参数名称\r参数类型\r是否启用\r是否必传\r默认值\r是否删除\r1、现阶段常用 基础参数\r外部名称、\r外部店铺ID、\rkey1、\rkey2、\rkey3、\rkey4、\rkey5、\rkey6、\rAPI配置平台、\r店铺是否开启 on：允许，off：不允许、\r是否删除：1 表示删除，0 表示未删除、\r附加信息、\r版本、\r时间戳、\r2、现阶段常用 业务参数\r业务是否开启 on：允许，off：不允许、\r3、店铺-业务-参数 value 表：\r店铺id\r业务id\r参数id\r参数名称\r参数value\r是否启用\r是否删除\r店铺API配置：\rID、\r店铺ID、\r店铺名称、\r外部名称、\r外部店铺ID、\rkey1、\rkey2、\rkey3、\rkey4、\rkey5、\rkey6、\rAPI配置平台、\r店铺是否开启 on：允许，off：不允许、\r是否删除：1 表示删除，0 表示未删除、\r附加信息、\r版本、\r时间戳、\r详情：\r店铺API配置ID：\r业务ID：1=交易单，2=退货退款单、3=换货单、4=自动补单\r业务类型：1=交易单，2=退货退款单、3=换货单、4=自动补单\r业务类型Name:交易单、退货退款单、换货单、自动补单\r是否开启业务：0关闭，1开启、\r业务参数：\r延迟抓单时间、\r重复抓单时间、\r抓单的结束时间、\r抓单频率、（越大频率越低，默认为0）\r店铺允许抓单的模式 0=RDS，1=API，2=MQ，可多选用英文逗号分隔：0,1,2、\r抓单状态、\r附加信息、\r版本、\r时间戳、\r是否删除：1 表示删除，0 表示未删除、\r备注：\r1、抓单频率 计算是否抓单：\r1、店铺很久没启动，启动后，定时任务 调度，立即通过\r2、定时任务短时间多次调用，需屏蔽，（区间补单需走 区间补单方法）\r2、自动补单 业务按开启的 其它业务类型创建多个任务。\r设计目标：\r1、灵活，可以很容易地启用或停用\r2、性能，不对正常的拉单业务操作造成影响\r3、开放，容易和第三方系统模块扩展整合\r发货信息实体：\r公司ID、\r公司名称\r店铺 ID、\r店铺 Name、\r发货创建ID、\r发货仓库Name、\r外部订单号、\rOMS订单号、\rOMS订单ID、\r发货时间、\r是否拆单、（是指发货时此 platOrderNo 有多个OMS 订单）\r是否合单、（是指发货时此 OMS订单 有多个 platOrderNo）\r是否发货完成、（是指发货时此 platOrderNo 有多个OMS 订单，最后一个发货的 OMS订单）\r快递ID、\r快递类别、\r快递名称、\r外部订单号、\r外部子订单号、\r平台商品ID、\r商品SKU、\r父级商品SKU、（通过此属性获得商品是否是组合商品）\r商品数量、\r包裹ID、\r快递运单号、\r备注：\r1、发货消息以 外部订单号 + OMS订单号 联合唯一，所以，一个外部订单可能有多个消息体，且因多包裹，会导致一消息体有多个 快递运单号。（一个 OMS订单号 使用一种快递，所以虽然多包裹产生多运单号，单不会多快递类型）\r2、OMS发货模块是按 OMS订单 以 外部订单号 group by 后分解为多个 消息体 调 发货 模块。\r发货_Return extends API_Return：\r开始时间、\r结束时间、\r请求URL、\r重试次数、\r成功信息、\r异常信息、（集合）\r发货结果、\r注意：一个订单因多包裹可产生多个发货尝试、每个发货尝试有1个发货结果。\r订单：\r商品：\r任务体：\r任务ID：\r上级任务ID：\r任务类型：\r交易单创建\r退款单创建\r换货单创建\r交易单Count\r退款单Count\r换货单Count\r交易单Down\r退款单Down\r换货单Down\r交易单Detail\r退款单Detail\r换货单Detail\r任务创建时间：\r任务接收/开始执行时间：\rAPI请求开始时间：\rAPI请求结束时间：\r任务结束时间：\r任务最大执行次数：\r任务执行次数：\r任务执行结果：\r请求参数：\r店铺ID、\r任务类型、\r状态、\r时间区间、\r页码、\r每页条数、\r返回参数集合：\r①、平台返回JSON、订单条数\r②、JSON部分字段、订单ID列表\r③、订单详情\r任务异常对象集合：\r订单处理：\r1、添加信息、\r2、扭转、\r3、翻译、\r4、解密、\rlog日志规范：\r店铺、\r业务_阶段、\r关键参数、\rException 异常类型及处理：\rAPI请求异常：\r异常标识生成异常类\r异常值生成异常类\r异常值且异常标识生成异常类\r枚举：（去除魔法值）\r平台类型、\r平台订单状态、退款单状态、\r平台支付方式、\rJSON格式化：\rXML格式化：\r存任务：\r取任务：\rAPI实体：\rAPI 异常的分类： RuntimeException 自动重试 包含： 各种服务异常、网络异常、运行产生的其它异常 可重试异常\t重试次数后 收录 不可重试异常\t直接收录\n基础工具util：\nJSON格式化：\rXML格式化：\rXML 及 json 格式化的工具类\n关于异常处理原则： 第一，能处理则进行处理和关心的异常，不能处理或不关心的异常则继续抛出。决不允许出现捕获异常但又不做任何处理或抛出操作，这样会丢失异常信息。 第二，异常抛出源需要在抛出异常之前将异常写入日志中。以备进行检查。 第三，业务逻辑层判断是否 RollBack 业务，，catch 异常后，如果需要回滚事务或业务 第四，finally 块必须对资源对象、流对象进行关闭，不要在 finally 块中使用 return。\n对 xxl-job 的代码分析及相应业务代码开发设计\n日志：\n1设计目标：\r1、灵活，可以很容易地启用或停用\r1、在灵活性方面，可以在配置文件config.properties或config.local.properties中指定选项来启用(true)或停用(false)，\r#是否启用系统监控模块中的功能 monitor.memory=true monitor.performance=true monitor.runing=true monitor.login=true monitor.index=true monitor.backup=true #是否启用业务日志记录功能 log.create=true log.delete=true log.update=true 2、性能，不对正常的业务操作造成影响\r在性能方面，使用内存缓冲区来临时存储日志对象，可以节省磁盘和网络开销，缓冲区的大小可以配置，当缓冲区满了或是人工强制执行的时候才会对日志进行持久化或其他处理，这样不但提高了吞吐量（批量提交、批量处理），而且对用户业务处理的影响非常小，因为产生日志对象之后只需要将日志对象加入缓冲区即可（无阻塞、内存操作）。除此之外，当对缓冲区中的日志对象进行持久化或其他处理的时候，会有独立的线程池中的线程来完成，不会阻塞用户业务处理线程（线程复用、异步非阻塞），\r3、开放，容易和第三方系统整合\r2、日志种类“\r1、业务日志：\r业务日志的要求：\r数据的增删改日志（方便任务重建）、\r失败任务记录（包含：任务参数、失败原因）、\r2、监控日志：\r监控日志的要求：\r用户请求响应时间、内存使用情况\r监控： 系统负载监控：Spring Boot Admin 用于监控基于 Spring Boot 的应用 任务监控： 执行任务数量、异常任务数量 节点监控：节点健康、节点任务饱和率、待执行任务-任务类型分布、待执行任务-任务状态分布、 异常任务监控：任务类型监控、任务原因分布\n返回的数据结果是以订单的 修改时间 倒序 排列的，通过从后往前翻页的方式可以避免漏单问题 asc 按升序排列 (不用写,默认使用这个) desc 按降序（倒序） 排列\n***************************************** 项目中的角色 *********************************** 1、业务 2、服务 3、平台 3.1、平台的信息 3.2、平台的处理 4、店铺 4.1、店铺的信息 4.2、店铺的处理 5、API 6、工具\n***************************************** 待确认信息 *********************************** 发货 需要支持配置即发即通知、全发后通知、合单全发后通知。\n例如淘宝平台是支持商品级发货信息同步， 如果配置了一个淘宝平台的店铺 全发后通知，那么发货时是按订单级发货信息同步处理，还是去OMS查询之前屏蔽的部分，继续以商品级发货信息分别同步 例如： 当 此店铺订单拆单发货时分 A、B两单，B单发货时此订单全发。 那么当A订单发货时屏蔽，B订单发货时是按整单发货，还是去OMS查询发货信息，然后分别发货。\n如果分别发货会有一个逻辑异常。A订单的运单号如果物流公司已经有了物流信息，同步会失败。\n基于 发货细粒度 设计发货结果缓存 key-value 发货细粒度：订单级、商品级、商品数量级\n订单级：每个订单只可同步一条物流单号 key：shopId + \u0026ldquo;:\u0026rdquo; + platOrderNo value:logisticNo + \u0026ldquo;:\u0026rdquo; + true/false\n商品级：每个订单下的每个商品只可同步一条物流单号 key：shopId + \u0026ldquo;:\u0026rdquo; + platOrderNo + \u0026ldquo;:\u0026rdquo; + sku value:logisticNo + \u0026ldquo;:\u0026rdquo; + true/false\n商品数量级：每个订单下的每个商品只可同步多条物流单号 key：shopId + \u0026ldquo;:\u0026rdquo; + platOrderNo + \u0026ldquo;:\u0026rdquo; + sku + \u0026ldquo;:\u0026rdquo; + logisticNo value:logisticNo + \u0026ldquo;:\u0026rdquo; goodsCount + \u0026ldquo;:\u0026rdquo; + true/false\n*************************************** ETL ********************************** ETL的设计分三部分：数据抽取、数据的清洗转换、数据的加载。抽取（extract）、转换（transform）、加载（load）至目的端的过程： 开源 1、Apache Camel\n不同的抽取方法： 1、MQ、 2、DB、 3、URL、\n一、数据的抽取（Extract） 注意：增量抽取更新数据\n二、数据的清洗转换（Cleaning、Transform） 1、映射转换、 2、SQL转换、················\t···\t···\t·····\n日志： 一类是执行过程（业务）日志： 一类是错误日志：\n消息转换： from(\u0026ldquo;amqp:queue:order\u0026rdquo;).process(new XmlToJsonProcessor()).to(\u0026ldquo;bean:orderHandler\u0026rdquo;);\n过滤： from(\u0026ldquo;amqp:queue:order\u0026rdquo;).filter(header(\u0026ldquo;foo\u0026rdquo;).isEqualTo(\u0026ldquo;bar\u0026rdquo;)).choice() .when(xpath(\u0026quot;/person/city = 'London'\u0026quot;)) .to(\u0026ldquo;file:target/messages/uk\u0026rdquo;) .otherwise() .to(\u0026ldquo;file:target/messages/others\u0026rdquo;);\n*************************************** Shepherd API网关项目 **********************************\nAPI网关是运行于外部请求与内部服务之间的一个流量入口，实现对外部请求的协议转换、鉴权、流控、参数校验、监控、告警、故障自愈、等通用功能。\n*************************************** WMS 项目 **********************************\n1、首先要有仓库库位管理系统： 比如要有：仓库、库区、货位，这些事对摆放商品的空间做的抽象 1.1仓库一般属性有：1、仓库类型（例：残损仓、三方仓、零售仓、虚拟仓）2、仓库的联系人、联系电话、仓库地址等仓库位置信息\n1.2库区属性与仓库类似：1库区类型（例：存货区、拣货区）2、库区编码、库区的联系人、联系电话、库区在仓库地址等库区位置信息 1.3货位同上，\n不同类型用于自动化处理，比如残损商品，入库会限制死路由到残损仓\n2、仓库作业 库内作业：补货、移位、入库、出库、借出、归还、盘点、 库间作业：调拨出库、调拨入库 其它：各种单据统计、各种维度数量统计、手持设备接入、一维码系统、库存报警\n订单服务需要提供： 1、包含此外部单号的OMS订单的所有已发货信息。 1、发货时间 2、是否拆单 3、是否合单 4、是否发货完成 2、此外部订单发货时是否位于不同OMS订单（判断拆单） 3、此外部订单发货时所在OMS订单是否有其它外部订单（判断合单） 4、此外部订单是否发货完成\n"},{"id":78,"href":"/Tech/10Miscellaneous/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","title":"文件管理","parent":"10、Miscellaneous","content":" 文件管理： 文件管理：\r图片、音频、视频、pdf、网页、文本\r1、目录标签化、\r2、文件类型标签化、\r3、文件属性标签化、\r4、查重\r5、给出保留建议\r6、文本文件关键字索引、全文搜索\r7、文本文件版本管理\r8、备份管理\r9、加密\r10、文件打开历史、文件夹打开历史、文件变动历史（例如 什么时间创建一个文件）\r11、文件编辑历史\r12、Archive、休闲娱乐、教程、电影、音乐、小说、\r13、标签云\r14、Data（数据）、Information（信息）、Knowledge（知识）\r15、序列、关键词、描述\r16、中国图书馆分类法、标签分类法、杜威十进制图书分类法\r17、我们把文件分成「工作、学习、生活、兴趣」四个大类、文档、图片、音乐、视频\r18、文件夹层级控制在了三层以内\r19、收藏夹和历史记录\r20、支持模糊搜索、过滤搜索结果\r21、Spotlight 全文检索功能，它能够自动索引 TXT、Word、Excel、PPT、PDF、EPUB 等文档里的内容\r22、知识图谱（Knowledge Graph）\r23、信息检索和推荐、相关性\r24、中文通用百科知识图谱（CN-DBpedia）\r25、ImageNet\r- 图片：\r1、每个目录随机抽取十几或几十张图缩小合并，形成一张比较直观的印象图。\r2、色调，tag，宽度什么的\r3、Image Comparer "},{"id":79,"href":"/Tech/10Miscellaneous/%E7%89%88%E6%9C%AC%E8%A7%A3%E9%87%8A2.0/","title":"版本解释2.0","parent":"10、Miscellaneous","content":"alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。\nbeta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。\nrc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。\nstable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。\n商业软件 RTM版：全称为Release to Manufacture。工厂版。改版程序已经固定，就差工厂包装、光盘印图案等工作了。\nOEM版：厂商定制版。\nEVAL版：评估版。就是有30或者60天等使用期限的版本。\nRTL版：Retail.(零售版)，这个版本就是真正发售的版本，有漂亮的包装、光盘、说明书等东西和高昂的价格。\n"},{"id":80,"href":"/Tech/10Miscellaneous/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83IDaas%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/","title":"用户中心 Idaas模块设计","parent":"10、Miscellaneous","content":" 用户中心IDaas模块设计 一、IDaaS Identity as a Service ，简称 IDaaS ，是一个基于身份的服务，它是一个认证、认可、访问、管理、统计、维护、管理等服务的集合。\nIDaaS ⾃适应⼆次认证、弱密码监测、账号⽣命周期管理、异常账号锁定等众多账号防护能⼒。\n提供 IP ⿊⽩名单防护、异常登录锁定、弱密码检测、图⽚验证码、僵⼫账号管理等能⼒，全⾯提⾼身份认证安全⽔位。与此同时，IDaaS 还提供了可视化的图表界⾯，直观展示安全⻛险。\n提⾼账户登录的安全性。IDaaS ⽀持 ⾃适应（设备、IP、静默（同一手机短时间多次）） 和 强制 两种⼆次认证类型。\n二、用户中心升级原因 对于自有账号体系的应用，都需要对接账号风控，平台建议用户接入淘系账号风控体系，使用淘系账号的应用将默认享有平台提供的账号风控能力，如使用自有账号体系的应用，应具备平台认可的应用身份服务（简称：IDAAS）能力，并开启二次认证等安全策略并回传日志到平台。\n三、两种升级方式主要工作 注意：无论是接入淘宝账户风控体系，还是自研对接御城河，都需要调整用户中心认证流程。\n3.1、调整认证流程 在修改密码、绑定手机、绑定邮箱、绑定身份证等认证流程时，需要调整认证流程，必须要时需添加二次认证校验。\n3.2、接入淘系账号风控体系 购买阿⾥云应⽤身份服务（IDaaS） 对接API，同步账户数据到淘系账号，由 IDaaS 进⾏统⼀认证。 idaas 数据将自动回流计算，无需isv/自研再对接御城河回流。 3.3、自研 对接API，应用需对接御城河 idaas 和二次认证接口回流数据。 四、调整认证所需工作 账户涉及二次认证新增属性（短信或MFA） 二次认证设置页 是否启用、启用模式、启用节点（登录、修改密码、手机、邮箱、身份证？）、启用（账户或组织）范围、认证类型（淘宝、自建） 二次认证方式（默认手机短信） 短信模板 验证码限制逻辑 验证码发送频率限制 同一验证码可以尝试 3 次输入，3 次均失败后，验证码失效。用户需要获取新验证码。 验证码有效期 二次认证弹窗页 当前认证手机号（中间遮掩） 获取验证码按钮（倒计时，防止重复点击） 验证码输入框 提交、取消按钮 后端各触发二次认证校验节点，二次认证校验统一接口 账户同步 选择所需同步账户范围 页 账户增删改等阶段对接阿里云 IDaaS API 上报日志 注意：\n如果是自建需要完成除 5 阶段外全部流程，如果对接阿里云 IDaaS ，只需完成 3、4、5 阶段、并对接API，其它由阿里云 IDaaS 控制。\n五、接入淘系账号风控体系流程说明 对接 阿⾥云应⽤身份服务 IDaaS ，对于我们应用的客户来说，实际上是透明的，他们并不会感知到后端验证的变更。\n5.1、接入淘系账号风控体系 1、在 IDaaS 创建⼀个应⽤，因为需要使⽤应⽤的 APP Key/Secret。 2、对接 IDaaS 同步相关接⼝，将您的应⽤的账户数据同步到 IDaaS。 3、对接 IDaaS 认证相关接⼝，将您的应⽤的认证请求切换到 IDaaS。\n5.1.1、账户同步 API 推送组织机构 推送账户 修改账户 删除账户 5.1.1、登录认证 API 账户密码认证 获取绑定OTP⼆维码 绑定OTP 清除OTP绑定状态 ⽣成短信随机码 校验随机码 导⼊常⽤设备和常⽤IP 图⽚验证码接⼝ 解锁账户接⼝ 启⽤禁⽤⽤户接⼝ 账户禁⽤ 六、自研对接御城河 6.1、账户同步 API IdaaS日志回传 二次认证日志回传 七、相关流程图 7.1、B/S架构对接细节 7.2、 IDaaS 参与总认证流程 "},{"id":81,"href":"/Tech/10Miscellaneous/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%E6%96%B9%E6%A1%88/","title":"用户中心二次验证方案","parent":"10、Miscellaneous","content":" 用户中心二次验证方案 平台 平台店铺 处理订单应用（大益源子） 处理订单的我方应用用户（客服） 用户中心（自有账号体系） IDaaS（一个基于用户中心提供二次验证的的服务） 御城河（平台的应用合规服务）\n一、原因 近年来国家陆续出台了个人信息保护和数据安全相关的法律法规，对保障消费者个人信息权益、规范数据处理活动提出了更明确的责任要求。为了更好的保障用户信息的安全、提升开发者应用对于用户个人信息的保护及应用自身的安全防护能力，平台因此提出《开发者安全能力标准》。\n淘宝平台要求获取消费者个人敏感信息的所有IT类应用对接御城河系统，应用标签包括但不限于：商家后台系统（简称“自研系统”）、国际商家后台系统（简称“自研系统”）、服务商后台系统、订单管理、ERP软件、进销存软件、全渠道ERP，仓储管理系统（WMS）、奇门-商家自研WMS系统等。\n二、用户中心升级原因 对于自有账号体系的应用，都需要对接账号风控，平台建议用户接入淘系账号风控体系，使用淘系账号的应用将默认享有平台提供的账号风控能力，如使用自有账号体系的应用，应具备平台认可的应用身份服务（简称：IDAAS）能力，并开启二次认证等安全策略并回传日志到平台。\n三、两种升级方式主要工作 注意：无论是接入淘宝账户风控体系，还是自研对接御城河，都需要调整用户中心认证流程。\n3.1、调整认证流程 在修改密码、绑定手机、绑定邮箱、绑定身份证等认证流程时，需要调整认证流程，必须要时需添加二次认证校验。\n3.2、接入淘系账号风控体系 购买阿⾥云应⽤身份服务（IDaaS） 对接API，同步账户数据到淘系账号，由 IDaaS 进⾏统⼀认证。 idaas 数据将自动回流计算，无需isv/自研再对接御城河回流。 3.3、自研 对接API，应用需对接御城河 idaas 和二次认证接口回流数据。 四、调整认证所需工作 账户涉及二次认证新增属性（短信或MFA） 二次认证设置页 是否启用、启用模式、启用节点（登录、修改密码、手机、邮箱、身份证？）、启用（账户或组织）范围、认证类型（淘宝、自建） 二次认证方式（默认手机短信） 短信模板 验证码限制逻辑 验证码发送频率限制 同一验证码可以尝试 3 次输入，3 次均失败后，验证码失效。用户需要获取新验证码。 验证码有效期 二次认证弹窗页 当前认证手机号（中间遮掩） 获取验证码按钮（倒计时，防止重复点击） 验证码输入框 提交、取消按钮 后端各触发二次认证校验节点，二次认证校验统一接口 账户同步 选择所需同步账户范围 页 账户增删改等阶段对接阿里云 IDaaS API 上报日志 注意：\n如果是自建需要完成除 5 阶段外全部流程，如果对接阿里云 IDaaS ，只需完成 3、4、5 阶段、并对接API，其它由阿里云 IDaaS 控制。\n五、接入淘系账号风控体系流程说明 对接 阿⾥云应⽤身份服务 IDaaS ，对于我们应用的客户来说，实际上是透明的，他们并不会感知到后端验证的变更。\n5.1、接入淘系账号风控体系 1、在 IDaaS 创建⼀个应⽤，因为需要使⽤应⽤的 APP Key/Secret。 2、对接 IDaaS 同步相关接⼝，将您的应⽤的账户数据同步到 IDaaS。 3、对接 IDaaS 认证相关接⼝，将您的应⽤的认证请求切换到 IDaaS。\n5.1.1、账户同步 API 推送组织机构 推送账户 修改账户 删除账户 5.1.1、登录认证 API 账户密码认证 获取绑定OTP⼆维码 绑定OTP 清除OTP绑定状态 ⽣成短信随机码 校验随机码 导⼊常⽤设备和常⽤IP 图⽚验证码接⼝ 解锁账户接⼝ 启⽤禁⽤⽤户接⼝ 账户禁⽤ 六、自研对接御城河 6.1、账户同步 API IdaaS日志回传 二次认证日志回传 七、相关流程图 7.1、B/S架构对接细节 7.2、 IDaaS 参与总认证流程 "},{"id":82,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC10%E7%AB%A0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C/","title":"Beginning C , Fifth Edition 第10章：基本输入和输出操作","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。\nC语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。\n本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。\n8.1 指针初探 "},{"id":83,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC11%E7%AB%A0%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/","title":"Beginning C , Fifth Edition 第11章：结构化数据","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。\nC语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。\n本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。\n8.1 指针初探 "},{"id":84,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC12%E7%AB%A0%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/","title":"Beginning C , Fifth Edition 第12章：处理文件","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。\nC语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。\n本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。\n8.1 指针初探 "},{"id":85,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC13%E7%AB%A0%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD/","title":"Beginning C , Fifth Edition 第13章：支持功能","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。\nC语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。\n本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。\n8.1 指针初探 "},{"id":86,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC14%E7%AB%A0%E9%AB%98%E7%BA%A7%E4%B8%93%E7%94%A8%E4%B8%BB%E9%A2%98/","title":"Beginning C , Fifth Edition 第14章：高级专用主题","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。\nC语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。\n本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。\n8.1 指针初探 "},{"id":87,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC1%E7%AB%A0C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/","title":"Beginning C , Fifth Edition 第1章： C 语言编程","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第1章 C 语言编程 程序即一组指令，可以让计算机依指令行事，完成指定的任务。\n本章的主要内容\nC 语言标准 标准库的概念 如何创建 C 程序 如何组织 C 程序 如何编写在屏幕上显示文本的程序 1.1 C 语言 1.2 标准库 标准库定义了编写C程序时常常需要的常量、符号和函数。它还提供了基本C语言的一些可选扩展，标准库以不依赖机器的形式实现，即相同的C代码在不同的底层硬件上会实现相同的功能。\n标准库在一系列文件——头文件中指定。头文件的扩展名总是.h。使用一组标准功能可用于C程序文件，只需要将对应的标准头文件含进来。\n1.3 学习 C 1.4 创建 C 程序 C 程序的创建工程有 4 个基本步骤：\n编辑 编译 链接 执行 程序要运行起来，必须要经过四个步骤：预处理、编译、汇编和链接。接下来通过几个简单的例子来详细讲解一下这些过程。 对于上边用到的几个选项需要说明一下。\n使用 gcc 命令不跟任何的选项的话，会默认执行预处理、编译、汇编、链接这整个过程，如果程序没有错，就会得到一个可执行文件，默认为a.out\n-E选项：提示编译器执行完预处理就停下来，后边的编译、汇编、链接就先不执行了。\n-S选项：提示编译器执行完编译就停下来，不去执行汇编和链接了。\n-c选项：提示编译器执行完汇编就停下来。\n所以，这三个选项相当于是限定了编译器执行操作的停止时间，而不是单独的将某一步拎出来执行。\n1.4.1 编辑 创建和修改 C 程序的源代码——我们编写的程序指令称之为源代码。\n1.4.2 编译 编译器可以将源代码转换成机器语言，在编译过程中，会找到并报告错误。这个阶段的输入是在编译期间产生的包含源代码的文件，常称为源文件。\n编译器会检查源文件中的错误。\n编译器输出的结果成为对象代码，存放于对象文件它与源文件同名，这些文件在Windows中扩展名通常是 .obj,Linux中通常是.o\n若编译器是GUN，编译命令是：\ngcc -c main.c 如果省略了 -c 这个参数，程序还会自动链接，生成可执行文件。\n编译过程包括两个阶段：第一个阶段称为预处理阶段，在此期间会修改或添加代码。第二阶段是生成对象代码的实际编译过程。源文件可以包含预处理宏，他们用于添加或修改 C 语言程序。\n1.4.3 链接 链接器（linker）将源代码文件中有编译器产生的各种对象模块组合起来，再从 C 语言提供的程序库中添加必要的代码模块，将他们组合成一个可执行的文件。\n链接器也会检测和报告错误，\n可以将一个程序拆分成几个源代码文件，再用链接器连接起来，每个源文件提供部分功能，每个源文件分别编译。\n链接阶段出现错误，意味着要重新编译源代码，链接成功则会产生一个可执行文件，但这并不意味着程序能正常工作。\n1.4.4 执行 执行阶段就是当成功完成了前述 3 个过程后运行程序。\n1.5 创建第一个程序 #include \u0026lt;stdio.h\u0026gt;\rint main(void){\rprintf(\u0026#34;Hello world!\u0026#34;);\rreturn 0;\r}\r1.6 编辑第一个程序 /* 注意 \\\u0026#34; ， 在要显示的文本中，\\\u0026#34;序列称之为转义序列（escape sequence）。 */\r#include \u0026lt;stdio.h\u0026gt;\rint main(void){\rprintf(\u0026#34;Hello world!\\n\u0026#34;);\rreturn 0;\r}\r转义序列（escape sequence） 在要显示的文本中，\u0026quot; 序列称为转义序列，\n反斜杠()在文本字符串里具有特殊的意义，他标识转义序列的开始。反斜杆后面的字符表示是哪种转义序列。\n表 1-1 是转义序列表： 1.7 处理错误 根据编译器提示，处理错误吧。\n1.8 剖析一个简单的程序 1.8.1 注释 多行注释：/* */；无论 /* 之后的任何文本都会被认为是注释直到标示注释结束的 */ 为止。\r单行注释：//；代码行上两个斜杠后面的所有内容都会被编译器忽略。 1.8.2 预处理指令 下面的代码行：\n#include \u0026lt;stdio.h\u0026gt; 符号 # 表示这是一个预处理指令（preprocessing directive），告诉编译器在编译源代码前，要先执行一些操作，编译器在编译过程开始前的预处理阶段处理这些指令，预处理指令相当多，大多数放于程序源文件的开头。\n头文件（header file） 在这个例子中，编译器要将 stdio.h 文件的内容包含进来，这个文件称之为头文件（header file），因为它通常放在程序的开头出。在本例中，头文件定义了 C 标准库中的一些函数信息，通常，在头文件中指定的信息应有编译器用于在程序中集成预定义函数和其他全局对象，有时需要创建自己的头文件。本例中用到标准库中的printf()函数，所以必须包含 stdio.h 头文件。 stdio.h 头文件包含了编译器理解 printf() 以及其他输入/输出函数所需要的信息。名称 stdio 是标准输入/输出（standard input/output）的缩写。C 语言中所有的头文件的扩展名都是 .h 。\n每个符合 C11 标准的 C 编译器 都有一些标准的头文件。这些头文件主要包含了与 C 标准库函数相关的声明。所有符合该标准的 C 编译器都支持同一组标准库函数，有同一组标准头文件，有一些编译器有额外的库函数，他们提供的功能一般是运行编译器的计算机所专用的。\n注意：\n在一些系统中，头文件名是不区分大小写的，但在#include 指令里，这些文件名通常是小写。\n1.8.3 定义 main() 函数 下面的 5 行指令定义了main()函数：\nint main(void)\r{\rprintf(\u0026#34;Hello world!\\n\u0026#34;);\rreturn 0;\r} 函数是两个括号主键执行某组操作的一段代码，每个 C 程序都是由一个或多个函数组成，每个 C 程序都必须有个 main() 函数，main()函数是每个 C 程序的执行起点。在执行阶段执行可执行文件时，操作系统会执行这个程序的main()函数。\n定义main()函数的第一行代码如下：\nint main(void) 定义 main() 函数的第一行代码开头是一个关键字 int，它标示 main() 函数的返回值类型。\n在下面的语句中，指定了执行完 main()函数后要返回的值：\nreturn 0; 这个 return 语句结束了 main() 函数的执行。\n函数名“main”后面的括号，是给函数main传递信息的入口，void 表示 给 main()函数传递的数据是无。\n在执行到函数体中的 return 语句时，就会停止执行该函数，将控制权返回给调用函数（对于 main 函数，则将控制权返回给操作系统）。\n1.8.4 关键字 1.8.5 函数体 函数体是在函数名称后面起始及结束两个大括号 之间 的 代码块。它们定义了函数执行时要完成的任务。\n每个函数必须有函数体，但函数体可以是空的。\n1.8.6输出信息 printf() 是一个标准的库函数,它将函数名后面引号内的信息输出到命令行上(实际上是标准输出流,默认为命令行)。在这个例子中,调用这个函数会显示双引号内的一段警示语：双引号内的字符串称为字符串字面量。注意这行代码用分号作为结尾。\n1.8.7 参数 包含在函数名后圆括号内的项称为参数，它是指要传递诶函数的数据，当一个函数有多个参数时，要用逗号隔开。\n注意：\n与C语言中所有可执行的语句一样, printf()行的末尾必须有分号(这与定义语句或指令语句不同),这是一个很容易犯的错误,尤其是初次使用C编程的人,老是忘了分号。\n1.8.8 控制符 反斜杠()在文本字符串里有特殊的意义,它表示转义序列的开始。反斜杠后面的字符表示是哪种转义序列。对于\\n, n表示换行。还有其他许多转义序列。显然,反斜杠是有特殊意义的,所以需要一种方式在字符串中指定反斜杠。为此,应使用两个反斜杠(\\)。\n1.8.9 三字母序列 这类转义序列存在的唯一原因是，有9个特殊的字母序列，称之为三字母序列，这是包含三个字母的序列，分别表示#、[、]、\\、^、~、|、{和}：\n在 International Organization of Standardization(ISO)不变的代码集中编写C代码时，需要用到它们，可以完全不用理会它们，使用三字母序列时，编译器会发出一个警告，因为通常是不应该使用三字母序列的。\n1.9 预处理器 预处理指令可以把头文件的内容包含到源文件中。编译的预处理阶段可以做的工作远不止此，除了指令外，源文件还可以包含宏。宏是提供给预处理器的指令，来添加或修改程序中的 C 语句。宏可以很简单，只定义一个符号，例如 INCHES_PER_FOOT ，只要出现这个符号，就用 12 代替。其指令如下：\n#define INCHES_PER_FOOT 12 在源文件中包含这个指令，则代码中只要出现 INCHES_PER_FOOT ，就用 12 替代它。例如：\nprintf(\u0026#34;Hello world!\\n\u0026#34;,INCHES_PER_FOOT); 在预处理后，这个语句变成：\nprintf(\u0026#34;Hello world!\\n\u0026#34;,12); 宏也可以很复杂，根据特定的条件把大量代码添加到源文件中。\n1.10 用 C 语言开发程序 介绍编写程序时需要完成的基本步骤。\n1.10.1 了解问题 在满足需求和完成项目的有限资金、人力及时间之间达成某种一致。\n了解需求，定义程序要解决的问题部分。\n1.10.2 详细设计 讲需求分解为可管理的单元模块，描述这些独立模块互相沟通的方式。\n1.10.3 实施 有计划的实施。\n1.10.4 测试 1.11 函数及模块化编程 大多数编程语言都提供一种方法，将程序切割成多个段，各个段都可以独立编写。在 C 语言中这些段称之为函数。\n函数与外界有一个特殊的接口，可以将信息传进来，也可以减函数产生的结果传出去。\n每个函数都完成一个指定的、定义明确的工作，程序中操作的执行由一个main()总体掌控。\n程序切割成多个易于管理的小单元，对编程非常重要。\n1.12 常见错误 编译和连接报错好找，但是不报错缺得不到正确的结果才是头疼的。\n1.13 要点 "},{"id":88,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC2%E7%AB%A0%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5/","title":"Beginning C , Fifth Edition 第2章：编程初步","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第2章 编程初步 在程序中仓储数据项的地方是可以变化的，叫做变量(variable)，这是本章的主题。\n本章的主要内容：\n内存的用法及变量的概念 在 C 中如何计算 变量的不同类型及其用途 强制类型转换的概念及其使用场合 编写一个程序，计算树木的高度 浮点数默认是 double 类型\n在数值的末尾添加一个 f，类型为 float\n在数字的末尾添加一个大写 L 或小写 l，类型为 long double\n2.1 计算机的内存 计算机执行程序时，组成程序的指令和程序操作的数据都必须存储到某个地方。这个地方就是机器的内存，也称之为主内存(main memory)，或随机访问存储器(Random Access Memory, RAM)，RAM是易失性存储器。关闭 PC 后，RAM 的内容就会丢失。PC 把一个或多个磁盘驱动器作为其永久存储器。要在程序结束执行后存储起来的任何数据，都应该写入磁盘。\n计算机用二进制存储数据：0 或 1.计算机有时用真(true)和假(false)表示它们：1 是真，0 是假。每一个数据称之为一个位(bit),即二进制数(binary digit)的缩写。\n字节的地址(address) 内存中的位以 8 个为一组，每组的 8 位称之为一个字节(byte)。为了使用字节的内容，每个字节用一个数字表示，第一个字节用 0 表示，第二个字节用 1 表示，直到计算机内存的最后一个字节。字节的这个数字标记称之为字节的地址(address)。因此，每个字节的地址都是唯一的。字节的地址唯一地表示计算机内存中的字节。\n总之，内存的最小单位是位(bit)，将8个位组合为一组，称之为字节(byte)。每个字节都有唯一的地址。字节的地址从 0 开始。位只能是 0 或 1 ，如图所示：\n计算机的内存的常用单位是千字节(KB)、兆字节(MB)、千兆字节(GB)。磁盘驱动器还使用兆兆字节(TB)。这些单位的大小如下：\n1KB 是1024 字节。 1MB 是1024 KB，也就是1 048 576 字节。 1GB 是1024 NB，也就是1 072 741 841 字节。 1TB 是1024 GB，也就是1 099 511 627 776 字节。 如果 PC 有 1GB 的 RAM ，字节地址就是0~1 073 741 841 。0 到 1023 共 1024 个数字而在二进制中，1023的十个位刚好全是1：11 1111 1111 ，(1 byte ,8位)，MB 需要 20 个位，GB 需要 30 个位，\n2.2 什么是变量 变量是计算机里一块特定的内存，它是由一个或多个连续的字节组成，一般是1、2、4、8 或 16 字节（byte）。每个变量都有一个名称，可以用该名称表示内存的这个位置，以提取它包含的数据或存储一个新的数值。\n变量的命名 给变量指定名称一遍称为变量名。变量的命名是很有弹性的。可以由：字母、数字、下划线（_）组成，要以字母或下划线开头，不能以数字开头。以一或两个下划线开头的变量名常用字头文件中，所以在源代码中给变量命名时，不要将下划线作第一个字符，以免和标准库里的变量名冲突。变量名的另一个要点是，变量名是区分大小写的。\n警告：\n变量名可以包含的字符数取决于编译器，遵循 C 语言标准的编译器至少支持 31 个字符，只要不超过这个程度就没问题。有些编译器会截短过长的变量名。\n2.3 存储整数的变量 int salary ; 这个语句称为变量声明，因为它声明了变量的名称，在这里，变量名是 salary。\n变量声明也指定了这个变量存储的数据类型。这里使用关键字 int 指定 salary 用来存放一个整数。\n变量声明也称为变量的定义，因为它分配了一些存储空间，来存储整数数值，该整数可用变量名 salary 来引用。\n注意：\n声明引入了一个变量名，定义则给变量分配了存储空间，有这个区别的原因在本书后面会很清楚。\n现在还未指定变量 salary 的值 ，所以此刻该变量包含一个垃圾值，即上次使用这块内存空间时遗留在此的值。\n下一个语句是：\nsalary = 10000; 这是一个简单的算数赋值语句，它将等号右边的数值存储到等号左边的变量中。\n等号“=”称为赋值运算符，它将右边的值赋予左边的变量。\n然后是熟悉的 printf() 语句，但它有两个参数：\nprintf(\u0026#34;My salary is %d.\u0026#34;,salary); 参数1：控制字符串，用来控制气候的参数输出以书面方式显示，它是放在双引号内的字符串，也称为格式字符串，因为它制定了输出数据的格式。 参数2：是变量名 salary，这个变量的显示方式由第一个参数——控制字符串来确定。 转换说明符（conversion specific） 在控制字符串在有个 %d，它称为变量值的转换说明符（conversion specific）。\n转换说明符确定变量在屏幕上显示的方式，换言之，他们制定最初的二进制值转换为什么形式，显示在屏幕上。在本列中使用了 d，它是应用于整数值的十进制说明符，表示第二个参数 salary 输出为一个十进制数。\n注意：\n转换说明符总是以 % 字符开头，以便 printf()函数识别出它们。所以如果要输出 % 字符，就必须用转义序列 %%。\n控制字符串可以存在多个转换说明符，例如：\nint brides = 5;\rint brothers = 10;\rprintf(\u0026#34;%d My salary is %d .\u0026#34;,brides,brothers); 在一个语句中声明多个同类型的变量时，可以用逗号将数据类型后面的变量名分开。例如：\nint brides ,brothers ;\rint brides2 ,\rbrothers2 ; 注意：\n声明变量要放在变量赋值语句之前。\n2.3.1 变量的使用 下面的代码展示了将两个整数变量进行计算并赋值个变量 a 。\nint brides = 5;\rint brothers = 10;\rint a = brides + brothers;\rprintf(\u0026#34; My salary is %d .\u0026#34;,a); 2.3.2 变量的初始化 变量的声明：\nint salary ; 此时变量的值是上一个程序在那块内存中留下的数值，它可以是任何数。\n变量的初始化：\nsalary = 10 ; 最好在声明变量时就对其进行初始化：\nint salary = 10 ; 1、基本算数运算 在 C 语言中，算数语句的格式如下：\n变量名 = 算数表达式； 赋值运算符右边的算数表达式指定使用变量中存储的值或者直接的数字，以算术运算符如加（+）、减（-）、乘（*）、除（/）、取模（%）等运算符进行计算。例如：\nint brides = 5;\rint brothers = 10;\rint a = brides + brothers + 5 ; 赋值运算先计算赋值运算符右边的算数表达式，再将所得结果赋值到左边的变量中。\n注意：\n应用运算符的值称为操作数。需要两个操作数的运算符(如%)称为二元运算符。应用于一个值的运算符称为一元运算符。因此-在表达式a-b中是二元运算符,在表达式-data中是一元运算符。\n如果两个或多个字符串彼此相邻,编译器会将它们连接起来,构成一个字符串。\n例如：\nint a = 10;\rint b = 20;\rprintf(\u0026#34;字符串1!%d \\n-- \\n\u0026#34;\u0026#34;字符串2!%d\u0026#34;, a, b);\r//或者\rprintf(\u0026#34;字符串1!%d \\n-- \\n\u0026#34;\r\u0026#34;字符串2!%d\u0026#34;,\ra, b); 2.4 变量和内存 每次声明给定类型的变量时，编译器都会给他分配一个足够大的内存空间，来保存该类型的变量。相同类型的不同变量占据相同打下ode内存空间（字节数）。不同类型的变量分配的内存空间就不一样了。整数变量还有几个不同的变体，以储存不同范围的整数。\n2.4.1 各种数据类型介绍 2.4.2 整型 整形包括短整型、整形和长整形。\n2.4.2.1 短整形 short a=1;\n2.1.2整形 一般占4个字节（32位），最高位代表符号，0表示正数，1表示负数，取值范围是-2147483648~2147483647，在内存中的存储顺序是地位在前、高位在后，例如0x12345678在内存中的存储如下：\n地址：0x0012ff78　0x0012ff79　0x0012ff7a　0x0012ff7b\n数据：　78　56　34　12\n定义：用int关键字，举例如下：\nint a=6;\n2.1.3 长整形 long a=10;\n2.2 浮点型 浮点型包括单精度型和双精度型。\n2.2.1 单精度型 浮点型，又称实型，也称单精度。一般占4个字节（32位），\nfloat a=4.5;\n地址：0x0012ff78　0x0012ff79　0x0012ff7a　0x0012ff7b\n数据：　00　00　90　40\n2.2.2 双精度型 一般占8个字节（64位）\ndouble a=4.5;\n地址：0x0012ff78　0x0012ff79　0x0012ff7a　0x0012ff7b　0x0012ff7c　0x0012ff7d　0x0012ff7e　0x0012ff7f\n数据：　00　00　00　00　00　00　12　40\n2.3 字符类型 在各种不同系统中，字符类型都占一个字节（8位）。定义如下：\nchar c=\u0026lsquo;a\u0026rsquo;;\n也可以用字符对应的ASCII码赋值，如下：\nchar c=97;\nshort a=1;\n在32 位的系统上short 咔出来的内存大小是2 个byte； int 咔出来的内存大小是4 个byte； long 咔出来的内存大小是4 个byte； float 咔出来的内存大小是4 个byte； double 咔出来的内存大小是8 个byte； char 咔出来的内存大小是1 个byte。\n2.4.1 带符号的整数类型 有 5 种基本的变量类型可以声明为存储带符号的整数值，如下表所示：\n类型名称 字节数 signed char 1 short int 2 int 4 long int 4 long long int 8 类型名称 short、long、和long long 可以用作 short int 、long int 和 long long int 的缩写。这些变量类型所占据的内存空间，及可以存储的取值范围，取决于所使用的编译器。很容易确定编译器允许的极限值，因为它们在 limits.h 头文件中定义。\n2.4.2 无符号的整数类型 对于每个存储带符号整数的类型，都有一个对应的类型来存储无符号的整数，它们占用的内存空间与无符号类型相同。每个无符号的类型名称都与带符号的类型名称相同，但要在前面加上关键字 unsigned 。\n类型名称 字节数 unsigned signed int 1 unsigned short int 2 unsigned int 4 unsigned long int 4 unsigned long long int 8 注意：\n如果变量的类型不同，但占用相同的字节数，则它们仍是不同的。Long 和 int 类型占用相同的内存量，但它们扔是不同的类型。\n2.4.3 指定整数常量 整数变量有不同的类型,整数常量也有不同的类型。例如,如果将整数写成100,它的类型就是int。如果要确保它是long类型,就必须在这个数值的后面加上一个大写L或小写l。所以, long类型的整数100应写为100L。虽然写为100l也是合法的,但应尽量避免,因为小写字母l与数字1很难辨别。\n例如：\n// 指定为 long 类型。\rlong Big_Number = 123456L;\r// 指定为 long long 类型。\rlong long Big_Number = 123456LL;\r// 指定为 无符号类型 类型。\runsigned int Big_Number = 123456U;\runsigned long Big_Number = 123456UL; 1、十六进制常量\n也可以用十六进制编写整数,即以16为基底。十六进制的数字等价于十进制的0~15表示方式是0~9和A~F(或a~f)。因为需要一种方式区分十进制的99和十六进制的99,所以在十六进制数的前面加上0x或0X。因此在程序中,十六进制的99可以编写成0x99或0X99,十六进制常量也可以有后缀。下面是十六进制常量的一些示例:\n0xFFFF 0xdead 0xfade 0xFade 0x123456EE 0xafL 0xFABABULL 最后一个示例的类型是 unsigned long long，倒数第二个示例的类型是 long。\n十六进制常量常用来表示位模式,因为每一个十六进制的数对应于4个二进制位。两个十六进制的数指定一个字节。第3章介绍的按位运算符一般与十六进制常量一起用于定义掩码。如果不熟悉十六进制,可以参阅附录A..\n2、八进制常量\n八进制数以 8 为基底。八进制数字为0~7,对应于二进制中的3位。八进制数起源于计算机内存采用 36 位字的时代,那时一个字是 3 位的组合。因此, 36 位二进制字可人写成 12 个八进制数。八进制数目前很少使用,需要知道它们,以免错误地指定八进制数。\n以 0 开头的整数常量,例如 014,会被编译器看作八进制数。因此, 014 等价于十进制的12,而不是十进制的 14,所以,不要在整数中加上前导 0 ,除非要指定八进制数。很少需要使用八进制数。\n3、默认的整数常量类型\n如前所述,没有后缀的整数常量默认为 int 类型,但如果该值太大,在 int 类型中放不下,该怎么办?对于这种情形,编译器创建了一个常量类型,根据值是否有后缀,来判断该值是否是十进制。表2-5列出了编译器如何判断各种情形下的整数类型。\n编译器选择容纳该值的第一种类型,如表中各项的数字所示。例如,后缀为 u 或 U 的十六进制常量默认为 unsigned int,否则就是 unsigned long。如果这个取值范围太小,就采用 unsigned long long 类型。当然,如果给变量指定的初始值在变量类型的取值范围中放不下,编译器就会发出一个错误消息。\n2.5 使用浮点数 浮点数包含的值带小数点，也可以表示分数和整数。例如：\n1.6 0.00008 7655.899 100.0 由于浮点数的标示方式，她位数是固定的。这回限制浮点数的精度，是一个缺点。 浮点数通常表示为一个小数乘以 10 的次方。例如：\n数值 指数表示法 在 C 语言中\r1.6 0.16 * 10^1 0.16E1 在 C 语言中的标示法，这些数字中的 E 标示指数，也可以使用 e 。对于小数位非常多的数，指数形式比较方便。0.5E-15当然比 0.0 000 000 000 000 005 更好。\n浮点数的表示\n下图显示显示了在 Intel PC 的内存中，浮点数是如何存储在 4 字节的内存中。\n这是个单精度的浮点数，在内存中占用4个字节。该值包含三部分：\n符号位 Sign（1bit）：表示浮点数是正数还是负数。0表示正数，1表示负数 8 位的指数 Exponent（8bits）：指数部分。类似于科学技术法中的M*10^N中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中是以2^7-1即127，也即01111111代表2^0，转换时需要根据127作偏移调整。 23 位的尾数 Mantissa（23bits）：基数部分。浮点数具体数值的实际表示。 1\u0026lt;= M \u0026lt;2 尾数部分包含浮点数中的小数，占用23位。它假定一个形式为 1.bbbbb\u0026hellip;b 的二进制值，二进制点的右边有 23 位。因此尾数的值总是大于等于 1，小于 2。那么如何把 24 位值放在 23 位中，其实很简单。最左边的一位总是 1 ，所以不需要存储，采用这种方式，可以给精度提供一个额外的二进制数字。\n指数是一个无符号的8位值，所以指数的值可以是 0~255。浮点数的实际值是尾数乘以 2的指数幂 2^exp ,其中 exp 是指数值。使用负的指数值可以表示很小的分数。为了包含这个浮点数表示。给浮点数的实际指数加上127，这将允许把-127~128的值表示为 8位无符号值。因此指数为 -6 会存储为 121 ，指数6会存储为133.但还有几个复杂的问题。\n浮点数由 10 进制改为 2 进制\n根据国际标准IEEE（电气和电子工程协会）规定，任何一个浮点数NUM的二进制数可以写为： NUM = (-1)^S * M * 2^E ;(S表示符号，E表示阶乘，M表示有效数字)\n将10进制小数改为内存中的浮点数过程：\n1、改写整数部分： 以数值 5.375 为例。先不考虑指数部分，我们先单纯的将十进制数改写成二进制。 整数部分很简单，5.即101.。\n2、改写小数部分： 小数部分我们相当于拆成是2^-1一直到2^-N的和。例如：0.375 = 0.25+0.125即2^-2+2^-3 ，也即.011。\n3、拼接及转变为二进制科学计数法：5.375 = 101.011 = -1^0 * 1.01011 * 2^2\n4、S = 0 , M = 01011 , E = 2 + 127 = 129 = 10000001\n5、放入内存并补位：0 10000001 01011000000000000000000\n关于一个整数及小数转为 2 进制的简便示例：\r1、整数部分除以 2 记录余数，将结果继续除 2 记录余数 ，直至结果小于 1 。\r2、小数部分乘以 2 记录结果的整数部分，将结果的小数部分继续乘以 2 ，直至结果的小数部分是 0 。\rNUM = 134.375\r整数 134 小数 0.375\r134 / 2 = 67 余 0 0.375 * 2 = 0.750 0\r67 / 2 = 33 余 1 0.750 * 2 = 1.5 1\r33 / 2 = 16 余 1 0.5 * 2 = 1.0 1\r16 / 2 = 8 余 0\r8 / 2 = 4 余 0\r4 / 2 = 2 余 0\r2 / 2 = 1 余 0\r1 = 1 余 1\r134 = 10000110 0.375 = 0.25 + 0.125 = 2^-2 + 2^-3 = 0.011\r//这是对二进制数的科学计数法\r10000110.011 = -1^0 * 1.0000110011 * 2^7\rS = 0, M = 0000110011……, E = 7 + 127 = 134 = 10000110\rS E M\r0 10000110 00001100110000000000000 浮点数中的保留数\n因为会给 浮点数的实际指数加上 127，实际指数为 -127 ，而存储的的指数是 0，这是一种特殊情况。浮点数 0 表示为尾数和指数所有为都是 0 ，所以指数为 -127 时，不能用于其他的值。\n0 11111111 00000000000000000000000 不是 1 * 2^128 ，且所有尾数位是 0 。负数除以 0 的结果是这个值取负，所以 -1 * 2^128 也是一个特殊值\n对于E还分为三种情况： ①E不全为0，不全为1: 这时就用正常的计算规则，E的真实值就是E的字面值减去127（中间值)，M的值要加上最前面的省去的1。 ②E全为0 这时指数E等于1-127为真实值，M不在加上舍去的1，而是还原为0.xxxxxxxx小数。这样为了表示0，和一些很小的整数。 所以在进行浮点数与0的比较时，要注意。 ③E全为1 当M全为0时，表示±无穷大（取决于符号位）；当M不全为1时，表示这数不是一个数（NaN）\n保留数：0 S = 0,E = 全是0，M = 全是0， 0 00000000 0000000000000000000000\n保留数：0. S = 0,E = 全是0，M = 不全是1， 0 00000000 0000000000000000000000\n保留数：±无穷大 = 正数或负数 / 0 S = 0或1,E = 全是1，M = 全是0， 0 11111111 00000000000000000000000 1 11111111 00000000000000000000000\n保留数：Not a Number(NaN) = 0 / 0 S = 0或1,E = 全是1，M = 1 或者 0，（尾数的首位是 1 或者 0 ，取决于 NaN 只是个 NaN，允许继续执行，还是一个发出信号的 NaN，在代码中生成一个可中断执行的异常。） 0 11111111 1…… 1 11111111 01……（当前导数为0时，其他尾数至少有一个是1，以根无穷大区分）\n23位二进制数：11111111111111111111111 转化为十进制数是 8388607 ，十进制浮点数转化为二进制的浮点数时因为位移影响所以：二进制的浮点数整数位会影响其小数位的长度。 例如一个十进制浮点数的整数部分极大，其转化为二进制时二进制数的整数部分也极大，需向左位移位数较多，影响其原小数位精度\n2.6 浮点数变量 浮点数变量类型只能存储浮点数。下表 2-6 是 3 种不同的浮点数变量。\n关键字 字节数 数值范围 float 4 ±3.4E±38（精确到 6 到 7 位小数） double 8 ±1.7E±308（精确到 15 位小数） long double 12 ±1.19E±38（精确到 18 位小数） 这是浮点数类型通常占用的字节数和取值范围。与整数一样,这些数所占用的字节数和取值范围取决于机器和编译器。在一些编译器上,类型 long double 和 double 相同。注意,小数的精确位数只是一个大约的数,因为浮点数在内部是以二进制方式存储的十进制的浮点数在二进制中并不总是有精确的表示形式。\n如果需要存储至多有 7 位精确值的数(范围从10^-38到10^38),就应需要使用 float 类型的变量。类型 float 的值称为单精度浮点数。从表 2-6 中得知,它占用4个字节。使用类型 double 的变量可以存储双精度浮点数。类型 double 的变量占用 8 个字节,有 15 位精确值,范围从10^-308到10^+308,它足以满足大多数的需求。\n编写一个类型为 float 的常量,需要在数值的末尾添加一个 f ,以区别 double 类型。\nfloat redius = 2.5f;\rdouble biggest = 123E30; 变量 radius 的初值是 2.5,变量 biggest 初始化为 123 后面加 30 个零。任何数,只要有小数点,就是 double 类型,除非加了 f,使它变为 float 类型。当用E或e指定指数值时,这个常量就不需要包含小数点。例如1E3f 是 float 类型, 3E8 是 double 类型。要声明 1ong double 类型的常量,需要在数字的末尾添加一个大写 L 或小写 l,例如:\nlong double biggest = 1234567.89123L; 2.6.1 使用浮点数完成除法运算 使用整数操作数进行除法运算时,通常会得到整数结果。除非除法运算的左操作数刚好是右操作数的整数倍,否则其结果是不正确的。在无法整除时，这时就需要用到浮点数了。使用浮点数进行除法运算,会得到正确的结果——至少是一个精确到固定位数的值。\n使用格式说明符 %f 显示浮点数。格式说明符一般必须对应输出的值的类型。如果使用格式说明符 %d 输出 float 类型的值,就会得到一个垃圾值。因为浮点数会解释为整数,同样,如果使用 % 输出整数类型的值,也会得到垃圾值。\n2.6.2 控制输出中的小数位数 例如,要使输出的小数点后有两位数,可以使用格式说明符 %.2f。如果小数点后需要有 3 位数,则可以使用 %.3f。\n2.6.3 控制输出中的字段宽度 输出的字段宽度是输出值所使用的总字符数(包括空格),在这个程序中,它是默认的。printf()函数确定了输出值需要占用多少个字符位置,小数点后的位数由我们指定并将它用作字段宽度。但我们可以自己确定字段宽度,也可以自己确定小数位数。如果要求输出一列排列整齐的数值,就应确定固定的字段宽度。如果让printr()函数指定字段宽度,输出的数字列就不整齐。用于浮点数的格式说明符的一般形式是:\n%[width] [.precision] [modifier]f 其中,方括号不包含在格式说明符中。它们包含的内容是可选的,所以可省略 width, .precision 或 modifier,或它们的任意组合。width 值是一个整数,指定输出的总字符数(包括空格),即字段宽度。precision 值也是一个整数,指定小数点后的位数。当输出类型是 long double 时, modifier 部分就是 L，否者就忽略它。\n我试了下，感觉 width 感觉没用啊。。。。。。\n指定字段宽度时,数值默认为右对齐。如果希望数值左对齐,只需要在 % 的后面添加一个负号。例如,格式说明符%-10.4f将输出一个左对齐的浮点数,其字段宽度为10个字符,小数点后有4位数。\n注意,也可以对整数值指定字段宽度及对齐方式。例如 %-15d 指定一个整数是左对齐,其字段宽度为 15 个字符。还有其他格式说明符,以后会学习它们。\n2.7 较复杂的表达式 对于较复杂的计算,需要更多地控制表达式的计算顺序。括号可以提供这方面的能力。当遇到错综复杂的情况时,括号还有助于使表达式更清晰。可以加入空格,将操作数和运算符分开,使算术表达式的可读性更高。\n函数：scanf(\u0026quot;%f\u0026quot;, \u0026amp;b); scanf(\u0026#34;%f\u0026#34;,\u0026amp;diameter); scanf() 是另一个需要包含头文件 stdio.h 的函数。它专门处理键盘输入,提取通过键盘输入的数据,按照第一个参数指定的方式解释它,第一个参数是放在双引号内的一个控制字符串。在这里,这个控制字符串是 %f.因为读取的值是 float 类型。scanf() 将这个数存入第二个参数指定的变量 diameter 中。第一个参数是一个控制字符串,和 print() 函数的用法类似,但它控制的是输入,而不是输出。第10章将详细介绍 scanf() 函数,附录 D总结了所有的控制字符串。\n寻址运算符 \u0026amp; 注意,变量名 diameter 前的 \u0026amp; 是个新东西,它称为寻址运算符,它允许 scanf() 函数将读入的数值存进变量 diameter.它的做法和将参数值传给函数是一样的。这里不详细解释它;第8章会详细说明。唯一要记住的是,使用函数 scanf() 时,要在变量前加上寻让运算符 \u0026amp; ,而使用 print() 函数时不添加它。\n在函数 scanf()的控制字符串中, % 字符表示某数据项的格式说明符的开头。% 字符后面的 f 表示输入一个浮点数。在控制字符串中一般有几个格式说明符,它们按顺序确定了函数中后面各参数的数据类型。在 scanf() 的控制字符串后面有多少个参数,控制字符串就有多少个格式说明符,本书的后面将介绍 scanf() 函数的更多运用,表 2-8 列出了卖取各种类型的数据时所使用的格式说明符:\n表 2-8\n操作 需要控制的字符串 读取 short 类型的数值 %hd 读取 int 类型的数值 %d 读取 long 类型的数值 %ld 读取 float 类型的数值 %f 或者 %e 读取 double 类型的数值 %lf 或者 %le 2.8 定义命名常量 一个值在程序中保持不变可以设为常量。\n这有两种方法：第一种是定义一个符号，在程序编译期间取代它。\n#include \u0026lt;stdio.h\u0026gt;\r#define PI 3.1415926f\rint main(void) {\rfloat a = 1000000000.000f;\rfloat b = 20.0f * PI;\rprintf(\u0026#34;你好\u0026#34;);\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;b);\rprintf(\u0026#34;数值 a ——\u0026gt; %5.2f \\n-- \\n\u0026#34;\u0026#34;数值 b ——\u0026gt; %f\u0026#34;, a, b);\rreturn 0;\r} 在注释和头文件的#include指令之后,有一个预处理指令:\n#define PI 3.1415926f 这里将PI定义为一个要被 3.14159f 取代的符号。使用 PI 而不是 Pi ,是因为在 C 语言中有一个通用的约定: #define 语句中的标识符都是大写。只要在程序里的表达式中引用 PI,预处理器就会用 #define 指令中的数值取代它。所有的取代动作都在程序编译之前完成。程序开始编译时,不再包含PI这个符号了,因为所有的PI都用 #define 指令中的数值取代了。这些动作都是在编译器处理时在内部发生的,源程序没有改变,仍包含符号 PI.\n警告：\n在预处理器在替代代码中的符号时,不会考虑它是否有意义。如果在替代字符串中出错,例如,如果编写了3.14.159f,预处理器仍会用它替代每个PI,而程序不会编译。\n第二种方法是将 Pi 定义成变量,但告诉编译器,它的值是固定的,不能改变。声明变量时,在变量名前加上 const 关键字,可以固化变量的值,例如:\nconst float b = 3.1415926f; 以这种方式定义 Pi 的优点是, Pi 现在定义为指定类型的一个常量值。在前面的例子中, PI 只是一个字符序列,替代代码中的所有 PI 。\n在 Pi 的声明中添加关键字 const 会使编译器检查代码是否试图改变它的值。这么做的代码会被标记为错误,且编译失败。\n注意：\nconst 会使编译器检查代码是否试图改变它的值。这么做的代码会被标记为错误,且编译失败。\n也就是说：在通过编译后是可以改变 const 标记的变量，例如：通过寻址运算符 \u0026amp;\n2.8.1 极限值 当然,一定要确定程序中给定的整数类型可以存储的极限值。如前所述,头文件 \u0026lt;limits.h\u0026gt;定义的符号表示每种类型的极限值。表2-9列出了对应于每种带符号整数类型的极限值符号名。\n表2-9 整数类型的极限值的符号\n类型 下限 上限 char CHAR_MIN CHAR_MAX short SHORT_MIN SHORT_MAX int INT_MIN INT_MAX long LONG_MIN LONG_MAX long long LLONG_MIN LLONG_MAX 无符号整数类型的下限都是 0,所以它们没有特定的符号。无符号整数类型的上限的符号分别是 UCHAR_MAX,USHRT_MAX、UINT_MAX、ULONG_MAX 和 ULLONG_MAX。\n要在程序中使用这些符号,必须在源文件中添加 \u0026lt;limits.h\u0026gt; 头文件的 #include 指令：\n#include \u0026lt;limits.h\u0026gt; 初始化最大值 int 变量，如下所示：\n//这个语句把number的值设置为最大值,编译器会利用该最大值编译代码。\rint number = INT_MAX; \u0026lt;float.h\u0026gt;头文件定义了表示浮点数的符号,其中一些的技术含量很高,所以这里只介绍我们感兴趣的符号。 3 种浮点数类型可以表示的最大正值和最小正值如表2-10所示。还可以使用FLT_DIG、DBL_DIG 和 LDBL_DIG符号,它们指定了对应类型的二进制尾数可以表示的小数位数。下面用一个例子来说明如何使用表示整数和浮点数的符号。\n表2-10 表示浮点数类型的极限值的符号\n类型 下限 上限 float CHAR_MIN CHAR_MAX double SHORT_MIN SHORT_MAX long double INT_MIN INT_MAX // Program 2.11 Finding the limits #include \u0026lt;stdio.h\u0026gt;// For command line input and output\r#include \u0026lt;limits.h\u0026gt;//For limits on integer types\r#include \u0026lt;float.h\u0026gt;// For limits on floating-point types\rint main(void) {\rprintf (\u0026#34;Variables of type char store values from %d to %d\\n\u0026#34;, CHAR_MIN, CHAR_MAX);\rprintf (\u0026#34;Variables of type unsigned char store values from O to %u\\n\u0026#34;, UCHAR_MAX);\rprintf (\u0026#34;Variables of type short store values from %d to %d\\n\u0026#34;, SHRT_MIN, SHRT_MAX);\rprintf (\u0026#34;Variables of type unsigned short store values from o to %u\\n\u0026#34;, USHRT_MAX) ;\rprintf (\u0026#34;Variables of type int store values from %d to %d\\n\u0026#34;, INT_MIN, INT_MAX);\rprintf (\u0026#34;Variables of type unsigned int store values from o to %u\\n\u0026#34;, UINT_MAX) ;\rprintf (\u0026#34;Variables of type long store values from %ld to %ld\\n\u0026#34;, LONG_MIN, LONG_MAX) ;\rprintf (\u0026#34;Variables of type unsigned long store values from o to %lu\\n\u0026#34;, ULONG_MAX) ;\rprintf (\u0026#34;Variables of type long long store values from %lld to %lld\\n\u0026#34;, LIONG_MIN, LLONG_MAX);\rprintf (\u0026#34;Variables of type unsigned long long store values from 0 to %llu\\n\u0026#34;, ULLONG_MAX);\rprintf (\u0026#34;\\nThe size of the smallest positive non-zero value of type float is %.3e\\n\u0026#34;, FLT_MIN);\rprintf (\u0026#34;The size of the largest value of type float is %.3e\\n\u0026#34;, FLT_MAX);\rprintf (\u0026#34;The size of the smallest non-zero value of type double is %.3e\\n\u0026#34;, DBL_MIN) ;\rprintf (\u0026#34;The size of the largest value of type double is %.3e\\n\u0026#34;, DBL_MAX) ;\rprintf (\u0026#34;The size of the smallest non-zero value of type long double is %.3Le\\n\u0026#34;, LDBL_MIN);\rprintf (\u0026#34;The size of the largest value of type long double is %.3Le\\n\u0026#34;, LDBL_MAX);\rprintf (\u0026#34;\\n Variables of type float provide %u decimal digits precision. \\n\u0026#34;, FLT_DIG);\rprintf (\u0026#34;Variables of type double provide %u decimal digits precision. \\n\u0026#34;, DBL_DIG);\rprintf (\u0026#34;Variables of type long double provide %u decimal digits precision. \\n\u0026#34;,LDBL_DIG);\rreturn 0;\r} 在一系列的printf()函数调用中,输出\u0026lt;limits.h\u0026gt;和\u0026lt;float.h\u0026gt;头文件定义的符号的值。计算机中的数值总是受限于该机器可以存储的值域,这些符号的值表示每种数值类型的极限值。这里用说明符 %u 输出无符号整数值。如果用 %d 输出无符号类型的最大值,则最左边的位(带符号类型的符号位)为 1 的数值就得不到正确的解释。\n对浮点数的极限值使用说明符 %e,表示这个数值是指数形式。同时指定精确到小数点后的 3 位数,因为这里的输出不需要非常精确。print()函数显示的值是 long double类型时,需要使用 L 修饰符。L 必须是大写,这里没有使用小写字母 l。%f说明符表示没有指数的数值,它对于非常大或非常小的数来说相当不方便。在这个例子中试一试,就会明白其含义。\n2.8.2 sizeof 运算符 使用 sizeof 运算符可以确定给定的类型占据多少字节。当然,在 C 语言中 sizeof 是一个关键字。表达式 sizeof(int) 会得到int类型的变量所占的字节数,所得的值是一个size_t类型的整数。size_t 类型在标准头文件\u0026lt;stddef.h\u0026gt; (和其他头文件)中定义,对应于一个基本整数类型。但是,与 size_t类型对应的类型可能在不同的 C 库中有所不同,所以最好使用 size_t 变量存储 sizeof 运算符生成的值,即使知道它对应的基本类型,也应如此。下面的语句是存储用 sizeof 运算符计算所得的数值:\nsize_t size = sizeof(long long); 也可以将 sizeof 运算符用于表达式,其结果是表达式的计算结果所占据的字节数。通常该表达式是某种类型的变量。除了确定某个基本类型的值占用的内存空间之外, sizeof 运算符还有其他用途,但这里只使用它确定每种类型占用的字节数。\n#include \u0026lt;stdio.h\u0026gt;// For command line input and output\rint main(void) {\rprintf (\u0026#34;Variables of type long long occupy %u butes. \\n\u0026#34;,sizef(long long));\rprintf (\u0026#34;Variables of type float occupy %u butes. \\n\u0026#34;,sizef(float));\rprintf (\u0026#34;Variables of type double occupy %u butes. \\n\u0026#34;,sizef(double));\rreturn 0;\r} 因为 sizeof 运算符的结果是一个无符号整数,所以用 %u 说明符输出它。注意,使用表达式 sizeof var_name 也可以得到变量 var-name 占用的字节数。显然,在关键字 sizeof 和变量名之间的空格是必不可少的。\n现在已经知道编译器给每个数值类型指定的极限值和占用的字节数了。\n注意：\n如果希望把 sizeof 运算符应用于一个类型,则该类型名必须放在括号中,例如sizeof(long double),将 sizeof 运算符应用于表达式时,括号就是可选的。\n2.9 选择正确的类型 必须仔细选择在计算过程中使用的变量类型,使之能包含我们期望的值。如果使用了错误的类型,程序就可能出现很难检测出来的错误。具体每类类型存储数值的区间如下：\n类型名称 占字节数 其他叫法 表示的数据范围 无符号 char 1 signed char -128 ~ 127 0 ~ 255 int 4 signed int -2,147,483,648 ~ 2,147,483,647 0 ~ 4,294,967,295 short 2 short int -32,768 ~ 32,767 0 ~ 65,535 long 4 long int -2,147,483,648 ~ 2,147,483,647 0 ~ 4,294,967,295 long long 8 long\tlong int -4,294,967,296 ~ 4,294,967,296 0 ~ 8,589,934,592 float 4 none 3.4E +/- 38 (7 digits) double 8 none 1.7E +/- 308 (15 digits) long double 10 none 1.2E +/- 4932 (19 digits) 这里有一个编程宗旨，就是能用小不用大。\n可以利用自动类型转换。\n2.10 强制类型转换 将一种类型显式转换为另一种类型的过程称为强制类型转换(cast)。\ndouble c;\rint d = 5;\rint e = 8;\rc = (double)(d + e) / 2; 将 (d + e) 的计算结果转换为 double，确保了结果的精确。\n2.10.1 自动转换类型 二元运算符要求其操作数有相同的类型。编译器在处理涉及不同类型的值操作时,会自动把其中一个操作数的类型转换为另一个操作数的类型。在二元算术运算中使用不同类型的操作数,编译器就会把其中一个值域较小的操作数类型转换为另个操作数的类型,这称为隐式类型转换(implicit conversion)。再看看前面计算收入的表达式：\n2.10.2 隐式类型转换的规则 算术运算式中，低类型转换为高类型 赋值表达式中，表达式的值转换为左边变量的类型 函数调用时，实参转换为形参的类型 函数返回值，return表达式转换为返回值类型 2.10.3 赋值语句中的隐式类型转换 赋值运算符右边的表达式值与左边的变量有不同的类型时，也可以进行隐式类型转换。在一些情况下，这会截短数值，丢失数据。\n2.11 再谈数值数据类型 char 类型的变量可以存储单个字符的代码。它只能存储一个字符代码（即一个整数），所以被看作为整数类型，可以像其他整数类型那样处理 char 类型存储的值，因此可以在算数运算中使用它。\n2.11.1 字符类型 在所有数据的类型中，char 类型占用的内存空间最少。一般只需一个字节（byte）（-128~127 或 0 ~ 255）。存储在 char 类型变量的整数可以表示为带符号或无符号的值,这取决于编译器。若表示为无符号的类型,则存储在 char 类型变量的值可以是0-255,若表示为带符号的类型则存储在 char 类型变量的值可以是-128-127,当然,这两个值域对应相同的位模式:0000 0000到1111 1111对于无符号的值,这8位都是数据位,所以0000 0000应于0, 1111 1111应于255,对于带符号的值,最左边的1位是符号位,所以-128的二进制值是1000 0000,0的二进制值是0000 0000, 127的二进制值是0111 1111 。值1111 11111是一个带符号的二进制值,其对应的十进制值是-1.从表示字符代码(位模式)的角度来看, char 类型是否带符号并不重要。重要的是何时对 char 类型的值执行算术运算。\nchar类型的变量有双重性:可以把它解释为一个字符,也可以解释为一个整数。\nchar character = 74;\rchar letter = \u0026#39;C\u0026#39;; 2.11.2 字符的输入和输出 使用scanf()函数和格式说明符%c,可以从键盘上读取单个字符,将它存储在char类型的变量中,例如:\nchar ch = 0;\rscanf(\u0026#34;%c\u0026#34;,\u0026amp;ch); 要使用print()函数将单个字符输出到命令行上,也可以使用格式说明符:\nprintf (\u0026#34;The character is %c\\n\u0026#34;, ch); 当然,也可以输出该字符的数值:\nprintf (\u0026#34;The character is %c and the code value is %d\\n\u0026#34;, ch, ch); 这个语句会把ch的值输出为一个字符和一个数值。\n注意： 标准库 ctype.h 头文件提供的toupper()和tolower()函数可以把字符转换为大写和小写。\n2.11.3 枚举 在编程时,常常希望变量存储一组可能值中的一个。例如一个变量存储表示当前月份的值。这个变量应只存储12个可能值中的一个,分别对应于1-12月。C语言中的枚举(enumeration)就用于这种情形。\n利用枚举,可以定义一个新的 整数类型,该类型变量的值域是我们指定的几个可能值。下面的语句定义了一个枚举类型 Weekday:\nenum Weekday {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}; 这个语句定义了一个类型,而不是变量。新类型的名称 Weekday 跟在关键字 enum 的后面,这个类型名称称为枚举的标记。Weekday 类型的变量值可以是类型名称后面的大括号中的名称指定的任意值。这些名称叫做枚举器(enumerator)或枚举常量(enumerationconstant),其数量可任意。每个枚举器都用我们赋予的唯一名称来指定,编译器会把 int 类型的整数值赋予每个名称。枚举是一个整数类型,因为指定的枚举器对应不同的整数值,这些整数默认从 0 开始,每个枚举器的值都比它之前的枚举器大 1。因此在这个例子中, Monday 到 Sunday 对应0-6.可以声明 Weekday 类型的一个新变量,并初始化它,如下所示:\nenum Weekday today = Wednesday; 这个语句声明了一个变量 today,将它初始化为 Wednesday。由于枚举器有默认值,所以 Wednesday对应 2,用于枚举类型变量的整数类型是由实现代码确定的,选择什么类型取决于枚举器的个数。\n也可以在定义枚举类型时,声明该类型的变量。下面的语句就定义了一个枚举类型和两个变量:\nenum Weekday (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday} today,tomorrow; 这个语句声明了枚举类型Weekday,定义了该类型的两个变量today和tomorrow。还可以在同一个语句中初始化变量,如下所示:\nenum Weekday (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday} today =Monday, tomorrow = Tuesday; 这个语句把变量today和tomorrow初始化为Monday和Tuesday。枚举类型的变量是整数类型,所以可以在算术表达式中使用。前面的语句还可以写为:\nenum Weekday (Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday} today =Monday, tomorrow - today +1; tomorrow 的初始值比 today 大 1。但是,在执行这个操作时,要确保算术运算的结果是一个有效的枚举值。\n注意: 可以给枚举类型指定一组可能的值,但没有检查机制来确保程序只使用这些值。所以程序员要确保只为给定的枚举类型使用有效的枚举值。一种方式是只给枚举类型的变量赋予枚举常量名。\n1,选择枚举值 可以给任意或所有枚举器明确指定自己的整数值。尽管枚举器使用的名称必须唯一,但枚举器的值不要求是唯一的。除非有特殊的原因让某些枚举器的值相同,否则一般应确保这些值也是唯一的。下面的例子定义了Weekday类型,使其枚举器的值从 1 开始:\nenum Weekday (Monday =1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday); 枚举器Monday到Sunday的对应值是1-7,在明确指定了值的枚举器后面,枚举器会被赋予连续的整数值。这可能使枚举器有相同的值,如下面的例子所示\nenum Weekday (Monday =5, Tuesday =4, Wednesday, Thursday =10, Friday = 3, Saturday, Sunday); Monday, Tuesday, Thursday 和 Friday 明确指定了值, Wednesday 设置为 Tuesday+1,所以它是 5, Monday 与它相同。同样, Saturday 和 Sunday 设置为 4 和 5,所以它们的值也是重复的。完全可以这么做,但除非有很好的理由使一些枚举常量的值相同,否则这容易出现混淆。\n只要希望变量有限定数量的可能值,就可以使用枚举。下面是定义枚举的另一个例子:\nenum Suit {clubs = 10, diamonds, hearts, spades}; enum Suit card_suit = diamonds; 第一个语句定义了枚举类型Suit,这个类型的变量可以有括号中的4个值的任意一个。第二个语句定义了Suit 类型的一个变量,把它初始化为 diamonds ,其对应的值是11。还可以定义一个枚举,表示扑克牌的面值,如下所示:\nenum FaceValue {two=2, three, four, five, six, seven eight, nine, ten, jack, queen, king, ace}; 在这个枚举中,枚举器的整数值匹配扑克牌的面值,其中ace的值最高。在输出枚举类型的变量值时,会得到数值。如果要输出枚举器的名称,必须提供相应的程序逻辑,详见下一章的内容。\n2,未命名的枚举类型 在创建枚举类型的变量时,可以不指定标记,这样就没有枚举类型名了。例如:\nenum {red, orange, yellow, green, blue, indigo, violet} shirt_color; 这里没有标记,所以这个语句定义了一个未命名的枚举类型,其可能的枚举器包括从 red 到 violet ,该语句还声明了未命名类型的变量 shirt_color.\n可以用通常的方式给 shirt_color 赋值:\nshirt_color =blue; 显然,未命名枚举类型的主要限制是,必须在定义该类型的语句中声明它的所有变量。由于没有类型名,因此无法在代码的后面定义该类型的其他变量。\n2.11.4 存储布尔值的变量 _Bool 类型存储布尔值。布尔值一般是比较的结果 true 或 false ;第 3 章将学习比较操作,并使用其结果做出判断。_Bool 类型的变量值可以是 0 或 1,对应于布尔值 false 和 true。由于值 0 和 1是 整数,所以 _Bool 类型也被看为整数类型。声明 _Bool 变量的方式与声明其他整数类型一样,例如:\n_Bool valid = 1// Boolean variable initialized to true _Bool 并不是一个理想的类型名称。名称 bool 看起来更简洁、可读性更高,但布尔类型是最近才引入C语言的,所以选择类型名称 _Bool ,可以最大限度地减少与已有代码冲突的可能性。如果把 bool 选作类型名称,则在将 bool 作为一种内置类型的编译器上,使用 bool 名称的程序大都不会编译。\n尽管如此,仍可以使用 bool 作为类型名称,只需在使用它的源文件中给\u0026lt;stdbool.h\u0026gt;标准头文件添加#include指令即可。除了把 bool 定义为 _Bool 的对应名称之外, \u0026lt;stdbool.h\u0026gt;头文件还定义了符号 true 和 false,分别对应 1 和 0。因此,如果在源文件中包含了这个头文件,就可以将上面的声明语句改写为:\n_Bool valid = 1;// Boolean variable initialized to true 这似乎比上面的版本清晰得多,所以最好包含\u0026lt;stabool.h\u0026gt;头文件,除非有特殊的理由。本书的其余部分使用 bool 表示布尔类型,但需要包含相应的头文件,其基本类型名称是 _Bool .\n可以在布尔值和其他数值类型之间进行类型转换。非零数值转换为 bool 类型时,会得到1(true), 0 就转换为 0(false)。如果在算术表达式中使用 bool 变量,编译器就会在需要时插入隐式类型转换。bool 类型的级别低于其他类型,所以在涉及 bool 类型和另一个类型的操作中, bool 值会转换为另一个值的类型。这里不详细介绍如何使用布尔变量,具体内容详见下一章。\n2.12 赋值操作的 op= 形式 op= 形式 是指 将：\nnumber = number + 10; 写为：\nnumber += 10; 这类赋值操作是给一个变量递增或递减一个数字,它非常常见,所以有一个缩写形式:\nnumber +=10; 变量名后面的 += 运算符是 op= 运算符家族中的一员。这个语句等价于上面的语句,但输入量少了许多。op=中的op可以是任意算术运算符:\n+ - * / % 如果 number 的值是10,就可以编写如下语句:\nnumber *=3;/ number will be set to number*3 which is 30\rnumber /=3;/ number will be set to number/3 which is 3\rnumber %=3;// number will be set to number3 which is 1 op= 中的op也可以是其他几个运算符:\n\u0026lt;\u0026lt; \u0026gt;\u0026gt; \u0026amp; ^ | 第3章将介绍这些运算符。op= 运算符的工作方式都相同。如果有如下形式的语句:\n1hs op= rhs; 其中 rhs 表示 op= 运算符右边的表达式,该语句的作用与如下形式的语句相同:\n1hs = 1hs op (rhs); 注意 rhs 表达式的括号,它表示 op 应用于整个 rhs 表达式的计算结果值。为了加强理解,下面看几个例子。下面的语句:\nvariable *=12; 等价于:\nvariable = variable * 12; 现在给一个整数变量加1有两种方式。下面的两个语句都给count加1:\ncount = count +1;\rcountd +=1; 下一章将介绍这个操作的另一种方式。有这么多选择,使编写C程序的人数无法统计。op= 运算符中的 op 应用于 rhs 表达式的计算结果,所以如下语句:\na/=b+1; 等价于:\na = a/(b + 1); 到目前为止,我们的计算能力比较受限。现在只能使用一组非常基本的算术运算符。而使用标准库的功能可以大大提升计算能力。所以在进入本章的最后一个例子之前,先看看标准库提供的一些数学函数。\n2.13 数学函数 math.h 头文件包含各种数学函数的声明。为了了解这些数学函数,下面介绍最常用的函数。所有的函数都返回一个 double 类型的值。表2-11列出了各种用于进行数值计算的函数,它们都需要 double 类型的参数。\n给函数名的末尾添加 f 或 l,就得到处理 float 和 long double 类型的函数版本,所以 ceilf() 应用于 float 值, sqrtl()应用于 long double 值。下面是使用这些函数的一些例子:\ndouble x = 2.25;\rdouble less = 0.0;\rless = floor(x);\rprintf(\u0026#34;test %.2f \\n\u0026#34;, less); 还有一些三角函数,如表 2-12 所示。给函数名的末尾添加f或1,就得到处理 float 和 long double 类型的函数版本,参数和返回值的类型也是 float, double 或 long double,角度表示为弧度。\n2.14 设计一个程序 下面设计本章末的一个真实例子,来试用一些数值类型。这里将从头开始编写一个程序,涉及编程的所有基本要素,包括：\n问题的初始描述、 问题的分析、 解决方案的准备、 编写程序、 运行程序,以及 测试它,确保它正常工作。 该过程的每一步都会引入新问题而不仅仅是纸上谈兵。\n2.15 小节 本章介绍了许多基础知识,讨论了C 程序的构建方式、各种算术运算、如何选择合适的变量类型等。除了算术运算之外,还学习了输入输出功能,通过scanf()将值输入变量,通过printf()函数把文本、字符值和数值变量输出到屏幕上。读者可能不能第一次就掌握所有这些内容,但可以在需要时复习本章。\n本章还介绍并使用了printf()函数的数据输出格式说明符,完整的说明符列表请参见附录D。附录D还描述了输入格式说明符,它们用于控制使用scanf()函数从键盘上读取数据时这些数据的解释方式。当无法确定如何处理输入或输出数据时,可以参阅附录D\n2.15 练习 "},{"id":89,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC3%E7%AB%A0%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/","title":"Beginning C , Fifth Edition 第3章：条件判断","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第3章 条件判断 本章将在可以编写的程序种类和构建程序的灵活性方面迈出一大步。我们要学习一种非常强大的编程工具:比较表达式的值,根据其结果,选择执行某组语句。也就是说,可以控制程序中语句的执行顺序。\n本章的主要内容:\n根据算术比较的结果来判断 逻辑运算符的概念及其用法 再谈从键盘上读取数据 编写一个可用作计算器的程序 3.1 判断过程 在程序中做出判断,就是选择执行一组程序语句,而不执行另一组程序语句。在现实生活中,我们总是要做判断。\n跟 Java 一样。\n3.1.1 算数比较 C中的比较涉及一些运算符。比较两个值有6个关系运算符：\n\u0026lt;\r\u0026lt;=\r==\r!=\r\u0026gt;\r\u0026gt;= 这些运算都会得到 int 类型的值。如果比较结果为真,每个操作的结果都是 1,否则如果比较结果为假,则每个操作的结果都是 0。如上一章所述, stabool.h 头文件为这些值定义了符号 true 和 false,于是 2!=3得到 true, 5L\u0026gt;3L 和 6 \u0026lt;= 12 也得到 true,表达式 2==3、5\u0026lt;4和 1.2\u0026gt;= 1.3 都得到 0,即 false。\n这些表达式称为逻辑表达式或布尔表达式,因为每个表达式都会得到两个结果之一: true 或 false,关系运算符生成布尔结果,所以可以把结果存储在 bool 类型的变量中。例如:\nbool result =5 \u0026lt;4;1/ result will be false 任何非零数值在转换为 bool 类型时,都得到 true。这表示,可以把算术表达式的结果赋予 bool 变量,如果它是非零值,就存储 true ,否则就存储 false.\n3.1.2 基本的 if 语句 有了用于比较的关系运算符后,就需要使用一个语句来做判断。最简单的语句就是 if 语句。如果要比较自己和他人的体重,并根据结果打印不同的句子,就可以编写如下程序:\nint my_weight = 169;// Weight in 1bs int your_weight = 175;/ Weight in 1bs if(your_weight \u0026gt; my_weight)\rprintf (\u0026#34;You are heavier than me.\\n\u0026#34;);\rif (your_weight \u0026lt; my_weight)\rprintf (\u0026#34;I am heavier than you.\\n\u0026#34;);\rif (your_weight == my_weight)\rprint (\u0026#34;We are exactly the same weight.\\n\u0026#34;); 3.1.3 扩展 if 语句: if-else 3.1.4 在 if 语句中使用代码块 3.1.5 嵌套的 if 语句 3.1.6 测试字符 3.1.7 逻辑运算符 \u0026amp;\u0026amp; //与\r|| //或\r！ //非 3.1.8 条件运算符 三元运算符\n3.1.9 运算符的优先级 从表3-2可以看出,所有比较运算符的优先级都低于二元算术运算符,二元逻辑运算符的优先级低于比较运算符。因此,先执行算术运算,再比较,之后执行逻辑操作。赋值是列表中的最后一个,所以它们在其他运算都完成后执行。条件运算符的优先级高于赋值运算符。\n3.2 多项选择问题 在编程时,常常会遇到多项选择问题。例如,根据候选人是否来自6所不同大学中的一所来选择一组不同的动作。另一个例子是根据某一天是星期几来执行某组语句。在c语言中,有两种方式处理多项选择问题。一种是采用 else-if 形式的 if 语句,这是处理多项选择的最常见方式。另一种是 switch 语句,它限制了选择某个选项的方式,但在使用 switch 语句的场合中,它提供了一种非常简洁且便于理解的解决方案。下面先介绍 else-if 语句。\n3.2.1 给多项选择使用 else-if 语句 3.2.2 switch 语句 3.2.2 goto 语句 int main(void){\rbool a = true;\rdouble x = 10.25;\rdouble less = 0.0;\rless = floor(x);\rlabel: ;\r--less;\rprintf(\u0026#34;test %.2f \\n\u0026#34;, less);\rgoto label;\r--less;\rprintf(\u0026#34;test %.2f \\n\u0026#34;, less);\r--less;\rless = (less--);\rprintf(\u0026#34;test %.2f \\n\u0026#34;, less);\rprintf(\u0026#34;Hello\\n world!\u0026#34;);\rprintf(\u0026#34;Hello\\t world!\u0026#34;);\rreturn 0;\r} 3.3 按位运算符 在进入本章的大型示例之前,还要先学习一组运算符,它们看起来类似于前面介绍的逻辑运算符,但实际上与逻辑运算符完全不同。这些运算符称为按位运算符,因为它们操作的是整数值中的位。按位运算符有6个,如表3-5所示。\n3.3.1 按位运算符的 op= 用法 所有的二元按位运算符都可以在 op= 形式的赋值语句中使用,但 ~ 运算符例外,它是一元运算符。如第2章所述,如下形式的语句:\nlhs op= rhs; 等价于:\nlhs = lhs op (rhs); 例如：\nvalue \u0026lt;\u0026lt;= 4; 3.3.2 使用按位运算符 从学术的角度来看,按位运算符很有趣,但它们用于什么场合?它们不用于日常的编程工作,但在一些领域非常有效。按位与\u0026amp;、按位或|运算符的一个主要用途是测试并设置整数变量中的各个位。此时可以使用各个位存储涉及二选一的数据。例如,可以使用一个整数变量存储一个人的几个特性。在一个位中存储这个人是男性还是女性,使用3个位指定这个人是否会说法语、德语或意大利语。再使用另一个位记录这个人的薪水是否多于S50000,在这4个位中,都记录了一组数据。下面看看这是如何实现的。\n掩码 只有两个位都是1,结果才是1,此时可以使用 \u0026amp; 运算符选择整数变量的一个部分,甚至可以选择其中的一个位。首先定义一个值,它一般称为掩码,用于选择需要的位。在掩码中,希望保持不变的位置上包含1,希望舍弃的位置上包含0。接着对这个掩码与要从中选择位的值执行按位与操作。下面看一个例子。下面的语句定义了掩码:\n// 00000000000000000000000000000001\runsigned int male=0x1;// Mask selecting first (rightmost) bit // 00000000000000000000000000000010\runsigned int french= 0x2;// Mask selecting second bit\r// 00000000000000000000000000000100\runsigned int german= 0x4;// Mask selecting third bit\r// 00000000000000000000000000001000\runsigned int italian =0x8;// Mask selecting fourth bit/\r// 00000000000000000000000000001010\runsigned int payBracket = 0x10;// Mask selecting fifth bit 在每条语句中, 1位表示该条件是true。这些二进制掩码都选择一个位,所以可以定义一个 unsigned int 变量 personal_data 来存储一个人的 5 项信息。如果第一位是 1,这个人就是男性,如果是 0,这个人就是女性。如果第二位是 1,这个人就说法语,如果是 0 这个人就不说法语,数据值右边的 5 位都是这样。 因此,可以给一个说德语的人测试变量 personal_data ,如下面的语句所示:\nif (personal_data \u0026amp; german)\r/* Do something because they speak German */ 如果 personal_data 对应掩码 german 的位是1,表达式personalData \u0026amp; german的值就不是0(true),否则就是0。\n任何非零数值在转换为 bool 类型时,都得到 true。这表示,可以把算术表达式的结果赋予 bool 变量,如果它是非零值,就存储 true ,否则就存储 false.\n掩码 german 其它位均为0，会将 personal_data 除 第三位 之外的值均为 0，\n当 personal_data 第三位的值是 1 时，personal_data \u0026amp; german 表达式的结果是 00100，否则的结果 00000\n因为 非 0 的数转化为 bool 时 会得到 true ，说以，只要 当 personal_data 第三位的值是 1 时 与掩码 00100 进行与运算，则可得到 true 变量，以此确定 personal_data 的第三位的值。\n总结一下：一个指定位为1其它位均为0的掩码与另一个数据进行 与 运算，则可以确定另一个数据指定位的值是否为 1。\n另一个需要理解的操作是如何设置各个位。此时可以使用按位 或(OR) 运算符。按位或运算符与测试位的掩码一起使用,就可以设置变量中的各个位。如果要设置变量 personal_data,记录某个说法语的人,就可以使用下面的语句:\npersonal_data |= french; 上面的语句与如下语句等效：\npersonal_data = personal_data | french; 掩码 french 第二位为 1，其它位均为0，\npersonal_data 与 掩码 french 进行 或(OR) 运算时：personal_data 的其它位为 1 时，与 0 或运算后结果也是 1，personal_data 的其它位为 0 时，与 0 或运算后结果也是 0，personal_data 第二位 与 1 进行或运算时会被设置为1。\n总结一下： 指定位数据与 0 进行或运算时会保持原值，与 1 进行或运算时会被设置为1，也就是完成了指定位数据赋值。\npersonal_data 中从右数的第二位设置为1,其他位都不变。利用运算符的工作方式,可以在一条语句中设置多个位: 上面的语句与如下语句等效：\npersonal_data = personal_data | french | german | male; 非（~）运算\n非运算即取反运算，在二进制中1变0,0变1 ~110101 =001010\n重置一个位 如何重置一个位?假定要将男性位设置为女性,就需要将一个位重置为0,此时应使用~运算符和按位与(AND)运算符:\npersonal_data \u0026amp;= ~male; 这是可行的,因为~male将表示男性的位设置为0,其他位仍设置为1。因此,对应于男性的位设置为0, 0与任何值的与操作都是0,其他位保持不变。如果另一个位是1,则1\u0026amp;1仍是1。如果另一个位是0,则0\u0026amp;1仍是0.使用位的例子记录了个人数据的特定项。如果要使用Windows应用程序编程接口(API)编写PC程序,就会经常使用各个位来记录各种Windows参数的状态,在这种情况下,按位运算符非常有用。\nint main(void){\runsigned int original = 0xABC;\runsigned int result = 0;\runsigned int mask = 0xF; // Rightmost four bits 最右边的四位\rprintf(\u0026#34;\\n original = %X\u0026#34;, original);\r// insert first digit in result\rresult |= original \u0026amp; mask; // Put right 4 bits from original in result 将结果从原位置右移4位\r// Get second digit 得到第二位数\roriginal \u0026gt;\u0026gt;= 4; // shift original right four positions 移动原始的右四个位置\rresult \u0026lt;\u0026lt;= 4; // Make room for next digit 给下一位腾出位置\rresult |= original \u0026amp; mask; // Put right 4 bits from original in result 将结果从原来的4位右移\r// Get third digit 得到第二位数\roriginal \u0026gt;\u0026gt;= 4; // Shift oriqinal right four positions 向右移动原来的四个位置\rresult \u0026lt;\u0026lt;= 4; // Make room for next digit 给下一位腾出位置\rresult |= original \u0026amp; mask; // Put right 4 bits from original in result 返回结果的右4位\rprintf(\u0026#34;\\t result = %X\\n\u0026#34;, result);\rreturn 0;\r} 这个程序使用了前面探讨的掩码概念。original中最右边的十六进制数是通过表达式original \u0026amp; mask将original和mask的值执行按位与操作而获得的。这会把其他十六进制数设置为0,因为mask的值的二进制形式为:\n0000 0000 0000 1111 可以看出, original中只有右边的4位没有改变。这4位都是1,在执行按位与操作的结果中,这4位仍是1,其他位都是0,这是因为0与任何值执行按位与操作,结果都是0,选择了右边的4位后,用下面的语句存储结果:\nresult |= original \u0026amp; mask; // Put right 4 bits from original in result result的内容与右边表达式生成的十六进制数进行或操作。为了获得original中的第二位,需要把它移动到第一个数字所在的位置。为此将original向右移动4位:\noriginal \u0026gt;\u0026gt;= 4; 第一个数字被移出,且被舍弃。为了给original的下一个数字腾出空间,下面的语句将result的内容向左移动4位:\nresult \u0026lt;\u0026lt;= 4; 现在要在result中插入original中的第二个数字,而当前这个数字在第一个数字的位置上,使用下面的语句:\nresult |= original \u0026amp; mask; // Put right 4 bits from original in result 要得到第三个数字,重复上述过程。显然,可以对任意多个数字重复这个过程。\n3.4 设计程序 3.4.1 问题 3.4.2 分析 3.4.3 解决方案 3.5 小节 3.6 联系 "},{"id":90,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC4%E7%AB%A0%E5%BE%AA%E7%8E%AF/","title":"Beginning C , Fifth Edition 第4章：循环","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第4章 循环 本章将介绍如何重复执行一个语句块,直到满足某个条件为止,这称为循环。语句块的执行次数可以简单地用一个计数器来控制,语句块重复执行指定的次数,或者还可以更复杂一些,重复执行一个语句块,直到满足某个条件为止,例如用户输入 quit。后者可以编写上一章的计算器示例,使计算过程重复需要的次数,而不必使用goto语句。\n本章的主要内容\n使语句或语句块重复执行指定的次数 重复执行语句或语句块,直到满足某个条件为止 使用for, while和do-while循环 递增和递减运算符的作用及其用法 编写一个简单的Simon游戏程序 4.1 循环 循环是带有比较数据项功能的一个基本编程工具。循环总是隐含了某种比较,因为它提供了终止循环的方式。典型的循环是使一系列语句重复执行指定的次数,这种循环会存储循环块执行的次数,与需要的重复次数相比较,比较的结果确定何时应终止循环。\n4.2 递增和递减运算符 ++ number;\r-- number; 4.3 for 循环 4.4 for 循环的一般语法 for(int i = 1, j = 2; i\u0026lt;=5; ++i,j = j+2)\rprintf(\u0026#34;%5d\u0026#34;,i*j); 4.5 再谈递增和递减运算符 4.5.1 递增运算符 先看看递增运算符。假如变量的类型是 int ，下面的3调语句有相同的结果：\ncount = count + 1;\rcount += 1;\r++count; 这些语句都给变量 count 加 1.最后一致形式最简洁。 也可以在表达式中使用递增运算符。这个运算符在表达式中的动作是递增变量的值,然后,在表达式中使用递增的值。例如,假设count的值是5,执行如下语句:\ntotal = ++count +6; 变量count会递增到6,在计算等号右边的表达式时,会使用这个值。因此变量total的值为12,这个指令改变两个变量count和total.\n4.5.2 递增运算符的前置和后置形式。 前面将++运算符放在变量前面,这叫做前置形式。这个运算符也可以写在变量的后面,这称为后置形式。在表达式中使用前置和后置形式的效果大不相同。如果在表达式中编写的是count++,则变量count的值在使用之后才递增。这看起来有点复杂。修改前面的例子:\ntotal = 6 + count ++; 4.5.3 递减运算符 递减运算符的操作和递增运算符完全相同。它的形式是\u0026ndash;,作用是给它操作的变量减1。它的使用方式和++完全相同。例如,假设变量count是int类型,下面3条语句会有相同的结果:\ncount = count - 1;\rcount -= 1;\r--count; 4.6 再论 for 循环 #include \u0026#34;stdio.h\u0026#34; int main(void){ unsigned long long int sum = 0LL; unsigned int count = 0; printf(\u0026#34;\\nEnter the number of integers you want to sum:\u0026#34;); scanf(\u0026#34;%u\u0026#34;, \u0026amp;count); for (int i = 1; i \u0026lt;= count; ++i) { sum += i; } printf(\u0026#34;\\nTotal of the first %u numbers is %llu\\n\u0026#34;, count, sum); return 0; } 4.6.1 修改 for 循环变量 上面的程序完全可以写为下面这样，结果完全一样：\n#include \u0026#34;stdio.h\u0026#34;\rint main(void){\runsigned long long int sum = 0LL;\runsigned int count = 0;\rprintf(\u0026#34;\\nEnter the number of integers you want to sum:\u0026#34;);\rscanf(\u0026#34;%u\u0026#34;, \u0026amp;count);\rfor (int i = 1; i \u0026lt;= count; sum += i++) ;\rprintf(\u0026#34;\\nTotal of the first %u numbers is %llu\\n\u0026#34;, count, sum);\rreturn 0;\r} 4.6.2 没有参数的 for 循环 for (;;){\r} 4.6.3 循环内的 break 语句 第3章在switch语句中使用过break语句。它的作用是终止switch块中代码的执行,并继续执行跟在switch后的第一行语句。break语句在循环体内的作用和switch基本相同。\n4.6.4 使用 for循环限制输入 4.6.5 生成伪随机整数 在前一个例子中,如果程序在每次执行时,可以生成要猜测的数字,该数字每次都不同,就更有趣了。为此,可以使用在头文件\u0026lt;stdlib.h\u0026gt;中声明的函数rand):\nint chosen = 0;\rchosen =rand(); 每次调用rand()函数,它都会返回一个随机整数,这个值在0到\u0026lt;stdlib.h\u0026gt;定义的RAND-MAX之间。由rand)函数产生的整数称为伪随机数(pseudo-random),因为真正的随机数只能在自然的过程中产生,而不能通过运算法则产生。\n每次调用rand()函数,它都会返回一个随机整数,这个值在0到\u0026lt;stdlib.h\u0026gt;定义的RAND MAX之间。由rand()函数产生的整数称为伪随机数(pseudo-random),因为真正的随机数只能在自然的过程中产生,而不能通过运算法则产生。\nrand()函数使用一个起始的种子值生成一系列数字,对于一个特定的种子,所产生的序列数永远是相同的。如果使用这个函数和默认的种子值,如上面的代码所示,就总是得到相同的序列数,这会使这个游戏没什么意思,只是在测试程序时比较有用。stdlib.h提供了另一个标准函数srand(),在调用这个函数时,可以用作为参数传递给函数的特定种子值来初始化序列数。\n乍看之下,这似乎并没有让猜数游戏改变多少,因为每次执行程序时,必须产生一个不同的种子值。此时可以使用另一个库函数:在\u0026lt;time.h\u0026gt;头文件中声明的函数time()。time()函数会把自1970年1月1日起至今的总秒数返回为一个整数,因为时间永不停歇所以每次执行程序时,都会得到不同的值。time)函数需要一个参数NULL, NULL是在\u0026lt;stdib.h\u0026gt;中定义的符号,表示不引用任何内容。NULL的用法和含义详见第7章。因此,要在每次执行程序时得到不同的伪随机序列数,可以使用以下的语句:\nsrand(time(NULL));\rint chosen = 0; // Use clock value as starting seed\rchosen = rand(); // set to a random integer 0 to RAND MAX 只需要在程序中调用一次函数srand()来生成序列。之后每次调用rand(),都会得到另一个伪随机数。上限值RAND_MAX相当大,通常是类型int可以存储的最大值。如果需要更小范围的数值,可以按比例缩小rand()的返回值,提供所需范围的值。假设要得到的数值在0到limit(不包含limit)的范围内,最简单的方法如下:\nsrand(time(NULL));\rint limit = 20;\rint chosen = 0; // Use clock value as starting seed\rchosen = rand() % limit; // 0 to limit - 1 4.6.6 再谈循环控制选项 for (int i = 1; i \u0026lt;= count; i+=2) {\r} 4.6.7 浮点类型的循环控制变量 for (double x = 1.0; x \u0026lt; 11; x += 1.0) {\rsum += 1.0/x;\r} 这种情形并不常见。注意,分数值通常没有浮点数形式的精确表示,所以不应把相等判断作为结束循环的条件,例如:\nfor (double x = 0.0; x != 2.0; x += 0.2) {\r} 这个循环应输出0.0-2.0之间的x值,其递增量为0.2,所以应该有11行输出。但0.2没有浮点数形式的二进制精确表示,所以这个循环会使计算机一直运行下去(除非在Microsoft Windows下使用Ctrl+C令它停止)。\n4.7 while 循环 while 循环 的一般语法如下：\nwhile( expression)\rstatement1;\rstatement2; while循环。在while循环中,只要某个逻辑表达式等于true,就重复执行一组语句。\n4.8 嵌套循环 有时需要将一个循环放在另一个循环里面。例如计算某条街上每间房子的居住人数。这需要进入每间房子,计算每间房子的居住人数。统计所有的房子是一个外部循环,在外部循环的每次迭代中,都要使用一个内部循环来计算居住人数。\n4.9 嵌套循环和 goto 语句 有时在这样的深层嵌套循环中,希望从最内层的循环跳到最外层循环的外面,执行最外层循环后面的语句。最内层循环中的break语句只能跳出这个最内层的循环,执行由j控制的循环。要使用break语句完全跳出嵌套循环,需要相当复杂的逻辑才能中断每一层循环,最后跳出最外层的循环。此时可以使用goto语句,因为它提供了一种避免复杂逻辑的方法。例如:\nfor (int i = 0; i \u0026lt; 10; ++i) {\rfor (int j = 0; j \u0026lt; 20; ++j) {\rfor (int k = 0; k \u0026lt; 20; ++k) {\r/* Do something useful */\rif (must escape) goto out;\r}\r}\r}\rout: 这段代码假定,可以在最内层的循环中修改 must_escape,发出应结束整个嵌套循环的信号。如果变量 must_escape 是true,就执行goto语句,直接跳到有out标志的语句。这样就可以直接退出整个嵌套循环,不需要在外部循环中进行复杂的判断。\n4.10 do-while 循环 第3种循环类型是do-while循环。既然已经有for循环和while循环了,为什么还需要这个循环? do-while和这两个循环有非常微妙的区别。它是在循环结束时测试循环是否继续,所以这个循环的语句或语句块至少会执行一次\n4.11 continue 语句 有时不希望结束循环,但要跳过目前的迭代,继续执行下一个迭代。循环体内的continue语句就有这个作用,它可以编写为:\ncontinue; 4.12 设计程序 4.12.1 问题 4.13 小节 4.14 习题 "},{"id":91,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC5%E7%AB%A0%E6%95%B0%E7%BB%84/","title":"Beginning C , Fifth Edition 第5章：数组","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第5章 数组 我们经常需要在程序中存储某种类型的大量数据值。例如,如果编写一个程序,追踪一支篮球队的成绩,就要存储一个赛季的各场分数和各个球员的得分,然后输出某个球员的整季得分,或在赛事进行过程中计算出赛季的平均得分。我们可以利用前面所学的知识编写一个程序,为每个分数使用不同的变量。然而,如果一个赛季里有非常多的赛事,这会非常繁琐,因为有球赛的每个球员都需要许多变量。所有篮球分数的类型都相同,不同的是分值,但它们都是篮球赛的分数。理想情况下,应将这些分值组织在一个名称下,例如球员的名字,这样就不需要为每个数据项定义变量了。\n本章将介绍如何在C程序中使用数组,然后探讨程序使用数组时,如何通过一个名称来引用一组数值。\n本章的主要内容:\n什么是数组 如何在程序中使用数组 数组如何使用内存 什么是多维数组 如何编写程序,计算帽子的尺寸 如何编写井字游戏 5.1 数组简介 说明数组的概念及其作用的最好方法,是通过一个例子,来说明使用数组后程序会变得非常简单。这个例子将计算某班学生的平均分数。\n5.1.1 不用数组的程序 非常麻烦\n5.1.2 什么是数组 数组是一组数目固定、类型相同的数据项,数组中的数据项称为元素。数组中的元素都是int, long或其他类型。下面的数组声明非常类似于声明一个含有单一数值的正常变量,但要在名称后的方括号中放置一个数。\nlong numbers [10]; 方括号中的数字定义了要存放在数组中的元素个数,称为数组维(array dimension)。数组有一个类型,它组合了元素的类型和数组中的元素个数。因此如果两个数组的元素个数相同、类型也相同,这两个数组的类型就相同。\n存储在数组中的每个数据项都用相同的名称访问,在这个例子中,该名称就是 numbers。要选择某个元素,可以在数组名称后的方括号内使用索引值。索引值是从0开始的连续整数。0是第一个元素的索引值,前面numbers数组的元素索引值是0-9,索引值0表示第一个元素,索引值9表示最后一个元素。因此数组元素可表示为numbers[0]numbers[1]、numbers[2] \u0026hellip;\u0026hellip;numbers[9]。\n如图5-1所示: 注意,索引值是从0开始,不是1,第一次使用数组时,这是一个常犯的错误,有时这称为off-by-one错误。在一个十元素数组中,最后一个元素的索引值是9,要访问数组中的第4个值,应使用表达式numbers[3]。数组元素的索引值是与第1个元素的偏移量。第1个元素的偏移量是0,第2个元素与第一个元素的偏移量是1,第3个元素与第一个元素的偏移量是2,依此类推。\n要访问numbers数组元素的值,也可以在数组名称后的方括号内放置表达式,该表达式的结果必须是一个整数,对应于一个可能的索引值。例如numbers[i-2]。如果i的值是3,就访问数组中的第2个元素numbers[1]。因此,有两种方法来指定索引值,以访问数组中的某个元素。其一,可以使用一个简单的整数,明确指定要访问的元素。其二,可以使用一个在执行程序期间计算的整数表达式。使用表达式的唯一限制是,它的结果必须是整数,该整数必须是对数组有效的索引值。\n注意,如果在程序中使用的索引值超过了这个数组的合法范围,程序将不能正常运作。编译器检查不出这种错误,所以程序仍可以编译,但是执行是有问题的。在最好的情况下,是从某处提取了一个垃圾值,所以结果是错误的,且每次执行的结果都不会相同。在最糟的情况下,程序可能会覆盖重要的信息,且锁死计算机,需要重启计算机。有时,这对程序的影响比较微妙:程序有时能正常工作,有时不能,或者程序看起来工作正常,但结果是错误的,只是不明显。因此,一定要细心检查数组索引是否在合法范围内。\n5.1.3 使用数组 跟 Java 一样\n#include \u0026lt;stdio.h\u0026gt;\rint main(void) {\rint grades[10];\runsigned int count = 10;\rlong sum = 0L;\rfloat average = 0.0f;\rprintf(\u0026#34;\\nEnter the 10 grades:\\n\u0026#34;);\rfor (unsigned int i = 0; i \u0026lt; count; ++i) {\rprintf(\u0026#34;%2u\u0026gt;\u0026#34;, i + 1);\rscanf(\u0026#34;%d\u0026#34;, \u0026amp;grades[i]);\rsum += grades[i];\r}\raverage = (float) sum / count;\rprintf(\u0026#34;\\nAverage of the ten grades entered is: %.2f\\n\u0026#34;, average);\rreturn 0;\r} 5.2 寻址运算符 寻址运算符 \u0026amp; 输出其操作数的内存地址。前面使用了寻址运算符 \u0026amp;,它广泛用于scanf()函数。它放在存储输入的变量名称之前, scanf()函数就可以利用这个变量的地址,允许将键盘输入的数据存入变量。只把这个变量名称用作函数的参数,函数就可以使用变量存储的值。而把寻址运算符放在变量名称之前,函数就可以利用这个变量的地址,修改在这个变量中存储的值,其原因参见第8章。下面是一些地址的例子:\n#include \u0026lt;stdio.h\u0026gt;\rint main(void){\rlong a = 1L;\rlong b = 2L;\rlong c = 3L;\rdouble d = 4.0;\rdouble e = 5.0;\rdouble f = 6.0;\rprintf(\u0026#34;%u bytes.\\n\u0026#34;, sizeof(long));\rprintf(\u0026#34;a:%p ;\\nb:%p ;\\nc:%p.\\n\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c);\rprintf(\u0026#34;%u bytes.\\n\u0026#34;, sizeof(double));\rprintf(\u0026#34;d:%p ;\\ne:%p ;\\nf:%p.\u0026#34;, \u0026amp;d, \u0026amp;e, \u0026amp;f);\r} 这个程序的输出如下：\n4 bytes.\ra:000000000064fe1c ;\rb:000000000064fe18 ;\rc:000000000064fe14.\r8 bytes.\rd:000000000064fe08 ;\re:000000000064fe00 ;\rf:000000000064fdf8. 得到什么地址取决于所使用的操作系统及编译器的分配内存方式。\n使用%u显示 sizeof 生成的值,因为它是无符号的整数。使用一个新的格式说明符 %p,来输出变量的地址。这个格式说明符指定输出一个内存地址,其值为十六进制。内存地址一般是32位或64位,地址的大小决定了可以引用的最大内存量。在本例使用的计算机上,内存地址是64位,表示为16个十六进制数;在其他机器上,这可能不同。然后,输出double变量占用的字节数,接着输出这3个变量的地址。\n事实上,程序本身不如输出那么有趣。看看显示出来的地址,地址值逐渐变小,呈等差排列,如图5-2所示。在本例使用的计算机上,地址b比a低4, c比b低4,这是因为每个long类型的变量占用4个字节。变量d、e、f也是如此,但它们的差是8,这是因为类型double的值用8个字节来存储 图5-2在变量d和c的地址之间有一个空隙。为什么?许多编译器给变量分配内存地址时,其地址都是变量字节数的倍数,所以4字节变量的地址是4的倍数, 8字节变量的地址是8的倍数。这就确保内存的访问是最高效的。本例使用的计算机在d和c之间有4字节的空隙,使d的地址是8的倍数。如果程序在c的后面定义了另一个long类型的变量,该变量就占用4字节的空隙,于是d和c之间就没有空隙了。\n注意：\n如果变量地址之间的间隔大于变量占用的字节数,可能是因为程序编译为调试版本。在调试模式下,编译器会配置额外的空间,以存储变量的其他信息,这些信息在程序以调试模式下执行时使用。\n5.3 数组和地址 下面声明了一个包含4个元素的数组:\nlong number[4]; 数组名称number指定了存储数据项的内存区域地址,把该地址和索引值组合起来就可以找到每个元素,因为索引值表示各个元素与数组开头的偏移量。\n声明一个数组时,要给编译器提供为数组分配内存所需的所有信息,包括值的类型和数组维,而值的类型决定了每个元素需要的字节数。数组维指定了元素的个数。数组占用的字节数是元素个数乘以每个元素的字节数。数组元素的地址是数组开始的地址,加上元素的索引值乘以数组中每个元素类型所需的字节数。图5-3是数组变量保存在内存中的情形。 获取数组元素地址的方式类似于普通变量。对value整数变量,可以用以下语句输出它的地址:\nprintf(\u0026#34;\\n%p\u0026#34;,\u0026amp;value); 要输出number数组的第3个元素的地址,可以编写如下代码:\nprintf(\u0026#34;\\n%p\u0026#34;,\u0026amp;value[2]); 下面的代码段设置了数组中的元素值,然后输出了每个元素的地址和内容:\nint data[5]\rfor (unsigned int i = 0; i \u0026lt;= 5; ++i) {\rdata[i] = 12*(i+1);\rprintf(\u0026#34;data[%d] address:%p contents:%d\\n\u0026#34;,i,\u0026amp;data[i],data[i]);\r} i的值显示在数组名后面的括号中。每个元素的地址都比前一个元素大4,所以每个元素占用4个字节。\n5.4 数组的初始化 当然,可以给数组的元素指定初值,这可能只是为了安全起见。预先确定数组元素的初始值,更便于查找错误。为了初始化数组的元素,只需在声明语句中,在大括号中指定一列初值,它们用逗号分开,例如:\ndouble values[5] = {1.5,2.5,3.5,4.5,5.5}; 这个语句声明了一个包含5个元素的数组value, values[0]的初值是1.5, value[1]的初值是2.5,依此类推。要初始化整个数组,应使每个元素都有一个值。如果初值的个数少于元素数,没有初值的元素就设成0。因此如果编写\ndouble values[5] = {1.5,2.5,3.5}; 前3个元素用括号内的值初始化,后两个元素初始化为0。\n如果没有给元素提供初值,编译器就会给它们提供初值0,所以初值提供了一种把整个数组初始化为0的简单方式。只需要给一个元素提供0:\ndouble values[5] = {0.0}; 整个数组就初始化为0.0.\n如果初值的个数超过数组元素的个数,编译器就会报错。在指定一列初始值时,不必提供数组的大小,编译器可以从该列值中推断出元素的个数:\ndouble values[] = {1.5,2.5,3.5}; 5.5 确定数组的大小 sizeof 运算符可以计算出指定类型的变量所占用的字节数。对类型名称应用sizeof运算符,如下:\nprintf(\u0026#34;%u bytes.\\n\u0026#34;, sizeof(long)); sizeof 运算符后类型名称外的括号是必需的。如果漏了它,代码就不会编译。也可以对变量应用 sizeof 运算符,它会计算出该变量所占的字节数。\n注意\nsizeof 运算符生成 size_t 类型的值,该类型取决于实现代码,一般是无符号的整数类型。如果给输出使用%u说明符,编译器又把size_t定义为unsigned long或者unsigned long long,编译器就可能发出警告: %u说明符不匹配print()函数输出的值。使用%zu会消除该警告消息。\nsizeof 运算符也可以用于数组。下面的语句声明一个数组:\ndouble values[] = {1.5,2.5,3.5};\rprintf(\u0026#34;%u bytes.\\n\u0026#34;, sizeof values); 也可以用表达式 sizeof values[0] 计算出数组中一个元素所占的字节数。这个表达式的值是8。当然,使用元素的合法索引值可以产生相同的结果。数组占用的内存是单个元素的字节数乘以元素个数。因此可以用sizeof运算符计算数组中元素的数目:\nsize_t element_count = sizeof values/sizeof values[0]; 执行这条语句后,变量 element_count 就含有数组 values 中元素的数量。element_count 声明为 size_t 类型,因为它是 sizeof 运算符生成的类型。可以将 sizeof 运算符应用于数据类型,所以可以重写先前的语句,计算数组元素的数量,如下所示:\nsize_t element_count = sizeof values/sizeof (double); 这会得到与前面相同的结果,因为数组的类型是double, sizeof(double)会得到元素占用的字节数。有时偶尔会使用错误的类型,所以最好使用前一条语句。\nsizeof 运算符应用于变量时不需要使用括号,但一般还是使用它们,所以前面的例子可以编写为:\n可以用 sizeof 计算出的数组元素个数 作为循环变量，防止下标越界。\n5.6 多维数组 下面介绍二维数组。二维数组可以声明如下:\nfloat carrots[3][5]; 这行语句声明了一个数组carrots,它包含3行5个浮点数元素。注意每一维都放在自己的方括号中。\n与田里的蔬菜一样,使这些数组排成矩形会比较方便。把这个数组排成3行5列,它们实际上按行顺序存储在内存中,如图5-4所示。很容易看出,最右边的索引变化地最快。在概念上,左边的索引选择一行,右边的索引选择该行中的一个元素。 图5-4也说明了如何将二维数组想象成一维数组,其中的每个元素本身是一个一维数组。可以将number数组视为3个元素的一维数组,数组中的每个元素都含有5个float类型的元素。第一行的5个float元素位于标记为numbers[0]的内存地址上,第二行的5·个foat元素位于numbers[1],最后一行的5个元素位于numbers[2]\n当然,分配给每个元素的内存量取决于数组所含的变量的类型。double类型的数组需要的内存比float或int类型的数组多。图5-5说明了数组numbers[4][10]的存储方式,该数组有4行10个float类型的元素。\n因为数组元素的类型是float,它在机器上占4个字节,这个数组占用的内存总数是4x10×4个字节,即160个字节。\n三维数组是二维数组的扩展:\nfloat carrots[4][10][20]; 这个语句声明的数组有800个元素,可以把它看作存储豆类植物的产量,豆类植物· 有三块田,每块田包含10行20列植物。根据需要,可以定义任意多维数组。\n5.7 多维数组的初始化 二维数组的初始化类似于一维数组,区别是把每一行的初始值放在大括号0中,再把所有行放在一对大括号中:\nint numbers[3][4]={\r{10,20,30,40},\r{15,25,35,45},\r{47,48,49,50}\r}; 初始化行中元素的每组值放在大括号中,所有的初始值则放在另一对大括号中。一行中的值以逗号分开,各行值也需要以逗号分开。\n如果指定的初值少于一行的元素数,这些值会从每行的第一个元素开始,依序赋予各元素,剩下未指定初值的元素则初始化为0。仅提供一个值,就可以把整个数组初始化为0:\nint numbers[3][4]={0}; 对于三维或三维以上的数组,这个过程会被扩展。例如三维数组有3级嵌套的括号,内层的括号包含每行的初始值,例如:\nint numbers[2][3][4]={\r{\r{10,20,30,40},\r{15,25,35,45},\r{47,48,49,50}\r},\r{\r{10,20,30,40},\r{15,25,35,45},\r{47,48,49,50}\r}\r}; 共 2 * 3 * 4 = 24 个元素。\n5.8 变长数组 前面的所有数组都在代码中指定了固定的长度。也可以定义其长度在程序运行期间确定的数组。下面是一个示例:\nsize_t size = 0;\rpintf(\u0026#34;输入：\u0026#34;);\rscan(\u0026#34;%zd\u0026#34;,\u0026amp;size);\rfloat values[size]; 在这段代码中,把从键盘上读取的一个值放在size中。接着使用size的值指定数组array的长度。因为sizet是用实现代码定义的整数类型,所以如果尝试使用%d读取这个值,就会得到一个编译错误。%zd中的z告诉编译器,它应用于size t,所以无论整数类型size t是什么,编译器都会使说明符适用于读取操作。\n遵循C11的编译器不必支持变长数组,因为它是一个可选特性。如果编译器不支持它,符号__STDC_ NO_VLA__ 就必须定义为1,使用下面的代码可以检查编译器是否支持变长数组:\n#ifdef __STDC_ NO_VLA__\rprintf(\u0026#34;不支持\u0026#34;);\rexit(1); 这段代码使用了第13章介绍的预处理器指令。如果定义了 STDC NO_VLA_ 符号, print()语句和后面的exit()语句就包含在程序中。如果不支持变长数组,但把这段代码放在main()的开头, printt()函数调用就会显示一个消息,并立即结束程序。\n5.9 设计一个程序 5.10 小结 5.11 习题 "},{"id":92,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC6%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E5%BA%94%E7%94%A8/","title":"Beginning C , Fifth Edition 第6章：字符串和文本的应用","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第6章：字符串和文本的应用 本章将探讨如何使用字符数组,以扩展数组知识。我们经常需要将文本字符串用作个实体,不过C语言没有提供字符串数据类型,而是使用char类型的数组元素存储字符串。本章将介绍如何创建和处理字符串变量,标准库函数如何简化字符串的处理。\n本章的主要内容:\n如何创建字符串变量 如何连接两个或多个字符串,形成一个字符串 如何比较字符串 如何使用字符串数组 哪些库函数能处理字符串,如何应用它们 6.1 什么是字符串 字符串常量的例子非常常见。字符串常量是放在一对双引号中的一串字符或符号。一对双引号之间的任何内容都会被编译器视为字符串,包括特殊字符和嵌入的空格。每次使用print()显示信息时,就将该信息定义成字符串常量了。以下的语句是用这种方法使用字符串的例子:\nprintf (\u0026#34;This is a string.\u0026#34;);\rprintf (\u0026#34;This is on\\ntwo lines!\u0026#34;);\rprintf (\u0026#34;For \\\u0026#34; you write \\\\\\\u0026#34;.\u0026#34;); 这3个字符串例子如图6-1所示。存储在内存中的字符码的十进制值显示在这些字符的下方。\n第一个字符串是一系列字符后跟一个句号。printf()函数会把这个字符串输出为:\nThis is a string. 第二个字符串有一个换行符\\n,所以字符串显示在两行上:\nThis is on\rtwo lines! ·第三个字符串有点难以理解,但print()函数的输出很清楚:\nFor \u0026#34; you write \\\u0026#34;. 必须把字符串中的双引号写为转义序列\u0026quot;,因为编译器会把双引号看作字符串的结尾。要在字符串中包含反斜杠,也必须使用转义序列\\,因为字符串中的反斜杠总是表示转义序列的开头。\n如图6-1所示,每个字符串的末尾都添加了代码值为0的特殊字符,这个字符称为空字符,写为\\0。C中的字符串总是由\\0字符结束,所以字符串的长度永远比字符串中的字符数多1。\n注意\n空字符不要和 NULL 混淆。空字符是字符串的终止符,而 NULL 是一个符号,表示不引用任何内容的内存地址。\n可以自己将 \\0 字符添加到字符串的结尾,但是这会使字符串的末尾有两个\\0字符。下面的程序说明了空字符是如何运作的:\n#include \u0026lt;stdio.h\u0026gt;\rint main(void){\rprintf (\u0026#34;This is a \\0 string.\u0026#34;);\rreturn 0;\r} 编译并执行这个程序,会得到如下输出:\nThis is a 这可不是我们期望的结果:仅显示了字符串的第一部分。这个程序显示了前两个字符后就结束输出,是因为print()函数遇到第一个空字符 \\0 时,就会停止输出。即使在字符串的末尾还有另一个 \\0,也永远不会执行它。在遇到第一个 \\0 时,就表示字符串结束了。\n6.2 存储字符串的变量 C 语言对变量存储字符串的语法没有特殊的规定,而且 C 根本就没有字符串变量,也没有处理字符串的特殊运算符。但这不成问题,因为标准库提供了许多函数来处理字符串,下面先看看如何创建表示字符串的变量。\n如本章开头所述,可以使用 char 类型的数组保存字符串。这是字符串变量的最简单式。char数组变量的声明如下:\nchar saying[20]; 这个变量可以存储一个至多包含19个字符的字符串,因为必须给终止字符提供一个数组元素。当然也可以使用这个数组存储20个字符,那就不是一个字符串了。\n警告\n声明存储字符串的数组时,其大小至少要比所存储的字符数多1,因为编译器会自动在字符串常量的末尾添加 \\0。\n也可以用以下的声明初始化前面的字符串变量:\nchar saying[] =\u0026#34;This is a string.\u0026#34;; 这里没有明确定义这个数组的大小。编译器会指定一个足以容纳这个初始化字符串常量的数值。在这个例子中它是18,其中17个元素用于存储字符串中的字符,再加上一个额外的终止字符 \\0。当然可以指定这个数值,但是如果让编译器指定,可以确保它一定正确。\n也可以用一个字符串初始化char类型数组的部分元素,例如:\nchar saying[40] =\u0026#34;To be\u0026#34;; 这里编译器会使用指定字符串的字符初始化从str0]到str[4]的前5个元素,而str[5]含有空字符\\0。当然,数组的所有40个元素都会被分配空间,可以以任意方式使用。初始化一个char数组,将它声明为常量,是处理标准信息的好方法:\nconst char message[] =\u0026#34;This is a string.\u0026#34;; 将 message 声明成常量,它就不会在程序中被显式更改。只要试图更改它,编译器都会产生错误信息。当标准信息在程序中的许多地方使用时,这种定义标准信息的方法特别有用。它可以防止在程序的其他部分意外地修改这种常量。当然,假使必须改变这条信息,就不应将它指定为 const。\n要引用存储在数组中的字符串时,只需使用数组名即可。例如,如果要用print()函数输出存储在 message 中的字符串,可以编写:\nprintf (\u0026#34;The message is:%s\u0026#34;,message); 这个 %s 说明符用于输出一个用空字符终止的字符串。函数printf()会在第一个参数的 %s 位置,输出 message 数组中连续的字符,直到遇到 \\0 字符为止。当然, char数组的执行方式与其他类型的数组一样,所以可以用相同的方式使用它。字符串处理函数唯需要特别考虑的是 \\0 字符,所以从外表看来,包含字符串的数组没有什么特别的。\n使用char数组存储许多不同的字符串时,必须用足以容纳要存储的最大字符串长度来声明数组的大小。在大多数情况下,一般的字符串都会小于这个最大值,所以确定字符串的长度是很重要的,特别是要给字符串添加更多的字符。下面用一个例子来说明:\n#include \u0026lt;stdio.h\u0026gt;\rint main(void) {\rchar str1[] = \u0026#34;To be or not to be\u0026#34;;\rchar str2[] = \u0026#34;,that is the question\u0026#34;;\runsigned int count = 0;\rwhile (str1[count] != \u0026#39;\\0\u0026#39;) {\r++count;\r}\rprintf(\u0026#34;The length of the string \\\u0026#34;%s\\\u0026#34; is %d characters.\\n\u0026#34;, str1, count);\rcount = 0;\rwhile (str2[count] != \u0026#39;\\0\u0026#39;) {\r++count;\r}\rprintf(\u0026#34;The length of the string \\\u0026#34;%s\\\u0026#34; is %d characters.\\n\u0026#34;, str2, count);\rreturn 0;\r} 字符串的多维数组 可以使用char类型的二维数组存储字符串,数组的每一行都用来存储一个字符串。这样,就可以存储一整串字符串,通过一个变量名来引用它们,例如:\nchar sayings [3][32] = {\r\u0026#34;Manners markth man.\u0026#34;,\r\u0026#34;Many hands make lightwork.\u0026#34;,\r\u0026#34;Manners markth man.\u0026#34;\r} 这条语句创建了一个数组,它包含3行,每行32个字符。括号中的字符串按顺序指定数组的3行sayings[0]、 sayings[1]和sayings[3]。注意,不需要用括号将每个字符串括起来。编译器能推断出每个字符串初始化数组的一行。第一维指定数组可以包含的字符串个数,第二维指定为32,刚好能容纳最长的字符串(包含\\0终止字符)。\n在引用数组的元素时,例如sayings[i][j],第一个索引i指定数组中的行,第二个索引j指定该行中的一个字符。要引用数组中包含一个字符串的一整行,只需在方括号中包含一个索引值。例如sayings[1]引用数组的第二个字符串, \u0026ldquo;Many hands make lightwork.\u0026quot;。\n在字符串数组中,必须指定第二维的大小,也可以让编译器计算数组有多少个字符串。上述定义可以写为:\nchar sayings [][32] = {\r\u0026#34;Manners markth man.\u0026#34;,\r\u0026#34;Many hands make lightwork.\u0026#34;,\r\u0026#34;Manners markth man.\u0026#34;\r} 因为有3个初始字符串,编译器会将数组的第一维大小指定为3。当然,还必须确保第二维的空间足以容纳最长的字符串,包含终止字符。\n6.3 字符串操作 上例说明了确定字符串长度的代码,但其实并不需要编写这样的代码。标准库提供了一个执行该操作的函数,和许多处理字符串的其他函数。要使用它们,必须把string.h 头文件包含在源文件中。\n后面面向任务的章节主要介绍C11标准引入的新字符串函数,它们比以前习惯使用的传统函数更安全、更健壮,它们提供了更强大的保护,可以防止出现缓存溢出等错误。但是,这个保护依赖仔细而正确的编码。\n6.3.1 检查对 C11 的支持 标准库提供的字符串处理函数默认集合并不安全。它们使代码包含错误的可能性很大,有时这些错误很难查找。一个较大的问题是在网络环境下使用时,它们允许恶意代码破坏程序。这些问题发生的主要原因是,无法验证数组有足够的空间执行操作。因此,C11标准包含字符串处理函数的可选版本,它们更安全、更不容易出错,因为它们会检查数组的维数,确保它们足够大。编写安全、不易出错的代码非常重要,所以这里主要介绍对数组进行边界检查的可选字符串处理函数。在我看来,任何遵循C11的编译器都应实现这些可选的字符串函数。所有的可选函数名都以s结尾。\n很容易确定C编译器附带的标准库是否支持这些可选函数。只需要编译并执行如下代码:\n#include \u0026lt;stdio.h\u0026gt;\rint main(void) {\r#if defined __STDC_LIB_EXT1__\rprintf(\u0026#34;P1\\n\u0026#34;);\r#else\rprintf(\u0026#34;P2\\n\u0026#34;);\r#endif\rreturn 0;\r} 根据C11标准实现可选函数的编译器,会定义 STDC_LIB_EXT1 符号。这段代码使用预处理器指令,根据是否定义了 STDC_LIB_EXT1 符号,插入两个printf()语句中的一个。如果定义了这个符号,代码就输出消息:\nP1 如果没有定义 STDC_LIB_EXT1 符号,代码就输出消息:\nP2 这里使用的预处理器指令(它们是以#开头的代码行)采用与if语句相同的执行方式。第13章将详细介绍预处理器指令。\n要使用string.h中的可选函数,必须在string.h的include语句之前,在源文件中定义 STDC_LIB_EXT1 符号,来表示值1,如下所示: #define STDC_LIB_EXT1 1// Make optional versions of functions available\n#define __STDC_LIB_EXT1__ 1// Make optional versions of functions available\r#include \u0026lt;string.h\u0026gt; 如果没有把这个符号定义为1,就只能使用字符串处理函数的标准集合。为什么需要这个精巧的机制,才能使用可选函数?原因是它不会中断推出C11标准之前编写的旧代码。显然,旧代码可能使用了一个或多个新函数名。尤其是,许多程序员以前都实现了自己的、更安全的字符串处理函数,这样就很容易与C11库产生名称冲突。出现这种冲突时,把 STDC_LIB_EXT1 定义为0,禁止使用可选函数,旧代码就可以用C11编译器编译了。\n6.3.2 确定字符串的长度 strnlen_s()函数返回字符串的长度,它需要两个参数:字符串的地址(这是一维char数组的数组名)和数组的大小。知道数组的大小,若字符串没有结尾的\\0字符,函数就可以避免访问最后一个元素后面的内存。\n该函数把字符串的长度返回为一个size_t类型的整数值。如果第一个参数是NULL,就返回0。如果在第二个参数值的元素个数中,第一个参数指定的数组不包含\\0字符,就返回第二个参数值,作为字符串的长度。\n#define __STDC_WANT_LIB_EXT1__ 1\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main(void) {\rchar s[] = \u0026#34;test\u0026#34;;\rprintf(\u0026#34;test:%zu\u0026#34;, strnlen(s, sizeof(s)));\rreturn 0;\r} 注意\n确定字符串长度的标准函数是strlen(),它只把字符串的地址作为参数。若字符串没有10,这个函数会越过字符串的末尾。\n6.3.3 复制字符串 strcpy_s()函数可以把一个字符串变量的内容赋予另一个字符串。它的第一个参数指定复制目标,第二个参数是一个整数,指定第一个参数的大小,第三个参数是源字符串。指定目标字符串的长度,可以使函数避免覆盖目标字符串中最后一个字符后面的内存。如果源字符串比目标字符串长,就会发生这种情形。如果一切正常,该函数就返回0,否则就返回非0整数值。下面是一个示例:\n#define __STDC_WANT_LIB_EXT1__ 1\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main(void) {\rchar s[] = \u0026#34;test\u0026#34;;\rchar s2[10];\runsigned int max = 3;\rstrncpy_s(s2, sizeof(s2), s,3);\rprintf(\u0026#34;tes:%s.\u0026#34;, s2);\rprintf(\u0026#34;test:%zu\u0026#34;, strnlen(s2, sizeof(s2)));\rreturn 0;\r} strncpy_s() 函数可以把源字符串的一部分复制到目标字符串中。在strcpy_s()函数名中添加n表示,可以至多复制指定的n个字符。前三个参数与strcpy_s()相同,第四个参数指定从第三个参数指定的源字符串中复制的最大字符数。如果在复制指定的最大字符数之前,在源字符串中找到了\\0,复制就停止,并把\\0添加到目标字符串的末尾。\n6.3.4 连接字符串 连接是把一个字符串连接到另一个字符串的尾部,这是很常见的需求。例如,把两个或多个字符串合成为一条信息。在程序中,将错误信息定义为几个基本的文本字符串,然后给它们添加另一个字符串,使之变成针对某个错误的信息。\n把一个字符串复制到另一个字符串的末尾时,需要确保操作是否安全的两个方面:第一,目标字符串的可用空间是否足够,不会覆盖其他数据,甚或代码;第二,连接得到的字符串末尾有、0字符。string.h中的可选函数strcat_s()满足这些要求。\nstrcat_s()函数需要三个参数:要添加新字符串的字符串地址,第一个参数可以存储的最大字符串长度,要添加到第一个参数中的字符串地址。该函数把一个整数错误码返回为erno_t类型的值,它是一个取决于编译器的整数类型。\n#define __STDC_WANT_LIB_EXT1__ 1\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main(void) {\rchar str1[50] = \u0026#34;to be, or not to be,\u0026#34;;\rchar str2[] = \u0026#34;that is question.\u0026#34;;\rint retval = strcat_s(str1, sizeof(str1), str2);\rprintf(\u0026#34;str1:%s\\n\u0026#34;, str1);\rchar s[] = \u0026#34;test\u0026#34;;\rchar s2[10];\runsigned int max = 3;\rstrncpy_s(s2, sizeof(s2), s,3);\rprintf(\u0026#34;tes:%s.\u0026#34;, s2);\rprintf(\u0026#34;test:%zu\u0026#34;, strnlen(s2, sizeof(s2)));\rreturn 0;\r} 字符串strl和strl连接在一起,所以这个代码段使用strcat s()把str2追加到strl上。该操作把str2复制到strl的末尾,覆盖strl中的0,再在最后添加一个1。如果一切正常,strcat s)就返回0。如果strl不够大,不能追加str2,或者有其他条件禁止该操作正确执行,返回值就非0\n与strncpy_s()一样,可选函数strncat_s()把一个字符串的一部分连接到另一个字符串上。它也有一个额外的参数,指定要连接的最大字符数。下面是其工作方式:\n警告\n不能把字符串连接到不包含字符串的数组中。如果希望使用strcats()或strncat_s()把preamble复制到joke中,就需要把joke初始化为空字符串。数组的维数在运行期间确定时,编译器就不允许在声明语句中初始化数组。要把joke初始化为空数组,可以使用赋值语句在joke[0]中存储\n注意\n终止程序时返回的任何非0值都表示异常。给异常使用不同的非0值,可以表示代\u0026quot;码中出现了异常。\n6.3.5 比较字符串 字符串库提供的函数还可以比较字符串,确定一个字符串是大于还是小于另一个字符串。字符串使用“大于”和“小于”这样的术语听起来有点奇怪,但是其结果相当简单。两个字符串的比较是基于它们的字符码,如图6-2所示,图中的字符码显示为十六进制数。\n如果两个字符串是相同的,它们就是相等的。要确定第一个字符串是小于还是大于第二个字符串,应比较两个字符串中第一对不同的字符。例如,如果第一个字符串中某字符的字符码小于第二个字符串中的对应字符,第一个字符串就小于第二个字符串。以字母次序安排字符串时,这种比较机制一般符合我们的预期。\n6.3.6 搜索字符串 头文件\u0026lt;string.h\u0026gt;声明了几个字符串搜索函数,但是在探讨它们之前,先了解下一章的主题-指针,这里需要这些基础知识,以理解如何使用字符串搜索函数。\n1. 指针的概念 每一个变量都有一个内存位置，每一个内存位置都定义了可使用 \u0026amp; 运算符访问的地址，它表示了在内存中的一个地址。\n我们将内存中字节的编号称为地址（Address）或指针（Pointer）。地址从 0 开始依次增加，对于 32 位环境，程序能够使用的内存为 4GB，最小的地址为 0，最大的地址为 0XFFFFFFFF。 数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。\n在 C 语言中，允许用一个变量来存放指针，这种变量称为指针变量。指针变量的值就是某份数据的地址，这样的一份数据可以是数组、字符串、函数，也可以是另外的一个普通变量或指针变量。\n1、定义指针变量\n定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：\ndatatype *name; datatype 表示该指针变量所指向的数据的类型，* 表示这是一个指针变量。\n2、寻址运算符 \u0026amp;\n在变量前加上寻让运算符 \u0026amp;，可以获得变量在内存中的地址。\n结合 定义指针变量 和 寻址运算符 即可完成对指针变量的定义和赋值。\nint a = 100;\rint *p_a = \u0026amp;a; 在定义指针变量 p_a 的同时对它进行初始化，并将变量 a 的地址赋予它，此时 p_a 就指向了 a。值得注意的是，p_a 作为一个变量，本身有自己的的一个地址，p_a 变量的值是 a 的地址。\n注意\n* 是一个特殊符号，在声明变量时，在变量名前加 * ，可以表明一个变量是指针变量，后边可以像使用普通变量一样直接用变量名来使用指针变量。也就是说，定义指针变量时必须带 *，给指针变量赋值时不能带 *。\n3、通过指针变量取得数据\n指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：\n*p_a; 此时：* 是取消引用运算符，其作用是访问指针指定的地址种存储的数据。 p_a 是一个 指针变量，通过 *p_a 来取得 p_a 存储的地址上的数据，例如：\n#include \u0026lt;stdio.h\u0026gt;\rint main(){\rint a = 15;\rint *p_a = \u0026amp;a;\rprintf(\u0026#34;%d, %d\\n\u0026#34;, a, *p_a); //两种方式都可以输出a的值\rreturn 0;\r} 普通变量和指针变量都是地址的助记符，程序被编译和链接后，a、p_a 被替换成相应的地址。虽然通过 *p_a 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p_a 要经过两次运算，多了一层“间接”。\n也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。\n指针除了可以获取内存上的数据，也可以修改内存上的数据，例如：\n#include \u0026lt;stdio.h\u0026gt;\rint main(){\rint a = 15, b = 99, c = 222;\rint *p = \u0026amp;a; //定义指针变量\r*p = b; //通过指针变量修改内存上的数据\rc = *p; //通过指针变量获取内存上的数据\rprintf(\u0026#34;%d, %d, %d, %d\\n\u0026#34;, a, b, c, *p);\rreturn 0;\r} 运行结果：\n99, 99, 99, 99 特殊符合 * 在不同的场景下有不同的作用：* 可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；使用指针变量时在前面加表示获取指针指向的数据，或者说表示的是指针指向的数据本身。 也就是说，定义指针变量时的和使用指针变量时的*意义完全不同。\n#define __STDC_WANT_LIB_EXT1__ 1\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main(void) {\rint Number = 25;\rint *ppNumber = \u0026amp;Number;//Number 是一个变量，用来存放整数，需要在前面加\u0026amp;来获得它的地址；\rprintf(\u0026#34;Number 变量的地址： %p\\n\u0026#34;, ppNumber);\rprintf(\u0026#34;Number 变量的值： %d\\n\u0026#34;, *ppNumber);\r} 不同数据类型的指针\nint *ip; /* 一个整型的指针 */\rdouble *dp; /* 一个 double 型的指针 */\rfloat *fp; /* 一个浮点型的指针 */\rchar *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。\n不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n2. 搜索字符串种的一个字符 函数strchr()在字符串中搜索给定的字符。它的第一个参数是要搜索的字符串(是char数组的地址),第二个参数是要查找的字符。这个函数会从字符串的开头开始搜索,返回在字符串中找到的第一个给定字符的地址。这是一个在内存中的地址,其类型为char*,表示\u0026quot;char的指针”。所以要存储这个返回值,必须创建一个能存储字符地址的变量。如果没有找到给定的字符,函数就会返回NULL,它相当于0,表示这个指针没有指向任何对象。\n函数 strchr() 的用法如下：\nchar str[] = \u0026#34;The quick brown fox\u0026#34;;\rchar ch =\u0026#39;q\u0026#39;;\rchar *pGot_char = NULL;\rpGot_char = strchr(str, ch); strchr() 函数的第一个参数是要查找的字符的地址,这里它是str的第一个元素。第二个参数是已找到的字符,这里它是char类型的ch, strchr() 函数希望其第二个参数是int类型,所以编译器在将它传给函数之前,先把ch的值转换为int类型。\nint ch = \u0026#39;q\u0026#39;; 函数经常要求将字符作为int类型参数传入,因为int类型比char类型更易用。而表·示文件尾的EOF字符是一个负整数,如果char是一个无符号类型,就不能表示负整数。图6-4说明了使用strchr() 函数搜索的结果。 在字符串中,第一个字符的地址是数组名称 str 指定的。\u0026lsquo;q\u0026rsquo;是字符串中的第5个字符,所以它的地址是str+4,与第一个字符偏移4字节。因此变量 pGot_char 将含有地址str+4.\n在表达式中使用变量名称 pGot_char 可以访问地址。如果要访问存储该地址中的字符,就必须取消对这个指针的引用。为此,在指针变量名之前使用取消引用运算符*,例如:\nprintf(\u0026#34;pGot_char:%c\\n\u0026#34;, *pGot_char); 下一章将详细介绍取消引用运算符。当然,我们要查找的字符不一定在字符串中,所以不要试图取消对NULL指针的引用,如果尝试取消NULL指针的引用,程序会崩溃。只要使用if语句就可以避免这种情况,如下:\nif (pGot_char)\rprintf(\u0026#34;pGot_char:%c\\n\u0026#34;, *pGot_char); NULL指针值转换为bool值false,非NULL指针值转换为true。如果 pGot_char 是NULL, if表达式就是false,不调用printf()语句。现在,只要变量pGot char不是NULL,就执行printf()语句。\n使用下面的代码很容易搜索一个字符的多个实例:\nchar str11[] = \u0026#34;Peter piper picked a peck of pickled pepper.\u0026#34;;\rchar ch11 = \u0026#39;p\u0026#39;;\rchar *pGot_char11 = str11;\rint count =0;\rwhile (pGot_char11 = strchr(pGot_char11, ch11)) {\r++count;\r++pGot_char11;\r}\rprintf (\u0026#34;The character \u0026#39;%c\u0026#39; was found %d times in the following string:\\n\\\u0026#34;%s\\\u0026#34;\\n\u0026#34;, ch11, count, str11); pGot_char 指针用字符串str的地址初始化。搜索在while循环条件中进行。调用 strchr() 函数,开始在 pGot_char 的地址中搜索ch,最初该地址是开始保存 str 的地方。返回值存储回pGot_char 中,所以这个值确定循环是否继续。如果找到了ch,就给 pGot_char 赋予在字符串中找到ch的地址,循环继续执行。在循环体中,递增找到字符的次数,还要递增 pGot_char ,使它包含的地址引用找到 ch 的位置后面的字符。接着下一个循环迭代从这个新地址开始搜索。strchr() 返回NULL时,循环结束。\n函数 strrchr() 基本上类似于 strchr() 的操作,其两个参数是相同的,第一个是要搜索的字符串的地址,第二个参数是要查找的字符。但 strrchr() 从字符串的末尾开始查找字符。因此,它返回字符串中的最后一个给定字符的地址,如果找不到给定字符,就返回NULL.\n3. 在字符串种查找子字符串 strstr() 函数是所有搜索函数中最有用的函数,它查找一个字符串中的子字符串,返回找到的第一个子字符串的位置指针。如果找不到匹配的子字符串,就返回NULL,所以如果返回值不是NULL,就说明这个函数找到了所需的子字符串。这个函数的第一个参数是要搜索的字符串,第二个参数是要查找的子字符串。下面有一个使用 strstr() 函数的例子:\nchar text[] = \u0026#34;Every dog has his day\u0026#34;;\rchar word[] =\u0026#34;dog\u0026#34;;\rchar *pFound = NULL;\rpFound = strstr(text, word); 这些语句在字符串 text 中寻找 word 中包含的子字符串。字符串\u0026quot;dog\u0026quot;出现在text的第7个位置,所以pFound设定为地址text+6,这个搜索是区分大小写的,所以如果在text字符串中查找的是\u0026quot;Dog\u0026rdquo;,就找不到匹配的子字符串。\n6.3.7 单元化字符串 标记是字符串中用某些预定义界定符界定的一个字符序列。例如,把这个句子看作,一个字符串,则单词用空格、逗号和句点来界定。\n把句子分解为单词称为语汇单元化(tokenizing),标准库提供了 strtok() 函数,来单元化字符串。它需要两个参数:要单元化的字符串,和包含所有可能的界定符的字符串。也有一个可选的单元化函数strtok_s(),它使用起来比标准函数更安全,所以这里会描述其工作方式。因为它是一个可选的标准函数,所以需要把_STDC_WANT_LIB_EXT1__ 符号定义为1,才能使用它。\nstrtok_s() 的工作方式有点复杂,因为它允许多次调用函数,在单个字符串中连续查找界定符。这里先解释必须提供的参数,再解释函数的操作。\nstrtok_s() 函数需要4个参数:\nstr:要单元化的字符串的地址。执行第一次单元化后,对同一个字符串执行第二次和后续的单元化操作时,这个参数就是NULL str-size:包含数组长度的整数变量的地址,在该数组中存储了第一个参数。在当前搜索后,函数会更新这个参数,使之存储字符串中要单元化的剩余字符数。 delimiters:包含所有可能界定符的字符串的地址。 pptr:指向char*型变量的指针,函数在该变量中存储信息,允许在找到第一个标记后,继续搜索标记。 注意\n指向char型变量的指针是char**类型,详见下一章。当然,对于char型的变量ptr,指向它的指针是\u0026amp;ptr.\n该函数返回char*类型的指针,指向标记的第一个字符,如果没有找到标记,就指向NULL,这表示字符串为空,或者只包含界定符。搜索多个标记时, strtok_s() 的操作如下:\n(1)在第一次调用函数时,若str不是NULL,就搜索str,找到第一个不是界定符的字符。如果没有找到该字符,就说明字符串中没有标记,函数就返回NULL。如果找到了非界定符,函数就在后续字符中搜索界定符。找到界定符后,就用\\0替代它,终止标记,然后再次调用函数,把NULL作为第一个参数,来查找另一个标记。\n(2)在搜索给定字符串的第二次和后续调用中,第一个参数必须是NULL,第二和第四个参数必须是第一次函数调用时使用的相同参数。如果知道自己在做什么,就可以提供不同的delimiters字符串参数。函数从str中插入上一个\\0的位置开始搜索非界定符如果没有找到该字符,就返回NULL,如果找到了,就搜索str中的后续字符,查找delimiters中的界定符。如果找到了界定符,就用 替代它,终止标记。然后再次调用限数,把NULL作为第一个参数,来查找另一个标记。\n如果仍不明白strtok_s() 的操作,可以看看下面的示例。但要使用它处理从键盘输入·的文本,需要一种读取一串字符的方式。stdio.h中的gets_s()就可以实现该功能。这是一个可选函数,因为它替代了gets(), gets()现在是一个废弃的函数,不应使用它。\ngets_s()函数需要两个参数,第一个是数组str的地址,该数组包含要存储的字符,第二个参数是数组的大小。该函数至多从键盘上读取比数组长度小1个字符,包括空格。如果在str中存储了最大字符数后,又输入了更多的字符,就会舍弃它们。按下回车键会终止输入。函数在读取的最后一个字符后面添加\\0。如果只按下回车键,而没有输入字符, str[0]就设置为10。如果一切正常, gets_s()就返回str,否则返回NULL。下面的示例会演示其工作方式,它单元化了输入的文本。\n6.3.8 将换行符读入字符串 程序 6.7 有一个问题。每行输入通过按下回车键来终止,这会输入一个换行符,但gets_s()没有把它存储在输入数组中。这意味着,如果不在一行的末尾或下一行的开头添加空格,一行中的最后一个单词就会与下一行中的第一个单词连接起来,但它们都是独立的单词。这会使输入过程非常不自然。使用fgets()函数可以更好地实现输入过程,该函数在输入的字符串中存储换行符,来结束输入过程。这是一个很常用的输入函数,可以用于读取文件和读取键盘输入。文件输入和输出参见第12章。\nfgets()函数需要3个参数:输入数组str的地址、要读取的最大学符数(通常是str的学符串长度)和输入源(对于键盘,它是stdin)。该函数至多读取第二个参数指定的字符数-1个字符,并追加\\0。按下回车键会在str中存储n,这会结束输入操作,还存储一个0,来结束字符串。程序 6.7 的修订版本演示了这个函数。\n6.4 分析和转换字符串 如果需要检查字符串内部的内容,可以使用在头文件\u0026lt;ctype.h\u0026gt;(详见第3章)中声明,的标准库函数。这些都是非常灵活的分析函数,可以测试有什么样的字符。它们还独立于计算机上的字符码。表6-1中的函数可以测试各种不同的字符种类。\n6.4.1 转换字符的大小写形式 6.4.2 将字符串转换成数值 6.5 设计一个程序 6.5.1 问题 开发一个程序,从键盘上读取任意长度的一段文本,确定该文本中每个单词的出现频率(忽略大小写)。该段文本的长度不完全是任意的,因为我们要给程序中的数组大小指定一个限制,但可以使该数组存储任意大小的文本。\n6.5.2 分析 6.5.3 解决方案 6.6 小结 6.7 习题 "},{"id":93,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC7%E7%AB%A0%E6%8C%87%E9%92%88/","title":"Beginning C , Fifth Edition 第7章：指针","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第 7 章：指针 第 6 章已提到过指针,还给出使用指针的提示。本章深入探索这个主题,了解指针的功用。本章将介绍许多新概念,所以可能需要多次重复某些内容。本章很长,需要花一些时间学习其内容,用一些例子体验指针。指针的基本概念很简单,但是可以应用它们解决复杂的问题。指针是用C语言高效编程的一个基本元素。\n本章的主要内容:\n指针的概念及用法 指针和数组的关系 如何将指针用于字符串 如何声明和使用指针数组 如何编写功能更强的计算器程序 7.1 指针初探 指针是 C 语言中最强大的工具之一,它也是最容易令人困惑的主题,所以一定要在开始时正确理解其概念,在深入探讨指针时,要对其操作有清楚的认识。\n第 2 和第 5 章讨论内存时,谈到计算机如何为声明的变量分配一块内存。在程序中使用变量名引用这块内存,但是一旦编译执行程序,计算机就使用内存位置的地址来引用它。这是计算机用来引用“盒子(其中存储了变量值)\u0026ldquo;的值。\n请看下面的语句:\nint number = 5; 这条语句会分配一块内存来存储一个整数,使用 number 名称可以访问这个整数。值 5 存储在这个区域中。计算机用一个地址引用这个区域。存储这个数据的地址取决于所使用的计算机、操作系统和编译器。在源程序中,这个变量名是固定不变的,但地址在不同的系统上是不同的。\n可以存储地址的变量称为指针(pointers),存储在指针中的地址通常是另一个变量,如图7-1所示。指针 pnumber 含有另一个变量 number 的地址,变量 number 是一个值为 99 的整数变量。存储在 pnumber 中的地址是 number 第一个字节的地址。“指针”这个词也用于表示一个地址,例如\u0026quot;strcat_s()函数返回一个指针\u0026rdquo;。\n首先,知道变量 pnumber 是一个指针是不够的,更重要的是,编译器必须知道它所指的变量类型。没有这个信息,根本不可能知道它占用多少内存,或者如何处理它所指的内存的内容。char 类型值的指针指向占有一个字节的值,而 long 类型值的指针通常指向占有4个字节的值。因此,每个指针都和某个变量类型相关联,也只能用于指向该类型的变量。所以如果指针的类型是 int,就只能指向 int 类型的变量,如果指针的类型是 float,就只能指向 float 类型的变量。一般给定类型的指针写成 type*,其中 type 是任意给定的类型。\n每个指针都和某个变量类型相关联\n类型名 void 表示没有指定类型,所以 void* 类型的指针可以包含任意类型的数据项地址。类型 void* 常常用做参数类型,或以独立于类型的方式处理数据的函数的返回值类型。任意类型的指针都可以传送为 void* 类型的值,在使用它时,再将其转换为合适的类型。例如, int 类型变量的地址可以存储在 void* 类型的指针变量中。要访问存储在 void* 指针所指地址中的整数值,必须先把指针转换为 int* 类型。本章后面介绍的 malloc() 库函数分配在程序中使用的内存,返回 void* 类型的指针。\n7.1.1 声明指针 以下语句可以声明一个指向 int 类型变量的指针:\nint *pnumber; pnumber 变量的类型是 int *,它可以存储任意 int 类型变量的地址。该语句还可以写作:\nint* pnumber; 这条语句的作用与上一条语句完全相同,可以使用任意一个,但最好始终使用其中的一个。\n这条语句创建了 pnumber 变量,但没有初始化它。未初始化的指针是非常危险的,比未初始化的普通变量危险得多,所以应总是在声明指针时对它进行初始化。重写刚才的声明,初始化 pnumber ,使它不指向任何对象:\nint *pnumber = NULL; NULL 是在标准库中定义的一个常量,对于指针它表示 0,NULL 是一个不指向任何内存位置的值。这表示,使用不指向任何对象的指针,不会意外覆盖内存。NULL 在头文件\u0026lt;stddef.h\u0026gt;. \u0026lt;stdib.h\u0026gt;、 \u0026lt;stdio.h\u0026gt;、\u0026lt;string.h\u0026gt;、\u0026lt;time.h\u0026gt;、\u0026lt;wchar.h\u0026gt;和\u0026lt;locale.h\u0026gt;中定义,只要编译器不能识别NULL,就应在源文件中包含\u0026lt;stddef.h\u0026gt;头文件。\n如果用已声明的变量地址初始化 pointer 变量,可以使用寻址运算符\u0026amp;,例如:\nint number = 99;\rint *pnumber = \u0026amp;number; pnumber 的初值是 number 变量的地址。注意, number 的声明必须在 pnumber 的声明之前。否则,代码就不能编译。编译器需要先分配好空间,才能使用 number 的地址初始化 pnumber 变量。\n指针的声明没有什么特别之处。可以用相同的语句声明一般的变量和指针,例如:\ndouble value,*pVal,fnum; 这条语句声明了两个双精度浮点数变量 value 和 fnum,以及一个指向 double 的变量 pVal,从该语句中可以看出,只有第2个变量 pVal 是指针,考虑如下语句:\nint *p,q; 上述语句声明了一个指针p和一个变量q,两者都是int类型。把p和q都当做指针是一个很常见的错误。\n7.1.2 通过指针访问值 使用间接运算符*可以访问指针所指的变量值。这个运算符也称为取消引用运算符(dereferencing operator),因为它用于取消对指针的引用。假设声明以下的变量:\nint number = 15;\rint *pointer = \u0026amp;number;\rint result =0; pointer 变量含有 number 变量的地址,所以可以在表达式中使用它计算 result 的新值,如下:\nint result =*pointer + 5; 表达式 *pointer 等于存储在 pointer 中的地址的值。这是存储在 number 中的值 15,所以 result 是15+5,等于20.\n理论先讲到这里。下面的小程序将凸显指针变量的某些特性。\n间接运算符*也是乘的符号,还可以用于指定指针类型。编译器不会混淆它们。编译器会根据星号出现的位置确定它是间接运算符还是乘号,还是类型指定语句的一部分。上下文决定了它的含义.\n图7-2说明了指针的用法。这里指针的类型是char*,即指向char的指针。pChar变量只能存储char本例的地址。存储在c中的值通过指针来修改。\n#include \u0026lt;stdio.h\u0026gt;\rint main(void) {\rint number = 0;\r// pnumber 变量是个指针变量\rint *pnumber = NULL;\rnumber = 10;\rprintf(\u0026#34;number\u0026#39;s address: %p\\n\u0026#34;, \u0026amp;number);\rprintf(\u0026#34;number\u0026#39;s value: %d\\n\\n\u0026#34;, number);\rpnumber = \u0026amp;number;\r// pnumber 变量的地址\rprintf(\u0026#34;pnumber\u0026#39;s address: %p\\n\u0026#34;, (void *) \u0026amp;pnumber);\r// pnumber 变量的大小\rprintf(\u0026#34;pnumber\u0026#39;s size: %zd bytes\\n\u0026#34;, sizeof(pnumber));\r// pnumber 变量存储的值（另一个变量 number 的地址）\rprintf(\u0026#34;pnumber\u0026#39;s value: %p\\n\u0026#34;, pnumber);\r// 通过 取消引用运算符 获得 pnumber 变量存储的地址的变量的值\rprintf(\u0026#34;value pointed to: %d\\n\u0026#34;, *pnumber);\rreturn 0;\r} 7.1.3 使用指针 可以通过指针 pnumber 访问 number 的内容,所以可以在算术语句中使用取消引用的指针,例如:\n*pointer += 25; 上述语句将变量 pnumber 所指向的地址中的值增加 25。星号 * 表示访问 pnumber 变量所指向的内容。这里它是变量 number 的内容。变量 pnumber 能存储任何 int 变量的地址。这表示可以用下面的语句改变 pnumber 指向的变量:\nint value =999;\rpnumber= \u0026amp;value; 重复之前的语句:\n*pointer += 25; 该语句操作的是新的变量 value, value 的新值是1024,这表示指针可以包含同一类型的任意变量的地址,所以使用一个指针变量可以改变其他许多变量的值,只要它们的类型与指针相同。\n7.1.4 指向常量的指针 可以改变指针中存储的地址,但不允许使用指针改变它指向的值。\nint main(void) { long value = 9999L; const long *pvalue = \u0026amp;value; // *pvalue = 8888L; // 只读变量不可赋值 value = 7777L; // pvalue 指向的值不能改变,但可以对 value 进行任意操作。 long number = 8888L; pvalue = \u0026amp;number; // 指针本身不是常量 /* * 指向常量的指针 * 可以改变指针中存储的地址,但不允许使用指针改变它指向的值 * */ return 0; } 声明指针时,可以使用const关键字指定,该指针指向的值不能改变。下面是声明const指针的例子:\nlong value = 9999L;\rconst long *pvalue = \u0026amp;value; // Defines a pointer to a constant 把 pvalue 指向的值声明为 const,所以编译器会检查是否有语句试图修改 pvalue 指向的值,并将这些语句标记为错误。例如,下面的语句就会让编译器生成一条错误信息:\n*pvalue = 8888L;// Error - attempt to change const location pvalue 指向的值不能改变,但可以对 value 进行任意操作。\nlong value =7777L; 改变了 pvalue 指向的值,但不能使用 pvalue 指针做这个改变。当然,指针本身不是常量,所以仍可以改变它指向的值:\nlong number =8888L;\rpvalue = \u0026amp;number;// OK-changing the address in pvalue 这会改变指向 number 的 pvalue 中的地址,仍然不能使用指针改变它指向的值。可以改变指针中存储的地址,但不允许使用指针改变它指向的值。\n7.1.5 常量指针 当然,也可以使指针中存储的地址不能改变。此时,在指针声明中使用const关键字的方式略有区别。下面的语句可以使指针总是指向相同的对象:\nint count = 43;\rint *const pcount =\u0026amp;count;// Defines a constant pointer 第二条语句声明并初始化了 pcount ,指定该指针存储的地址不能改变。编译器会检查代码是否无意中把指针指向其他地方,所以下面的语句会在编译时生成一条错误信息:\nint count = 43;\rint *const pcount =\u0026amp;count;// Defines a constant pointer\rint item = 34;\rpcount =\u0026amp;item; 但使用 pcount,仍可以改变 pcount 指向的值:\n*pcount =345; 这条语句通过指针引用了存储在 count 中的值,并将其改为 345。还可以直接使用 count 改变这个值。\n可以创建一个常量指针,它指向一个常量值:\nint item =25;\rconst int *const pitem = \u0026amp;item; pitem 是一个指向常量的常量指针,所以所有的信息都是固定不变的。不能改变存储在 pitem 中的地址,也不能使用 pitem 改变它指向的内容。但仍可以直接修改 item 的值。如果希望所有的信息都固定不变,可以把 item 指定为 const.\nconst long *pvalue long const *pvalue\n可以改变指针中存储的地址,但不允许使用指针改变它指向的值。\nint *const pcount\n指针中存储的地址不能改变\nconst int *const pitem\n所以所有的信息都是固定不变的。不能改变存储在 pitem 中的地址,也不能使用 pitem 改变它指向的内容\nconst 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。\n7.1.6 指针的命名 我们已经开始编写相当大的程序了。程序越来越大,就越难记住哪个是一般变量,哪个是指针。因此,最好将p作为指针名的第一个字母。如果严格遵循这个命名方法,肯定很清楚哪个变量是指针。\n7.2 数组和指针 下面复习一下什么是数组,什么是指针:\n数组是相同类型的对象集合,可以用一个名称引用。例如,数组scores[50]可以含有 50 场篮球季赛的比分。使用不同的索引值可以引用数组中的每个元素。scores[0]是第一个分数, scores[49]是最后一个分数。如果每个月有 10 场比赛,就可以使用多维数组scores[12][10]。如果一月开始比赛,则五月的第3场比赛用scores[5][2]引用。 指针是一个变量,它的值是给定类型的另一个变量或常量的地址。使用指针可以在不同的时间访问不同的变量,只要它们的类型相同即可。 数组和指针似乎完全不同,但它们有非常密切的关系,有时还可以互换。下面考虑字符串。字符串是char类型的数组。如果用scanf_s()输入一个字符,可以使用如下语句:\nchar single =0;\rscanf_s(\u0026#34;%c\u0026#34;, \u0026amp;single, sizeof (single) ); 这里, scanf_s() 需要将寻址运算符\u0026amp;用于single,因为scanf_s()需要存储输入数据的地址;否则它就不能修改地址。然而,如果读入字符串,可以编写如下代码:\nchar multiple [10];\rscanf_s(\u0026#34;%s\u0026#34;, multiple, sizeof (multiple)); 这里不需要使用\u0026amp;运算符,而使用了数组名称,就像指针一样。如果以这种方式使用数组名称,而没有带索引值,它就引用数组的第一个元素的地址。但数组不是指针,它们有一个重要区别:可以改变指针包含的地址,但不能改变数组名称引用的地址。\n下面通过几个例子来了解数组和指针如何一起使用。这些例子串在一起,构成一个完整的练习。通过这些练习,很容易掌握指针的基本概念及其和数组的关系。\n,这个例子进一步说明了,数组名称本身引用了一个地址,执行以下程序:\n// Program 7.4 Arrays and pointers #include \u0026lt;stdio.h\u0026gt; int main (void){ char multiple[] =\u0026#34;My string\u0026#34;; char *p = \u0026amp;multiple [0]; printf (\u0026#34;The address of the first array element : %p\\n\u0026#34;, p); p = multiple; printf (\u0026#34;The address obtained from the array name: p\\n\u0026#34;, multiple); return o; } 在某台计算机上的输出如下所示:\nThe address of the first array element : 000000000012ff06 The address obtained from the array name: 000000000012ff06 可以从这个程序的输出中得到一个结论: \u0026amp;multiple[0]会产生和multiple表达式相同的值。这正是我们期望的,因为multiple等于数组第一个字节的地址, \u0026amp;multiple[0]等于数组第一个元素的第一个字节,如果它们不同,才令人惊讶。如果p设置为multiple,而multiple的值与\u0026amp;multiple[0]相同,那么p+1等于什么。试试下面的例子。\n// Program 7.5 Incrementing a pointer to an array #define __STDC_WANT_LIB_EXT1__ 1\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main (void){\rchar multiple[] =\u0026#34;a string\u0026#34;;\rchar *p = multiple;\rfor(int i=0; i \u0026lt; strnlen s(multiple, sizeof (multiple)) ; ++i)\rprintf (\u0026#34;multiple[%d] =c *(p+%d) = %c \u0026amp;multiple [%d] = %p p+%d=%p\\n\u0026#34;,i, multiple[i], i, *(p+i), i, amultiple[i], i, p+i);\rreturn 0;\r} 输出如下所示:\nmultiple [0] = a *(p+0) =\u0026amp;multiple[0] = 000000000012feff p+0 = 000000000012feff\rmultiple [1] = *(p+1) =\u0026amp;multiple[1] = 000000000012ff00 p+1 = 000000000012ff00\rmultiple [2] = s *(p+2) =\u0026amp;multiple[2] = 000000000012ff01 p+2 = 000000000012ff01\rmultiple [3] = t *(p+3) =\u0026amp;multiple[3] = 000000000012ff02 p+3 = 000000000012ff02\rmultiple [4] = r *(p+4) =\u0026amp;multiple[4] = 000000000012ff03 p+4 = 000000000012ff03\rmultiple [5] = I *(p+5) =\u0026amp;multiple[5] = 000000000012ff04 p+5 = 000000000012ff04\rmultiple [6] = n *(p+6) =\u0026amp;multiple[6] = 000000000012ff05 p+6 = 000000000012ff05\rmultiple [7] = g *(p+7) =\u0026amp;multiple[7] = 000000000012ff06 p+7 = 000000000012ff06 注意输出中右边的地址列表。p 设置为 multiple 的地址, p+n 就等于 multiple + n ,所以 multiple[n] 与 *(multiple+n) 是相同的。地址加上了 1,对于元素占用一个字节的数组来说,这正是我们期望的。从输出的两列中可以看出, *(p+n)是给p中的地址加上整数 n,再对得到的地址取消引用,就计算出了 与multiple[n]相同的结果。\n试试看不同类型的数组\n// Program 7.5 Incrementing a pointer to an array #include \u0026lt;stdio.h\u0026gt;\rint main (void){\rlong multiple[] = {15L,25L,35L,45L};\rlong *p = multiple;\rfor (int i=0; i \u0026lt; sizeof (multiple) /sizeof (multiple[0]) ; ++i)\rprintf (\u0026#34;address p+%d (\u0026amp;multiple[%d]) : %llu * (p+%d) value: %d\\n\u0026#34;, i, i, (unsigned long long) (p+i), i, *(p+i));\rprintf (\u0026#34;\\n Type long occupies: %d bytes\\n\u0026#34;, (int) sizeof (1ong));\rreturn 0;\r} 输出如下所示:\naddress p+0 (\u0026amp;multiple [0]): 1244928 * (p+0) value: 15 address p+1 (\u0026amp;multiple [1]): 1244932 * (p+1) value: 25 address p+2 (\u0026amp;multiple [2]): 1244936 * (p+2) value: 35 address p+3 (\u0026amp;multiple [3]): 1244940 * (p+3) value: 45 Type long occupies: 4 bytes 这次,指针 p 设置为 multiple 的地址,而 multiple 是 long 类型的数组。该指针最初包含数组中第一个字节的地址,也就是元素 multiple[0] 的第一个字节。这次地址转换为 unsigned long long 后,用%llu转换说明符显示,所以它们都是十进制值,这将易于看出后续地址的区别。\n注意看输出。在这个例子中, p 是 1244928, p+1 是 1244932 ,而 1244932 比 1244928 大 4,但我们仅给p加上了 1,这并没有错。编译器知道,给地址值加 1 时,就表示要访问该类型的下一个变量。这就是为什么声明一个指针时,必须指定该指针指向的变量类型。char 类型存储在一个字节中, long 变量一般占用4个字节。在计算机上声明为 long 的变量占4个字节,给 long 类型的指针加 1,结果是给地址加 4,因为 long 类型值占 4 个字节。如果计算机在 8 个字节中存储 long 类型,则给指向 long 的指针加 1,会给地址值加 8.\n这个循环可以执行,因为表达式 multiple 和 multiple+i 都等于一个地址。我们输出这些地址的值,再使用*运算符输出这些地址存储的值。地址的算术运算规则与指针p相同。给 multiple 加1,会得到数组中下一个元素的地址,即内存中 multiple 后面的 4 个字节。但注意,数组名称是一个固定的地址,而不是一个指针。可以在表达式中使用数组名及其引用的地址,但不能修改它。\n7.3 多维数组 前面讨论的都是一维数组与数组的关系,二维或多维数组是否相同?它们在某种程度上是相同的。然而,指针和数组名称之间的差异变得更为明显。考虑第5章末尾在井字程序中使用的数组。数组声明如下:\nchar board [3] [3] ={\r{\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#34;},\r{\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;},\r{\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}\r}； 二维数组和指针\n// Program 7.7 Two-dimensional arrays and pointers #include \u0026lt;stdio.h\u0026gt;\rint main (void){\rchar board [3] [3] ={\r{\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#34;},\r{\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;},\r{\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}\r};\rprintf (\u0026#34;address of board: %p\\n\u0026#34;, board);\rprintf (\u0026#34;address of board [0] [0] : %p\\n\u0026#34;, \u0026amp;board [0] [0]);\rprintf (\u0026#34;value of board[0]: %p\\n\u0026#34;, board [0]);\rreturn 0;\r} 输出如下所示:\naddress of board: 000000000012ff07\raddress of board[0] [0] : 000000000012ff07 value of board[0]: 000000000012ff07 看图：\n可以看到, 3个输出值都是相同的,从中可以得到什么推论?声明一维数组x[n1]时,[n1]放在数组名称之后,告诉编译器它是一个有n1个元素的数组。声明二维数组y[n1][n2]时,编译器就会创建一个大小为 n1 的数组,它的每个元素是一个大小为n2的数组.\n如第5章所述,声明二维数组时,就是在创建一个数组的数组。因此,用数组名称和一个索引值访问这个二维数组时,例如board[0],就是在引用一个子数组的地址。仅使用二维数组名称,就是引用该二维数组的开始地址,它也是第一个子数组的开始地址。\n总之, board, board[0]和\u0026amp;board[0][0]的数值相同,但它们并不是相同的东西: board是char型二维数组的地址, board[0]是char型一维子数组的地址,它是 board 的一个子数组, \u0026amp;board[0][0] 是char 型数组元素的地址。最近的加油站有61/2英里远,与帽子尺寸61/2英寸并不是一回事。也就是说,表达式 board[1] 和 board[1][0] 的地址相同。这很容易理解,因为 board[1][0] 是第二个子数组 board[1] 的第一个元素。\n但是,用指针记号获取二维数组中的值时,仍然必须使用间接运算符,但要非常小心。如果改变上面的例子,显示第一个元素的值,就知道原因了:\n// Program 7.7A Two-dimensional arrays and pointers #include \u0026lt;stdio.h\u0026gt;\rint main (void){\rchar board [3] [3] ={\r{\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#34;},\r{\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;},\r{\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}\r};\rprintf (\u0026#34;value of board [0] [0] : %c\\n\u0026#34;, board[0][0]);\rprintf (\u0026#34;value of *board[0] : %c\\n\u0026#34;, board[0]);\rprintf (\u0026#34;value of **board : %c\\n\u0026#34;, **board) ;\rreturn 0; 输出如下所示:\nvalue of board[0] [0] : 1\rvalue of *board[0] : 1 value of **board : 1 可以看到,如果使用board获取第一个元素的值,就需要使用两个间接运算符 *board .如果只使用一个,只会得到子数组的第一个元素,即 board[0] 引用的地址。多维数组和它的子数组之间的关系如图7-3所示。\n如图7-3所示,board 引用子数组中第一个元素的地址 , 而board[0]. board[1] 和 board[2] 引用对应子数组中第一个元素的地址。用两个索引值访问存储在数组元素中的值。明白了多维数组是怎么回事,下面看看如何使用 board 得到数组中的所有值。\n注意：\n尽管可以把二维数组看作一维数组的数组,但这不是在内存中布置二维数组的方式。,二维数组的元素存储为一个很大的一维数组,编译器确保可以像一维数组的数组那样访问它。\n// Program 7.8 Getting values in a two-dimensional array #include \u0026lt;stdio.h\u0026gt;\rint main (void){\rchar board [3] [3] ={\r{\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#34;},\r{\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;},\r{\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}\r};\r// List all elements of the array\rfor(int i=o ; i\u0026lt; 9 ; ++i)\rprintf (\u0026#34; board: %c\\n\u0026#34;, *(*board + i));\rreturn 0;\r} 输出如下所示:\nboard: 1 board: 2 board: 3 board: 4 board: 5 board: 6\rboard: 7 board: 8 board: 9 这个程序要注意在循环中取消引用 board 的方法:\nprintf (\u0026#34; board: %c\\n\u0026#34;, *(*board + i)); 可以看到,使用表达式 *(*board+i) 可以得到一个数组元素的值。括号中的表达式 *board+i 会得到board 数组中偏移量为 i 的元素的地址\n只使用 board,就是在使用char** 类型的地址值。取消对 board 的引用,会得到相同的地址值,但其类型是 char*,给它加i会得到一个 char* 的地址,它是内存中的第 i 个元素,即数组中的一个字符。取消对它的引用,会得到该地址中存储的内容。\n括号在这里是很重要的。省略它们会得到 board 所指向的值(即存储在 board 中的地址所引用的值)再加上 i 的值。因此,如果 i 的值是2, *board+i 会得到数组的第一个元素值加 2,我们真正想要的是将 i的值加到 board 中的地址,然后对这个新地址取消引用,得到一个值。\n下面去掉例子中的括号,看看会发生什么。改变数组的初值,使字符变成从 9 到 1.如果去掉printf()函数调用中表达式的括号:\nprintf (\u0026#34; board: %c\\n\u0026#34;, **board + i); 输出如下所示:\nboard: 9 board: :\rboard: ;\rboard: \u0026lt;\rboard: =\rboard: \u0026gt; board: ?\rboard: @ board: A 这是因为i的值加到数组 board 中的第一个元素(这个元素用表达式 **board 来访问)上。在ASCI表中,得到的字符是从9到A'.\n另外,如果使用表达式**(board+i),一样会导致错误的结果。此时, **(board+0) 指向 board[0][0],而 **(board+1) 指向 board[1][0], **(board+2) 指向 board[2][0]。如果增加的数值过大,就会访问数组以外的内存位置,因为这个数组没有第4个元素。\n7.3.1 多维数组和指针 前面通过指针的表示法用数组名称引用二维数组,现在学习使用声明为指针的变量。如前所述,这有非常大的区别。如果声明一个指针,给它指定数组的地址,就可以用该指针访问数组的成员。\n// Program 7.9 Getting values in a two-dimensional array #include \u0026lt;stdio.h\u0026gt;\rint main (void){\rchar board [3] [3] ={\r{\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#34;},\r{\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;},\r{\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;}\r};\rchar *pboard = *board; // A pointer to char\rfor(int i=o ; i\u0026lt; 9 ; ++i)\rprintf (\u0026#34; board: %c\\n\u0026#34;, *(pboard + i));\rreturn 0;\r} 输出和程序7.8相同。\n代码说明\n这里用数组中第一个元素的地址初始化指针,然后用一般的指针算术运算遍历整个数组:\nchar *pboard = *board; // A pointer to char\rfor(int i=o; i\u0026lt;9; ++i)\rprintf (\u0026#34; board: c\\n\u0026#34;, *(pboard+i)); 注意,取消了对board的引用(board),得到了需要的地址,因为board是 char* 类型,是指针的指针,是子数组 board[0] 的地址,而不是一个元素的地址(它必须是char*类型).可以用以下的方式初始化指针pboard:\nchar *pboard = *board[0][0]; 效果相同。用下面的语句初始化指针pboard:\npboard = board; 这是错误的。如果这么做,至少会得到编译器的警告,理想情况下,它根本不会编,译。严格地讲,这是不合法的,因为 pboard 和 board 有不同的间接级别。这个专业术语的意思是 pboard 指针引用的地址包含一个 char 类型的值,而 board 引用一个地址,那个地址引用另一个含有 char 类型值的地址。 board 比pboard 多了一级。因此, pboard 指针需要一个*,以获得地址中的值,而 board 需要两个*。一些编译器允许这么用,但是会给出一条警告信息。然而,这是很糟的用法,不应这么用!\n7.3.3 访问数组元素 可以使用几种方法访问二维数组的元素。表7-1列出了访问 board 数组的方法。最左列包含 board 数组的行索引值,最上面的一行包含列索引值。表中对应于给定行索引和列索引的项列出了引用该元素的各种表达式。\n7.4 内存的使用 指针是一个非常灵活且强大的编程工具,有非常广泛的应用。大多数C程序都在某种程度上使用了指针。c语言还有一个功能:动态内存分配,它依赖指针的概念,为在代码中使用指针提供了很强的激励机制,它允许在执行程序时动态分配内存。只有使用指针,才能动态分配内存\n。大多数产品程序都使用了动态内存分配。例如电子邮件客户端在检索电子邮件时,事先并不知道有多少封电子邮件,也不知道每封邮件需要多少内存。电子邮件客户端在运行期间会得到足够的内存,来管理电子邮件的数量和大小。\n第5章的一个程序计算一组学生的平均分,当时它只处理10个学生。理想情况下,该程序应能处理任意多个学生,但事先不知道要处理多少个学生,所使用的内存也不会比指定的学生分数所需的内存多。动态内存分配(dynamic memory allocation)就可以实现这个功能。可以在执行时创建足以容纳所需数据量的数组。\n在程序的执行期间分配内存时,内存区域中的这个空间称为堆(heap),还有另一个内存区域,称为堆栈(stack),其中的空间分配给函数的参数和本地变量。在执行完该函数后,存储参数和本地变量的内存空间就会释放。堆中的内存是由程序员控制的。如本章后面所述,在分配堆上的内存时,由程序员跟踪所分配的内存何时不再需要,并释放这些空间,以便于以后重用它们。\n7.4.1 动态内存分配：malloc()函数 第5章提到,可以利用变量指定数组的维,在运行期间创建数组。也可以在允许期间明确地分配内存。在运行时分配内存的最简单的标准库函数是 malloc() 。使用这个函数时,需要在程序中包含头文件\u0026lt;stdlib.h\u0026gt;。使用 malloc() 函数需指定要分配的内存字节数作为参数。这个函数返回所分配内存的第一个字节的地址。因为返回的是一个地址,所以这里必须使用指针。\n动态内存分配的一个例子如下:\nint *pNumber = (int*)malloc(100); 这条语句请求100个字节的内存,并把这个内存块的地址赋予 pNumber ,只要不修改它,任何时间使用这个变量 pNumber,它都会指向所分配的 100 个字节的第一个 int 的位置。这个内存块能保存25个 int 值,每个 int 占4个字节。这个语句假定 int 需要4个字节,最好删除这个假定,而编写如下语句:\nint *pNumber = (int*) malloc (25*sizeof(int)); 现在 malloc() 的参数清晰地指定,应分配足以容纳 25 个 int 值的内存。\n注意,类型转换 (int*) 将函数返回的地址转换成 int 类型的指针。这么做是因为 malloc() 是一般用途的函数,可为任何类型的数据分配内存。这个函数不知道要这个内存做什么用,所以它返回的是一个 void 类型的指针,写成 void*。类型 void* 的指针可以指向任意类型的数据,然而不能取消对 void 指针的引用,因为它指向未具体说明的对象。许多编译器会把 malloc() 返回的地址自动转换成赋值语句左边的指针类型,但加上显式类型转换指令是无害的。\n注意：\n只要可能,编译器就总是把赋予语句中右操作数的表达式值转换为左操作数中存储它所需的类型。\n可以请求任意数量的字节,字节数仅受制于计算机中未用的内存以及 malloc() 的运用场合。如果因某种原因而不能分配请求的内存, malloc() 会返回一个 NULL 指针。这个指针等于0。最好先用 if 语句检查请求动态分配的内存是否已分配,再使用它。就如同金钱,没钱又想花费,会带来灾难性的后果。因此,应编写如下语句:\nint *pNumber = (int*) malloc (25*sizeof(int));\rif (!pNumber) {\r// Code to deal with memory allocation failure ...处理内存分配失败的代码…\r} 现在,至少可以显示一条信息,然后中止程序。这比允许程序继续执行,使之使用 NULL 地址存储数据导致崩溃要好得多。然而,在某些情况下,可以释放在别的地方使用的内存,以便程序有足够的内存继续执行下去。\n7.4.2 释放动态分配的内存 在动态分配内存时,应该总是在不需要该内存时释放它们。堆上分配的内存会在程序结束时自动释放,但最好在使用完这些内存后立即释放,甚至是在退出程序之前,也应立即释放。在比较复杂的情况下,很容易出现内存泄漏。当动态分配了一些内存时,没有保留对它们的引用,就会出现内存泄漏,此时无法释放内存。这常常发生在循环内部,由于没有释放不再需要的内存,程序会在每次循环迭代时使用越来越多的内存,最终占用所有内存。\n当然,要释放动态分配的内存,必须能访问引用内存块的地址。要释放动态分配的内存,而该内存的地址存储在 pNumber 指针中,可以使用下面的语句:\nfree(pNumber);\rpNumber = NULL; free()函数的形参是void *类型,所有指针类型都可以自动转换为这个类型,所以可以把任意类型的指针作为参数传送给这个函数。只要pNumber包含分配内存时返回的地址,就会释放所分配的整个内存块,以备以后使用。在指针指向的内存释放后,应总是把指针设置为NULL.\n警告：\n在释放指针指向的堆内存时,必须确保它不被另一个地址覆盖。\n如果给 free() 函数传送一个空指针,该函数就什么也不做。应避免两次释放相同的内存区域,因为在这种情况下, free() 函数的操作是不确定的,因此也就无法预料。如果多个指针变量引用已分配的内存,就有可能两次释放相同的内存,所以要特别小心。\n7.4.3 用 calloc() 函数分配内存 在\u0026lt;stdlib.h\u0026gt;头文件中声明的 calloc() 函数与 malloc() 函数相比有两个优点。第一,它把内存分配为给定大小的数组,第二,它初始化了所分配的内存,所有的位都是0。calloc() 函数需要两个参数:数组的元素个数和数组元素占用的字节数,这两个参数的类型都是 size_t 。该函数也不知道数组元素的类型,所以所分配区域的地址返回为void*类型。\n下面的语句使用 calloc() 为包含75个int元素的数组分配内存:\nint *pNumber = (int*) calloc (75, sizeof (int)); 如果不能分配所请求的内存,返回值就是 NULL ,也可以检查分配内存的结果,这,非常类似于 malloc(),但calloc()分配的内存区域都会初始化为0。当然,可以让编译器执行类型转换:\nint *pNumber = calloc (75, sizeof (int)); 后面的代码省略了这个类型转换。\n将程序7.11改为使用 calloc() 代替 malloc() 来分配需要的内存,只需要修改一条语句。.其他代码不变:\n7.4.4 扩展动态分配的内存 realloc() 函数可以重用或扩展以前用 malloc() 或 calloc() (或者realloc())分配的内存。realloc() 函数需要两个参数:一个是包含地址的指针,该地址以前由malloc(), calloc()或 realloc() 返回,另一个是要分配的新内存的字节数。\nrealloc() 函数分配第二个参数指定的内存量,并把第一个指针参数引用的、以前分配的内存内容传递到新分配的内存中,且所传递的内容量是新旧内存区域中较小的那一个。该函数返回一个指向新内存的 void* 指针,如果函数因某种原因失败,就返回 NULL。新扩展的内存可以大于或小于原内存。如果 realloc() 的第一个参数是 NULL,就分配第二个参数指定的新内存,所以此时它类似于 malloc() 。如果第一个参数不是NULL,但不指向以前分配的内存,或者指向已释放的内存,结果就是不确定的。\n这个操作最重要的特性是 realloc() 保存了原内存区域的内容,且保存的量是新旧内存区域中较小的那一个。如果新内存区域大于旧内存区域,新增的内存就不初始化,而是包含垃圾值。\n下面是使用动态分配的内存的基本规则:\n避免分配大量的小内存块。分配堆上的内存有一些系统开销,所以分配许多小的内存块比分配几个大内存块的系统开销大。 仅在需要时分配内存。只要使用完堆上的内存块,就释放它。 总是确保释放已分配的内存。在编写分配内存的代码时,就要确定在代码的什么地方释放内存。 在释放内存之前,确保不会无意中覆盖堆上已分配的内存的地址,否则程序就会出现内存泄漏。在循环中分配内存时,要特别小心。 注意：\n使用realloc()分配内存失败后调用free(),编译器可能会发出一个警告。这里调用free()是有效的,因为内存是以前分配的,但编译器不知道。\n7.5 使用指针处理字符串 前面使用 char 类型的数组元素存储字符串,也可以使用 char 类型的指针变量引用字符串。这个方法在处理字符串时非常灵活。下面的语句声明了一个 char 类型的指针变量:\nchar *pstring = NULL; 注意,指针只是一个存储另一个内存位置的地址的变量。前面只创建了指针,没有指定一个存储字符串的地方。要存储字符串,需要分配一些内存,在指针变量中存储其地址。在这种情况下,动态内存分配功能非常有效,例如:\n#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint main(void) {\rconst size_t BUF_SIZE = 100; // Input buffer size\rchar buffer[BUF_SIZE]; // A 100 byte input buffer\rscanf_s(\u0026#34;%s\u0026#34;, buffer, BUF_SIZE); // Read a string\r// Allocate space for the string\rsize_t length = strnlen(buffer, BUF_SIZE) + 1;\rchar *pstring = malloc(length);\rif (!pstring) {\rprintf(\u0026#34;Memory allocation failed.\\n\u0026#34;);\rreturn 1;\r}\rstrcpy_s(pstring, length, buffer); // copy string to new memory\rprintf(\u0026#34;%s\u0026#34;, pstring);\rfree(pstring);\rpstring = NULL;\r} 这段代码把一个字符串读入一个 char 数组中,给读入的字符串分配堆上的内存,再将字符串复制到新内存中。把字符串复制到 pString 引用的内存中,就允许重用 buffer ,来读取更多的数据。显然,下一步是读取另一个字符串,那么,如何处理任意长度的多个字符串?\n7.5.1 使用指针数组 当然,处理多个字符串时,可以在堆上使用指针数组存储对字符串的引用。假定从键盘上读取10个字符串,并存储它们。可以创建一个指针数组,存储字符串的位置:\nchar *ps [10] = { NULL }; 这条语句声明了一个数组 ps,它包含10个 char 类型的元素, ps 中的每个元素都可以存储字符串的地址。第5章提到,如果在数组初始化列表中提供的初始值个数少于数组的元素个数,剩下的元素就初始化为0,因此,上述语句的初始化列表中只有一个值 NUL L,它将任意大小的指针数组中的所有元素都初始化为 NULL 。\n下面使用这个指针数组:\n#define STR_COUNT 10 // Number of string pointers const size_t BUF_SIZE = 100; // Input buffer size\rchar buffer [BUF_SIZE]; // A 100 byte input buffer char *ps [STR_COUNT] ={NULL}; // Array of pointers11\rsize_t str_size = 0;\rfor (size_t i =o ; i\u0026lt; STR_COUNT ; ++i)\r{\rscanf_s (\u0026#34;%s\u0026#34;, buffer, BUF_SIZE); // Read a string str_size = strnlen_s (buffer, BUF_SIZE) + 1; // Bytes required\rps[i] = malloc(str_size); // Allocate space for the string\rif (!ps[i]) return 1; // Allocation failed so end\rstrcpy_s(ps[i], str_size, buffer); // Copy string to new memory\r}\r// Do things with the strings. .\r// Release the heap memory\rfor (size_t i =o; i\u0026lt; STR_COUNT ; ++i)\r{\rfree (ps [i]);\rps [i] =NULL;\r} ps 数组的每个元素都保存从键盘读取的一个字符串的地址。该数组有 STR_COUNT 个元素。注意在初始化数组时,不能使用变量指定数组的维数,即使把这个变量声明为 const 也不行。用变量指定数组的维数,该数组就是变长的,不允许初始化它,但总是可以在创建数组后,在循环中设置元素的值。在编译代码之前,符号用它表示的内容替代,所以在编译时, ps 的维数是 10。\n字符串在 for 循环中输入。字符串读入 buffer 后,就使用 malloc() 在堆上分配足够的内存,来存储字符串。malloc()返回的指针存储在 ps 数组的一个元素中。接着,把 buffer 中的字符串复制到为它分配的内存中,使 buffer 可用于读取下一个字符串。最后得到一个字符串数组,其中的每个字符串都占用它需要的字节数,这是非常高效的。但如果不知道要输入多少个字符串,该怎么办?下面通过一个示例说明如何处理这种情形。\n这是程序6.10的修订版,它在某个随意的散文中查找每个单词出现的次数。这个版本在堆上分配内存,来存储散文、单词和单词数。因为代码很多,所以内存分配函数中.省略了NULL指针的检查,以减少代码行数,但读者应总是包含它们。下面是代码:\n7.5.2 指针和数组记号 前面的例子使用了指针记号,但不一定要这么做。对于指向一块堆内存的指针变量,还可以使用数组记号来存储相同类型的几个数据项。例如,下面的语句分配了一些堆内存:\nint count = 100;\rdouble* data = calloc (count, sizeof (double)); 这段代码分配了足够的内存来保存 double 类型的 100 个值,并把它们初始化为 0.0 这个内存的地址存储在 data 中。可以访问这个内存,就好像 data 是一个包含 100 个 double 元素的数组。例如,可以利用循环在内存中设置不同的值:\nfor (int i=0; i \u0026lt; count ; ++i) data [i] = (double) (i + 1)*(i + 1); 这段代码把值设置为 1.0、4.0、9.0 等。它只使用了指针名和放在方括号中的索引值,就好像在使用数组一样。不要忘了, data 是一个指针,而不是数组。表达式sizeof(data)得到存储地址所需的字节数,在我的系统中是 8,如果 data 是一个数组,该表达式就得到数组占用的字节数,即800。\n可以重写程序7.13中的for循环,使用数组记号检查最新找到的单词是否已存在:\nfor(int i =o ; i \u0026lt; word count ; ++i)\r{\rif (strcmp (pwords [i], pWord) ==0)\r{\r++pnword [i];\rnew word = false;\rbreak;\r}\r} 假定 pWords 是 char* 型数组的起始地址,则表达式 pWords[i] 访问第 i 个元素。因此这个表达式访问第 i 个单词,与最初的表达式 (pWords +i) 完全相同。同样, pnWord[i]与(pnWord + i)等价。数组记号比指针记号更容易理解,所以应尽可能使用它。下面的示例就对堆内存使用数组记号。\n7.6 程序设计 前面介绍了C语言中一个比较难的部分,现在运用学过的内容编写一个应用程序尤,其是指针记号。本节将依循惯例,先分析、设计,然后一步步编写代码。这是本章最后一个程序。\n7.6.1 问题 要处理的问题是用一些新的特性重写第3章的计算器程序,但这次要使用指针。主要改进如下:\n允许使用有符号的小数,包含带-或+符号的小数和有符号的整数。 允许表达式组合多运算式,如2.5+3.7-6/6. 添加运算符^,计算幂,因此2^3会得到8 允许使用前一个运算的结果。如果前一个运算的结果是2.5,那么=2+7会得到12,任何以赋值运算符开头的输入行都自动假设左操作数是前一个运算的结果。不考虑运算符的优先级,只简单地从左到右计算输入的表达式,将每个运算符应用于前一个结果和右操作数。所以下面的表达式: 1+ 23-4*-5 会以如下方式计算: ((1+2)3-4)(-5) 7.6.2 分析 7.6.3 解决方案 7.7 小结 本章涵盖了许多基础知识,详细探讨了指针。读者现在应该了解指针和数组(一维和多维数组)间的关系了,并掌握了它们的用法。本章介绍了动态分配内存的函数malloc()、calloc()和realloc(),它们给程序提供了足够的内存,以执行数据处理。函数free()用来释放先前由malloc()、 calloc()和realloc()分配的内存。读者应该很清楚如何给字符串使用指针,如何使用指针数组,如何使用指针记号。\n本章讨论的主题是本书以后许多章书的基础,对编写C程序是很有帮助的,所以在进入下一章之前,一定要熟练掌握这些内容。\n注意本章许多示例的代码都很混乱。Main0中的语句数非常大,很难理解代码,程序7.15尤其如此,其中的main()超过了100行代码。这不是好的C编程方式。C程序应由许多短函数构成,每个函数都执行定义好的操作。而程序 7.15 的逻辑可以自然地分成几个不同的、定义好的、相互独立的操作。其中还有一些重复的代码,例如,提取左操作数的代码与提取右操作数的代码就几乎完全相同。第8章将使用函数组织程序,对函数有了更多的了解后,就可以更好地实现程序7.15了。\n7.8 习题 "},{"id":94,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC8%E7%AB%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/","title":"Beginning C , Fifth Edition 第8章：程序的结构","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第8章：程序的结构 如第 1 章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。\nC 语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。\n本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。\n本章的主要内容:\n数据如何传给函数 函数如何返回结果 如何定义自己的函数 函数原型的概念和使用场合 函数使用指针参数的优势 8.1 程序的结构 如概述所言,C 程序是由许多函数组成的,其中最重要的就是函数 main(),它是执行的起点。本书介绍库函数 printf() 或 scanf() 时,说明了一个函数可以调用另一个函数,完成特定的工作,在任务完成后调用函数继续执行。不考虑存储在全局变量(参见第9章)中的数据或者可以通过指针参数访问的数据的负面影响,程序中的每个函数都是一个执行特定操作的自包含单元。调用一个函数时,就执行该函数体内的代码,这个函数执行结束后,控制权就回到调用该函数的地方。如图8-1所示为 C 程序由 5 个函数组成时的执行顺序,它并未显示任何语句细节。\n这个程序以正常的方式按顺序执行语句,当遇到调用一个函数的语句时,就把参数值传递给函数,从该函数的起始点开始执行,即该函数体的第一条语句。这个函数会一直执行,在遇到 return 语句或到达这个函数体的结束括号时,就返回调用它的那个位置之后执行。\n这些组成程序的函数通过函数调用及其 return 语句链接在一起,完成各种工作,以达到程序的目标。图 8-1 中的每个函数在程序中只执行一次。实际上,每个函数可以执行多次,且可以从程序中的多个地方调用。前面的例子中就多次调用函数 printf() 和 scanf()。\n在详细了解如何定义自己的函数之前,必须解释变量的一个重要方面,这个方面一直未提及。\n8.1.1 变量的作用域和生存期 在前面所有的例子中,都是在定义 main() 函数体的起始处声明程序的变量。事实上,可以在任何代码块的起始处定义变量。这有什么不同吗?这是绝对不同的。变量只存在于定义它们的块中。它们在声明时创建,在遇到下一个闭括号时就不存在了。\n在一个块内的其他块中声明的变量也是这样。在外部块的起始处声明的变量也存在于内部块中。这些变量可以随意访问,只要内部块中没有同名的变量即可。\n变量在一个块内声明时创建,在这个块结束时销毁,这种变量称为自动变量,因为它们是自动创建和销毁的。给定变量可以在某个程序代码块中访问和引用,这个程序代码块称为变量的作用域。在作用域内使用变量是没有问题的。但是如果试图在变量的作用域外部引用它,编译程序时就会得到一条错误信息,因为这个变量在它的作用域之外不存在。例如下面的代码:\n{ int a = 0; // Create a // Reference to a is OK here // Reference to b is an error here - it hasn\u0026#39;t been created yet { int b= 10; // Create b // Reference to a and b is OK here }// b dies here // Reference to b is an error here - it has been destroyed // Reference to a is OK here }// a dies here 对于在一个块内声明的所有变量,在这个块的结束括号之后它们就不再存在。变量 a 可在内外两个块内访问,因为它是在外部块中声明的。变量 b 只能在内部块中访问,因为它是在内部块中声明的。\n执行程序时,会创建变量,并给它分配内存。有时,在一个块中声明了自动变量,在这个块结束时,该变量占用的内存就会返回给系统。当然,在执行块内调用的函数时,变量仍存在,只有执行到创建变量的块的尾部时才销毁变量。变量存在的时间称为变量的生存期。\n注意：\n本代码块声明的变量名称与父代码块声明的变量名称相同，在本代码块使用这个同名变量时，使用的时本代码块声明的变量，而不是父代码块声明的那个同名变量。\n8.1.2 变量的作用域和函数 在讨论创建函数的细节之前,最后要讨论的是,每个函数体都是一个块(当然,它可能含有其他块)。因此,在一个函数内声明的自动变量是这个函数的本地变量,在其他地方不存在。所以,在一个函数内部声明的变量完全独立于在其他函数或嵌套块内声明的变量。可以在不同的函数内使用相同的变量名称,它们是完全独立的。这的确是一个优点。处理很大的程序时,确保所有变量使用不同的名称是比较困难的。能在不同的函数中使用相同的变量名(如 count)是很方便的。当然,最好避免在不同的函数中使用不必要或易引起误解的相同变量名。应该尽量使用便于理解程序的名称。\n8.2 函数 本书的程序广泛使用了内置函数,例如 printf() 或 strcpy()。还介绍了在按名称引用内置函数时如何执行它们,如何通过函数名称后括号内的参数给函数传递信息。例如, printf() 函数的第一个参数通常是一个字符串,其后的参数(可能没有)是一系列要显示其值的变量或表达式。\n可以通过两种方法接收函数返回的信息。第一种方法是使用函数的一个参数。通过函数的一个参数提供变量的地址,这个函数会修改该变量的值。例如,使用scanf_s()从键盘上读取数据时,输入会存储到一个作为参数提供的地址中。第二种方法是通过返回值接收函数传回的信息。例如对于strlen_s()函数,当调用该函数时,它会返回程序代码作为参数传送给它的字符串的长度。因此,如果在表达式2strlen(str, sizeof(str))中, str是字符串\u0026quot;example\u0026quot;,strlen()函数返回的值就是7,接着用值7取代表达式中的函数调用。因此,这个表达式是27。函数会返回一个特定类型的值,所以在能使用该类型变量的任意表达式中,都可以使用函数调用,作为表达式的一部分。所有的程序都必须编写函数 main(),所以我们已经具备函数构成的基本知识。下面详细讨论函数的构成。\n8.2.1 定义函数 创建一个函数时,必须指定函数头作为函数定义的第一行,跟着是这个函数放在括号内的执行代码。函数头后面放在括号内的代码块称为函数体。\n函数头定义了函数的名称、函数参数(它们指定调用函数时传给函数的值的类型和个数)和函数返回值的类型。 函数体包含在调用函数时执行的语句,以及对传给它的参数值执行操作的语句。 函数的一般形式如下所示:\nReturn_type Function_name(Parameters -separated by commas)\r{\r// statements...\r} 函数体内可以没有语句,但是必须有大括号。如果函数体内没有语句,返回类型必须是 void,此时函数没有任何作用。void 类型表示“不存在任何类型”,所以这里它表示函数没有返回值。没有返回值的函数必须将返回类型指定为 void,而返回类型不是 void 的函数都在函数体中有一个 return 语句,返回一个指定返回类型的值。\n没有函数体的函数通常在复杂程序的测试阶段使用。例如,所定义的函数只包含一条 return 语句,返回一个默认值。这允许在执行程序时只用选定的函数执行一些操作,然后逐步增加函数体中的代码,在每个阶段进行测试,直到完成整个工作。\n术语“参数”表示函数定义中的一个占位符,指定了调用函数时传送给函数的值的类型。参数包含在函数体内,用来表示函数执行时使用的数据类型和名称。术语“变元”表示调用函数时提供的对应于参数的值。本章后面关于函数的参数部分将详细介绍参数。\n注意：\n函数体内的语句也可能含有嵌套的语句块,但不能在一个函数体内定义另一个函数。\n调用函数的一般形式是:\nFunction_name(List of Arguments - separated by commas) 使用函数名后跟括号内一连串以逗号分隔的变元,与调用 printf() 和 scanf() 函数一样。函数调用可以显示在一行中,如下所示:\nprintf(\u0026#34;I used to be indecisive but now I\u0026#39;m not so sure.\u0026#34;); 像这样调用的函数可以是有返回值的函数。在这个例子中,返回值会被丢弃。返回类型定义为void的函数只能这样调用。有返回值的函数通常会出现在表达式中,例如:\nresult = 2.0 * sqrt(2.0); sqrt()函数(在头文件\u0026lt;math.h\u0026gt;中声明)返回的值乘以 2.0,结果存储到变量 result 中。很明显,返回类型为 void 的函数不返回任何值,所以不可能成为表达式的一部分。\n1. 函数的命名\n在 C 语言中,函数的名称可以是任何合法的名称,但不能是保留字(如int、double和sizeof等),也不能和程序中其他函数的名称相同。注意,不要使用与任何标准库函数相同的名称,以避免混淆。当然,如果使用库函数名,且在源文件中包含该库函数的头文件,程序就不会编译。\n区别自己的函数和标准库函数的一个方法是,函数名用一个大写字母开头,但一些程序员觉得这相当受限。函数名以大写字母开头也常常用作 struct 类型名,参见第11章。\n合法的函数名与变量名的形式相同:一串字母和数字,第一个必须是字母。与变量名称一样,下划线字符算是一个字母。除此之外,函数的名称可以任意,但是最好能说明函数的作用,且不能太长。有效的函数名称示例如下:\ncube_root FindLast findNext Explosion Back2Front 通常,将函数名称(和变量名称)定义为包含多个单词。有3个常见的方法可以采用:\n在函数名称中用下划线字符分开每个单词。 将每个单词的第一个字母大写。 将除第一个单词之外的每个单词的第一个字母大写 这 3 种方法都很好,但第3种形式常常用于变量名。采用哪一个取决于程序员,但最好在选择了一种方法后就一直使用它。当然,可以对函数使用一种方法,对变量使用另一种方法。在本书中这3种方法都有使用,阅读完本书后,读者就会对使用哪种方法有自己的看法了。\n2. 函数的参数\n函数的参数在函数头中定义,是调用函数时必须指定的变元的占位符。函数的参数是一列变量名称和它们的类型,参数之间以逗号分隔。整个参数列表放在函数名称后的括号中。函数也可以没有参数,此时应在括号中放置void。\n参数提供了调用函数给被调用函数传递信息的方法。这些参数名对于函数而言是本地的,调用函数时给它们指定的值称为“变元”。然后使用这些参数名在函数体中编写计算操作,当函数执行时,参数使用变元的值。当然,函数也可以在函数体中声明本地定义的自动变量。函数执行完毕后,这些变量就会销毁。最后当计算完成时,如果返回类型不是void,函数将一个适当的值返回给原来的调用语句,并从那一点继续执行。\n要把数组作为变元传递给函数,还必须传递一个额外的变元,指定数组的大小。没有这个额外参数,函数就不知道数组中有多少个元素。\n调用函数时,要使用函数名称,后跟放在括号中的变元。在调用时指定的变元会取代函数中的参数。因此,函数执行时,会使用为变元提供的值进行计算。调用函数时指定的变元的类型、个数和顺序必须和函数头中指定的参数一致。调用函数和被调用函数之间的关系与传送的信息如图8-2所示。\n如果函数的变元类型不匹配对应参数的类型,编译器就会插入一个类型转换操作,将变元值的类型转换为参数的类型。这可能会截断变元值,例如把double类型的值传送给int类型的参数,所以这是一个危险的操作。如果编译器不能把变元转换为需要的类型,就会得到一条错误消息。\n3. 指定返回值的类型\n另一个常见的函数形式如下:\nReturn_type Function_name (List of Parameters - separated by commas)\r{\r// Statements..\r} Return_type指定了函数返回值的类型。如果在表达式中使用函数,或函数在赋值语句的右侧使用,则函数的返回值会取代该函数。函数的返回值可以指定为 C 语言中任何合法的类型,包括枚举类型和指针。\n返回类型也可以是 void* ,表示指向 void 的指针。此时,返回值是一个地址值,但没有指定类型。希望返回一个能灵活返回指向各种类型的地址时,就可以使用这个类型,例如分配内存的 malloc() 函数。返回类型也可以指定为 void ,表示没有返回值。\n注意：\n第 11 章将介绍 structs 类型,它提供了把几个数据项作为一个单元来处理的方式。函数的参数可以是 struct 类型或指向 struct 的指针,也可以返回一个 struct 或指向 struct 的指针。\n8.2.2 return 语句 return 语句允许退出函数,从调用函数中发生调用的那一点继续执行。return 语句最简单的形式如下:\nreturn; 这个形式的 return 语句用于返回类型声明为 void 的函数,它不返回任何值。较常见的 return 语句形式是:\nreturn expression; 这个形式的 return 语句必须用于返回类型没有声明为 void 的函数,返回给调用程序的值是计算 expression 的结果,其类型应是给函数指定的返回类型。\n警告：\n如果函数的返回类型定义为 void ,却试图返回一个值,编译程序时就会得到一条错误消息。如果函数的返回类型没有定义为 void,而只使用了 return,编译器也会生成一条错误消息。\n如果 expression 生成的值的类型不同于函数头声明的返回类型,编译器会将 expression 的类型转换成需要的类型。如果不能转换,编译器就生成一条错误消息。一个函数中可能有多条 return 语句,但每条 return 语句都必须提供一个可以转换为函数头中为返回值指定的类型的值。\n注意：\n调用函数不必识别或处理被调用函数返回的值。程序员负责确定如何使用函数调用的返回值。\n8.3 按值传递机制 给函数传送变元时,变元值不会直接传递给函数,而是先制作变元值的副本,存储在栈上,再使这个副本可用于函数,而不是使用初始值,如图8-4所示。\n图 8-4 中的 Average() 函数仅计算其两个变元的平均值,这两个变元映射为参数 x 和 y。 Average() 函数不能访问调用该函数时传递为变元的变量 value1 和 value2,只能访问这两个变元值的副本。这表示函数不能修改存储在 value1 或 value2 中的值。这个机制是C语句中所有变元值传递给函数的方式,称为按值传递机制(pass-by-value mechanism)。\n被调用函数修改属于调用函数的变量值的唯一方式是,把变量的地址接收为变元值。给函数传递地址时,它只是所传递地址的副本,而不是初始的地址。但是,副本仍是一个地址,仍引用最初的变量。这就是必须把变量的地址传递给 scanf_s() 的原因。不传递地址,该函数就不能在最初的变量中存储值。\n把数组传递为变元时,按值传递机制的一个有趣结论是,第 5 章讨论数组时提到,数组名本身引用了数组的起始地址,但它不是指针,不能修改这个地址。但是,把数组名用作变元时,会制作该地址的副本,并将副本传递给函数。该副本现在只是一个地址,所以被调用函数可以用任意方式修改这个地址。当然,最初的数组地址不受影响。这不是推荐方式,但意味着可以用如下方式实现程序 8.3 中的 Sum() 函数:\ndouble Sum (double x[], size_t n)\r{\rdouble sum = 0.0;\rfor (size_t i= 0 ; i \u0026lt;n; ++i)\rsum += * (x++) ;\rreturn sum;\r} 这段代码把数组名 x 看作一个指针。这是合法的,因为给参数 x 传递为变元的任意值最终都是一个double* 类型的值。\n从函数返回的值也是一个副本。这是必需的,因为在函数体内定义的自动变量和其他本地变量都会在函数返回时删除。程序8-3中的 GetData() 函数返回 nValues 的值, nValues 在函数结束时不再存在,但会制作其值的副本,传递回 main()。\n8.4 函数原型 在程序 8.3 的变体中,先定义 main()函数,再定义 average()、Sum()和 GetData()函数:\n// #include \u0026amp; #define directives...\rint main (void)\r{\r// Code in main () ...\r}\rdouble Average (double x[], size_t n)\r{\rreturn Sum (x, n) /n;\r}\rdouble Sum (double x[], size_t n)\r{\r// Statements... } size_t GetData(double *data, size_t max_count)\r{\r// Statements... } 这段代码不会编译。编译器在遇到 Average() 函数的调用时,不知道该如何处理,因为那时 Average()函数还没有声明。在 main()中调用 GetData()时也是这样。编译器开始编译 Average()时, Sum()还没有定义,不能处理对这个函数的调用。为了编译这段代码,必须在main()的定义之前添加代码,告诉编译器 Average()、 Sum()和 GetData()函数的信息。\n函数声明也称为函数原型,是一个定义函数基本特性的语句,它定义了函数的名称、返回值的类型和每个参数的类型。事实上,可以将它编写为与函数头一模一样,只是要在尾部加一个分号。函数声明也叫做函数原型,因为它提供了函数的所有外部规范。函数原型能使编译器在使用这个函数的地方创建适当的指令,检查是否正确地使用它。在程序中包含头文件时,这个头文件就会在程序中为库函数添加函数原型。例如,头文件\u0026lt;stdio.h\u0026gt;含有 printf()和 scanf()的函数原型。\n为了使程序 8.3 的变体可以编译,只需要在函数 main()的定义前面添加其他 3 个函数的原型:\n// #include \u0026amp; #define directives...\r// Function prototypes\rdouble Average (double x[], size_t n);\rdouble Sum (double x[], size_t n);\rsize_t GetData(double *data, size_t max_count);\rint main (void)\r{\r// Code in main () ...\r}\rdouble Average (double x[], size_t n)\r{\rreturn Sum (x, n) /n;\r}\rdouble Sum (double x[], size_t n)\r{\r// Statements... } size_t GetData(double *data, size_t max_count)\r{\r// Statements... } 现在,编译器可以编译 main()中的 Average()函数调用,因为编译器知道该函数的所有特性,例如名称、参数类型和返回类型。在技术上,可以把 Average()函数的声明放在 main()函数体中,只是 Average()函数的声明必须放在该函数的调用之前,但事实上这种做法并不可行。函数原型一般放在源文件的开头处,而且在所有函数的定义和头文件之前。另外,在源文件中,函数原型在所有函数的外部,函数的作用域是从其声明处开始直到源文件的结尾。因此无论函数的定义放在什么地方,源文件中的任意函数都可以调用该文件中的其他函数 。\n注意参数名不一定与函数定义中的参数名相同,甚至不需要在函数原型中包含参数名。在 GetData()原型中,为了显示出区别,故意忽略了参数名。这是可行的,但不推荐使用。注意参数类型 double*等价于函数定义中的参数类型 double[]。在函数原型中使用不同的参数名,一个用途是使原型中的参数名比较长,更容易理解;而在函数定义中,要使参数名短一些,代码比较简洁。\n有时函数fun1()调用另一个函数fun2(), fun2()又调用了fun1()。此时必须给函数定义原型,程序才能编译。无论在什么地方调用,最好总是把函数的声明放在程序的源文件中。这有助于程序与设计保持一致,还可以防止在程序的另一部分调用函数时出错。当然, main()函数不需要函数原型,因为在程序开始执行时,这个函数会由主机环境调用。\n8.5 指针用作参数和返回值 前面介绍了如何把函数参数指定为指针类型,把地址作为相应的变元传递给函数。另外,如果函数修改在调用函数中定义的变量值,也需要使用指针变元。事实上这是唯一的方法。\n前面还提到,把数组作为变元,通过指针参数传递给函数时,只传递了该数组的地址副本,而没有传递数组。函数中为数组元素定义的值可以在把该函数作为变元的函数中修改。被调用函数需要知道传递给它的数组的元素个数。这有两种方式:第一种方式是定义一个额外的参数,即数组的元素个数。对于带有指针参数 p 和元素个数 n 的函数,数组元素可以通过其地址来访问,它们的地址是 p 到 p+n-1。这种方式等价于传递了两个指针,一个是 p,指向数组的第一个元素;另一个是 p+n,指向最后一个元素后面的地址。这个机制在其他编程语言(如C++)中用得很多。第二种方式是在函数可以访问的最后一个数组元素中存储一个特别的唯一值。这个机制用于字符串,表示字符串的 char 数组在最后一个元素中存储了\u0026quot;0\u0026rsquo;。这个机制有时也可以应用于其他类型数据的数组。例如, 温度值数组可以在最后一个元素中存储-1000,标记数组的结束,因为这从来都不是一个有效的温度。\n8.5.1 常量参数 可以使用 const 关键字修饰函数参数,这表示函数将传送给参数的变元看做一个常量。由于变元是按值传送的,所以只有参数是一个指针时,这个关键字才有效。一般将 const 关键字应用于指针参数,指定函数不修改该变元指向的值。下面是带一个 const 参数的函数示例:\nbool SendMessage (const char* pmessage)\r{\r// Code to send the message return true;\r} 参数 pmessage 的类型是指向 const char 的指针。换言之,不能修改的是 char 值,而不是其地址。把 const 关键字放在开头,指定被指向的数据是常量。编译器将确认函数体中的代码没有使用pmessage 指针修改消息文本。也可以把指针本身指定为 const ,但这没有意义,因为地址是按值传送的,所以不能改变调用函数中的原始指针。\n将指针参数指定为 const 有另一个用途。const 修饰符暗示,函数不修改指针指向的数据,因此编译器知道,指向常量数据的指针变元应是安全的。另一方面,如果不给参数使用 const 修饰符,对编译器而言,函数就可以修改变元指向的数据。将指向常量数据的指针作为变元传送给未声明为 const 的参数时,C编译器至少应给出一条警告消息。\n提示：\n如果函数不修改指针参数指向的数据,就把该函数参数声明为 const。这样,编译器就会确认,函数的确没有改变该数据。将指向常量的指针传送给函数时,还可以避免出现警告或错误消息。\n当参数是指向指针的指针时,使用它就有点复杂了。此时,传递给该参数的变元是按值传递的,就像其他变元一样,所以无法把指针指定为const。但是,可以把指针指向的指针定义为const,防止修改指针指向的内容。但我们仅希望最终被指向的数据是const。对于指针的指针参数,下面是const一种可能的用途:\nvoid sort (const char** str, size_t n); 这是 sort()函数的原型,其第一个参数是指向 const char 的指针的指针类型。把第一个参数看作一个字符串数组,则字符串本身是常量,它们的地址和数组的地址都不是常量。这是合适的,因为该函数会重新安排在数组中存储的地址,而不修改它们指向的字符串。\n第二种可能的用途是:\nvoid sort ( char *const *str, size_t n); 这里,第一个参数是指向 char 的常量指针的指针。变元是一个字符串数组,函数可以修改字符串,但不能修改数组中的地址。例如,函数可以用空格替换标点符号,但不能重新安排字符串在数组中的顺序。\n对指针的指针参数使用常量的最后一种可能用途是:\nsize_t max_length (const char* const* str, size_t n); 在这个函数原型中,第一个参数是指向 const char 的常量指针的指针类型。数组中的指针是常量,它们指向的字符串也是常量。该函数可以访问数组,但不能以任何方式修改数组。这个函数一般返回字符串的最大长度,获得这个数据时不会修改任何内容。\n试试看：使用指针传输数据\n下面用更实际的方式练习使用指针给函数传递数据的方式,并复习第 7 章的程序 7.14 中排序字符串函数的修改版本。源代码除了定义 main()函数之外,还定义了 5 个函数。这里先列出了 main()函数的实现代码和函数原型,后面将讨论其他 5 个函数的实现方式。\n#define __STDC_WANT_LIB_EXT1__ 1\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;stdbool.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\r#define BUF_LEN 256 // Input buffer size\r#define INIT_NSTR 2 // Initial number of strings\r#define NSTR_INCR 2 // increment to number to strings\rchar *str_in(); // Reads a string\rvoid str_sort(const char **, size_t); // Sorts an array of strings\rvoid swap(const char **, const char **); // Swaps two pointers\rvoid str_out(const char *const *, size_t); // Outputs the strings、\rvoid free_memory(char **, size_t); // Free all heap memory\rint main(void) {\rsize_t pS_size = INIT_NSTR;\rchar **pS = calloc(pS_size, sizeof(char *));\rif (!pS) {\rprintf(\u0026#34;Failed to allocate memory for string pointers.In\u0026#34;);\rexit(1);\r}\rchar **pTemp = NULL;\rsize_t str_count = 0;\rchar *pStr = NULL;\rprintf(\u0026#34;Enter one string per line. Press Enter to end: \\n\u0026#34;);\rwhile ((pStr = str_in()) != NULL) {\rif (str_count == pS_size) {\rpS_size += NSTR_INCR;\rif (!(pTemp = realloc(pS, pS_size * sizeof(char *)))) {\rprintf(\u0026#34;Memory allocation for array of strings failed. In\u0026#34;);\rreturn 2;\r}\rpS = pTemp;\r}\rpS[str_count++] = pStr;\r}\rstr_sort(pS, str_count);\rstr_out(pS, str_count);\rfree_memory(pS, str_count);\rreturn 0;\r} 这里为代码使用的符号选择值,可以确保内存的重新分配发生得比较频繁。如果希望跟踪这个活动,可以添加 printf() 调用。在实际的程序中,所选的值应最小化重复的堆内存分配的可能性,以避免其系统开销。\n把函数原型放在源文件的开头,函数的定义就可以采用任意顺序。字符串存储在堆内存中,指向每个字符串的指针存储在 ps 数组的一个元素中,该数组也在堆内存中。数组 pS 的初始容量可以容纳符号 INIT_NSTR 定义的指针个数。main() 的操作非常简单,它使用 str_in() 从键盘上读取字符串,调用 str_sort() 给字符串排序,调用 str_out() 把字符串按排序后的顺序输出,再调用 free_memory() 函数释放已分配的堆内存。\n字符串通过str_in()从键盘上读取,该函数的实现代码如下:\nchar *str_in(void) {\rchar buf[BUF_LEN];\rif (!gets_s(buf, BUF_LEN)) {\rprintf(\u0026#34;\\nError reading string. \\n\u0026#34;);\rreturn NULL;\r}\rif (buf[0] == \u0026#39;\\0\u0026#39;) {\rreturn NULL;\r}\rsize_t str_len = strnlen_s(buf, BUF_LEN) + 1;\rchar *pString = malloc(str_len);\rif (!pString) {\rprintf(\u0026#34;Memory allocation failure.\\n\u0026#34;);\rreturn NULL;\r}\rstrcpy_s(pString, str_len, buf);\rreturn pString;\r} 返回类型是 char*,即指向字符串的指针。字符串读入本地数组 buf 中。给读取的字符串分配足够的堆内存,其地址存储在本地变量 pString 中。 buf 中的字符串复制到堆内存中,返回 pString 中存储的地址。如果读取了空字符串,函数就返回 NULL。在 main()中,字符串在一个循环中读取,当 str_in()返回 NULL 时,这个循环就结束。非 NULL 字符串地址存储在 ps数组的下一个可用元素中。如果数组已满,就调用 realloc() 函数,给数组增加 NSTR_INCR 个元素。已有的数据放在由 realloc() 分配的新内存中,即使它们可能不位于相同的地址中也是如此。\n读取了所有的字符串后,就调用 str_sort() 函数把它们按升序存储。str_sort() 函数的实现代码如下:\nvoid str_sort(const char **p, size_t n) {\rbool sorted = false;\rwhile (!sorted) {\rsorted = true;\rfor (int i = 0; i \u0026lt; n - 1; ++i) {\rif (strcmp(p[i], p[i + 1]) \u0026gt; 0) {\rsorted = false;\rswap(\u0026amp;p[i], \u0026amp;p[i + 1]);\r}\r}\r}\r} 这段代码使用冒泡排序法给字符串排序,与第 7 章的示例相同。对指向字符串的指针数组 ps 执行该过程,如图8-5所示。\n这个过程比较相邻的两个数组元素,如果它们的顺序不正确,就交换其位置。在图8-5所示的例子中,对所有元素进行第一次选代后,元素就排好序,但这个过程一般要重复多次。\nstr_sort() 的第一个参数是 const char** 类型,即指向 const char的指针的指针。这是一个指向字符串的指针数组,其中字符串是常量,但其地址不是常量。排序过程会重新安排存储在数组元素中的地址,使字符串以顺序排列。字符串本身不改变,也不修改它们在堆内存中的地址。第二个变元是数组元素指向的字符串个数,它是必需的,因为没有它,函数就无法确定有多少个字符串。注意在 str_sort() 函数中没有 return 语句。在执行到函数体的末尾时,就等价于执行一个没有返回表达式的 return 语句。显然,这仅适用于返回类型为 void 的函数。\nstr_sort() 函数调用 swap()交换两个指针。一定要清楚这个函数的作用,才能明白为什么使用这样的参数类型。注意,变元是按值传递的,所以必须把变量的地址传递给函数,函数才能修改调用函数中的值。swap() 函数的变元是 \u0026amp;p[i]和 \u0026amp;p[i+1],它们是 p[i]和 p[i+1]的地址,即指向这些元素的指针。这些元素是什么类型?它们是指向 const char的指针,其类型是 const char*。把这些放在一起,就有了swap()函数的参数类型 const char**,即指向 const char的指针的指针。必须以这种方式指定函数,因为swap(函数要修改p数组中的元素内容。如果在参数类型定义中只使用了一个*,且使用p[i]和p[i+1]作为变元,函数就会接收包含在这些元素中的内容,这可不是我们希望的。当然, const char**类型与 const char*[]类型相同,后者是 const char类型的数组。这里可以使用这两种类型中的任意一种,但必须编写 const char p1[],而不是 const char*[]pl。\nswap()函数的实现代码如下:\nvoid swap(const char **pl, const char **p2) {\rconst char *pT = *pl;\r*pl = *p2;\r*p2 = pT;\r} 如果理解了使用这些参数类型的原因,交换代码就很容易理解了。函数交换了 pl 和 p2 的内容。它们的内容是 const char* 类型,所以交换值时使用的本地临时变量也使用这个类型。\n字符串数组排序完成后,就调用str_out()输出,该函数的实现代码如下:\nvoid str_out(const char *const *pStr, size_t n) {\rprintf(\u0026#34;The sorted strings are:\\n\u0026#34;);\rfor (size_t i = 0; i \u0026lt; n; ++i)\rprintf(\u0026#34;%s\\n\u0026#34;, pStr[i]);// Display a string } 第一个参数是 const char* const* 类型,它是指向 const char 的 const 指针的指针。该函数只是访问数组变元,不修改数组中的指针或指针指向的内容,所以可以把数组元素和它们指向的内容指定为 const。第二个变元是要显示的字符串个数。函数体中的代码在前面解释过了,这里不再赘述。\nmain()中的最后一步是调用 free_memory(),释放已分配的所有堆内存。 free_memory() 的实现代码如下:\nvoid free_memory(char **pS, size_t n) {\rfor (size_t i = 0; i \u0026lt; n; ++i) {\rfree(pS[i]);\rpS[i] = NULL;\r}\rfree(pS);\rpS = NULL;\r} 堆内存的释放分两个阶段。存储字符串的内存在 for 循环中选代数组元素,一个个地释放。每个指针指向的内容释放后,指针就重置为 NULL。字符串的所有内存都释放后,就调用一次free(),释放为存储字符串地址而分配的内存。\n在本例的下载文件中添加了许多注释。对于包含几个函数的较长程序,这是一个很好的实践方式,确保阅读程序的人了解每个函数的作用。\n这个程序的输出如下:\nEnter one string per line. Press Enter to end: Many a mickle makes a muckle. Least said, soonest mended. Pride comes before a fall. A stitch in time saves nine. A wise man hides the hole in his carpet. The sorted strings are:\rA stitch in time saves nine. A wise man hides the hole in his carpet.\rLeast said, soonest mended. Many a mickle makes a muckle. Pride comes before a fall. 8.5.2 返回指针的风险 前面介绍了如何从函数中返回数值,其实返回的是该值的副本。从函数中返回指针是一个非常强大的功能,因为它允许返回一整组值,而不仅仅返回一个值。在前面的示例中, str_in()函数返回一个指向字符串的指针,当然,此时也是返回指针值的副本。由此可能得到一个错误的结论:函数的返回值不会出错。尤其是,返回指针有一些特定的风险。下面先看一个非常简单的例子,说明其中一个风险。\n试试看:从函数中返回数值\n这里使用加薪作为这个例子的基础,因为它是一个大众化的主题。\n#include \u0026lt;stdio.h\u0026gt;\rlong *IncomePlus(long *pPay);\rint main(void) {\rlong your_pay = 30000L;\rlong *pold_pay = \u0026amp;your_pay;\rlong *pnew_pay = NULL;\rpnew_pay = IncomePlus(pold_pay);\rprintf(\u0026#34;Old pay=$%ld\\n\u0026#34;, *pold_pay);\rprintf(\u0026#34; New pay =$%ld\\n\u0026#34;, *pnew_pay);\rreturn 0;\r}\rlong *IncomePlus(long *pPay) {\r*pPay += 10000L;\rreturn pPay;\r} 执行这个程序,输出如下:\nold pay =$40000 New pay = $40000 在 main()函数中,为变量 your_pay 设置一个初始值,定义两个用于 IncomePlus()函数的指针, IncomePlus()函数用来增加 your_pay。一个指针初始化为 your_pay的地址,另一个初始化为 NULL,因为它接收 IncomePlus()函数返回的地址。\n输出看起来不错,但不正确。如果不知道原来的薪水是 $30 000,这个输出看起来好像薪水一点都没有增加。因为函数 IncomePlus()通过指针 pold_pay修改了 your_pay的值,原来的值已经改变了。很明显,两个指针 pold_pay和 pnew_pay 引用相同的位置:your_pay.这是函数 IncomePlus()中的下述语句的结果:\nreturn pPay; 这会返回函数调用时接收到的指针值,即 pold_pay 内的地址。结果是原来的薪水增长了-这就是指针的作用。\n但是,这不是返回指针的唯一问题。下面是一个变体。\n为了避免干扰变元指向的变量,可以考虑在函数 IncomePlus() 中使用本地存储器存储返回值。对这个例子 IncomePlus() 函数做如下小修改:\nlong *IncomePlus(long *pPay) {\rlong pay = 0;\rpay = *pPay + 10000L;\rreturn \u0026amp;pay;\r} 编译这个例子,可能会得到一条警告消息。但运行程序,得到的结果如下(由于计算机不同,得到的结果可能不同,但该结果可能是正确的):\nOld pay=$30000\r进程已结束,退出代码-1073741819 (0xC0000005) pay 的值$27 467 656 让人吃惊。但在抱怨此类错误前可能会犹豫。如前所述,在不同的计算机上可能会得到不一样的结果,这次可能是正确的结果。编译这个版本的程序,应该会得到一个警告,例如“指向本地 pay的指针是无效的返回值”。这是因为这个程序返回了变量 pay的地址,在退出函数 IncomePlus() 时,它超出了作用域,使 pay的新值非常大-这个值是一个垃圾值,是其他程序遗留下来的。这是很容易犯的错误,如果编译器没有提出警告,就很难找出这个错误。\n这看起来是正确的,但事实上程序中有一个严重的错误。虽然变量 pay 超出了作用域,因此不再存在,但它所占的内存尚未被重新使用。在这个例子中,显然某些对象使用了 pay 变量使用过的这个内存,生成了巨大的输出值。使用如下定律可以避免这类问题。\n定律：\n绝不返回函数中本地变量的地址。\n如何实现 IncomePlus() 函数?如果要求函数修改传递给它的地址,第一个实现方式就很好。但如果不想改变地址,就应只返回 pay 的新值,而不是指针。调用程序必须存储这个返回值,而不是地址。\n如果要将 pay 的新值存储到另一个位置中,函数 IncomePlus()就可以用 malloc()函数为它分配空间,并返回这个内存的地址。然而,应该注意调用函数必须释放该内存。最好给函数传送两个变元,一个变元是初始 pay的地址,另一个是存储新 pay的地址。这样,调用函数就可以支配内存了。如果因为某种原因必须传递指向 pay初始值的指针,就应把参数的类型指定为 const long*来保护它。\n将执行期间分配内存与释放内存分开,有时会造成内存泄漏。在循环中重复调用的函数动态分配内存后,却没有释放它,就会出现内存泄漏。结果,越来越多可用的内存被占据了,当没有内存可用时,程序就会崩溃。应尽可能使分配内存的函数在使用完内存后就释放它。如果不能由函数释放内存,就要编写代码,释放动态分配的内存。\n8.6 小结 本章尚未完成函数的讨论,所以第9章的最后将通过另一个例子介绍使用函数的更多内容。下面总结创建和使用函数时的重点:\nC程序由一个或多个函数组成,其中一个是main()函数。该函数永远是执行的起点,操作系统通过一个用户命令调用它。 函数是程序中独立的一块自包含代码。函数的名称采用标识符名称的形式,由一系列字母和数字组成,第一个字符必须是字母(下划线算是字母)。 函数定义由函数头和函数体组成。函数头定义了函数的名称、函数返回值的类型及函数中所有参数的类型和名称。函数体含有函数的可执行语句,定义了这个函数的功能。 在函数中声明的所有变量都是函数的本地变量。 函数原型是一个以分号终止的声明语句,用以定义函数的名称、返回类型和函数的参数类型。在可执行代码中,如果函数调用出现在函数定义之前,就需要函数原型给编译器提供函数相关信息。 在源文件中使用函数之前,应该先定义这个函数,或用函数原型声明这个函数。 将指针参数指定为const就会告诉编译器,这个函数不改变该参数指向的数据。 函数变元的类型必须符合函数头中对应的参数。如果指定参数的类型是int,但传送了double类型的值,该值就会被截断,删除小数部分。 有返回值的函数可以用在表达式中,就如同它是一个与返回值类型相同的值一样, 在调用函数中,是将变元值的副本传给函数,而不是传送原始值。这种给函数传送数据的方式称为按值传递机制。 如果函数要修改在调用函数中定义的变量,就需要将这个变量的地址作为变元传送。 这些涵盖了创建定制函数的重点。第9章将介绍使用函数的其他技巧,在真实的例子中使用函数。\n8.7 习题 "},{"id":95,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC9%E7%AB%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2/","title":"Beginning C , Fifth Edition 第9章：函数再探","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 第 9 章：函数再探 学习了第8章后,读者就应具备创建和使用函数的基础知识了。本章将以此为基础,介绍函数的使用和操作,尤其是如何通过指针访问函数。也会使用一些更灵活的方法在函数之间通信。 本章的主要内容:\n函数指针的概念及其用法 如何在函数内使用静态变量 如何在函数之间共享变量 函数如何调用自己,而不陷入无限循环 编写一个五子棋游戏(也称为Reversi) 9.1 函数指针 指针对于操作数据和含有数据的变量是一个非常有用的工具。只要一把火钳就可处理所有火热的东西;同样,使用指针也可以操作函数,函数的内存地址存储了函数开始执行的位置(起始地址),存储在函数指针中的内容就是这个地址。\n不过,仅有地址还不够。如果函数通过指针来调用,还必须提供变元的类型和个数,以及返回值的类型。编译器不能仅通过函数的地址来推断这些信息。这意味着,声明函数指针比声明数据类型指针复杂一些。指针包含了地址,而且必须定义一个类型;同样,函数指针也包含了地址,也必须定义一个原型。\n9.1.1 声明函数指针 函数指针的声明看起来有点奇怪,容易混涌,所以下面从一个简单的例子开始:\nint (*pfunction) (int); 这是一个函数指针变量的声明,它不指向任何内容-一该语句只定义了指针变量。这个指针的名称是 pfunction,指向一个参数是 int 类型、返回值是 int 类型的函数。而且,这个指针只能指向有这些特征的函数。如果函数接受 float 变元,返回 float 值,就需要声明另一个有这些特征的指针。图 9-1 说明了声明的各个成分。\n在函数指针的声明中有许多括号。在这个例子中,声明的 *pfunction 部分必须放在括号中。如果省略了括号,就变成 pfunction()函数的声明了,这个函数返回一个指向 int 的值,这可不是我们希望的结果。第二对括号包含参数列表,这与标准函数声明相同。函数指针只能指向特定的函数,该函数有特定的返回类型、特定的参数个数和特定类型的参数。函数名称可以随意,与其他指针变量一样。\n9.1.2 通过函数指针调用函数 假定定义如下函数原型:\nint sum (int a, int b); // Calculates a+b 这个函数有两个 int 类型的参数,返回值的类型是 int,所以可以把它的地址存储在声明如下的函数指针中:\nint (*pfun)(int, int)= sum; 这条语句声明了一个函数指针 pfun,它存储函数的地址,该函数有两个 int 类型的参数,返回值的类型是 int。该语句还用 sum()函数的地址初始化 pfun。要提供初始值,只需要使用有所需原型的函数名。\n现在可以通过函数指针调用sum()函数:\nint result = pfun (45, 55); 这条语句通过 pfun 指针调用变元值为 45 和 55 的 sum()函数,将 sum()的返回值用作 result 变量的初始值,因此 result 是100。注意,像使用函数名那样使用函数指针名调用该指针指向的函数,不需要取消引用运算符。\n假定定义了有如下原型的另一个函数:\nint product (int a, int b); // Calculates a*b 就可以使用下面的语句在 pfun 中存储 product() 的地址:\npfun = product; pfun包含 product()的地址,所以可以通过指针调用 product():\nint result = pfun (5, 12); 执行了这条语句后,result就包含60。\n下面以一个简单的例子来说明函数指针是如何运作的。\n#include \u0026lt;stdio.h\u0026gt;\r// Function prototypes\rint sum(int, int);\rint product(int, int);\rint difference(int, int);\rint main(void) {\rint a = 10;\rint b = 5;\rint result = 0;\rint (*pfun)(int, int);\rpfun = sum;\rresult = pfun(a, b);\rprintf(\u0026#34;pfun = sum result = %2d\\n\u0026#34;, result);\rpfun = product;\rresult = pfun(a, b);\rprintf(\u0026#34;pfun = product result = %2d\\n\u0026#34;, result);\rpfun = difference;\rresult = pfun(a, b);\rprintf(\u0026#34;pfun = difference result = %2d\\n\u0026#34;, result);\rreturn 0;\r}\rint sum(int x, int y) {\rreturn x + y;\r}\rint product(int x, int y) {\rreturn x * y;\r}\rint difference(int x, int y) {\rreturn x - y;\r} 这个程序的输出结果如下:\npfun = sum result = 15\rpfun = product result = 50\rpfun = difference result = 5 在此将指针名当成函数名来使用,后面跟随放在括号中的变元列表。而将函数指针变量名当做原来的函数名,则变元列表必须对应函数头的参数列表,如图9-2所示。\n9.1.3 函数指针的数组 函数指针和一般的变量是一样的,所以可创建函数指针的数组。要声明函数指针数组,只需要将数组的大小放在函数指针数组名之后。例如:\nint (*pfunctions[10])(int) 这条语句声明了一个包含 10个元素的 pfunctions 数组。这个数组里的每个元素都能存储一个函数的地址,该函数有两个int类型的参数,返回类型是int。下面看一个实例。\n#include \u0026lt;stdio.h\u0026gt;\r// Function prototypes\rint sum(int, int);\rint product(int, int);\rint difference(int, int);\rint main(void) {\rint a = 10;\rint b = 5;\rint result = 0;\rint (*pfun[3])(int, int);\rpfun[0] = sum;\rpfun[1] = product;\rpfun[2] = difference;\rfor(int i = 0;i\u0026lt;3;i++){\rresult = pfun[i](a,b);\rprintf(\u0026#34;pfun result = %2d\\n\u0026#34;, result);\r}\rreturn 0;\r}\rint sum(int x, int y) {\rreturn x + y;\r}\rint product(int x, int y) {\rreturn x * y;\r}\rint difference(int x, int y) {\rreturn x - y;\r} 这类似于前面对一个指针变量的声明,只是指针名称后面多了放在方括号中的数组大小。如果需要的是二维数组,就应有两对方括号,如同声明一般的数组类型一样。参数列表仍然要放在括号内,这与单个指针的声明相同。另外,和一般的数组一样,函数指针数组的所有元素都是相同的类型,都只能接受指定的变量列表。因此在此例中,这些指针都只能指向带两个int参数、返回int值的函数。\n给数组中的指针赋值时,语句和一般的数组元素相同:\npfun[0] = sum; 除了等号右侧的函数名称之外,这就是一个正常的数据数组,其用法也完全相同。可以在声明中初始化指针数组的所有元素:\nint (*pfun [3]) (int, int) = ( sum, product, difference ); 这条语句初始化了3个元素,所以不再需要执行初始化的赋值语句。事实上,也可以去掉数组的大小,由初始化列表确定数组的大小:\nint (*pfun []) (int, int) = ( sum, product, difference ); 大括号内的初始值个数确定了数组中的元素数目。因此,函数指针数组的初始化列表与其他数组的初始化列表的作用相同。\n这行语句说明,可以通过指针将函数调用合并到表达式中,这和使用一般函数调用的方式相同。这里通过指针调用两个函数,将它们的结果用作通过指针调用的第三个函数的变元。pfun数组元素依次对应函数sum()、product()和difference(),因此这行语句相当于下面的语句:\n9.1.4 作为变元的函数指针 也可以将函数指针作为变元来传递,这样就可以根据指针所指向的函数而调用不同的函数了。\n修改上一个例子,将函数指针作为变元传入函数:\n#include \u0026lt;stdio.h\u0026gt;\r// Function prototypes\rint sum(int, int);\rint product(int, int);\rint difference(int, int);\rint any_function (int (*pfun) (int, int), int x, int y);\rint main(void) {\rint a = 10;\rint b = 5;\rint result = 0;\rint (*pf)(int, int) = sum;\rresult = any_function(pf, a, b);\rprintf(\u0026#34;pfun result = %2d\\n\u0026#34;, result);\rresult = any_function(product, a, b);\rprintf(\u0026#34;pfun result = %2d\\n\u0026#34;, result);\rresult = any_function(difference, a, b);\rprintf(\u0026#34;pfun result = %2d\\n\u0026#34;, result);\rreturn 0;\r}\rint any_function(int (*pfun) (int, int), int x, int y) {\rreturn pfun(x,y);\r}\rint sum(int x, int y) {\rreturn x + y;\r}\rint product(int x, int y) {\rreturn x * y;\r}\rint difference(int x, int y) {\rreturn x - y;\r} 将函数指针作为变元的函数是 any_function(),它的函数原型如下:\nint any_function (int (*pfun) (int, int), int x, int y); any_function() 函数有3个参数,第一个参数是一个函数指针,它指向的函数接受两个整数参数并返回整数。any_function() 函数的后两个参数都是整数,在调用第一个参数指定的函数时使用。any_function() 函数返回一个整数,而这个整数是调用第一个变元指定的函数得到的。\n在 any_function()函数的定义里,指针变元指定的函数在 return 语句中调用:\nint any_function(int (*pfun) (int, int), int x, int y) {\rreturn pfun(x,y);\r} 这个定义使用了指针名称 pfun ,后跟的另外两个参数用作被调用函数的变元。pfun的值和另外两个参数x和y的值都来自于 main()。\n注意在 main()中声明的函数指针 pf 是如何初始化的:\nint (*pf)(int, int) = sum;// Pointer to function 将函数 sum()的名称作为初始化值放在等号的后面,如前所述,只要将函数名作为初始化值,就可以将函数指针初始化为指定函数的地址。\nany_function()的第一个调用给any_function()传递了指针pf、变量a及b的值:\nresult = any_function(pf, a, b); 指针 pf 和平常一样用作变元,any_function()返回的值存储到变量 result 中。pf的初始值是 sum()函数的地址,所以在 any_function()内调用了 sum()函数,因此返回值是 a 与 b 的和。\n9.2 函数中的变量 将程序分解成函数,不仅简化了开发程序的过程,还增强了程序语言解决问题的能力。设计优良的函数常常可以重用,使新应用程序的开发变得更快、更简单。标准库就证明了可重用函数的威力。函数中变量的属性以及 C 语言在声明变量时提供的一些额外功能进一步增强了程序语言的力量。下面介绍函数中的变量。\n9.2.1 静态变量:函数内部的追踪 前面使用的所有变量在执行到定义它的块尾时就超出了作用域,它们在栈上分配的内存会被释放,以供另一个函数使用。这些变量称为自动变量,因为它们是在声明时自动创建的,在程序退出声明它的块后自动销毁。这是一种非常高效的过程,因为只要正在执行的语句在声明变量的函数内,函数中包含数据的内存就会一直保存该数据。\n然而在某些情况下,要求在退出一个函数调用后,该调用中的数据可以在程序的其他函数中使用。例如保留函数中的某种计数器,如函数的调用次数或输出行数。这使用自动变量是做不到的。\n不过,C语言提供了静态变量,可以达到这个目的。例如用下面的语句声明一个静态变量count:\nstatic int count = 0; 上述语句中的static是C的一个关键字,该语句声明的变量和自动变量有两点不同。第一,虽然它在函数的作用域内定义,但当执行退出该函数后,这个静态变量不会销毁。第二,自动变量每次进入作用域时,都会初始化一次,但是声明为static的变量只在程序开始时初始化一次。静态变量只能在包含其声明的函数中可见,但它是一个全局变量,因此可以用全局变量的方式使用它。\n注意：\n可以在函数内创建任何类型的静态变量。\n下面这个简单的例子演示了静态变量的用法:\n#include \u0026#34;stdio.h\u0026#34;\rvoid test1(void);\rvoid test2(void);\rint main(void) {\rfor (int i = 0; i \u0026lt; 5; ++i) {\rtest1();\rtest2();\rprintf(\u0026#34;\\n\u0026#34;);\r}\rreturn 0;\r}\rvoid test1(void) {\rint count = 0;\rprintf(\u0026#34;test1 count = %d\\n\u0026#34;, ++count);\r}\rvoid test2(void) {\rstatic int count = 0;\rprintf(\u0026#34;test2 count = %d\\n\u0026#34;, ++count);\r} 程序的输出结果如下:\ntest1 count = 1\rtest2 count = 1\rtest1 count = 1\rtest2 count = 2\rtest1 count = 1\rtest2 count = 3\rtest1 count = 1\rtest2 count = 4\rtest1 count = 1\rtest2 count = 5 可以看出,这两个 count 变量是完全不同的,其值的变化清楚地说明了它们是相互独立的。静态变量 count 在函数 test2()内声明,如下所示:\nstatic int count = 0; 可以给这个变量指定初始值,但这里将它初始化为0,因为将它声明为静态变量。\n注意：\n所有的静态变量都会初始化为0,除非将它们初始化为其他值。\n静态变量 count 用于计算函数的调用次数。当程序开始执行时初始化它,程序退出函数后,它的当前值仍然保留。该变量没有在函数的后续调用中重新初始化。由于该变量声明为static,因此编译器只将它初始化一次。初始化操作是在程序开始之前进行的,所以总是可以确保静态变量在使用时初始化。\n自动变量 count 在函数 test1() 内的声明如下所示:\nint count = 0; 这是自动变量,所以它默认不会在程序开始执行时初始化。如果不给它指定初始值,它将会含有一个垃圾值。这个变量会在每次执行函数时初始化为0,在每次退出 test1()后删除,因此它永远不会大于1。\n只要程序开始执行,静态变量就一直存在,但是它只能在声明它的范围内可见,不能在该作用域的外部引用。\n9.2.2 在函数之间共享变量 也可以在所有的函数之间共享变量。常量在程序文件的开头声明,所以常量位于组成程序的所有函数的外部)。同样,也可以采用这种方式声明变量,这种变量称为全局变量,因为它们可以在任意位置访问。全局变量的声明方式和一般变量相同,但声明它的位置非常重要,这个位置确定了变量是否为全局变量。\n修改前一个例子,在函数之间共享count变量。\n#include \u0026#34;stdio.h\u0026#34;\rint count = 0;\rvoid test1(void);\rvoid test2(void);\rint main(void) {\rint count = 0;\rfor (int i = 0; count \u0026lt; 5; ++count) {\rtest1();\rtest2();\rprintf(\u0026#34;\\n\u0026#34;);\r}\rreturn 0;\r}\rvoid test1(void) {\rprintf(\u0026#34;test1 count = %d\\n\u0026#34;, ++count);\r}\rvoid test2(void) {\rstatic int count;\rprintf(\u0026#34;test2 count = %d\\n\u0026#34;, ++count);\r} 在这个例子中,有3个不同的 count 变量。第一个是全局变量 count ,它在文件的开头声明:\n#include \u0026#34;stdio.h\u0026#34;\rint count = 0; 这不是静态变量(但也可以把它声明成静态变量),而是全局变量,所以如果没有初始化它,它就默认为0。从声明该全局变量到程序结束的任何函数中都可以访问它。\n第二个 count 是自动变量,在 main() 函数中声明:\nint count = 0; 它和全局变量同名,所以在 main() 函数中不能访问全局变量 count.在 main()函数中使用的 count 都是在 main()函数体中声明的自动变量。本地变量隐藏了全局变量。\n第三个 count 是静态变量,在函数 test2()里声明:\nstatic int count; 这是一个静态变量,所以默认初始化为 0。这个变量也隐藏了同名的全局变量,所以在 test2()内只能访问静态变量 count。\n函数 test1() 使用的是全局变量 count。函数 main()和 test2()使用的是 count的本地版本,因为本地声明隐藏了同名的全局变量。\n显然,main()内的 count 变量从 0 递增到 4,因为调用了 5 次 test1()和 test2()。在 test1()及 test2()内, count变量是不同的,否则程序就不会输出 1~5 的值。\n删除 test2()内对静态变量 count 的声明,可以进一步证实这个事实。这会使 test1()和 test2()共享全局变量 count,显示出的值会变成 1~10。如果将 test2()内的 count 变量改成已初始化的自动变量,如下面的语句所示:\nint count = 0; test1()会输出 1~5 ,而 test2()的输出始终是 1 ,这是因为该变量现在是自动变量,每次执行函数时都会重新初始化。\n全局变量可以取代函数变元及返回值。完全取代自动变量似乎很吸引人,但应少使用全局变量,全局变量可以简化并缩短某些程序,但过度使用会使程序很难理解,且容易出错。主要原因是很容易修改全局变量,却忘记它对整个程序带来的后果。程序越大,避免错误引用全局变量的难度就越大。而本地变量可以有效地隔离各个函数,避免这些函数的活动互相干扰。删除程序 9.5 中 main() 的本地变量 count ,看看输出结果会如何。\n注意：\n在 C 语言中,最好不要给本地变量和全局变量使用相同的名称。这不但没有好处,反而有坏处,如上面的例子所示。\n9.3 调用自己的函数:递归 函数调用自己称为递归。递归在程序设计中不常见,所以本节仅介绍概念。不过在某些情况下,这是一个效率很高的技巧,可以显著简化解决特定问题所需的代码。递归也有几个坏处,但这里也不涉及。\n显然,函数调用自己时,一个直接的问题是如何停止递归过程。下面的函数示例就陷入了一个无限循环:\nvoid Looper (void){\rprintf (\u0026#34;Looper function called. \\n\u0026#34;);\rLooper (); } 调用这个函数会输出无数行结果,因为在执行printfO调用后,函数会调用它自己。代码中没有停止该过程的机制。这就类似于一个无限循环问题,解决方法也很类似:个调用自己的函数必须包含停止处理的方式,下面说明这个方式。\n递归的主要用途是解决复杂的问题,所以很难用简单的例子说明其工作原理。因此,这里使用标准证明方式:计算整数阶乘。所谓整数阶乘,就是从1到该整数的所有整数之积。下面是相关代码:\n#include \u0026#34;stdio.h\u0026#34;\r# define __STDC_WANT_LIB_EXT1__ 1\runsigned long long factorial(unsigned long long);\rint main(void) {\runsigned long long number = 0LL;\rprintf(\u0026#34;Enter an integer value:\u0026#34;);\rscanf_s(\u0026#34;%llu\u0026#34;, \u0026amp;number);\rprintf(\u0026#34;The factorial of %llu is %llu\\n\u0026#34;, number, factorial(number));\rreturn 0;\r}\runsigned long long factorial(unsigned long long n) {\rif (n \u0026lt; 2LL)\rreturn n;\rreturn n * factorial(n - 1LL);\r} 程序的输出结果如下:\nEnter an integer value:15\rThe factorial of 15 is 1307674368000 9.4 变元个数可变的函数 在标准库中,某些函数的变元数是可变的,例如函数 printf()和 scanf()。有时需要这么做,所以标准库\u0026lt;stdarg.h\u0026gt;提供了编写这种函数的例程。\n编写参数个数可变的函数时,第一个明显的问题是如何指定它的原型。假设要创建一个函数,计算两个或多个 double值的平均值。显然,计算少于两个数的平均值是没有意义的。它的原型可以这么编写:\ndouble average (double vl, double v2,...); 第二个参数类型后的 3 个点(省略号)表示,在前两个固定的变元后面,可以有数量可变的变元。至少要有一个固定的变元,其他内容和一般的函数原型一样,前两个变元是double类型,返回的结果也是double类型。\n变元个数可变的第二个问题是,在编写函数时如何引用变元?我们不知道有多少个变元,所以不可能给它们指定名称。唯一的方法是通过指针间接地指定变元。\u0026lt;stdarg.h\u0026gt;头文件为此提供了通常实现为宏的例程,宏的外观和操作都类似于函数,所以将它们作为函数来讨论。要实现变元个数可变的函数,必须同时使用3个宏: va_start()、va_arg()、va_end()。第一个宏的形式如下:\nvoid va_start (va_list parg, last_fixed_arg); 这个宏的名称来源于 variable argument start。这个函数接受两个变元: va_list 类型的指针 parg 和为函数指定的最后一个固定参数的名称。va_list 类型也在\u0026lt;stdarg.h\u0026gt;头文件中定义,用于存储支持可变参数列表的例程所需的信息。\n以 average() 函数为例,可以将该函数编写成:\ndouble average (double vl, double v2, ...){\rva_list parg; // Pointer for variable argument list\r// More code to go here...\rva_start ( parg, v2);\r// More code to go here...\r} 首先,声明一个 va_list 类型的变量 parg。然后,用 parg 作为第一个变元,指定最后一个固定参数 v2 作为第二个变元,调用 va_start()。调用 va_start()的结果是将变量 parg 设定为指向传送给函数的第一个可变变元。此时并不知道这个值的类型,标准库对此也无能为力。但必须确定每一个可变变元的类型,例如假设所有的可变变元都是同一种特定的类型,或从固定变元包含的信息推断每个变元的类型。\naverage() 函数处理 double 类型的变元,所以确定可变变元的类型不成问题。现在必须知道如何访问每个可变变元的值,因此下面完成 average()函数:\ndouble average(double vl, double v2, ...) {\rva_list parg; // Pointer for variable argument list\rdouble sum = vl + v2;\rdouble value = 0.0;\rint count = 2;\rva_start (parg, v2); // Initialize argument pointer\rwhile ((value = va_arg (parg, double)) != 0.0) {\rsum += value;\r++count;\r}\rva_end (parg); // End variable argument process\rreturn sum / count;\r} 在声明 parg 后,将变量 sum 声明为 double 类型,同时用前两个固定变元 v1 和 v2 的和来初始化 sum。所有变元值的和都会累加到 sum 中,所以下一个变量 value 声明成 double ,用于存储获得的每个可变变元的值。然后声明计数器 count ,用来存储变元的数目,并将该计数器初始化为 2,因为至少有两个固定变元。在调用 va_start() 初始化 parg 后,在下面的 while 循环内执行大部分的操作:\nwhile ((value = va_arg (parg, double)) != 0.0) 循环条件调用了\u0026lt;stdarg.h\u0026gt;头文件中的另一个函数 va_arg()。 va_arg()的第一个变元是通过调用 va_start()初始化的变量 parg,第二个变元是期望确定的变元类型的说明。 va_arg()函数会返回 parg 指定的当前变元值,并将它存储到 value 中。同时会更新 parg 指针,使之根据调用中指定的类型,指向列表中的下一个变元。必须有某种方式来确定可变变元的类型,因为如果指定的类型不正确,就不能正确得到下一个变元。在这个例子中编写函数时,假设所有的变元都是 double 类型。另一个假设是除了最后一个变元外,其他变元都是非零值。这反映在循环继续条件中,即 value 不等于 0 。在循环中,在 sum 中累计总和,并递增 count.\n变元值等于 0 时,就结束循环,执行下一行语句:\nva_end (parg); 调用va_end()函数,处理该过程的剩余工作。它将parg重置为指向NULL。如果省掉这个调用,程序就不会正常工作。整理完成后,就可以用下面的语句返回需要的结果了:\nreturn sum / count; 编写完函数 average() 后,最好用一个小程序确保它可以正常工作:\n#include \u0026#34;stdio.h\u0026#34;\r#include \u0026#34;stdarg.h\u0026#34;\rdouble average(double vl, double v2, ...);\rint main(void) {\rdouble v1 = 10.5, v2 = 2.5;\rint num1 = 6, num2 = 5;\rlong num3 = 12L, num4 = 20L;\rprintf(\u0026#34;Average = %.2lf\\n\u0026#34;, average(v1, 3.5, v2, 4.5, 0.0));\rprintf(\u0026#34;Average = %.2lf\\n\u0026#34;, average(1.0, 2.0, 0.0));\rprintf(\u0026#34;Average = %.2lf\\n\u0026#34;, average((double) num2, v2, (double) num1, (double) num4, (double) num3, 0.0));\rreturn 0;\r}\rdouble average(double vl, double v2, ...) {\rva_list parg; // Pointer for variable argument list\rdouble sum = vl + v2;\rdouble value = 0.0;\rint count = 2;\rva_start (parg, v2); // Initialize argument pointer\rwhile ((value = va_arg (parg, double)) != 0.0) {\rsum += value;\r++count;\r}\rva_end (parg); // End variable argument process\rreturn sum / count;\r} 编译并运行程序,输出如下:\nAverage = 5.25\rAverage = 1.50\rAverage = 9.10 这是用不同数目的变元调用 3 次 average() 的结果。可变的变量必须转换成 double 类型,因为这是函数 average() 假设的变元类型。可以用任何数目的变元调用 average() 函数,但最后一个变元必须是 0.0。\nprintf()如何处理混合类型? printf()的第一个变元是带有格式说明符的控制字符串,它提供的信息确定了其后变元的类型和个数。第一个变元后面的变元个数必须匹配控制字符串中格式说明符的数目,这些变元的类型也必须符合对应的格式说明符隐含的类型。如果为要输出的变量指定了错误的类型,输出的结果就不正确。\n9.4.1 复制 va_list 有时需要多次处理可变的变元列表。\u0026lt;stdarg.h\u0026gt;头文件为此定义了一个复制已有 va_list 的例程。假定在函数中使用 va_start() 创建并初始化了一个 va_list 对象 parg,现在要复制 parg:\nva_list parg_copy;\rva_copy (parg_copy, parg) ; 第一条语句创建了一个新的 va_list 变量 parg_copy,下一条语句将 parg 的内容复制到 parg_copy 中。接着可以独立地处理 parg 和 parg_copy,使用 va_arg()和 va_end() 提取变元值。\n注意, copy()例程复制 va_list 对象时,不需要考虑它所处的状态。所以,如果用 parg 执行va_arg(),从列表中提取变元值,之后执行 copy() 例程, parg_copy 的状态就与已经提取出来的一些变元值相同。另外注意,在对 parg_copy 执行pa_end()之前,不能将 va_list 对象 parg_copy 用作另一个复制过程的目标。\n9.4.2 长度可变的变元列表的基本规则 以下是编写变元数目可变的函数的基本规则:\n在变元数目可变的函数中,至少要有一个固定变元。 必须调用 va_start()初始化函数中可变变元列表指针的值。变元指针的类型必须声明为 va_list类型。 必须有确定每个变元的类型的机制。可以假设默认的类型,或用一个参数来指定变元的类型。例如,在 average()函数中,可以有另一个固定的变元,它的值为 0 时表示变元的类型是 double;它的值为 1 时表示变元的类型是 long。如果在 va_arg() 调用中指定的变元类型不对应调用函数时指定的变元值,函数就不能正常工作。 必须有确定何时终止变元列表的方法。例如,在可变的变元列表中,最后一个变元有固定的值,称为“哨兵”值,可以检测它,因为它不同于其他变元的值。或者,在第一个变元中包含变元的个数或变元列表中的可变变元个数。 va_arg()的第二个变元指定了变元值的类型,这个指针类型可以在类型名的后面加上*来指定。最好检查一下编译器的文档说明,了解其他限制。 在退出变元数目可变的函数前,必须调用va_end()。否则,函数将不会正常运作。 可以试着修改程序 9.7,更好地了解这个过程。在 average()函数中输出一些信息,看看改变了某些数据后会发生什么。例如,可以在 average()函数的循环中显示 value 和 count,再修改 main(),使用非 double 类型的变元,或调用最后一个变元不是 0.0 的函数。\n9.5 main()函数 main()函数是程序执行的起点。这个函数有一个参数列表,在命令行中执行程序时,可以给它传递变元。main(函数可以有两个参数,也可以没有参数。\nmain()函数有参数时,第一个参数的类型是 int,表示在命令行中执行 main()函数的参数个数,包含程序名在内。第二个参数是一个字符串指针数组。因此,如果在语句行中,在程序名称的后面添加两个变元,main()函数的第一个变元值就是 3,第二个参数是一个包含 3 个指针的数组,第一个指针指向程序的名称,第二和第三个指针指向在命令行上输入的两个变元。\n#include \u0026#34;stdio.h\u0026#34;\rint main(int argc, char *argv[]) {\rprintf(\u0026#34;Program name: %s\\n\u0026#34;, argv[0]);\rfor (int i = 1; i \u0026lt; argc; ++i)\rprintf(\u0026#34;Argument %d: %s\\n\u0026#34;, i, argv[i]);\rreturn 0;\r} argc 的值至少是1,因为执行程序时,必须输入程序名称。argv[0]是程序名称,argv 数组中的后续元素是在命令行下输入的变元。上述程序在 for 循环中依序输出这些变元。\n这个程序的源文件是 D:\\Projects\\GitHubProjects\\USFM\\9\\9.5\\cmake-build-debug\\main.c,所以输入如下命令来执行它:\nfirst second_arg \u0026#34;Third is this\u0026#34; 注意,使用双引号包含有空格的变元。这是因为空格一般被看做分隔符。可以将变元放在双引号中,确保将它当作一个变元。\n上述命令会创建下面的输出:\nD:\\Projects\\GitHubProjects\\USFM\\9\\9.5\\cmake-build-debug\\main.exe first second_arg \u0026#34;Third is this\u0026#34;\rProgram name: D:\\Projects\\GitHubProjects\\USFM\\9\\9.5\\cmake-build-debug\\main.exe\rArgument 1: first\rArgument 2: second_arg\rArgument 3: Third is this 将最后一个变元放在双引号中,确保将它看做一个变元,而不是 3 个变元。\n所有命令行变元都以字符串读入,如果在命令行上输入数值,就需要把包含数值的字符串转换成适当的数值类型。为此可以使用表9-1中的函数,这些函数在\u0026lt;stdlib.h\u0026gt;头文件中声明。\n表9-1 将字符串转换为数值的函数\n函数 说明 atof() 将作为变元传送的字符串转换为 double 类型 atoi() 将作为变元传送的字符串转换为 int 类型 atol() 将作为变元传送的字符串转换为 long 类型 atoll() 将作为变元传送的字符串转换为 long long 类型 例如,如果需要将一个命令行变元用作整数,可以用下面的方式处理:\nint arg_value = 0;\rif (argc \u0026gt; 1)\rarg_value = atoi(argv [1]);\relse{\rprintf (\u0026#34;Command line argument missing. \u0026#34;);\rreturn 1;\r} 注意检查变元的个数,在处理命令行变元前,先检查变元的数目是很重要的,因为很容易忘记输入变元。\n9.6 结束程序 上一章的程序 8.4 有多个实例,说明在 main()调用的函数中,可能需要结束程序的执行。在 main()中,可以返回以结束程序。但在其他函数中不会使用这个技术。在其他函数中结束程序可以是正常或不正常程序结束。函数确定计算结束是因为没有更多的数据要处理,或者用户输入的数据表示程序应结束。这些情形会导致程序正常结束。一般情况下,需要在一个函数中不正常地结束程序时,通常是因为在函数中检测到某个灾难性的状态,例如数据中某个严重的错误使程序不能继续执行;或者发生了大多数情况下不会发生的外部故障,例如找不到磁盘文件,或者在读取文件时检测到错误。\nstdlib.h 头文件提供的几个函数可以用于终止程序的执行。stdlib.h 头文件还提供了一些函数,标识出在程序正常结束时要调用的一个或多个自定义函数。这类函数可能没有参数,且把返回类型指定为void。当然,应通过函数指针标识要在终止程序时调用的函数。\n9.6.1 abort()函数 调用 abort() 函数会不正常地结束程序。它不需要参数,当然也没有返回值。希望结束程序时,可以调用它:\nabort(); 该函数会清空输出缓冲区,关闭打开的流,但它是否这么做取决于实现代码。\n9.6.2 exit()和atexit()函数 调用 exit() 函数会正常结束程序。该函数需要一个 int 类型的参数,它表示程序结束时的状态。该参数可以是 0 或者表示成功结束的 EXIT_SUCCESS,它会返回给主机环境。例如:\nexit(EXIT_SUCCESS); 如果变元是 EXIT_FAILURE,就把表示终止不成功的消息返回给主机环境。无论如何, exit()都会清空所有输出缓冲区,把它们包含的数据写入目的地,再关闭所有打开的流,之后把控制权返回给主机环境。返回给主机环境的值由实现代码确定。注意调用 exit()会正常终止程序,无论变元的值是什么。调用 atexit(),可以注册由 exit()调用的自定义函数。\n调用 atexit()会标识应用程序终止时要执行的函数。下面是其用法:\nvoid CleanUp (void); // Prototype of function to be called on normal exit\r...\rif (atexit(CleanUp))\rprintf(\u0026#34;Registration of function failed! \\n\u0026#34;); 把要调用的函数名作为变元传递给 atexit(),如果注册成功,就返回 0,否则返回非 0 值。调用几次 atexit(),就可以注册几个函数,必须给函数提供遵循 C 标准的实现代码,且注册的函数最多为 32 个。把几个函数注册为调用 exit()时执行,它们就在程序终止时以注册顺序的倒序调用。即调用 atexit()注册的最后一个函数最先执行。\n9.6.3 _Exit()函数 _Exit()函数的作用与 exit()相同,它也会正常终止程序,并把变元值返回给主机环境。区别是它无法影响程序终止时调用 _Exit()函数的结果,因为它不调用任何已注册的函数。调用 _Exit()的方法如下:\n_Exit(1); 9.6.4 quick_exit()和 at_quick_exit()函数 调用 quick_exit() 会正常终止程序,再调用 _Exit() 把控制权返回给主机环境。 quick_exit()的变元是一个 int 类型的状态码,该函数在调用 _Exit() 时传递该变元。在调用 _Exit() 之前, quick_exit()会调用通过 at_quick_exit()函数调用注册的函数。下面把函数注册为由quick_exit()调用:\nvoid CloseFiles (void) ;\rvoid CloseCommunicationsLinks (void);\r...\rat_quick_exit (CloseCommunicationsLinks);\rat_quick_exit (CloseFiles); 最后两个语句把函数注册为由 quick_exit()调用,于是先调用 CloseFiles(),再调用CloseCommunicationLinks()。\nquick_exit()函数提供了与 exit()平行的程序终止机制。注册为由 exit()和 quick_exit()调用的函数完全相互独立。通过调用 atexit()注册的函数不由 quick_exit()调用,用at_quick_exit()注册的函数也不由 exit()调用。\n9.7 提高性能 有 3 个工具可以使编译器生成性能更佳的代码。其中一个工具与短函数调用的编译方式相关,另一个工具涉及指针的使用。但这些工具不能保证其效果,而是取决于编译器的实现方式。第三个工具用于永远不返回的函数。这里先探讨短函数。\n9.7.1 内联声明函数 C语言的功能结构要求将程序分解为许多函数,函数有时可以非常短。短函数的每次调用可以用实现该函数功能的内联代码替代,以提高执行性能。这意味着不需要给函数传递值或返回一个值。要让编译器采用这种技术,可以把短函数指定为 inline,下面是一个例子:\ninline double bmi(double kg_wt, double m_height) {\rreturn kg_wt / (m_height * m_height);\r} 这个函数根据成人的体重(Kg)及身高(m)计算其体质指数。这个操作可以定义为一个函数,也可以使用调用的内联实现方式,因为其代码非常简单。要采用后一种方式,需要在函数头中使用 inline 关键字来指定。但一般不保证编译器能识别声明为 inline 的函数,因为该关键字对于编译器来说只是一个提示。\n9.7.2 使用 restrict 关键字 专业的 C 编译器可以优化对象代码的性能,这涉及到改变在代码中为操作指定的计算顺序。为了优化代码,编译器必须确保操作的这种重新排序不影响计算的结果,并用指针指出这方面的错误。为了优化涉及指针的代码,编译器必须能确定指针是没有别名的一一换言之,每个指针引用的数据项都没有在给定范围内以其他方式引用。关键字 restrict 就可以告诉编译器,何时出现这种情况,并允许应用代码优化功能。下面是一个在\u0026lt;string.h\u0026gt;中声明的函数示例:\nerrno_t strcpy_s (char * restrict s1, rsize_t slmax, const char * restrict s2){\r// Implementation of the function to copy s2 to s1\r} 这个函数将 s2 复制到 s1 中。关键字 restrict 应用于两个指针参数,表示在函数体中,s1和 s2 引用的字符串仅通过这两个指针引用,所以编译器可以优化为该函数生成的代码。关键字 restrict 仅将信息告知编译器,但不保证进行优化。当然,如果在条件不具备的代码上应用了关键字 restrict ,代码就会生成不正确的结果。在大多数情况下,不需要使用关键字 restrict,只有代码进行大量计算,进行代码优化才有显著的效果,而这还取决于编译器。\n9.7.3 _Noreturn 函数限定符 有时,实现的函数永远都不返回。例如,可能定义一个函数,在程序正常终止时调用。这种函数不会返回,因为控制权会像通常那样返回给调用者,此时,可以告诉编译器,该函数不返回:\n_Noreturn void EndAll (void){\r// Tidy up open files...\rexit (EXIT SUCCESS) ;\r} _Noreturn 限定符告诉编译器,这个函数不返回给其调用函数。因为该函数不返回,所以唯一可用的返回类型是 void。知道一个函数永远都不返回,编译器就可以省略把控制权返回到调用点所需的代码和存储空间。stdnoreturn.h 头文件定义了宏 noreturn,它扩展为_Noreturn,所以只要在源文件中包含这个头文件,就可以使用 noreturn。\n9.8 设计程序 到此函数已经介绍完毕,我们的 C 语言学习之旅也已过半,一些不太复杂的问题应该都可以解决。接下来的这个程序将实际用到目前学过的各种 C 元素。\n9.8.1 问题 现在要解决的问题是编写一个游戏。选择编写游戏程序有几个理由。首先,游戏比其他类型的程序复杂,即使是比较简单的游戏程序。其次,游戏比较有趣!\n这个游戏与五子棋或 Microsoft Windows 3.0 的 Reversi 有相同的性质。这个游戏要两位玩家在棋盘上轮流放置不同颜色的棋子,一位玩家使用黑子,另一位玩家使用白子。棋盘是一个偶数边的正方形,图 9-4 显示了从开始位置到连续下五子的过程。\n只能将一个棋子放在对手的棋子旁,使对手在对角线、水平线或垂直线上的棋子被自己的棋子包围住,这样对手的棋子就变成自己的棋子了;游戏结束时,棋子多的玩家就获胜。如果所有的方格都放置了棋子,游戏就结束;或者没有玩家在放下棋子后能将对方的棋子变成自己的棋子,这局也算结束。这个游戏可以使用任何大小的棋盘,这里使用 6×6 的棋盘,并使一位玩家和计算机对奕。\n9.8.2 分析 这个问题的分析和以前所见的稍有不同。本章介绍的重点是结构化编程,换句话说,就是将一个大问题分解成许多小问题逐一解决,这就是要花这么多时间介绍函数的原因。\n最好先用一张图来进行分析。首先有一个方框,它代表整个程序或 main()函数。下一层是要在 main()函数中直接调用的函数,并说明这些函数的功能。再下一层是这些函数要使用的更小的函数。不必编写函数,只要写出它们必须完成的工作即可。然而这些就是函数要做的工作,所以这是设计程序的一种好方法。图 9-5 显示了程序要执行的任务。\n现在可以开始思考操作或函数的执行顺序了。图 9-6 是一个流程图,它不仅描述了这组函数,还描述了这些函数的执行顺序与确定其执行顺序的逻辑。这更精确地说明了程序的运作方式。\n当然,这还没有完成,还必须详细填入许多细节。这种图可以帮助理清程序的逻辑,进而对程序的运作方式进行更详细的定义。\nP354\n9.8.3 解决方案 本节列出解决问题的步骤。\n1. 步骤 1 首先,建立并显示初始棋盘。为了使游戏程序比较短,使用比较小的棋盘(6×6)。但这里在程序中通过一个预处理器指令将棋盘的大小设置为一个符号,以便在以后改变棋盘的大小。使用一个独立的函数显示棋盘,因为这是一个自包含的活动。\n从声明、初始化及显示棋盘的代码开始。计算机使用@作为棋子,玩家使用0作为棋子:\n"},{"id":96,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition/","title":"Beginning C , Fifth Edition","parent":"Beginning C ,Fifth Edition","content":" Beginning C ,Fifth Edition 译者序 前言 有抱负的程序员必将面对的三重障碍，遍布程序设计语言中的各类术语、理解如何使用语言元素的语法和作用（而不仅仅只是知道它们的概念）、领会如何在实际场景中应用该语言。\n"},{"id":97,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/C-Standard-Functions/","title":"C Standard Functions","parent":"Beginning C ,Fifth Edition","content":" 头文件\u0026lt;stdio.h\u0026gt; scanf_s const size_t BUF_SIZE = 100; // Input buffer size char buffer[BUF_SIZE]; // A 100 byte input buffer scanf_s(\u0026#34;%s\u0026#34;, buffer, BUF_SIZE); // Read a string 从各种来源读取数据，根据其解释并将format结果存储到给定位置。\n1）从中读取数据 stdin\n2）从文件流中读取数据 stream\n3）从空终止的字符串中读取数据buffer。到达字符串的末尾等同于达到文件结束条件fscanf\n"},{"id":98,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/","title":"Go入门指南 第10章：结构（struct）与方法（method）","parent":"Go入门指南","content":" 第10章：结构（struct）与方法（method） 10.1 结构体定义 10.2 使用工厂方法创建结构体实例 10.3 使用自定义包中的结构体 10.4 带标签的结构体 10.5 匿名字段和内嵌结构体 10.6 方法 10.7 类型的 String() 方法和格式化描述符 10.8 垃圾回收和 SetFinalizer "},{"id":99,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0%E6%8E%A5%E5%8F%A3interface%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/","title":"Go入门指南 第11章：接口（interface）与反射（reflection）","parent":"Go入门指南","content":" 第11章：接口（interface）与反射（reflection） 11.1 接口是什么 11.2 接口嵌套接口 11.3 类型断言：如何检测和转换接口变量的类型 11.4 类型判断：type-switch 11.5 测试一个值是否实现了某个接口 11.6 使用方法集与接口 11.7 第一个例子：使用 Sorter 接口排序 11.8 第二个例子：读和写 11.9 空接口 11.10 反射包 11.11 Printf 和反射 11.12 接口与动态类型 11.13 总结：Go 中的面向对象 11.14 结构体、集合和高阶函数 第三部分：Go 高级编程 "},{"id":100,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/","title":"Go入门指南 第12章：读写数据","parent":"Go入门指南","content":" 第12章：读写数据 12.1 读取用户的输入 12.2 文件读写 12.3 文件拷贝 12.4 从命令行读取参数 12.5 用 buffer 读取文件 12.6 用切片读写文件 12.7 用 defer 关闭文件 12.8 使用接口的实际例子：fmt.Fprintf 12.9 格式化 JSON 数据 12.10 XML 数据格式 12.11 用 Gob 传输数据 12.12 Go 中的密码学 "},{"id":101,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC13%E7%AB%A0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/","title":"Go入门指南 第13章：错误处理与测试","parent":"Go入门指南","content":" 第13章：错误处理与测试 13.1 错误处理 13.2 运行时异常和 panic 13.3 从 panic 中恢复（Recover） 13.4 自定义包中的错误处理和 panicking 13.5 一种用闭包处理错误的模式 13.6 启动外部命令和程序 13.7 Go 中的单元测试和基准测试 13.8 测试的具体例子 13.9 用（测试数据）表驱动测试 13.10 性能调试：分析并优化 Go 程序 "},{"id":102,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC1%E7%AB%A0Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90%E5%8F%91%E5%B1%95%E4%B8%8E%E6%99%AE%E5%8F%8A/","title":"Go入门指南 第1章： Go 语言的起源，发展与普及","parent":"Go入门指南","content":" Go入门指南.mk 1.1 起源与发展 1.2 语言的主要特性与发展的环境和影响因素 "},{"id":103,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%AB%A0%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","title":"Go入门指南 第2章：安装与运行环境","parent":"Go入门指南","content":" Go入门指南.mk 第2章：安装与运行环境 2.1 平台与架构 2.2 Go 环境变量 Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：\n$GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。 目标机器是指你打算运行你的 Go 应用程序的机器。\nGo 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。\n为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。\n$GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节。 2.3 在 Linux 上安装 Go 2.4 在 Mac OS X 上安装 Go 2.5 在 Windows 上安装 Go 2.6 安装目录清单 你的 Go 安装目录（$GOROOT）的文件夹结构应该如下所示：\nREADME.md, AUTHORS, CONTRIBUTORS, LICENSE\n/bin：包含可执行文件，如：编译器，Go 工具 /doc：包含示例程序，代码工具，本地文档等 /lib：包含文档模版 /misc：包含与支持 Go 编辑器有关的配置文件以及 cgo 的示例 /os_arch：包含标准库的包的对象文件（.a） /src：包含源代码构建脚本和标准库的包的完整源代码（Go 是一门开源语言） /src/cmd：包含 Go 和 C 的编译器和命令行脚本 2.7 Go 运行时（runtime） 尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。\nruntime 主要由 C 语言编写（Go 1.5 开始自举），并且是每个 Go 包的最顶级包。你可以在目录 $GOROOT/src/runtime 中找到相关内容。\n垃圾回收器 Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。目前 gccgo 还没有回收器，同时适用 gc 和 gccgo 的新回收器正在研发中。使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。\nGo 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。但总的来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。\n2.8 Go 解释器 因为 Go 具有像动态语言那样快速编译的能力，自然而然地就有人会问 Go 语言能否在 REPL（read-eval-print loop）编程环境下实现。Sebastien Binet 已经使用这种环境实现了一个 Go 解释器，你可以在这个页面找到：https://github.com/sbinet/igo。## 第2章：安装与运行环境\n"},{"id":104,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC3%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%85%B6%E5%AE%83%E5%B7%A5%E5%85%B7/","title":"Go入门指南 第3章：编辑器、集成开发环境与其它工具","parent":"Go入门指南","content":" Go入门指南.mk 第3章：编辑器、集成开发环境与其它工具 3.1 Go 开发环境的基本要求 这里有一个可以用来开发 Go 的集成开发环境，你期待有以下哪些特性，从而替代你使用文本编辑器写代码和命令行编译与链接程序的方式？\n语法高亮是必不可少的功能，这也是每个开发工具都提供配置文件来实现自定义配置的原因。 可以自动保存代码，至少在每次编译前都会保存。 可以显示代码所在的行数。 拥有较好的项目文件纵览和导航能力，可以同时编辑多个源文件并设置书签，能够匹配括号，能够跳转到某个函数或类型的定义部分。 完美的查找和替换功能，替换之前最好还能预览结果。 可以注释或取消注释选中的一行或多行代码。 当有编译错误时，双击错误提示可以跳转到发生错误的位置。 跨平台，能够在 Linux、Mac OS X 和 Windows 下工作，这样就可以专注于一个开发环境。 最好是免费的，不过有些开发者还是希望能够通过支付一定金额以获得更好的开发环境。 最好是开源的。 能够通过插件架构来轻易扩展和替换某个功能。 尽管集成开发环境本身就是非常复杂的，但一定要让人感觉操作方便。 能够通过代码模版来简化编码过程从而提升编码速度。 使用 Go 项目的概念来浏览和管理项目中的文件，同时还要拥有构建系统的概念，这样才能更加方便的构建、清理或运行我们建立的程序或项目。构建出的程序需要能够通过命令行或 IDE 内部的控制台运行。 拥有断点、检查变量值、单步执行、逐过程执行标识库中代码的能力。 能够方便的存取最近使用过的文件或项目。 拥有对包、类型、变量、函数和方法的智能代码补全的功能。 能够对项目或包中的代码建立抽象语法树视图（AST-view）。 内置 Go 的相关工具。 能够方便完整地查阅 Go 文档。 能够方便地在不同的 Go 环境之间切换。 能够导出不同格式的代码文件，如：PDF，HTML 或格式化后的代码。 针对一些特定的项目有项目模板，如：Web 应用，App Engine 项目，从而能够更快地开始开发工作。 具备代码重构的能力。 集成像 hg 或 git 这样的版本控制工具。 集成 Google App Engine 开发及调试的功能。 3.2 编辑器和集成开发环境 3.3 调试器 如果你不想使用调试器，你可以按照下面的一些有用的方法来达到基本调试的目的：\n在合适的位置使用打印语句输出相关变量的值（print/println 和 fmt.Print/fmt.Println/fmt.Printf）。\n在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息：\n%+v 打印包括字段在内的实例的完整信息 %#v 打印包括字段和限定类型名称在内的实例的完整信息 %T 打印某个类型的完整说明 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。\n使用关键字 defer 来跟踪代码执行过程（第 6.4 节）。\n3.4 构建并运行 Go 程序 3.5 格式化代码 3.6 生成代码文档 3.7 其它工具 3.8 Go 性能说明 3.9 与其它语言进行交互 "},{"id":105,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"Go入门指南 第4章：基本结构和基本数据类型","parent":"Go入门指南","content":" Go入门指南.mk 第二部分：语言的核心结构与技术 第4章：基本结构和基本数据类型 4.1 文件名、关键字与标识符 Go 的源文件以 .go 为后缀名存储在计算机中，这些文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 scanner_test.go 。文件名不包含空格或其他特殊字符。\n一个源文件可以包含任意多行的代码，Go 本身没有对源文件的大小进行限制。\n有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头，然后紧跟着 0 个或多个字符或 Unicode 数字\n_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。\n程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。\n如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。\n4.2 Go 程序的基本结构和要素 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。\n如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。\n你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。\n一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。\n标准库 在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。\nGo 的标准库包含了大量的包（如：fmt 和 os），但是你也可以创建自己的包（第 9 章）。\n如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决定了其构建顺序。\n属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，每个目录都只包含一个包。\n如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。\nGo 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。\n如果 A.go 依赖 B.go，而 B.go 又依赖 C.go：\n编译 C.go, B.go, 然后是 A.go. 为了编译 A.go, 编译器读取的是 B.o 而不是 C.o. 这种机制对于编译大型的项目时可以显著地提升编译速度。\n每一段代码只会被编译一次\n一个 Go 程序是通过 import 关键字将一组包链接在一起。\nimport \u0026ldquo;fmt\u0026rdquo; 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。包名被封闭在半角双引号 \u0026quot;\u0026quot; 中。如果你打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译包的源代码。\n如果需要多个包，它们可以被分别导入：\nimport \u0026#34;fmt\u0026#34;\rimport \u0026#34;os\u0026#34; 或\nimport \u0026#34;fmt\u0026#34;; import \u0026#34;os\u0026#34; 但是还有更短且更优雅的方法（被称为因式分解关键字，该方法同样适用于 const、var 和 type 的声明或定义）：\nimport (\r\u0026#34;fmt\u0026#34;\r\u0026#34;os\u0026#34;\r) 它甚至还可以更短的形式，但使用 gofmt 后将会被强制换行：\nimport (\u0026#34;fmt\u0026#34;; \u0026#34;os\u0026#34;) 当你导入多个包时，最好按照字母顺序排列包名，这样做更加清晰易读。\n如果包名以 / 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。 如果包名以 ./ 开头，则 Go 会在相对目录中查找； 如果包名不是以 . 或 / 开头，如 \u0026ldquo;fmt\u0026rdquo; 或者 \u0026ldquo;container/list\u0026rdquo;，则 Go 会在全局文件进行查找； 导入包即等同于包含了这个包的所有的代码对象。\n除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。\n包通过下面这个被编译器强制执行的规则来决定是否将自身的代码对象暴露给外部文件：\n可见性规则 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。\n（大写字母可以使用任何 Unicode 编码的字符，比如希腊文，不仅仅是 ASCII 码中的大写字母）。\n因此，在导入一个外部包后，能够且只能够访问该包中导出的对象。\n假设在包 pack1 中我们有一个变量或函数叫做 Thing（以 T 开头，所以它能够被导出），那么在当前包中导入 pack1 包，Thing 就可以像面向对象语言那样使用点标记来调用：pack1.Thing（pack1 在这里是不可以省略的）。\n因此包也可以作为命名空间使用，帮助避免命名冲突（名称冲突）：两个包中的同名变量的区别在于他们的包名，例如 pack1.Thing 和 pack2.Thing。\n你可以通过使用包的别名来解决包名之间的名称冲突，或者说根据你的个人喜好对包名进行重新设置，如：import fm \u0026ldquo;fmt\u0026rdquo;。下面的代码展示了如何使用包的别名：\npackage main\rimport fm \u0026#34;fmt\u0026#34; // alias3\rfunc main() {\rfm.Println(\u0026#34;hello, world\u0026#34;)\r} 注意事项\n如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！“。\n包的分级声明和初始化 你可以在使用 import 导入包之后定义或声明 0 个或多个常量（const）、变量（var）和类型（type），这些对象的作用域都是全局的（在本包范围内），所以可以被本包中所有的函数调用（如 gotemplate.go 源文件中的 c 和 v），然后声明一个或多个函数（func）。\npackage main\rimport (\r\u0026#34;fmt\u0026#34;\r)\rconst c = \u0026#34;C\u0026#34;\rvar v int = 5\rtype T struct{}\rfunc init() {\r// initialization of package\r}\rfunc main() {\rvar a int\rFunc1()\r// ...\rfmt.Println(a)\r}\rfunc (t T) Method1() {\r//...\r}\rfunc Func1() { // exported function Func1\r//...\r} 4.2.2 函数 这是定义一个函数最简单的格式：\nfunc functionName() 你可以在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型。\nmain 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。如果你的 main 包的源代码没有包含 main 函数，则会引发构建错误 undefined: main.main。main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。如果你不小心为 main 函数添加了参数或者返回类型，将会引发构建错误\nfunc main must have no arguments and no return values results. 在程序开始执行并完成初始化后，第一个调用（程序的入口点）的函数是 main.main()（如：C 语言），该函数一旦返回就表示程序已成功执行并立即退出。\n函数里的代码（函数体）使用大括号 {} 括起来。\n左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示：\n`build-error: syntax error: unexpected semicolon or newline before {` （这是因为编译器会产生 func main() ; 这样的结果，很明显这错误的）\nGo 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误\n右大括号 } 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行：\nfunc Sum(a, b int) int { return a + b } 对于大括号 {} 的使用规则在任何时候都是相同的（如：if 语句等）。\n因此符合规范的函数一般写成如下的形式：\nfunc functionName(parameter_list) (return_value_list) {\r…\r} 其中：\nparameter_list 的形式为 (param1 type1, param2 type2, …) return_value_list 的形式为 (ret1 type1, ret2 type2, …) 只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法；否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。\n下面这一行调用了 fmt 包中的 Println 函数，可以将字符串输出到控制台，并在最后自动增加换行字符 \\n：\nfmt.Println（\u0026#34;hello, world\u0026#34;） 使用 fmt.Print(\u0026ldquo;hello, world\\n\u0026rdquo;) 可以得到相同的结果。\nPrint 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。\n单纯地打印一个字符串或变量甚至可以使用预定义的方法来实现，如：print、println：print(\u0026ldquo;ABC\u0026rdquo;)、println(\u0026ldquo;ABC\u0026rdquo;)、println(i)（带一个变量 i）。\n这些函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 fmt 中的相关函数。\n当被调用函数的代码执行到结束符 } 或返回语句时就会返回，然后程序继续执行调用该函数之后的代码。\n程序正常退出的代码为 0 即 Program exited with code 0；如果程序因为异常而被终止，则会返回非零值，如：1。这个数值可以用来测试是否成功执行一个程序。\n4.2.3 注释 示例 4.2 hello_world2.go\npackage main\rimport \u0026#34;fmt\u0026#34; // Package implementing formatted I/O.\rfunc main() {\rfmt.Printf(\u0026#34;Καλημέρα κόσμε; or こんにちは 世界\\n\u0026#34;)\r} 上面这个例子通过打印 Καλημέρα κόσμε; or こんにちは 世界 展示了如何在 Go 中使用国际化字符，以及如何使用注释。\n注释不会被编译，但可以通过 godoc 来使用（第 3.6 节）。\n单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。\n每一个包应该有相关注释，在 package 语句之前的块注释将被默认认为是这个包的文档说明，其中应该提供一些相关信息并对整体功能做简要的介绍。一个包可以分散在多个文件中，但是只需要在其中一个进行注释说明即可。当开发人员需要了解包的一些情况时，自然会用 godoc 来显示包的文档说明，在首行的简要注释之后可以用成段的注释来进行更详细的说明，而不必拥挤在一起。另外，在多段注释之间应以空行分隔加以区分。\n示例：\n// Package superman implements methods for saving the world.\r//\r// Experience has shown that a small number of procedures can prove\r// helpful when attempting to save the world.\rpackage superman 几乎所有全局作用域的类型、常量、变量、函数和被导出的对象都应该有一个合理的注释。如果这种注释（称为文档注释）出现在函数前面，例如函数 Abcd，则要以 \u0026ldquo;Abcd\u0026hellip;\u0026rdquo; 作为开头。\n示例：\n// enterOrbit causes Superman to fly into low Earth orbit, a position\r// that presents several possibilities for planet salvation.\rfunc enterOrbit() error {\r...\r} godoc 工具（第 3.6 节）会收集这些注释并产生一个技术文档。\n4.2.4 类型 变量（或常量）包含数据，这些数据可以有不同的数据类型，简称类型。使用 var 声明的变量的值会自动初始化为该类型的零值。类型定义了某个变量的值的集合与可对其进行操作的集合。\n类型可以是基本类型，如：int、float、bool、string；结构化的（复合的），如：struct、array、slice、map、channel；只描述类型的行为的，如：interface。\n结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。\n函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如：\nfunc FunctionName (a typea, b typeb) typeFunc 你可以在函数体中的某处返回使用类型为 typeFunc 的变量 var：\nreturn var 一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来，如：\nfunc FunctionName (a typea, b typeb) (t1 type1, t2 type2) 示例： 函数 Atoi (第 4.7 节)：func Atoi(s string) (i int, err error)\n返回的形式：\nreturn var1, var2 这种多返回值一般用于判断某个函数是否执行成功（true/false）或与其它返回值一同返回错误消息（详见之后的并行赋值）。\n使用 type 关键字可以定义你自己的类型，你可能想要定义一个结构体(第 10 章)，但是也可以定义一个已经存在的类型的别名，如：\ntype IZ int 这里并不是真正意义上的别名，因为使用这种方法定义之后的类型可以拥有更多的特性，且在类型转换时必须显式转换。\n然后我们可以使用下面的方式声明变量：\nvar a IZ = 5 这里我们可以看到 int 是变量 a 的底层类型，这也使得它们之间存在相互转换的可能（第 4.2.6 节）。\n如果你有多个类型需要定义，可以使用因式分解关键字的方式，例如：\ntype (\rIZ int\rFZ float64\rSTR string\r) 每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值的类型），因为 Go 语言是一种静态类型语言。\n4.2.5 Go 程序的一般结构 下面的程序可以被顺利编译但什么都做不了，不过这很好地展示了一个 Go 程序的首选结构。这种结构并没有被强制要求，编译器也不关心 main 函数在前还是变量的声明在前，但使用统一的结构能够在从上至下阅读 Go 代码时有更好的体验。\n所有的结构将在这一章或接下来的章节中进一步地解释说明，但总体思路如下：\n在完成包的 import 之后，开始对常量、变量和类型的定义或声明。 如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执- 行这个函数）。 如果当前包是 main 包，则定义 main 函数。 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。 示例 4.4 gotemplate.go\npackage main\rimport (\r\u0026#34;fmt\u0026#34;\r)\rconst c = \u0026#34;C\u0026#34;\rvar v int = 5\rtype T struct{}\rfunc init() { // initialization of package\r}\rfunc main() {\rvar a int\rFunc1()\r// ...\rfmt.Println(a)\r}\rfunc (t T) Method1() {\r//...\r}\rfunc Func1() { // exported function Func1\r//...\r} Go 程序的执行（程序启动）顺序如下：\n按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程： 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。 4.2.6 类型转换 在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）：\nvalueOfTypeB = typeB(valueOfTypeA) 类型 B 的值 = 类型 B(类型 A 的值)\n示例：\na := 5.0\rb := int(a) 但这只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（例如将 int16 转换为 int32）。当从一个取值范围较大的转换到取值范围较小的类型时（例如将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。\n具有相同底层类型的变量之间可以相互转换：\nvar a IZ = 5\rc := int(a)\rd := IZ(c) 4.2.7 Go 命名规范 干净、可读的代码和简洁性是 Go 追求的主要目标。通过 gofmt 来强制实现统一的代码风格。Go 语言中对象的命名也应该是简洁且有意义的。像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。返回某个对象的函数或方法的名称一般都是使用名词，没有 Get\u0026hellip; 之类的字符，如果是用于修改某个对象，则使用 SetName。有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。\n4.3 常量 常量使用关键字 const 定义，用于存储不会改变的数据。\n存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。\n常量的定义格式：const identifier [type] = value，例如：\nconst Pi = 3.14159 在 Go 语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。\n显式类型定义： const b string = \u0026ldquo;abc\u0026rdquo; 隐式类型定义： const b = \u0026ldquo;abc\u0026rdquo; 一个没有指定类型的常量被使用时，会根据其使用环境而推断出它所需要具备的类型。换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。\nvar n int\rf(n + 5) // 无类型的数字型常量 “5” 它的类型在这里变成了 int 常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。\n正确的做法：const c1 = 2/3 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()。\n数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出：\nconst Ln2 = 0.693147180559945309417232121458\\\r176568075500134360255254120680009\rconst Log2E = 1/Ln2 // this is a precise reciprocal\rconst Billion = 1e9 // float constant\rconst hardEight = (1 \u0026lt;\u0026lt; 100) \u0026gt;\u0026gt; 97 根据上面的例子我们可以看到，反斜杠 \\ 可以在常量表达式中作为多行的连接符使用。\n与各种类型的数字型变量相比，你无需担心常量之间的类型转换问题，因为它们都是非常理想的数字。\n不过需要注意的是，当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表达常量所代表的数值而导致溢出，这会在编译期间就引发错误。另外，常量也允许使用并行赋值的形式：\n因式分解关键字???\nconst beef, two, c = \u0026#34;eat\u0026#34;, 2, \u0026#34;veg\u0026#34;\rconst Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6\rconst (\rMonday, Tuesday, Wednesday = 1, 2, 3\rThursday, Friday, Saturday = 4, 5, 6\r) 常量还可以用作枚举：\nconst (\rUnknown = 0\rFemale = 1\rMale = 2\r) 现在，数字 0、1 和 2 分别代表未知性别、女性和男性。这些枚举值可以用于测试某个变量或常量的实际值，比如使用 switch/case 结构 (第 5.3 节).\n在这个例子中，iota 可以被用作枚举值：\nconst (\ra = iota\rb = iota\rc = iota\r) 4.4 变量 4.5 基本类型和运算符 4.6 字符串 4.7 strings 和 strconv 包 4.8 时间和日期 4.9 指针 "},{"id":106,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC5%E7%AB%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","title":"Go入门指南 第5章：控制结构","parent":"Go入门指南","content":" Go入门指南.mk 第5章：控制结构 5.1 if-else 结构 5.2 测试多返回值函数的错误 5.3 switch 结构 5.4 for 结构 5.5 Break 与 continue 5.6 标签与 goto "},{"id":107,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC6%E7%AB%A0%E5%87%BD%E6%95%B0function/","title":"Go入门指南 第6章：函数（function）","parent":"Go入门指南","content":" 第6章：函数（function） 6.1 介绍 6.2 函数参数与返回值 6.3 传递变长参数 6.4 defer 和追踪 6.5 内置函数 6.6 递归函数 6.7 将函数作为参数 6.8 闭包 6.9 应用闭包：将函数作为返回值 6.10 使用闭包调试 6.11 计算函数执行时间 6.12 通过内存缓存来提升性能 "},{"id":108,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC7%E7%AB%A0%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/","title":"Go入门指南 第7章：数组与切片","parent":"Go入门指南","content":" 第7章：数组与切片 7.1 声明和初始化 7.2 切片 7.3 For-range 结构 7.4 切片重组（reslice） 7.5 切片的复制与追加 7.6 字符串、数组和切片的应用 "},{"id":109,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC8%E7%AB%A0Map/","title":"Go入门指南 第8章： Map","parent":"Go入门指南","content":" 第8章：Map 8.1 声明、初始化和 make 8.2 测试键值对是否存在及删除元素 8.3 for-range 的配套用法 8.4 map 类型的切片 8.5 map 的排序 8.6 将 map 的键值对调 "},{"id":110,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0%E5%8C%85package/","title":"Go入门指南 第9章：包（package）","parent":"Go入门指南","content":" 第9章：包（package） 9.1 标准库概述 9.2 regexp 包 9.3 锁和 sync 包 9.4 精密计算和 big 包 9.5 自定义包和可见性 9.6 为自定义包使用 godoc 9.7 使用 go install 安装自定义包 9.8 自定义包的目录结构、go install 和 go test 9.9 通过 Git 打包和安装 9.10 Go 的外部包和项目 9.11 在 Go 程序中使用外部库 "},{"id":111,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","title":"Go入门指南","parent":"Go入门指南","content":" Go入门指南.mk 标签：Golang、基础、 时间：2020年10月15日6:25:00 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 第一部分：学习 Go 语言 第1章：Go 语言的起源，发展与普及 1.1 起源与发展 1.2 语言的主要特性与发展的环境和影响因素 第2章：安装与运行环境 2.1 平台与架构 2.2 Go 环境变量 2.3 在 Linux 上安装 Go 2.4 在 Mac OS X 上安装 Go 2.5 在 Windows 上安装 Go 2.6 安装目录清单 2.7 Go 运行时（runtime） 2.8 Go 解释器 第3章：编辑器、集成开发环境与其它工具 3.1 Go 开发环境的基本要求 3.2 编辑器和集成开发环境 3.3 调试器 3.4 构建并运行 Go 程序 3.5 格式化代码 3.6 生成代码文档 3.7 其它工具 3.8 Go 性能说明 3.9 与其它语言进行交互 第二部分：语言的核心结构与技术 第4章：基本结构和基本数据类型 4.1 文件名、关键字与标识符 4.2 Go 程序的基本结构和要素 4.3 常量 4.4 变量 4.5 基本类型和运算符 4.6 字符串 4.7 strings 和 strconv 包 4.8 时间和日期 4.9 指针 第5章：控制结构 5.1 if-else 结构 5.2 测试多返回值函数的错误 5.3 switch 结构 5.4 for 结构 5.5 Break 与 continue 5.6 标签与 goto 第6章：函数（function） 6.1 介绍 6.2 函数参数与返回值 6.3 传递变长参数 6.4 defer 和追踪 6.5 内置函数 6.6 递归函数 6.7 将函数作为参数 6.8 闭包 6.9 应用闭包：将函数作为返回值 6.10 使用闭包调试 6.11 计算函数执行时间 6.12 通过内存缓存来提升性能 第7章：数组与切片 7.1 声明和初始化 7.2 切片 7.3 For-range 结构 7.4 切片重组（reslice） 7.5 切片的复制与追加 7.6 字符串、数组和切片的应用 第8章：Map 8.1 声明、初始化和 make 8.2 测试键值对是否存在及删除元素 8.3 for-range 的配套用法 8.4 map 类型的切片 8.5 map 的排序 8.6 将 map 的键值对调 第9章：包（package） 9.1 标准库概述 9.2 regexp 包 9.3 锁和 sync 包 9.4 精密计算和 big 包 9.5 自定义包和可见性 9.6 为自定义包使用 godoc 9.7 使用 go install 安装自定义包 9.8 自定义包的目录结构、go install 和 go test 9.9 通过 Git 打包和安装 9.10 Go 的外部包和项目 9.11 在 Go 程序中使用外部库 第10章：结构（struct）与方法（method） 10.1 结构体定义 10.2 使用工厂方法创建结构体实例 10.3 使用自定义包中的结构体 10.4 带标签的结构体 10.5 匿名字段和内嵌结构体 10.6 方法 10.7 类型的 String() 方法和格式化描述符 10.8 垃圾回收和 SetFinalizer 第11章：接口（interface）与反射（reflection） 11.1 接口是什么 11.2 接口嵌套接口 11.3 类型断言：如何检测和转换接口变量的类型 11.4 类型判断：type-switch 11.5 测试一个值是否实现了某个接口 11.6 使用方法集与接口 11.7 第一个例子：使用 Sorter 接口排序 11.8 第二个例子：读和写 11.9 空接口 11.10 反射包 11.11 Printf 和反射 11.12 接口与动态类型 11.13 总结：Go 中的面向对象 11.14 结构体、集合和高阶函数 第三部分：Go 高级编程 第12章：读写数据 12.1 读取用户的输入 12.2 文件读写 12.3 文件拷贝 12.4 从命令行读取参数 12.5 用 buffer 读取文件 12.6 用切片读写文件 12.7 用 defer 关闭文件 12.8 使用接口的实际例子：fmt.Fprintf 12.9 格式化 JSON 数据 12.10 XML 数据格式 12.11 用 Gob 传输数据 12.12 Go 中的密码学 第13章：错误处理与测试 13.1 错误处理 13.2 运行时异常和 panic 13.3 从 panic 中恢复（Recover） 13.4 自定义包中的错误处理和 panicking 13.5 一种用闭包处理错误的模式 13.6 启动外部命令和程序 13.7 Go 中的单元测试和基准测试 13.8 测试的具体例子 13.9 用（测试数据）表驱动测试 13.10 性能调试：分析并优化 Go 程序 "},{"id":112,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/%E6%A0%87%E9%A2%98/","title":"标题","parent":"Go入门指南","content":" Go入门指南 标签：Golang、基础 时间：2020年10月15日00点11分 连接：https://www.saveload.cn/html/GoLang/Go入门指南.mk "},{"id":113,"href":"/Tech/1Book/The-Rust-Programming-Language/rust/","title":"Rust","parent":"The Rust Programming Language","content":" Rust编程语言 标签：Rust、基础、 时间：2020年8月6日6:25:00 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 介绍 第 1章 入门 1.1。安装 1.2。你好，世界！ 1.3。您好，货运！ 第 2章 编写猜谜游戏 第 3章 通用编程概念 3.1。变量和可变性 3.2。资料类型 3.3。功能 3.4。注释 3.5。控制流 第 4章 了解所有权 4.1。什么是所有权？ 4.2。参考和借阅 4.3。切片类型 第 5章 使用结构来构造相关数据 5.1。定义和实例化结构 5.2。使用结构的示例程序 5.3。方法语法 第 6章 枚举和模式匹配 6.1。定义枚举 6.2。匹配控制流运算符 6.3。如果让简洁控制流 第 7 章 使用软件包，板条箱和模块管理不断增长的项目 Rust 中有三和重要的组织概念：包、箱、模块。\nPackages: A Cargo feature that lets you build, test, and share crates 包装：货运功能，可让您构建，测试和共享包装箱 Crates: A tree of modules that produces a library or executable 板条箱：产生库或可执行文件的模块树 Modules and use: Let you control the organization, scope, and privacy of paths 模块和用途：让您控制路径的组织，范围和隐私 Paths: A way of naming an item, such as a struct, function, or module 路径：一种命名项目的方法，例如结构，函数或模块 7.1。Packages and Crates 包装和板条箱 Cargo 是 Rust 的构建系统和包管理器。它可以帮助开发人员下载和管理依赖项，并帮助创建 Rust 包。在 Rust 社区中，Rust 中的“包”通常被称为“crate”（板条箱），因此在安装 Rust 时会得到 Cargo。\n要创建一个新的包，请使用关键字 new，跟上包名称。\ncargo new my-project 当运行 cargo new 时是在创建一个包\n运行 tree 命令以查看目录结构，它会报告已创建了一些文件和目录，首先，它创建一个带有包名称的目录，并且在该目录内有一个存放你的源代码文件的 src 目录，src 目录下会生成一个 main.rs 源文件，Cargo 默认这个文件为二进制箱的根，编译之后的二进制箱将与包名相同：\n$ tree .\r.\r└── hello_opensource\r├── Cargo.toml\r└── src\r└── main.rs\r2 directories, 2 files main.rs 文件经过编译后生产问二进制可执行文件与包名相同\n一个软件包包含一个Cargo.toml文件，包必须由一个 Cargo.toml 文件来管理，该文件描述了包的基本信息以及依赖项。\n一个包最多包含一个库\u0026quot;箱\u0026quot;，可以包含任意数量的二进制\u0026quot;箱\u0026quot;，但是至少包含一个\u0026quot;箱\u0026quot;（不管是库还是二进制\u0026quot;箱\u0026quot;）。\nCargo 的约定是如果在代表表的 Cargo.toml 的同级目录下包含 src 目录且其中包含 main.rs 文件的话，Cargo 就知道这个包带有一个与包同名的二进制 crate，且 src/main.rs 就是 crate 根。另一个约定如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。crate 根文件将由 Cargo 传递给 rustc来实际构建库或者二进制项目。\n我们有一个仅包含src / main.rs的软件包，这意味着它仅包含一个名为的二进制条板箱my-project。如果软件包包含src / main.rs 和src / lib.rs，则它有两个包装箱：库和二进制文件，两者的名称与软件包相同。通过将文件放在src / bin目录中，一个软件包可以具有多个二进制文件箱：每个文件将是一个单独的二进制文件箱。\n这是因为 main.rs 和 lib.rs 对于一个 crate 来讲，是两个特殊的文件名。rustc 内置了对这两个特殊文件名的处理（当然也可以通过 Cargo.toml 进行配置，不详谈），我们可以认为它们就是一个 crate 的入口。\n可执行 crate 和库 crate 是两种不同的 crate。\n板条箱会将范围内的相关功能组合在一起，因此该功能易于在多个项目之间共享。例如，rand我们在第2章中使用的 板条箱提供了生成随机数的功能。通过将rand板条箱放入我们项目的范围，我们可以在自己的项目中使用该功能。rand板条箱提供的所有功能都可以通过板条箱的名称进行访问rand。\nKeeping a crate’s functionality in its own scope clarifies whether particular functionality is defined in our crate or the rand crate and prevents potential conflicts. For example, the rand crate provides a trait named Rng. We can also define a struct named Rng in our own crate. Because a crate’s functionality is namespaced in its own scope, when we add rand as a dependency, the compiler isn’t confused about what the name Rng refers to. In our crate, it refers to the struct Rng that we defined. We would access the Rng trait from the rand crate as rand::Rng. 将板条箱的功能保持在其自己的范围内可以澄清是在我们的板条箱中还是在rand板条箱中定义了特定功能，并防止了潜在的冲突。例如，rand 板条箱提供了一个名为的特征 Rng。我们还可以在自己的板条箱中定义一个 struct named Rng。由于包装箱的功能是在其自己的作用域中命名的，因此当我们添加rand为依赖项时，编译器不会对名称Rng所指的内容感到困惑。在我们的箱子中，它指的 struct Rng是我们定义的。我们可以Rng从rand板条箱访问 特质rand::Rng。\n上面提到了 trait 和 struct ，struct 是 5.1 里面说的 结构。trait： 一个Trait描述了一种抽象接口（找不到很合适的词），这个抽象接口可以被类型继承。Trait只能由三部分组成（可能只包含部分）：\nfunctions（方法） types（类型） constants（常量） 7.2。Defining Modules to Control Scope and Privacy 定义模块以控制范围和隐私 7.3。引用模块树中项目的路径 7.4。使用关键字将路径带入范围 7.5。将模块分成不同的文件 第 8章 常用收藏 8.1。用向量存储值列表 8.2。使用字符串存储UTF-8编码文本 8.3。在哈希图中存储具有关联值的键 第 9章 错误处理 9.1。不可挽回的错误与恐慌！ 9.2。结果可恢复错误 9.3。恐慌！还是不要慌！ 第 10章 通用类型，特征和寿命 10.1。通用数据类型 10.2。特性：定义共同的行为 10.3。使用生命周期验证参考 第 11章 编写自动化测试 11.1。如何编写测试 11.2。控制测试的运行方式 11.3。测试组织 第 12章 I_O项目：构建命令行程序 12.1。接受命令行参数 12.2。读取文件 12.3。重构以提高模块化和错误处理 12.4。通过测试驱动开发来开发库的功能 12.5。使用环境变量 12.6。将错误消息写入标准错误而不是标准输出 第 13章 功能语言功能：迭代器和闭包 13.1。闭包：可以捕获其环境的匿名函数 13.2。使用迭代器处理一系列项目 13.3。改善我们的I_O项目 13.4。比较性能：循环与迭代器 第 14章 有关Cargo和Crates.io的更多信息 14.1。使用发布配置文件自定义构建 14.2。将箱子发布到Crates.io 14.3。货运工作区 14.4。通过商品安装从Crates.io安装二进制文件 14.5。使用自定义命令扩展货物 第 15章 智能指针 15.1。使用盒子 指向堆上的数据 15.2。使用Deref特性将智能指针视为常规参考 15.3。使用Drop Trait运行清理代码 15.4。钢筋混凝土，参考计数智能指针 15.5。RefCell 和内部可变性模式 15.6。参考周期可能会泄漏内存 第 16章 无畏的并发 16.1。使用线程同时运行代码 16.2。使用消息传递在线程之间传输数据 16.3。共享状态并发 16.4。具有同步和发送特征的可扩展并发 第 17章 Rust的面向对象编程功能 17.1。面向对象语言的特征 17.2。使用允许不同类型值的特性对象 17.3。实施面向对象的设计模式 第 18章 模式与匹配 18.1。可以使用所有场所模式 18.2。可引用性：模式是否可能不匹配 18.3。模式语法 第 19章 高级功能 19.1。不安全的锈 19.2。高级特质 19.3。高级类型 19.4。高级功能和闭包 19.5。巨集 第 20章 最终项目：构建多线程Web服务器 20.1。构建单线程Web服务器 20.2。将我们的单线程服务器转变为多线程服务器 20.3。正常关机和清理 第 21章 附录 21.1。A-关键字 21.2。B-运算符和符号 21.3。C-可衍生特征 21.4。D-有用的开发工具 21.5。电子版 21.6。F-这本书的翻译 21.7。G-如何制造锈蚀和“夜锈” "},{"id":114,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-10%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E5%92%8C%E5%AF%BF%E5%91%BD/","title":"The Rust Programming Language 第 10章 通用类型，特征和寿命","parent":"The Rust Programming Language","content":" 第 10章 通用类型，特征和寿命 10.1。通用数据类型 10.2。特性：定义共同的行为 10.3。使用生命周期验证参考 "},{"id":115,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-11%E7%AB%A0-%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/","title":"The Rust Programming Language 第 11章 编写自动化测试","parent":"The Rust Programming Language","content":" 第 11章 编写自动化测试 11.1。如何编写测试 11.2。控制测试的运行方式 11.3。测试组织 "},{"id":116,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-12%E7%AB%A0-I_O%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/","title":"The Rust Programming Language 第 12章 I O项目：构建命令行程序","parent":"The Rust Programming Language","content":" 第 12章 I_O项目：构建命令行程序 12.1。接受命令行参数 12.2。读取文件 12.3。重构以提高模块化和错误处理 12.4。通过测试驱动开发来开发库的功能 12.5。使用环境变量 12.6。将错误消息写入标准错误而不是标准输出 "},{"id":117,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-13%E7%AB%A0-%E5%8A%9F%E8%83%BD%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/","title":"The Rust Programming Language 第 13章 功能语言功能：迭代器和闭包","parent":"The Rust Programming Language","content":" 第 13章 功能语言功能：迭代器和闭包 13.1。闭包：可以捕获其环境的匿名函数 13.2。使用迭代器处理一系列项目 13.3。改善我们的I_O项目 13.4。比较性能：循环与迭代器 "},{"id":118,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-14%E7%AB%A0-%E6%9C%89%E5%85%B3Cargo%E5%92%8CCrates.io%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/","title":"The Rust Programming Language 第 14章 有关 Cargo和 Crates.io的更多信息","parent":"The Rust Programming Language","content":" 第 14章 有关Cargo和Crates.io的更多信息 14.1。使用发布配置文件自定义构建 14.2。将箱子发布到Crates.io 14.3。货运工作区 14.4。通过商品安装从Crates.io安装二进制文件 14.5。使用自定义命令扩展货物 "},{"id":119,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","title":"The Rust Programming Language 第 15章 智能指针","parent":"The Rust Programming Language","content":" 第 15章 智能指针 15.1。使用盒子 指向堆上的数据 15.2。使用Deref特性将智能指针视为常规参考 15.3。使用Drop Trait运行清理代码 15.4。钢筋混凝土，参考计数智能指针 15.5。RefCell 和内部可变性模式 15.6。参考周期可能会泄漏内存 "},{"id":120,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-16%E7%AB%A0-%E6%97%A0%E7%95%8F%E7%9A%84%E5%B9%B6%E5%8F%91/","title":"The Rust Programming Language 第 16章 无畏的并发","parent":"The Rust Programming Language","content":" 第 16章 无畏的并发 16.1。使用线程同时运行代码 16.2。使用消息传递在线程之间传输数据 16.3。共享状态并发 16.4。具有同步和发送特征的可扩展并发 "},{"id":121,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-17%E7%AB%A0-Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8A%9F%E8%83%BD/","title":"The Rust Programming Language 第 17章 Rust的面向对象编程功能","parent":"The Rust Programming Language","content":" 第 17章 Rust的面向对象编程功能 17.1。面向对象语言的特征 17.2。使用允许不同类型值的特性对象 17.3。实施面向对象的设计模式 "},{"id":122,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8C%B9%E9%85%8D/","title":"The Rust Programming Language 第 18章 模式与匹配","parent":"The Rust Programming Language","content":" 第 18章 模式与匹配 18.1。可以使用所有场所模式 18.2。可引用性：模式是否可能不匹配 18.3。模式语法 "},{"id":123,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-19%E7%AB%A0-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/","title":"The Rust Programming Language 第 19章 高级功能","parent":"The Rust Programming Language","content":" 第 19章 高级功能 19.1。不安全的锈 19.2。高级特质 19.3。高级类型 19.4。高级功能和闭包 19.5。巨集 "},{"id":124,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-1%E7%AB%A0-%E5%85%A5%E9%97%A8/","title":"The Rust Programming Language 第 1章 入门","parent":"The Rust Programming Language","content":" 第 1章 入门 1.1。安装 单独有写一篇如何安装\n更新和卸载 通过安装Rust后rustup，轻松更新到最新版本。在您的外壳中，运行以下更新脚本：\n$ rustup update 要卸载Rust和rustup，请从您的外壳运行以下卸载脚本：\n$ rustup self uninstall 本地文件 运行rustup doc以在浏览器中打开本地文档。\n1.2。你好，世界！ fn main() {\rprintln!(\u0026#34;Hello, world!\u0026#34;);\r} 编译和运行 \u0026gt;$ rustc main.rs\r\u0026gt;.\\main.exe Rust程序剖析 第一行声明一个名为的函数main，该函数不带参数且不返回任何内容。如果有参数，它们将放在括号内()。该main功能很特殊：它始终是每个可执行Rust程序中运行的第一个代码。 函数主体用大括号括起来{}。 println!调用Rust宏。如果改为调用函数，则将其输入为println（不带!）。 我们用分号（;）结束该行，这表明该表达式已结束，下一个表达式可以开始了。Rust代码的大多数行以分号结尾。 Rust风格是缩进四个空格，而不是制表符。\n1.3。Hello, Cargo! 您好，货运！ Cargo是Rust的构建系统和包管理器。大多数Rustacean使用此工具来管理他们的Rust项目，因为Cargo会为您处理很多任务，例如:\n构建代码， 下载代码所依赖的库以及构建这些库。（我们称库为您的代码需要依赖项。） 请在终端中输入以下内容，检查是否已安装Cargo：\n$ cargo --version 用 Cargo 创建项目 $ cargo new hello_cargo\r$ cd hello_cargo 第一个命令创建一个名为hello_cargo的新目录。我们已将项目命名为hello_cargo，并且Cargo在同名目录中创建其文件。\n进入hello_cargo目录并列出文件。您会看到Cargo为我们生成了两个文件和一个目录：一个Cargo.toml文件和一个其中带有main.rs文件的 src目录。\n"},{"id":125,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-20%E7%AB%A0-%E6%9C%80%E7%BB%88%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"The Rust Programming Language 第 20章 最终项目：构建多线程 Web服务器","parent":"The Rust Programming Language","content":" 第 20章 最终项目：构建多线程Web服务器 20.1。构建单线程Web服务器 20.2。将我们的单线程服务器转变为多线程服务器 20.3。正常关机和清理 "},{"id":126,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-21%E7%AB%A0-%E9%99%84%E5%BD%95/","title":"The Rust Programming Language 第 21章 附录","parent":"The Rust Programming Language","content":" 第 21章 附录 21.1。A-关键字 21.2。B-运算符和符号 21.3。C-可衍生特征 21.4。D-有用的开发工具 21.5。电子版 21.6。F-这本书的翻译 21.7。G-如何制造锈蚀和“夜锈” "},{"id":127,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-2%E7%AB%A0-%E7%BC%96%E5%86%99%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F/","title":"The Rust Programming Language 第 2章 编写猜谜游戏","parent":"The Rust Programming Language","content":" 第 2章 编写猜谜游戏 use std::io;\rfn main() {\rprintln!(\u0026#34;Guess the number!\u0026#34;);\rprintln!(\u0026#34;Please input your guess.\u0026#34;);\rlet mut guess = String::new();\rio::stdin()\r.read_line(\u0026amp;mut guess)\r.expect(\u0026#34;Failed to read line\u0026#34;);\rprintln!(\u0026#34;You guessed: {}\u0026#34;, guess);\r} 让我们逐行进行介绍。为了获得用户输入，然后将结果打印为输出，我们需要将 io(input/output)库纳入范围。该io库来自标准库（称为std）：\nuse std::io; Rust 的标准库，有一个 prelude 子模块，这里面包含了默认导入（std 库是默认导入的，然后 std 库中的 prelude 下面的东西也是默认导入的）的所有符号。\nuse 关键字 use 关键字能够将模块标识符引入当前作用域,这样就解决了局部模块路径过长的问题。 所有的系统库模块都是被默认导入的，所以在使用的时候只需要使用 use 关键字简化路径就可以方便的使用了。 当然，有些情况下存在两个相同的名称，且同样需要导入，我们可以使用 as 关键字为标识符添加别名\n"},{"id":128,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-3%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/","title":"The Rust Programming Language 第 3章 通用编程概念","parent":"The Rust Programming Language","content":" 第 3章 通用编程概念 3.1。变量和可变性 3.2。资料类型 3.3。功能 3.4。注释 3.5。控制流 "},{"id":129,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-4%E7%AB%A0-%E4%BA%86%E8%A7%A3%E6%89%80%E6%9C%89%E6%9D%83/","title":"The Rust Programming Language 第 4章 了解所有权","parent":"The Rust Programming Language","content":" 第 4章 了解所有权 4.1。什么是所有权？ 4.2。参考和借阅 4.3。切片类型 "},{"id":130,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-5%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E6%9E%84%E9%80%A0%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/","title":"The Rust Programming Language 第 5章 使用结构来构造相关数据","parent":"The Rust Programming Language","content":" 第 5章 使用结构来构造相关数据 5.1。定义和实例化结构 5.2。使用结构的示例程序 5.3。方法语法 "},{"id":131,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-6%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","title":"The Rust Programming Language 第 6章 枚举和模式匹配","parent":"The Rust Programming Language","content":" 第 6章 枚举和模式匹配 6.1。定义枚举 6.2。匹配控制流运算符 6.3。如果让简洁控制流 "},{"id":132,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-7%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%9D%BF%E6%9D%A1%E7%AE%B1%E5%92%8C%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%B8%8D%E6%96%AD%E5%A2%9E%E9%95%BF%E7%9A%84%E9%A1%B9%E7%9B%AE/","title":"The Rust Programming Language 第 7章 使用软件包，板条箱和模块管理不断增长的项目","parent":"The Rust Programming Language","content":" 第 7 章 使用软件包，板条箱和模块管理不断增长的项目 Rust 中有三和重要的组织概念：包、箱、模块。\nPackages: A Cargo feature that lets you build, test, and share crates 包装：货运功能，可让您构建，测试和共享包装箱 Crates: A tree of modules that produces a library or executable 板条箱：产生库或可执行文件的模块树 Modules and use: Let you control the organization, scope, and privacy of paths 模块和用途：让您控制路径的组织，范围和隐私 Paths: A way of naming an item, such as a struct, function, or module 路径：一种命名项目的方法，例如结构，函数或模块 7.1。Packages and Crates 包装和板条箱 Cargo 是 Rust 的构建系统和包管理器。它可以帮助开发人员下载和管理依赖项，并帮助创建 Rust 包。在 Rust 社区中，Rust 中的“包”通常被称为“crate”（板条箱），因此在安装 Rust 时会得到 Cargo。\n要创建一个新的包，请使用关键字 new，跟上包名称。\ncargo new my-project 当运行 cargo new 时是在创建一个包\n运行 tree 命令以查看目录结构，它会报告已创建了一些文件和目录，首先，它创建一个带有包名称的目录，并且在该目录内有一个存放你的源代码文件的 src 目录，src 目录下会生成一个 main.rs 源文件，Cargo 默认这个文件为二进制箱的根，编译之后的二进制箱将与包名相同：\n$ tree .\r.\r└── hello_opensource\r├── Cargo.toml\r└── src\r└── main.rs\r2 directories, 2 files main.rs 文件经过编译后生产问二进制可执行文件与包名相同\n一个软件包包含一个Cargo.toml文件，包必须由一个 Cargo.toml 文件来管理，该文件描述了包的基本信息以及依赖项。\n一个包最多包含一个库\u0026quot;箱\u0026quot;，可以包含任意数量的二进制\u0026quot;箱\u0026quot;，但是至少包含一个\u0026quot;箱\u0026quot;（不管是库还是二进制\u0026quot;箱\u0026quot;）。\nCargo 的约定是如果在代表表的 Cargo.toml 的同级目录下包含 src 目录且其中包含 main.rs 文件的话，Cargo 就知道这个包带有一个与包同名的二进制 crate，且 src/main.rs 就是 crate 根。另一个约定如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根。crate 根文件将由 Cargo 传递给 rustc来实际构建库或者二进制项目。\n我们有一个仅包含src / main.rs的软件包，这意味着它仅包含一个名为的二进制条板箱my-project。如果软件包包含src / main.rs 和src / lib.rs，则它有两个包装箱：库和二进制文件，两者的名称与软件包相同。通过将文件放在src / bin目录中，一个软件包可以具有多个二进制文件箱：每个文件将是一个单独的二进制文件箱。\n这是因为 main.rs 和 lib.rs 对于一个 crate 来讲，是两个特殊的文件名。rustc 内置了对这两个特殊文件名的处理（当然也可以通过 Cargo.toml 进行配置，不详谈），我们可以认为它们就是一个 crate 的入口。\n可执行 crate 和库 crate 是两种不同的 crate。\n板条箱会将范围内的相关功能组合在一起，因此该功能易于在多个项目之间共享。例如，rand我们在第2章中使用的 板条箱提供了生成随机数的功能。通过将rand板条箱放入我们项目的范围，我们可以在自己的项目中使用该功能。rand板条箱提供的所有功能都可以通过板条箱的名称进行访问rand。\nKeeping a crate’s functionality in its own scope clarifies whether particular functionality is defined in our crate or the rand crate and prevents potential conflicts. For example, the rand crate provides a trait named Rng. We can also define a struct named Rng in our own crate. Because a crate’s functionality is namespaced in its own scope, when we add rand as a dependency, the compiler isn’t confused about what the name Rng refers to. In our crate, it refers to the struct Rng that we defined. We would access the Rng trait from the rand crate as rand::Rng. 将板条箱的功能保持在其自己的范围内可以澄清是在我们的板条箱中还是在rand板条箱中定义了特定功能，并防止了潜在的冲突。例如，rand 板条箱提供了一个名为的特征 Rng。我们还可以在自己的板条箱中定义一个 struct named Rng。由于包装箱的功能是在其自己的作用域中命名的，因此当我们添加rand为依赖项时，编译器不会对名称Rng所指的内容感到困惑。在我们的箱子中，它指的 struct Rng是我们定义的。我们可以Rng从rand板条箱访问 特质rand::Rng。\n上面提到了 trait 和 struct ，struct 是 5.1 里面说的 结构。trait： 一个Trait描述了一种抽象接口（找不到很合适的词），这个抽象接口可以被类型继承。Trait只能由三部分组成（可能只包含部分）：\nfunctions（方法） types（类型） constants（常量） 7.2。Defining Modules to Control Scope and Privacy 定义模块以控制范围和隐私 对于一个软件工程来说，我们往往按照所使用的编程语言的组织规范来进行组织，组织模块的主要结构往往是树。Java 组织功能模块的主要单位是类，而 JavaScript 组织模块的主要方式是 function。\n这些先进的语言的组织单位可以层层包含，就像文件系统的目录结构一样。Rust 中的组织单位是模块（Module）。\n访问权限：\nRust 中有两种简单的访问权：公共（public）和私有（private）。\n默认情况下，如果不加修饰符，模块中的成员访问权将是私有的。\n如果想使用公共权限，需要使用 pub 关键字。\n对于私有的模块，只有在与其平级的位置或下级的位置才能访问，不能从其外部访问。\n如果模块中定义了结构体，结构体除了其本身是私有的以外，其字段也默认是私有的。所以如果想使用模块中的结构体以及其字段，需要 pub 声明。\n如果我们将一个枚举公开，则其所有变体都将公开。\nIn this section, we’ll talk about modules and other parts of the module system, namely paths that allow you to name items; the use keyword that brings a path into scope; and the pub keyword to make items public. We’ll also discuss the as keyword, external packages, and the glob operator. For now, let’s focus on modules! 在本节中，我们将讨论模块和模块系统的其他部分，即允许您命名项目的路径。use将路径带入范围的关键字；以及将pub项目设为公开的关键字。我们还将讨论as关键字，外部包和glob运算符。现在，让我们专注于模块！\nModules let us organize code within a crate into groups for readability and easy reuse. Modules also control the privacy of items, which is whether an item can be used by outside code (public) or is an internal implementation detail and not available for outside use (private). 模块使我们可以将板条箱中的代码分为几组，以提高可读性和重用性。模块还控制项目的隐私，即项目是可以由外部代码使用（公共）还是内部实现细节而不能用于外部使用（私有）。\nAs an example, let’s write a library crate that provides the functionality of a restaurant. We’ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than actually implement a restaurant in code. 例如，让我们写一个提供餐厅功能的库箱。我们将定义函数的签名，但将它们的主体留空以专注于代码的组织，而不是实际在代码中实现餐厅。\nIn the restaurant industry, some parts of a restaurant are referred to as front of house and others as back of house. Front of house is where customers are; this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work. 在餐饮业中，餐厅的某些部分称为 房屋前部，而其他部分称为房屋后部。屋前就是顾客的所在。主机在这里招待客户，服务器在接受订单和付款，调酒师在这里喝酒。屋后是厨师在厨房工作，洗碗碟机，经理进行行政工作的地方。\nTo structure our crate in the same way that a real restaurant works, we can organize the functions into nested modules. Create a new library named restaurant by running cargo new \u0026ndash;lib restaurant; then put the code in Listing 7-1 into src/lib.rs to define some modules and function signatures. 为了以与实际餐厅相同的方式构造板条箱，我们可以将功能组织到嵌套模块中。restaurant通过运行创建一个新的库 cargo new \u0026ndash;lib restaurant；然后将清单7-1中的代码放入src / lib.rs中，以定义一些模块和函数签名。\nFilename: src/lib.rs\nmod front_of_house {\rmod hosting {\rfn add_to_waitlist() {}\rfn seat_at_table() {}\r}\rmod serving {\rfn take_order() {}\rfn serve_order() {}\rfn take_payment() {}\r}\r} 我们以mod关键字开头定义模块，然后指定模块名称（在本例中为front_of_house），并将大括号放在模块主体周围。在模块内部，我们可以有其他模块，在这种情况下，可以使用hosting和serving。模块还可以保存其他项的定义，例如结构，枚举，常量，特征或功能（如清单7-1所示）。\n通过使用模块，我们可以将相关的定义分组在一起，并命名它们为什么相关。使用此代码的程序员可以更轻松地找到他们想要使用的定义，因为他们可以基于组导航代码，而不必阅读所有定义。向此代码添加新功能的程序员将知道将代码放置在何处以保持程序的组织性。\nEarlier, we mentioned that src/main.rs and src/lib.rs are called crate roots. The reason for their name is that the contents of either of these two files form a module named crate at the root of the crate’s module structure, known as the module tree. 在前面，我们提到src / main.rs和src / lib.rs称为板条箱根。之所以要使用它们，是因为这两个文件中的任何一个的内容都构成了一个模块crate，该模块在板条箱的模块结构的根目录下被命名为模块树。\n清单7-2显示了清单7-1中的结构的模块树。\ncrate\r└── front_of_house\r├── hosting\r│ ├── add_to_waitlist\r│ └── seat_at_table\r└── serving\r├── take_order\r├── serve_order\r└── take_payment This tree shows how some of the modules nest inside one another (for example, hosting nests inside front_of_house). The tree also shows that some modules are siblings to each other, meaning they’re defined in the same module (hosting and serving are defined within front_of_house). To continue the family metaphor, if module A is contained inside module B, we say that module A is the child of module B and that module B is the parent of module A. Notice that the entire module tree is rooted under the implicit module named crate. 这个树显示了一些模块是如何相互嵌套的(例如，在front_of_house中托管嵌套)。该树还表明，有些模块是彼此的兄弟模块，这意味着它们定义在同一个模块中(托管和服务是在front_of_house中定义的)。继续使用“家族”这个比喻，如果模块A包含在模块B中，我们就说模块A是模块B的子模块，模块B是模块A的父模块。请注意，整个模块树的根位于名为crate的隐含模块下。\nThe module tree might remind you of the filesystem’s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules. 模块树可能使您想起计算机上文件系统的目录树。这是一个非常恰当的比较！就像文件系统中的目录一样，您可以使用模块来组织代码。就像目录中的文件一样，我们需要一种找到模块的方法。\n7.3。Paths for Referring to an Item in the Module Tree 引用模块树中项目的路径 To show Rust where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. If we want to call a function, we need to know its path. 为了向Rust展示在模块树中找到项目的位置，我们使用的路径与浏览文件系统时使用的路径相同。如果要调用函数，则需要知道其路径。\nA path can take two forms: 路径可以采用两种形式：\nAn absolute path starts from a crate root by using a crate name or a literal crate. 一个绝对路径从crate 关键字开始描述。 A relative path starts from the current module and uses self, super, or an identifier in the current module. 相对路径从 self 或 super 关键字或一个在当前模块中的一个标识符开始描述。 Both absolute and relative paths are followed by one or more identifiers separated by double colons (::). 绝对路径和相对路径后均跟随一个或多个标识符，并用双冒号（::）隔开。\nLet’s return to the example in Listing 7-1. How do we call the add_to_waitlist function? This is the same as asking, what’s the path of the add_to_waitlist function? In Listing 7-3, we simplified our code a bit by removing some of the modules and functions. We’ll show two ways to call the add_to_waitlist function from a new function eat_at_restaurant defined in the crate root. The eat_at_restaurant function is part of our library crate’s public API, so we mark it with the pub keyword. In the ”Exposing Paths with the pub Keyword” section, we’ll go into more detail about pub. Note that this example won’t compile just yet; we’ll explain why in a bit. 让我们回到清单7-1中的示例。我们如何调用该 add_to_waitlist函数？这和询问add_to_waitlist函数的路径是什么一样 ？在清单7-3中，我们通过删除一些模块和函数来简化了代码。我们将展示两种add_to_waitlist从eat_at_restaurant板条箱根中定义的新函数调用函数的方法 。该eat_at_restaurant函数是我们的库箱公共API的一部分，因此我们将其标记为pub关键字。在“使用pub关键字公开路径”部分中，我们将详细介绍pub。请注意，该示例尚未编译。我们稍后会解释原因。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rmod hosting {\rfn add_to_waitlist() {}\r}\r}\rpub fn eat_at_restaurant() {\r// Absolute path 绝对路径\rcrate::front_of_house::hosting::add_to_waitlist();\r// Relative path 相对路径\rfront_of_house::hosting::add_to_waitlist();\r} 清单7-3：add_to_waitlist使用绝对路径和相对路径调用函数\nThe first time we call the add_to_waitlist function in eat_at_restaurant, we use an absolute path. The add_to_waitlist function is defined in the same crate as eat_at_restaurant, which means we can use the crate keyword to start an absolute path. 第一次在中调用add_to_waitlist函数时eat_at_restaurant，我们使用绝对路径。该add_to_waitlist函数与定义在同一板条箱中eat_at_restaurant，这意味着我们可以使用crate关键字来启动绝对路径。\nAfter crate, we include each of the successive modules until we make our way to add_to_waitlist. You can imagine a filesystem with the same structure, and we’d specify the path /front_of_house/hosting/add_to_waitlist to run the add_to_waitlist program; using the crate name to start from the crate root is like using / to start from the filesystem root in your shell. 之后 crate，我们将包括每个后续模块，直到我们逐步实现add_to_waitlist。您可以想象一个具有相同结构的文件系统，我们将指定/front_of_house/hosting/add_to_waitlist运行 add_to_waitlist程序的路径。使用crate名称从板条箱根/启动就像使用从外壳中的文件系统根启动一样。\nThe second time we call add_to_waitlist in eat_at_restaurant, we use a relative path. The path starts with front_of_house, the name of the module defined at the same level of the module tree as eat_at_restaurant. Here the filesystem equivalent would be using the path front_of_house/hosting/add_to_waitlist. Starting with a name means that the path is relative. 第二次调用add_to_waitlist时eat_at_restaurant，我们使用相对路径。路径以开头front_of_house，在与模块树相同级别定义的模块名称eat_at_restaurant。这里等效的文件系统将使用path front_of_house/hosting/add_to_waitlist。以名称开头表示路径是相对的。\nChoosing whether to use a relative or absolute path is a decision you’ll make based on your project. The decision should depend on whether you’re more likely to move item definition code separately from or together with the code that uses the item. For example, if we move the front_of_house module and the eat_at_restaurant function into a module named customer_experience, we’d need to update the absolute path to add_to_waitlist, but the relative path would still be valid. However, if we moved the eat_at_restaurant function separately into a module named dining, the absolute path to the add_to_waitlist call would stay the same, but the relative path would need to be updated. Our preference is to specify absolute paths because it’s more likely to move code definitions and item calls independently of each other. 选择使用相对还是绝对路径是您根据项目决定的。该决定应取决于您是更可能将物料定义代码与使用物料的代码分开移动还是一起使用。例如，如果将front_of_house模块和 eat_at_restaurant函数移动到名为的模块中customer_experience，则需要将绝对路径更新为add_to_waitlist，但是相对路径仍然有效。但是，如果我们将eat_at_restaurant函数单独移动到名为的模块中dining，则add_to_waitlist调用的绝对路径 将保持不变，但是相对路径将需要更新。我们倾向于指定绝对路径，因为它更有可能彼此独立地移动代码定义和项目调用。\n让我们尝试编译清单7-3，找出为什么它还不能编译！清单7-4显示了我们得到的错误。\n$ cargo build\rCompiling restaurant v0.1.0 (file:///projects/restaurant)\rerror[E0603]: module `hosting` is private\r--\u0026gt; src/lib.rs:9:28\r|\r9 | crate::front_of_house::hosting::add_to_waitlist();\r| ^^^^^^^\rerror[E0603]: module `hosting` is private\r--\u0026gt; src/lib.rs:12:21\r|\r12 | front_of_house::hosting::add_to_waitlist();\r| ^^^^^^^\rerror: aborting due to 2 previous errors\rFor more information about this error, try `rustc --explain E0603`.\rerror: could not compile `restaurant`.\rTo learn more, run the command again with --verbose. 清单7-4：编译清单7-3中的代码产生的编译器错误\nThe error messages say that module hosting is private. In other words, we have the correct paths for the hosting module and the add_to_waitlist function, but Rust won’t let us use them because it doesn’t have access to the private sections. 错误消息表明该模块hosting是私有的。换句话说，我们具有hosting模块和add_to_waitlist 功能的正确路径，但是Rust不允许我们使用它们，因为它无法访问私有部分。\nModules aren’t useful only for organizing your code. They also define Rust’s privacy boundary: the line that encapsulates the implementation details external code isn’t allowed to know about, call, or rely on. So, if you want to make an item like a function or struct private, you put it in a module. 模块不仅仅对组织代码有用。他们还定义了Rust的 隐私边界：封装实现细节的行不允许外部代码知道，调用或依赖。因此，如果要将项目设为函数或结构私有，则将其放在模块中。\nThe way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default. Items in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. The reason is that child modules wrap and hide their implementation details, but the child modules can see the context in which they’re defined. To continue with the restaurant metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant in which they operate. Rust中隐私的工作方式是默认情况下所有项目（函数，方法，结构，枚举，模块和常量）都是私有的。父模块中的项目不能使用子模块中的私有项目，但是子模块中的项目可以使用其祖先模块中的项目。原因是子模块包装并隐藏了它们的实现细节，但是子模块可以看到定义它们的上下文。要继续使用餐厅的隐喻，可以将隐私规则视为餐厅的后台办公室：餐厅客户的隐私是私人的，但办公室经理可以查看并在其经营的餐厅中做任何事情。\nRust chose to have the module system function this way so that hiding inner implementation details is the default. That way, you know which parts of the inner code you can change without breaking outer code. But you can expose inner parts of child modules\u0026rsquo; code to outer ancestor modules by using the pub keyword to make an item public. Rust选择以这种方式使模块系统起作用，以便默认隐藏内部实现细节。这样，您就知道可以更改内部代码的哪些部分而不会破坏外部代码。但是，您可以通过使用pub 关键字将项目公开，从而将子模块代码的内部部分公开给外部祖先模块。\nExposing Paths with the pub Keyword 使用pub关键字公开路径 Let’s return to the error in Listing 7-4 that told us the hosting module is private. We want the eat_at_restaurant function in the parent module to have access to the add_to_waitlist function in the child module, so we mark the hosting module with the pub keyword, as shown in Listing 7-5. 让我们回到清单7-4中的错误，告诉我们该hosting模块是私有的。我们希望eat_at_restaurant父模块中的add_to_waitlist功能可以访问子模块中的功能，因此我们hosting用pub关键字标记 模块，如清单7-5所示。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rpub mod hosting {\rfn add_to_waitlist() {}\r}\r}\rpub fn eat_at_restaurant() {\r// Absolute path\rcrate::front_of_house::hosting::add_to_waitlist();\r// Relative path\rfront_of_house::hosting::add_to_waitlist();\r} 清单7-5：从以下位置声明要使用的hosting模块pubeat_at_restaurant\n不幸的是，清单7-5中的代码仍然导致错误，如清单7-6所示。\n$ cargo build\rCompiling restaurant v0.1.0 (file:///projects/restaurant)\rerror[E0603]: function `add_to_waitlist` is private\r--\u0026gt; src/lib.rs:9:37\r|\r9 | crate::front_of_house::hosting::add_to_waitlist();\r| ^^^^^^^^^^^^^^^\rerror[E0603]: function `add_to_waitlist` is private\r--\u0026gt; src/lib.rs:12:30\r|\r12 | front_of_house::hosting::add_to_waitlist();\r| ^^^^^^^^^^^^^^^\rerror: aborting due to 2 previous errors\rFor more information about this error, try `rustc --explain E0603`.\rerror: could not compile `restaurant`.\rTo learn more, run the command again with --verbose. Listing 7-6: Compiler errors from building the code in Listing 7-5 清单7-6：构建清单7-5中的代码产生的编译器错误\nWhat happened? Adding the pub keyword in front of mod hosting makes the module public. With this change, if we can access front_of_house, we can access hosting. But the contents of hosting are still private; making the module public doesn’t make its contents public. The pub keyword on a module only lets code in its ancestor modules refer to it. 发生了什么？在pub关键字前面添加关键字mod hosting可使模块成为公共模块。进行此更改后，如果可以访问front_of_house，就可以访问hosting。但是，内容的hosting仍然是私有的; 公开该模块不会公开其内容。pub模块上的关键字仅允许其祖先模块中的代码引用它。\nThe errors in Listing 7-6 say that the add_to_waitlist function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules. 清单7-6中的错误表明该add_to_waitlist函数是私有的。隐私规则适用于结构，枚举，函数，方法以及模块。\nLet’s also make the add_to_waitlist function public by adding the pub keyword before its definition, as in Listing 7-7. 我们还add_to_waitlist通过在pub 关键字的定义之前添加关键字来使该函数公开，如清单7-7所示。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rpub mod hosting {\rpub fn add_to_waitlist() {}\r}\r}\rpub fn eat_at_restaurant() {\r// Absolute path\rcrate::front_of_house::hosting::add_to_waitlist();\r// Relative path\rfront_of_house::hosting::add_to_waitlist();\r} Listing 7-7: Adding the pub keyword to mod hosting and fn add_to_waitlist lets us call the function from eat_at_restaurant 清单7-7：向 和添加pub关键字mod hosting，fn add_to_waitlist让我们从中调用函数 eat_at_restaurant\nNow the code will compile! Let’s look at the absolute and the relative path and double-check why adding the pub keyword lets us use these paths in add_to_waitlist with respect to the privacy rules. 现在代码将编译！让我们看一下绝对路径和相对路径，并仔细检查为什么添加pub关键字可以使我们add_to_waitlist根据隐私规则使用这些路径 。\nIn the absolute path, we start with crate, the root of our crate’s module tree. Then the front_of_house module is defined in the crate root. The front_of_house module isn’t public, but because the eat_at_restaurant function is defined in the same module as front_of_house (that is, eat_at_restaurant and front_of_house are siblings), we can refer to front_of_house from eat_at_restaurant. Next is the hosting module marked with pub. We can access the parent module of hosting, so we can access hosting. Finally, the add_to_waitlist function is marked with pub and we can access its parent module, so this function call works! 在绝对路径中，我们从crate周转箱模块树的根开始。然后front_of_house在板条箱根中定义模块。该 front_of_house模块是不公开的，但由于eat_at_restaurant 功能是一样的模块定义front_of_house（即， eat_at_restaurant和front_of_house是兄弟），我们可以参照 front_of_house从eat_at_restaurant。接下来是hosting标有的模块pub。我们可以访问的父模块hosting，因此我们可以访问 hosting。最后，该add_to_waitlist函数标有pub，我们可以访问其父模块，因此此函数调用有效！\nIn the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from front_of_house. The front_of_house module is defined within the same module as eat_at_restaurant, so the relative path starting from the module in which eat_at_restaurant is defined works. Then, because hosting and add_to_waitlist are marked with pub, the rest of the path works, and this function call is valid! 在相对路径中，逻辑与绝对路径相同（除了第一步）：路径不是从板条箱根开始，而是从 front_of_house。该front_of_house模块与定义在同一模块内eat_at_restaurant，因此从eat_at_restaurant定义该模块的模块开始的相对路径 有效。然后，由于hosting和 add_to_waitlist标记为pub，因此其余路径起作用，并且此函数调用有效！\nStarting Relative Paths with super 起始相对路径 super We can also construct relative paths that begin in the parent module by using super at the start of the path. This is like starting a filesystem path with the .. syntax. Why would we want to do this? 我们还可以通过super在路径的开头使用来构造从父模块 开始的相对路径。这就像使用..语法来启动文件系统路径。我们为什么要这样做？\nConsider the code in Listing 7-8 that models the situation in which a chef fixes an incorrect order and personally brings it out to the customer. The function fix_incorrect_order calls the function serve_order by specifying the path to serve_order starting with super: 考虑清单7-8中的代码，该代码对厨师修复错误订单并将其亲自带给客户的情况进行建模。该函数通过指定以以下内容开头的路径来fix_incorrect_order调用该函数：serve_orderserve_ordersuper\nFilename: src/lib.rs 文件名：src / lib.rs\nfn serve_order() {}\rmod back_of_house {\rfn fix_incorrect_order() {\rcook_order();\rsuper::serve_order();\r}\rfn cook_order() {}\r} Listing 7-8: Calling a function using a relative path starting with super 清单7-8：使用从以下开始的相对路径调用函数 super\nThe fix_incorrect_order function is in the back_of_house module, so we can use super to go to the parent module of back_of_house, which in this case is crate, the root. From there, we look for serve_order and find it. Success! We think the back_of_house module and the serve_order function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate’s module tree. Therefore, we used super so we’ll have fewer places to update code in the future if this code gets moved to a different module. 该fix_incorrect_order功能位于back_of_house模块中，因此我们可以使用super转到的父模块back_of_house，在本例中为crate根。从那里，我们寻找serve_order并找到它。成功！我们认为，如果我们决定重组包装箱的模块树，则back_of_house模块和serve_order功能之间可能会保持相同的关系并在一起移动。因此，我们曾经使用过super这样的方法， 以便将来在将代码移至其他模块时，将在更少的地方进行代码更新。\nsuper 代表当前模块的父模块\nMaking Structs and Enums Public 公开结构和枚举 We can also use pub to designate structs and enums as public, but there are a few extra details. If we use pub before a struct definition, we make the struct public, but the struct’s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a public back_of_house::Breakfast struct with a public toast field but a private seasonal_fruit field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what’s in season and in stock. The available fruit changes quickly, so customers can’t choose the fruit or even see which fruit they’ll get. 我们也可以pub用来将结构体和枚举指定为公共，但是还有一些额外的细节。如果pub在结构定义之前使用，则将结构公开，但结构的字段仍将是私有的。我们可以根据具体情况公开或不公开每个字段。在清单7-9中，我们定义了一个back_of_house::Breakfast具有公共toast字段但私有seasonal_fruit字段的公共结构。这可以在一家餐馆中为案例建模，顾客可以在这家餐馆选择随餐添加的面包类型，但是厨师会根据季节和库存情况决定随餐搭配的水果。可用的水果变化很快，因此客户无法选择水果，甚至看不到会得到哪种水果。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod back_of_house { pub struct Breakfast { pub toast: String, seasonal_fruit: String, } impl Breakfast { pub fn summer(toast: \u0026amp;str) -\u0026gt; Breakfast { Breakfast { toast: String::from(toast), seasonal_fruit: String::from(\u0026#34;peaches\u0026#34;), } } } } pub fn eat_at_restaurant() { // Order a breakfast in the summer with Rye toast let mut meal = back_of_house::Breakfast::summer(\u0026#34;Rye\u0026#34;); // Change our mind about what bread we\u0026#39;d like meal.toast = String::from(\u0026#34;Wheat\u0026#34;); println!(\u0026#34;I\u0026#39;d like {} toast please\u0026#34;, meal.toast); // The next line won\u0026#39;t compile if we uncomment it; we\u0026#39;re not allowed // to see or modify the seasonal fruit that comes with the meal // meal.seasonal_fruit = String::from(\u0026#34;blueberries\u0026#34;); } Listing 7-9: A struct with some public fields and some private fields 清单7-9：具有一些公共字段和一些私有字段的结构\nBecause the toast field in the back_of_house::Breakfast struct is public, in eat_at_restaurant we can write and read to the toast field using dot notation. Notice that we can’t use the seasonal_fruit field in eat_at_restaurant because seasonal_fruit is private. Try uncommenting the line modifying the seasonal_fruit field value to see what error you get! 由于结构中的toast字段back_of_house::Breakfast是公共字段，因此eat_at_restaurant我们可以toast使用点符号对字段进行读写。注意，我们不能在其中使用该seasonal_fruit字段， eat_at_restaurant因为它seasonal_fruit是私有的。尝试取消注释修改seasonal_fruit字段值的行，以查看出现什么错误！\nAlso, note that because back_of_house::Breakfast has a private field, the struct needs to provide a public associated function that constructs an instance of Breakfast (we’ve named it summer here). If Breakfast didn’t have such a function, we couldn’t create an instance of Breakfast in eat_at_restaurant because we couldn’t set the value of the private seasonal_fruit field in eat_at_restaurant. 另外，请注意，由于back_of_house::Breakfast具有私有字段，因此该结构需要提供一个公共的关联函数来构造的实例Breakfast（在summer此已将其命名）。如果Breakfast没有这样的功能，我们将无法创建Breakfastin 的实例，eat_at_restaurant因为我们无法在中设置私有seasonal_fruit字段的值 eat_at_restaurant。\nIn contrast, if we make an enum public, all of its variants are then public. We only need the pub before the enum keyword, as shown in Listing 7-10. 相反，如果我们将一个枚举公开，则其所有变体都将公开。我们只需要关键字pubbefore enum，如清单7-10所示。\nFilename: src/lib.rs\nmod back_of_house {\rpub enum Appetizer {\rSoup,\rSalad,\r}\r}\rpub fn eat_at_restaurant() {\rlet order1 = back_of_house::Appetizer::Soup;\rlet order2 = back_of_house::Appetizer::Salad;\r} Listing 7-10: Designating an enum as public makes all its variants public 清单7-10：将枚举指定为公共会使其所有变体成为公共\nBecause we made the Appetizer enum public, we can use the Soup and Salad variants in eat_at_restaurant. Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with pub. 由于我们将Appetizer枚举公开，因此可以在中使用Soup和Salad 变体eat_at_restaurant。枚举不是很有用，除非它们的变体是公开的。pub在每种情况下都必须对所有枚举变量进行注释会很烦人 ，因此枚举变量的默认设置是公开的。结构通常在没有公开其字段的情况下很有用，因此结构字段遵循一般默认规则，即除非使用注释，否则所有内容均为私有pub。\nThere’s one more situation involving pub that we haven’t covered, and that is our last module system feature: the use keyword. We’ll cover use by itself first, and then we’ll show how to combine pub and use. pub我们还没有涉及另一种情况，那就是我们的最后一个模块系统功能：use关键字。我们将use首先介绍其本身，然后说明如何结合pub和use。\n7.4。Bringing Paths into Scope with the use Keyword 使用关键字将路径带入范围 每一个 Rust 文件的内容都是一个\u0026quot;难以发现\u0026quot;的模块。(每一个 Rust 文件 他的内容都默认属于 一个与文件名一样的 模块。)\nuse 关键字能够将模块标识符引入当前作用域：\n这样就解决了局部模块路径过长的问题。\n当然，有些情况下存在两个相同的名称，且同样需要导入，我们可以使用 as 关键字为标识符添加别名：\nuse crate::nation::government::govern;\nuse crate::nation::govern as nation_govern;\n所有的系统库模块都是被默认导入的，\n使用 use 关键字简化路径就可以方便的使用\n我们可以一次将一个路径引入一个范围，然后使用该use关键字将该路径中的项目视为本地项目。\nIt might seem like the paths we’ve written to call functions so far are inconveniently long and repetitive. For example, in Listing 7-7, whether we chose the absolute or relative path to the add_to_waitlist function, every time we wanted to call add_to_waitlist we had to specify front_of_house and hosting too. Fortunately, there’s a way to simplify this process. We can bring a path into a scope once and then call the items in that path as if they’re local items with the use keyword. 到目前为止，似乎我们编写的用于调用函数的路径并不方便且冗长。例如，清单7-7中，我们是否选择了绝对或相对路径的add_to_waitlist功能，我们每次想打电话时add_to_waitlist，我们必须指定front_of_house和 hosting太。幸运的是，有一种方法可以简化此过程。我们可以一次将一个路径引入一个范围，然后使用该use关键字将该路径中的项目视为本地项目。\nIn Listing 7-11, we bring the crate::front_of_house::hosting module into the scope of the eat_at_restaurant function so we only have to specify hosting::add_to_waitlist to call the add_to_waitlist function in eat_at_restaurant. 在清单7-11中，我们将crate::front_of_house::hosting模块放入eat_at_restaurant函数的范围内，因此我们只需要指定 hosting::add_to_waitlist在中调用add_to_waitlist函数即可 eat_at_restaurant。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rpub mod hosting {\rpub fn add_to_waitlist() {}\r}\r}\ruse crate::front_of_house::hosting;\rpub fn eat_at_restaurant() {\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\r} Listing 7-11: Bringing a module into scope with use 清单7-11：将模块带入范围 use\nAdding use and a path in a scope is similar to creating a symbolic link in the filesystem. By adding use crate::front_of_house::hosting in the crate root, hosting is now a valid name in that scope, just as though the hosting module had been defined in the crate root. Paths brought into scope with use also check privacy, like any other paths. use在作用域中添加和路径类似于在文件系统中创建符号链接。通过添加use crate::front_of_house::hosting板条箱根，hosting现在在该范围内是一个有效名称，就像hosting 模块已在板条箱根中定义一样。与use 其他路径一样，进入作用域的路径也会检查隐私。\nYou can also bring an item into scope with use and a relative path. Listing 7-12 shows how to specify a relative path to get the same behavior as in Listing 7-11. 您还可以通过use和相对路径将某项纳入范围。清单7-12显示了如何指定相对路径以获得与清单7-11相同的行为。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rpub mod hosting {\rpub fn add_to_waitlist() {}\r}\r}\ruse self::front_of_house::hosting;\rpub fn eat_at_restaurant() {\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\r} Listing 7-12: Bringing a module into scope with use and a relative path 清单7-12：通过use和相对路径将模块引入作用域\nCreating Idiomatic use Paths 创建惯用use路径 In Listing 7-11, you might have wondered why we specified use crate::front_of_house::hosting and then called hosting::add_to_waitlist in eat_at_restaurant rather than specifying the use path all the way out to the add_to_waitlist function to achieve the same result, as in Listing 7-13. 在清单7-11中，您可能想知道为什么我们指定use crate::front_of_house::hosting然后调用hosting::add_to_waitlist， eat_at_restaurant而不是像清单7-13那样use一直指定到add_to_waitlist函数的路径，以获得相同的结果。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rpub mod hosting {\rpub fn add_to_waitlist() {}\r}\r}\ruse crate::front_of_house::hosting::add_to_waitlist;\rpub fn eat_at_restaurant() {\radd_to_waitlist();\radd_to_waitlist();\radd_to_waitlist();\r} Listing 7-13: Bringing the add_to_waitlist function into scope with use, which is unidiomatic 清单7-13：瞻add_to_waitlist功能为与范围use，这是unidiomatic\nAlthough both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with use. Bringing the function’s parent module into scope with use so we have to specify the parent module when calling the function makes it clear that the function isn’t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where add_to_waitlist is defined. 尽管清单7-11和7-13都完成了相同的任务，但是清单7-11是惯用的将函数带入作用域的方法use。将函数的父模块带入范围内，use因此我们在调用函数时必须指定父模块，以便清楚地知道该函数不是本地定义的，同时仍使完整路径的重复最小化。清单7-13中的代码不清楚在哪里add_to_waitlist定义。\nOn the other hand, when bringing in structs, enums, and other items with use, it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library’s HashMap struct into the scope of a binary crate. 另一方面，当使用引入结构，枚举和其他项目时use，指定完整路径是惯用的。清单7-14显示了将标准库的HashMap结构引入二进制条板箱范围的惯用方式。\nFilename: src/main.rs 文件名：src / main.rs\nse std::collections::HashMap;\rfn main() {\rlet mut map = HashMap::new();\rmap.insert(1, 2);\r} Listing 7-14: Bringing HashMap into scope in an idiomatic way 清单7-14：HashMap以惯用的方式进入范围\nThere’s no strong reason behind this idiom: it’s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way. 这个习惯用语没有充分的理由：这只是惯例的出现，人们已经习惯了以这种方式读取和编写Rust代码。\nThe exception to this idiom is if we’re bringing two items with the same name into scope with use statements, because Rust doesn’t allow that. Listing 7-15 shows how to bring two Result types into scope that have the same name but different parent modules and how to refer to them. 这个习惯用法的例外是，如果我们将两个具有相同名称的项目放入use语句范围内，因为Rust不允许这样做。清单7-15显示了如何将两个Result具有相同名称但父模块不同的类型引入范围，以及如何引用它们。\nFilename: src/lib.rs 文件名：src / lib.rs\nuse std::fmt;\ruse std::io;\rfn function1() -\u0026gt; fmt::Result {\r// --snip--\r}\rfn function2() -\u0026gt; io::Result\u0026lt;()\u0026gt; {\r// --snip--\r} Listing 7-15: Bringing two types with the same name into the same scope requires using their parent modules. 代码清单7-15：将两个具有相同名称的类型带入相同的作用域需要使用它们的父模块\nAs you can see, using the parent modules distinguishes the two Result types. If instead we specified use std::fmt::Result and use std::io::Result, we’d have two Result types in the same scope and Rust wouldn’t know which one we meant when we used Result. 如您所见，使用父模块可以区分这两种Result类型。如果相反，我们指定use std::fmt::Result和use std::io::Result，我们将Result在同一范围内有两种类型，而Rust在使用时将不知道我们指的是哪一种Result。\nProviding New Names with the as Keyword 使用as关键字提供新名称 There’s another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify as and a new local name, or alias, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two Result types using as. 还有另一个解决方案，可以通过以下方式将相同名称的两种类型引入同一作用域use：在路径之后，我们可以as为该类型指定一个新的本地名称或别名。清单7-16显示了另一种方式来编写清单7-15中的代码，方法是使用来重命名两种Result类型之一as。\nFilename: src/lib.rs 文件名：src / lib.rs\nuse std::fmt::Result;\ruse std::io::Result as IoResult;\rfn function1() -\u0026gt; Result {\r// --snip--\r}\rfn function2() -\u0026gt; IoResult\u0026lt;()\u0026gt; {\r// --snip--\r} Listing 7-16: Renaming a type when it’s brought into scope with the as keyword 清单7-16：使用as关键字将类型带入范围时重命名\nIn the second use statement, we chose the new name IoResult for the std::io::Result type, which won’t conflict with the Result from std::fmt that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you! 在第二个use语句中，我们IoResult为 std::io::Result类型选择了新名称，这与 我们也将其引入范围的Resultfrom 不会冲突std::fmt。清单7-15和清单7-16被认为是惯用的，因此选择取决于您！\nRe-exporting Names with pub use 用以下方式重新导出名称 pub use When we bring a name into scope with the use keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code’s scope, we can combine pub and use. This technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope. 当我们使用use关键字将名称带入范围时，新范围中可用的名称是私有的。为了使调用我们代码的代码能够引用该名称，就像在该代码的范围内定义了该名称一样，我们可以将pub 和组合在一起use。这项技术称为重新导出，因为我们将某个项目放入范围内，同时也使该项目可供其他人进入其范围内。\nListing 7-17 shows the code in Listing 7-11 with use in the root module changed to pub use. 清单7-17显示了清单7-11中的代码，use其中根模块更改为pub use。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house {\rpub mod hosting {\rpub fn add_to_waitlist() {}\r}\r}\rpub use crate::front_of_house::hosting;\rpub fn eat_at_restaurant() {\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\r} Listing 7-17: Making a name available for any code to use from a new scope with pub use 清单7-17：在新作用域中使名称可用于任何代码 pub use\nBy using pub use, external code can now call the add_to_waitlist function using hosting::add_to_waitlist. If we hadn’t specified pub use, the eat_at_restaurant function could call hosting::add_to_waitlist in its scope, but external code couldn’t take advantage of this new path. 通过使用pub use，外部代码现在可以add_to_waitlist使用调用该函数hosting::add_to_waitlist。如果未指定pub use，则该 eat_at_restaurant函数可以hosting::add_to_waitlist在其作用域内调用，但外部代码无法利用此新路径。\nRe-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain. For example, in this restaurant metaphor, the people running the restaurant think about “front of house” and “back of house.” But customers visiting a restaurant probably won’t think about the parts of the restaurant in those terms. With pub use, we can write our code with one structure but expose a different structure. Doing so makes our library well organized for programmers working on the library and programmers calling the library. 当代码的内部结构与调用代码的程序员对域的思考方式不同时，重新导出很有用。例如，在这个餐厅的比喻中，经营餐厅的人会想到“房子的前面”和“房子的后面”。但是光顾这些餐厅的顾客可能不会考虑这些餐厅的组成部分。使用 pub use，我们可以使用一种结构编写代码，但可以公开不同的结构。这样做使我们的库井井有条，适合从事库工作的程序员和调用库的程序员。\nUsing External Packages In Chapter 2, we programmed a guessing game project that used an external package called rand to get random numbers. To use rand in our project, we added this line to Cargo.toml: 在第2章中，我们编写了一个猜测游戏项目，该项目使用一个名为的外部软件包rand来获取随机数。要rand在我们的项目中使用，我们将此行添加到Cargo.toml中：\nFilename: Cargo.toml 文件名：Cargo.toml\n[dependencies]\rrand = \u0026#34;0.5.5\u0026#34; Adding rand as a dependency in Cargo.toml tells Cargo to download the rand package and any dependencies from crates.io and make rand available to our project. rand在Cargo.toml中添加依赖项后，Cargo会rand从crates.io下载 软件包和任何依赖项，并将其rand提供给我们的项目。\nThen, to bring rand definitions into the scope of our package, we added a use line starting with the name of the crate, rand, and listed the items we wanted to bring into scope. Recall that in the “Generating a Random Number” section in Chapter 2, we brought the Rng trait into scope and called the rand::thread_rng function: 然后，为了将rand定义带入包的范围，我们添加了一个use以板条箱名称开头的 行rand，并列出了我们希望带入范围的项目。回想一下，在第2章的“生成随机数”部分中，我们将Rng特征引入了范围并称为rand::thread_rng函数：\nuse rand::Rng;\rfn main() {\rlet secret_number = rand::thread_rng().gen_range(1, 101);\r} Members of the Rust community have made many packages available at crates.io, and pulling any of them into your package involves these same steps: listing them in your package’s Cargo.toml file and using use to bring items from their crates into scope. Rust社区的成员已经在crates.io上提供了许多软件包 ，将它们中的任何一个放入到软件包中都涉及这些相同的步骤：将它们列出在软件包的Cargo.toml文件中，然后use将其包装中的物品带入范围。\nNote that the standard library (std) is also a crate that’s external to our package. Because the standard library is shipped with the Rust language, we don’t need to change Cargo.toml to include std. But we do need to refer to it with use to bring items from there into our package’s scope. For example, with HashMap we would use this line: 请注意，标准库（std）也是我们包外部的板条箱。由于标准库随附Rust语言，因此我们不需要将Cargo.toml更改为include std。但是我们确实需要引用它，use以将其中的项目带入我们的包的范围。例如，HashMap我们将使用以下行：\nuse std::collections::HashMap; This is an absolute path starting with std, the name of the standard library crate. 这是一个以开头的绝对路径std，即标准库箱的名称。\nUsing Nested Paths to Clean Up Large use Lists 使用嵌套路径清理大use列表 If we’re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two use statements we had in the Guessing Game in Listing 2-4 bring items from std into scope: 如果我们使用在同一个板条箱或同一个模块中定义的多个项目，则在每行中列出每个项目会占用我们文件中的大量垂直空间。例如，use清单2-4中的Guessing Game中的以下两个语句将项目从std以下范围引入：\nFilename: src/main.rs 文件名：src / main.rs\n// --snip--\ruse std::cmp::Ordering;\ruse std::io;\r// --snip-- Instead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18. 相反，我们可以使用嵌套路径将同一项目合并到一行中。为此，我们先指定路径的公共部分，然后指定两个冒号，然后在路径不同部分的列表周围使用花括号，如清单7-18所示。\nFilename: src/main.rs 文件名：src / main.rs\n// --snip--\ruse std::{cmp::Ordering, io};\r// --snip-- Listing 7-18: Specifying a nested path to bring multiple items with the same prefix into scope 清单7-18：指定嵌套路径以将具有相同前缀的多个项目带入范围\nIn bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate use statements needed by a lot! 在较大的程序中，使用嵌套路径从同一板条箱或模块中将许多项目纳入范围可以减少use很多所需的独立语句！\nWe can use a nested path at any level in a path, which is useful when combining two use statements that share a subpath. For example, Listing 7-19 shows two use statements: one that brings std::io into scope and one that brings std::io::Write into scope. 我们可以在路径的任何级别上使用嵌套路径，这在组合两个use共享子路径的语句时非常有用。例如，清单7-19显示了两个 use语句：一个std::io进入范围，另一个 std::io::Write进入范围。\nFilename: src/lib.rs 文件名：src / lib.rs\nuse std::io;\ruse std::io::Write; Listing 7-19: Two use statements where one is a subpath of the other 清单7-19：两个use语句，其中一个是另一个的子路径\nThe common part of these two paths is std::io, and that’s the complete first path. To merge these two paths into one use statement, we can use self in the nested path, as shown in Listing 7-20. 这两个路径的共同部分是std::io，这就是完整的第一个路径。要将这两个路径合并为一条use语句，我们可以使用self嵌套路径，如清单7-20所示。\nFilename: src/lib.rs 文件名：src / lib.rs\nuse std::io::{self, Write}; Listing 7-20: Combining the paths in Listing 7-19 into one use statement 清单7-20：将清单7-19中的路径合并为一条use语句\nThis line brings std::io and std::io::Write into scope. 此行带来了std::io和std::io::Write成的范围。\nThe Glob Operator 全局运算符 If we want to bring all public items defined in a path into scope, we can specify that path followed by , the glob operator: 如果要将路径中定义的所有公共项目都纳入范围，可以指定该路径，后跟，glob运算符：\nuse std::collections::*; This use statement brings all public items defined in std::collections into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined. 该use语句将定义的所有公共项目std::collections带入当前范围。使用glob运算符时要小心！Glob使得更难分辨作用域中的名称以及程序中使用的名称的定义位置。\nThe glob operator is often used when testing to bring everything under test into the tests module; we’ll talk about that in the “How to Write Tests” section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see the standard library documentation for more information on that pattern. 测试时通常使用glob运算符将要测试的所有内容带入tests模块；我们将在第11章的“如何编写测试”部分中讨论这一点。glob运算符有时也用作前奏模式的一部分： 有关该模式的更多信息，请参见标准库文档。\n7.5。Separating Modules into Different Files 将模块分成不同的文件 So far, all the examples in this chapter defined multiple modules in one file. When modules get large, you might want to move their definitions to a separate file to make the code easier to navigate. 到目前为止，本章中的所有示例都在一个文件中定义了多个模块。当模块变大时，您可能希望将其定义移动到单独的文件中，以使代码更易于浏览。\nFor example, let’s start from the code in Listing 7-17 and move the front_of_house module to its own file src/front_of_house.rs by changing the crate root file so it contains the code shown in Listing 7-21. In this case, the crate root file is src/lib.rs, but this procedure also works with binary crates whose crate root file is src/main.rs. 例如，让我们从清单7-17中的代码开始，通过更改板条箱根文件将 front_of_house模块移至其自己的文件src / front_of_house.rs，使其包含清单7-21中所示的代码。在这种情况下，板条箱根文件是src / lib.rs，但是此过程也适用于板条箱根文件是src / main.rs的二进制板条箱。\nFilename: src/lib.rs 文件名：src / lib.rs\nmod front_of_house;\rpub use crate::front_of_house::hosting;\rpub fn eat_at_restaurant() {\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\rhosting::add_to_waitlist();\r} Listing 7-21: Declaring the front_of_house module whose body will be in src/front_of_house.rs 清单7-21：front_of_house在src / front_of_house.rs中声明其主体的模块\nAnd src/front_of_house.rs gets the definitions from the body of the front_of_house module, as shown in Listing 7-22. 和SRC / front_of_house.rs得到从身体的定义 front_of_house模块，如清单7-22英寸\nFilename: src/front_of_house.rs 文件名：src / front_of_house.rs\npub mod hosting {\rpub fn add_to_waitlist() {}\r} Listing 7-22: Definitions inside the front_of_house module in src/front_of_house.rs 清单7-22：src / front_of_house.rs中front_of_house 模块内部的定义\nUsing a semicolon after mod front_of_house rather than using a block tells Rust to load the contents of the module from another file with the same name as the module. To continue with our example and extract the hosting module to its own file as well, we change src/front_of_house.rs to contain only the declaration of the hosting module: 在分号之后mod front_of_house而不是在分号之后使用分号告诉Rust从另一个与模块同名的文件中加载模块的内容。为了继续我们的示例并将hosting模块提取到其自己的文件中，我们将src / front_of_house.rs更改为仅包含hosting模块的声明：\nFilename: src/front_of_house.rs 文件名：src / front_of_house.rs\npub mod hosting; Then we create a src/front_of_house directory and a file src/front_of_house/hosting.rs to contain the definitions made in the hosting module: 然后，我们创建一个src / front_of_house目录和一个文件 src / front_of_house / hosting.rs，以包含在hosting模块中所做的定义 ：\nFilename: src/front_of_house/hosting.rs 文件名：src / front_of_house / hosting.rs\npub fn add_to_waitlist() {} The module tree remains the same, and the function calls in eat_at_restaurant will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size. 模块树保持不变，eat_at_restaurant 即使定义存在于不同的文件中，调用的函数也无需任何修改即可工作。这种技术使您可以随着模块大小的增加而将其移动到新文件中。\nNote that the pub use crate::front_of_house::hosting statement in src/lib.rs also hasn’t changed, nor does use have any impact on what files are compiled as part of the crate. The mod keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module. 请注意，src / lib.rs中的pub use crate::front_of_house::hosting语句 也没有更改，也不会影响作为板条箱一部分编译的文件。该关键字声明模块和锈看起来具有相同的名称作为该进入该模块的代码模块的文件。usemod\nSummary 摘要 Rust lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module. You can do this by specifying absolute or relative paths. These paths can be brought into scope with a use statement so you can use a shorter path for multiple uses of the item in that scope. Module code is private by default, but you can make definitions public by adding the pub keyword. Rust使您可以将一个包分成多个包装箱，然后将一个包装箱分成多个模块，以便可以从另一个模块引用一个模块中定义的项目。您可以通过指定绝对或相对路径来做到这一点。可以使用一条use语句将这些路径纳入范围，因此您可以在该范围内为该项目的多次使用使用较短的路径。默认情况下，模块代码是私有的，但是您可以通过添加pub关键字来使定义公开。\nIn the next chapter, we’ll look at some collection data structures in the standard library that you can use in your neatly organized code. 在下一章中，我们将研究标准库中的一些集合数据结构，您可以在整洁的代码中使用它们。\n"},{"id":133,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-8%E7%AB%A0-%E5%B8%B8%E7%94%A8%E6%94%B6%E8%97%8F/","title":"The Rust Programming Language 第 8章 常用收藏","parent":"The Rust Programming Language","content":" 第 8章 Common Collections 常用集合 Rust’s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill you’ll develop over time. In this chapter, we’ll discuss three collections that are used very often in Rust programs:Rust的标准库包括许多非常有用的数据结构，称为 collections。大多数其他数据类型表示一个特定值，但是集合可以包含多个值。与内置数组和元组类型不同，这些集合指向的数据存储在堆中，这意味着在编译时不需要知道数据量，并且可以在程序运行时增加或缩小。每种类型的收藏品都有不同的功能和成本，并且根据当前情况选择合适的收藏品是您将随着时间的推移而发展的一项技能。在本章中，我们将讨论Rust程序中经常使用的三个集合：\nA vector allows you to store a variable number of values next to each other. 一个 矢量 允许你值的可变数量的存储彼此相邻。 A string is a collection of characters. We’ve mentioned the String type previously, but in this chapter we’ll talk about it in depth. 一个字符串是字符的集合。我们之前已经提到过该String类型，但是在本章中我们将深入讨论它。 A hash map allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a map. 一个 哈希表 ，您可以将值与特定的键关联。这是称为map的更通用数据结构的特定实现。 To learn about the other kinds of collections provided by the standard library, see the documentation. 要了解标准库提供的其他种类的集合，请参阅文档。\nWe’ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special. 们将讨论如何创建和更新向量，字符串和哈希图，以及使每个特征与众不同的地方。\n8.1。Storing Lists of Values with Vectors 用向量存储值列表 The first collection type we’ll look at is Vec, also known as a vector. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart. 我们要研究的第一个集合类型是矢量Vec，也称为矢量。向量使您可以在单个数据结构中存储多个值，该结构将所有值彼此相邻放置在内存中。向量只能存储相同类型的值。当您具有项目列表时，例如文件中的文本行或购物车中项目的价格时，它们很有用。\nCreating a New Vector To create a new, empty vector, we can call the Vec::new function, as shown in Listing 8-1. 要创建一个新的空向量，我们可以调用该Vec::new函数，如清单8-1所示。\nlet v: Vec\u0026lt;i32\u0026gt; = Vec::new(); Listing 8-1: Creating a new, empty vector to hold values of type i32 清单8-1：创建一个新的空向量来保存类型的值 i32\nNote that we added a type annotation here. Because we aren’t inserting any values into this vector, Rust doesn’t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we’ll cover how to use generics with your own types in Chapter 10. For now, know that the Vec type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets. In Listing 8-1, we’ve told Rust that the Vec in v will hold elements of the i32 type. 请注意，我们在此处添加了类型注释。因为我们没有在此向量中插入任何值，所以Rust不知道我们打算存储哪种元素。这是重要的一点。向量是使用泛型实现的；我们将在第10章中介绍如何将泛型与您自己的类型一起使用。现在，您知道Vec标准库提供的类型可以容纳任何类型，并且当特定向量具有特定类型时，该类型将在尖括号中指定。在清单8-1中，我们告诉Rust，Vecin v将容纳该i32类型的元素。\nIn more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation. It’s more common to create a Vec that has initial values, and Rust provides the vec! macro for convenience. The macro will create a new vector that holds the values you give it. Listing 8-2 creates a new Vec that holds the values 1, 2, and 3. The integer type is i32 because that’s the default integer type, as we discussed in the “Data Types” section of Chapter 3. 在更实际的代码中，Rust通常可以在插入值后就推断出要存储的值的类型，因此您几乎不需要执行此类型注释。创建Vec具有初始值的更为常见，Rust vec!为方便起见提供了该宏。宏将创建一个新向量，其中包含您提供的值。清单8-2创建一个新的Vec保存价值1，2和3。整数类型是i32因为这是默认的整数类型，正如我们在第3章的“数据类型”一节中讨论的那样。\nlet v = vec![1, 2, 3]; Listing 8-2: Creating a new vector containing values 清单8-2：创建一个包含值的新向量\nBecause we’ve given initial i32 values, Rust can infer that the type of v is Vec, and the type annotation isn’t necessary. Next, we’ll look at how to modify a vector. 因为我们已经给定了初始i32值，所以Rust可以推断出的类型v 为Vec，并且不需要类型注释。接下来，我们将研究如何修改向量。\nUpdating a Vector To create a vector and then add elements to it, we can use the push method, as shown in Listing 8-3. 要创建一个向量，然后向其中添加元素，我们可以使用push方法，如清单8-3所示。\nlet mut v = Vec::new();\rv.push(5);\rv.push(6);\rv.push(7);\rv.push(8); Listing 8-3: Using the push method to add values to a vector 清单8-3：使用该push方法向向量添加值\nAs with any variable, if we want to be able to change its value, we need to make it mutable using the mut keyword, as discussed in Chapter 3. The numbers we place inside are all of type i32, and Rust infers this from the data, so we don’t need the Vec annotation. 与任何变量一样，如果我们希望能够更改其值，则需要使用mut关键字使它可变，如第3章中所述。我们放入其中的数字均为type i32，Rust从数据中推断出这一点，因此我们不需要Vec注释。\nDropping a Vector Drops Its Elements 删除向量将删除其元素 Like any other struct, a vector is freed when it goes out of scope, as annotated in Listing 8-4. 像其他任何struct一个向量一样，向量超出范围时将被释放，如清单8-4所示。\n{\rlet v = vec![1, 2, 3, 4];\r// do stuff with v\r} // \u0026lt;- v goes out of scope and is freed here Listing 8-4: Showing where the vector and its elements are dropped 清单8-4：显示放置向量及其元素的位置\nWhen the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let’s tackle that next! 当向量被丢弃时，其所有内容也将被丢弃，这意味着其所持有的那些整数将被清除。这似乎很简单，但是当您开始引入对向量元素的引用时，可能会变得更加复杂。让我们接下来解决这个问题！\nReading Elements of Vectors 向量的阅读要素 Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we’ve annotated the types of the values that are returned from these functions for extra clarity. 既然您知道如何创建，更新和销毁向量，那么下一步就是了解如何读取向量的内容。有两种方法可以引用存储在向量中的值。在示例中，我们为从这些函数返回的值的类型添加了注释，以更加明确。\nListing 8-5 shows both methods of accessing a value in a vector, either with indexing syntax or the get method. 清单8-5展示了两种使用索引语法或方法访问向量中值的get方法。\nfn main() {\rlet v = vec![1, 2, 3, 4, 5];\rlet third: \u0026amp;i32 = \u0026amp;v[2];\rprintln!(\u0026#34;The third element is {}\u0026#34;, third);\rmatch v.get(2) {\rSome(third) =\u0026gt; println!(\u0026#34;The third element is {}\u0026#34;, third),\rNone =\u0026gt; println!(\u0026#34;There is no third element.\u0026#34;),\r}\r} Listing 8-5: Using indexing syntax or the get method to access an item in a vector 清单8-5：使用索引语法或get方法访问向量中的项目\nNote two details here. First, we use the index value of 2 to get the third element: vectors are indexed by number, starting at zero. Second, the two ways to get the third element are by using \u0026amp; and [], which gives us a reference, or by using the get method with the index passed as an argument, which gives us an Option\u0026lt;\u0026amp;T\u0026gt;. 请在此处注意两个细节。首先，我们使用的索引值2获取第三个元素：向量从零开始按数字索引。其次，获得第三个元素的两种方法是使用\u0026amp;和[]，这为我们提供了一个参考，或者使用get将索引作为参数传递的方法，这给了我们一个Option\u0026lt;\u0026amp;T\u0026gt;。\nRust has two ways to reference an element so you can choose how the program behaves when you try to use an index value that the vector doesn’t have an element for. As an example, let’s see what a program will do if it has a vector that holds five elements and then tries to access an element at index 100, as shown in Listing 8-6. Rust有两种引用元素的方法，因此您可以选择在尝试使用向量没有元素的索引值时程序的行为。作为示例，让我们看看程序具有一个包含五个元素的向量，然后尝试访问索引为100的元素时的操作，如清单8-6所示。\nlet v = vec![1, 2, 3, 4, 5];\rlet does_not_exist = \u0026amp;v[100];\rlet does_not_exist = v.get(100); Listing 8-6: Attempting to access the element at index 100 in a vector containing five elements 清单8-6：尝试在包含五个元素的向量中访问索引为100的元素\nWhen we run this code, the first [] method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there’s an attempt to access an element past the end of the vector. 当我们运行此代码时，第[]一种方法将导致程序出现恐慌，因为它引用了不存在的元素。如果要访问向量结尾之后的元素，则当您希望程序崩溃时，最好使用此方法。\nWhen the get method is passed an index that is outside the vector, it returns None without panicking. You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances. Your code will then have logic to handle having either Some(\u0026amp;element) or None, as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that’s too large and the program gets a None value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo! 当该get方法传递给向量之外的索引时，它None不会惊慌地返回 。如果在正常情况下偶尔访问超出向量范围的元素，则可以使用此方法。然后，您的代码将具有处理或包含Some(\u0026amp;element)或的 逻辑None，如第6章中所述。例如，索引可能来自输入数字的人。如果他们不小心输入了一个太大的数字而程序得到了一个None值，您可以告诉用户当前向量中有多少个项目，并给他们另一个输入有效值的机会。这比由于错字而导致程序崩溃更人性化！\nWhen the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can’t have mutable and immutable references in the same scope. That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won’t work. 当程序具有有效的引用时，借用检查器将执行所有权和借用规则（在第4章中介绍），以确保该引用和对向量内容的任何其他引用保持有效。回想一下规则，该规则规定在同一范围内不能有可变和不可变的引用。该规则适用于清单8-7，其中我们对向量中的第一个元素持有不变的引用，并尝试将元素添加到末尾，这是行不通的。\nlet mut v = vec![1, 2, 3, 4, 5];\rlet first = \u0026amp;v[0];\rv.push(6);\rprintln!(\u0026#34;The first element is: {}\u0026#34;, first); Listing 8-7: Attempting to add an element to a vector while holding a reference to an item 清单8-7：尝试在保留对项目的引用的同时向矢量添加元素\nCompiling this code will result in this error: 编译此代码将导致以下错误：\n$ cargo run\rCompiling collections v0.1.0 (file:///projects/collections)\rerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\r--\u0026gt; src/main.rs:6:5\r|\r4 | let first = \u0026amp;v[0];\r| - immutable borrow occurs here\r5 | 6 | v.push(6);\r| ^^^^^^^^^ mutable borrow occurs here\r7 | 8 | println!(\u0026#34;The first element is: {}\u0026#34;, first);\r| ----- immutable borrow later used here\rerror: aborting due to previous error\rFor more information about this error, try `rustc --explain E0502`.\rerror: could not compile `collections`.\rTo learn more, run the command again with --verbose. The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector? This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector currently is. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation. 清单8-7中的代码可能看起来应该工作：为什么对第一个元素的引用应该关心向量结尾处的变化？此错误是由于向量的工作方式造成的：如果没有足够的空间将所有元素放在每个元素的旁边，则在向量的末尾添加一个新元素可能需要分配新的内存并将旧元素复制到新空间中向量当前所在的其他位置。在这种情况下，对第一个元素的引用将指向释放的内存。借用规则阻止程序在这种情况下结束。\nNote: For more on the implementation details of the Vec type, see “The Rustonomicon”. 注意：有关该Vec类型的实现详细信息，请参见“ The Rustonomicon”。\nIterating over the Values in a Vector 遍历向量中的值 If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time. Listing 8-8 shows how to use a for loop to get immutable references to each element in a vector of i32 values and print them. 如果我们要依次访问向量中的每个元素，则可以遍历所有元素，而不必一次使用索引来访问一个。清单8-8显示了如何使用for循环获取i32值向量中每个元素的不可变引用并进行打印。\nlet v = vec![100, 32, 57];\rfor i in \u0026amp;v {\rprintln!(\u0026#34;{}\u0026#34;, i);\r} Listing 8-8: Printing each element in a vector by iterating over the elements using a for loop 清单8-8：通过使用for循环遍历元素来打印向量中的每个元素\nWe can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The for loop in Listing 8-9 will add 50 to each element. 我们还可以迭代对可变向量中每个元素的可变引用，以对所有元素进行更改。for清单8-9中的循环将添加50到每个元素。\nlet mut v = vec![100, 32, 57];\rfor i in \u0026amp;mut v {\r*i += 50;\r} Listing 8-9: Iterating over mutable references to elements in a vector 清单8-9：迭代对向量中元素的可变引用\nTo change the value that the mutable reference refers to, we have to use the dereference operator () to get to the value in i before we can use the += operator. We’ll talk more about the dereference operator in the “Following the Pointer to the Value with the Dereference Operator” section of Chapter 15. 要更改可变引用所引用的值，我们必须使用解引用运算符（）来获取值，i然后才能使用该 +=运算符。我们将在 第15章的“使用Dereference运算符跟随指针到值”部分中进一步讨论dereference运算符\nUsing an Enum to Store Multiple Types 使用枚举存储多种类型 At the beginning of this chapter, we said that vectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum! 在本章开始时，我们说过向量只能存储相同类型的值。这可能会带来不便；肯定有一些用例需要存储不同类型的项目列表。幸运的是，枚举的变体是在相同的枚举类型下定义的，因此当我们需要在向量中存储不同类型的元素时，我们可以定义和使用枚举！\nFor example, say we want to get values from a row in a spreadsheet in which some of the columns in the row contain integers, some floating-point numbers, and some strings. We can define an enum whose variants will hold the different value types, and then all the enum variants will be considered the same type: that of the enum. Then we can create a vector that holds that enum and so, ultimately, holds different types. We’ve demonstrated this in Listing 8-10. 例如，假设我们要从电子表格的一行中获取值，其中该行中的某些列包含整数，一些浮点数和一些字符串。我们可以定义一个枚举，其变量将包含不同的值类型，然后所有枚举变量将被视为相同的类型：枚举的类型。然后，我们可以创建一个包含该枚举的向量，从而最终包含不同的类型。我们已在清单8-10中对此进行了演示。\nenum SpreadsheetCell {\rInt(i32),\rFloat(f64),\rText(String),\r}\rlet row = vec![\rSpreadsheetCell::Int(3),\rSpreadsheetCell::Text(String::from(\u0026#34;blue\u0026#34;)),\rSpreadsheetCell::Float(10.12),\r]; Listing 8-10: Defining an enum to store values of different types in one vector 清单8-10：定义将一个enum不同类型的值存储在一个向量中\nRust needs to know what types will be in the vector at compile time so it knows exactly how much memory on the heap will be needed to store each element. A secondary advantage is that we can be explicit about what types are allowed in this vector. If Rust allowed a vector to hold any type, there would be a chance that one or more of the types would cause errors with the operations performed on the elements of the vector. Using an enum plus a match expression means that Rust will ensure at compile time that every possible case is handled, as discussed in Chapter 6. Rust需要知道在编译时向量中将包含哪些类型，因此Rust确切知道要存储每个元素需要多少内存。第二个优点是，我们可以明确说明此向量允许哪些类型。如果Rust允许向量保留任何类型，则一个或多个类型可能会导致对向量元素执行的操作出错。使用枚举加match表达式意味着Rust将在编译时确保处理所有可能的情况，如第6章中所述。\nWhen you’re writing a program, if you don’t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won’t work. Instead, you can use a trait object, which we’ll cover in Chapter 17. 在编写程序时，如果您不知道程序将在运行时获取的完整类型集以存储在向量中，则枚举技术将不起作用。相反，您可以使用trait对象，我们将在第17章中介绍。\nNow that we’ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on Vec by the standard library. For example, in addition to push, a pop method removes and returns the last element. Let’s move on to the next collection type: String! 现在，我们已经讨论了一些使用向量的最常用方法，请确保查看API文档中Vec有关标准库定义的所有有用方法的信息 。例如，除了push，pop 方法还删除并返回最后一个元素。让我们继续下一个集合类型：String！\n8.2。Storing UTF-8 Encoded Text with Strings 使用字符串存储UTF-8编码文本 We talked about strings in Chapter 4, but we’ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust’s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you’re coming from other programming languages. 我们在第4章中讨论过字符串，但是现在我们将更深入地研究它们。新的Rustaceans通常由于以下三个原因而卡在字符串上：Rust暴露可能的错误的倾向，字符串是比许多程序员认为的更复杂的数据结构以及UTF-8。当您来自其他编程语言时，这些因素的组合似乎很难。\nIt’s useful to discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text. In this section, we’ll talk about the operations on String that every collection type has, such as creating, updating, and reading. We’ll also discuss the ways in which String is different from the other collections, namely how indexing into a String is complicated by the differences between how people and computers interpret String data. 在集合的上下文中讨论字符串很有用，因为字符串是作为字节的集合实现的，另外还有一些在这些字节被解释为文本时提供有用功能的方法。在本节中，我们将讨论String每种集合类型所具有的操作，例如创建，更新和读取。我们还将讨论与String 其他集合不同的方式，即String，由于人和计算机解释String数据的方式不同，如何索引到a 中变得复杂 。\nWhat Is a String? 什么是字符串？ We’ll first define what we mean by the term string. Rust has only one string type in the core language, which is the string slice str that is usually seen in its borrowed form \u0026amp;str. In Chapter 4, we talked about string slices, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program’s binary and are therefore string slices. 我们将首先定义术语字符串的含义。Rust在核心语言中只有一种字符串类型str，即通常以借用形式看到的字符串切片\u0026amp;str。在第4章中，我们讨论了字符串切片，这是对存储在其他位置的一些UTF-8编码的字符串数据的引用。例如，字符串文字存储在程序的二进制文件中，因此是字符串切片。\nThe String type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to “strings” in Rust, they usually mean the String and the string slice \u0026amp;str types, not just one of those types. Although this section is largely about String, both types are used heavily in Rust’s standard library, and both String and string slices are UTF-8 encoded. 这种String类型是Rust的标准库提供的，而不是编码到核心语言中的，是一种可增长，可变，拥有的，UTF-8编码的字符串类型。当Rustaceans在Rust中引用“字符串”时，它们通常指 String和切片\u0026amp;str类型，而不仅仅是这些类型之一。尽管本节主要涉及String，但在Rust的标准库中都大量使用了这两种类型，并且这两种类型String和字符串切片均采用UTF-8编码。\nRust’s standard library also includes a number of other string types, such as OsString, OsStr, CString, and CStr. Library crates can provide even more options for storing string data. See how those names all end in String or Str? They refer to owned and borrowed variants, just like the String and str types you’ve seen previously. These string types can store text in different encodings or be represented in memory in a different way, for example. We won’t discuss these other string types in this chapter; see their API documentation for more about how to use them and when each is appropriate. 锈病的标准库还包括一些其他字符串类型，如 OsString，OsStr，CString，和CStr。图书馆包装箱可以提供更多的选项来存储字符串数据。看看这些名称全都以String 或结尾Str吗？它们是指拥有和借用的变体，就像您之前看到的String和 str类型一样。例如，这些字符串类型可以用不同的编码存储文本，或者以不同的方式在内存中表示。在本章中，我们不会讨论其他字符串类型。有关如何使用它们以及何时使用它们的更多信息，请参见其API文档。\nCreating a New String Many of the same operations available with Vec are available with String as well, starting with the new function to create a string, shown in Listing 8-11. Vec也可以使用许多与之相同的操作String ，从new创建字符串的函数开始，如清单8-11所示。\nlet mut s = String::new(); Listing 8-11: Creating a new, empty String 清单8-11：创建一个新的空 String\nThis line creates a new empty string called s, which we can then load data into. Often, we’ll have some initial data that we want to start the string with. For that, we use the to_string method, which is available on any type that implements the Display trait, as string literals do. Listing 8-12 shows two examples. 这行会创建一个名为的新空字符串s，然后我们可以将数据加载到其中。通常，我们会使用一些初始数据作为字符串的开头。为此，我们使用该to_string方法，该方法可在实现该Display特征的任何类型上使用，就像字符串文字一样。清单8-12显示了两个示例。\nlet data = \u0026#34;initial contents\u0026#34;;\rlet s = data.to_string();\r// the method also works on a literal directly:\rlet s = \u0026#34;initial contents\u0026#34;.to_string(); Listing 8-12: Using the to_string method to create a String from a string literal 清单8-12：使用该to_string方法String从字符串文字创建一个\nThis code creates a string containing initial contents. 此代码创建一个包含的字符串initial contents。\nWe can also use the function String::from to create a String from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses to_string. 我们还可以使用该函数String::from根据String字符串文字创建一个。清单8-13中的代码与清单8-12中使用的代码等效to_string。\nlet s = String::from(\u0026#34;initial contents\u0026#34;); Listing 8-13: Using the String::from function to create a String from a string literal 清单8-13：使用该String::from函数String从字符串文字创建一个\nBecause strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, String::from and to_string do the same thing, so which you choose is a matter of style. 因为字符串用于很多事情，所以我们可以对字符串使用许多不同的通用API，从而为我们提供了很多选择。其中一些似乎多余，但它们都有自己的位置！在这种情况下，String::from和 to_string做同样的事情，所以，你选择的是一个风格问题。\nRemember that strings are UTF-8 encoded, so we can include any properly encoded data in them, as shown in Listing 8-14. 请记住，字符串是UTF-8编码的，因此我们可以在其中包含任何正确编码的数据，如清单8-14所示。\nlet hello = String::from(\u0026#34;السلام عليكم\u0026#34;);\rlet hello = String::from(\u0026#34;Dobrý den\u0026#34;);\rlet hello = String::from(\u0026#34;Hello\u0026#34;);\rlet hello = String::from(\u0026#34;שָׁלוֹם\u0026#34;);\rlet hello = String::from(\u0026#34;नमस्ते\u0026#34;);\rlet hello = String::from(\u0026#34;こんにちは\u0026#34;);\rlet hello = String::from(\u0026#34;안녕하세요\u0026#34;);\rlet hello = String::from(\u0026#34;你好\u0026#34;);\rlet hello = String::from(\u0026#34;Olá\u0026#34;);\rlet hello = String::from(\u0026#34;Здравствуйте\u0026#34;);\rlet hello = String::from(\u0026#34;Hola\u0026#34;); Listing 8-14: Storing greetings in different languages in strings 清单8-14：将不同语言的问候语存储在字符串中\nAll of these are valid String values. 所有这些都是有效值String。\nUpdating a String A String can grow in size and its contents can change, just like the contents of a Vec, if you push more data into it. In addition, you can conveniently use the + operator or the format! macro to concatenate String values. 如果您将更多数据推入其中，则A的String大小可能会增加，其内容也会发生变化，就像a的内容一样Vec。此外，您可以方便地使用+运算符或format!宏来连接String值。\nAppending to a String with push_str and push 用push_str和附加到字符串push\nWe can grow a String by using the push_str method to append a string slice, as shown in Listing 8-15. 我们可以String使用push_str方法添加一个字符串切片来增加a ，如清单8-15所示。\nlet mut s = String::from(\u0026#34;foo\u0026#34;);\rs.push_str(\u0026#34;bar\u0026#34;); Listing 8-15: Appending a string slice to a String using the push_str method 清单8-15：String 使用push_str方法将字符串切片附加到\nAfter these two lines, s will contain foobar. The push_str method takes a string slice because we don’t necessarily want to take ownership of the parameter. For example, the code in Listing 8-16 shows that it would be unfortunate if we weren’t able to use s2 after appending its contents to s1. 在这两行之后，s将包含foobar。该push_str方法采用字符串切片，因为我们不一定要获取参数的所有权。例如，清单8-16中的代码显示，如果s2将其内容附加到之后无法使用，那将是不幸的s1。\nlet mut s1 = String::from(\u0026quot;foo\u0026quot;);\rlet s2 = \u0026quot;bar\u0026quot;;\rs1.push_str(s2);\rprintln!(\u0026quot;s2 is {}\u0026quot;, s2);\rListing 8-16: Using a string slice after appending its contents to a String 清单8-16：将字符串切片的内容附加到 String\nIf the push_str method took ownership of s2, we wouldn’t be able to print its value on the last line. However, this code works as we’d expect! 如果该push_str方法拥有的所有权s2，我们将无法在最后一行打印其值。但是，此代码可以按我们期望的那样工作！\nThe push method takes a single character as a parameter and adds it to the String. Listing 8-17 shows code that adds the letter l to a String using the push method. 该push方法将单个字符作为参数并将其添加到中 String。清单8-17显示了使用方法将字母l添加到a的代码。Stringpush\nlet mut s = String::from(\u0026#34;lo\u0026#34;);\rs.push(\u0026#39;l\u0026#39;); Listing 8-17: Adding one character to a String value using push 清单8-17：String使用以下命令向值添加一个字符push\nAs a result of this code, s will contain lol. 由于此代码，s将包含lol。\nConcatenation with the + Operator or the format! Macro 与+运算符或format!宏的串联\nOften, you’ll want to combine two existing strings. One way is to use the + operator, as shown in Listing 8-18. 通常，您需要合并两个现有的字符串。一种方法是使用+ 运算符，如清单8-18所示。\nlet s1 = String::from(\u0026#34;Hello, \u0026#34;);\rlet s2 = String::from(\u0026#34;world!\u0026#34;);\rlet s3 = s1 + \u0026amp;s2; // note s1 has been moved here and can no longer be used Listing 8-18: Using the + operator to combine two String values into a new String value 清单8-18：使用+运算符将两个 String值合并为一个新String值\nThe string s3 will contain Hello, world! as a result of this code. The reason s1 is no longer valid after the addition and the reason we used a reference to s2 has to do with the signature of the method that gets called when we use the + operator. The + operator uses the add method, whose signature looks something like this: 该代码s3将包含该字符串Hello, world!。加s1完后该原因不再有效，而我们引用的原因s2与使用+运算符时调用的方法的签名有关。该+运营商使用的add方法，其签名看起来是这样的：\nfn add(self, s: \u0026amp;str) -\u0026gt; String { This isn’t the exact signature that’s in the standard library: in the standard library, add is defined using generics. Here, we’re looking at the signature of add with concrete types substituted for the generic ones, which is what happens when we call this method with String values. We’ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the + operator. 这不是标准库中的确切签名：在标准库中，add是使用泛型定义的。在这里，我们正在看add用具体类型代替泛型类型的签名，这是当我们用String值调用此方法时发生的情况。我们将在第10章中讨论泛型。此签名为我们提供了了解+运算符的棘手位所需的线索。\nFirst, s2 has an \u0026amp;, meaning that we’re adding a reference of the second string to the first string because of the s parameter in the add function: we can only add a \u0026amp;str to a String; we can’t add two String values together. But wait—the type of \u0026amp;s2 is \u0026amp;String, not \u0026amp;str, as specified in the second parameter to add. So why does Listing 8-18 compile? 首先，s2有一个\u0026amp;，表示由于函数中的参数，我们正在将第二个字符串的引用添加到第一个字符串：我们只能将a添加到；我们不能将两个值加在一起。但等待中的类型是，不，如在第二个参数指定。那么为什么清单8-18会编译？sadd\u0026amp;strStringString\u0026amp;s2\u0026amp;String\u0026amp;stradd\nThe reason we’re able to use \u0026amp;s2 in the call to add is that the compiler can coerce the \u0026amp;String argument into a \u0026amp;str. When we call the add method, Rust uses a deref coercion, which here turns \u0026amp;s2 into \u0026amp;s2[..]. We’ll discuss deref coercion in more depth in Chapter 15. Because add does not take ownership of the s parameter, s2 will still be a valid String after this operation.\nSecond, we can see in the signature that add takes ownership of self, because self does not have an \u0026amp;. This means s1 in Listing 8-18 will be moved into the add call and no longer be valid after that. So although let s3 = s1 + \u0026amp;s2; looks like it will copy both strings and create a new one, this statement actually takes ownership of s1, appends a copy of the contents of s2, and then returns ownership of the result. In other words, it looks like it’s making a lot of copies but isn’t; the implementation is more efficient than copying.\nIf we need to concatenate multiple strings, the behavior of the + operator gets unwieldy:\nlet s1 = String::from(\u0026quot;tic\u0026quot;);\rlet s2 = String::from(\u0026quot;tac\u0026quot;);\rlet s3 = String::from(\u0026quot;toe\u0026quot;);\rlet s = s1 + \u0026quot;-\u0026quot; + \u0026amp;s2 + \u0026quot;-\u0026quot; + \u0026amp;s3;\rAt this point, s will be tic-tac-toe. With all of the + and \u0026quot; characters, it’s difficult to see what’s going on. For more complicated string combining, we can use the format! macro:\nlet s1 = String::from(\u0026quot;tic\u0026quot;);\rlet s2 = String::from(\u0026quot;tac\u0026quot;);\rlet s3 = String::from(\u0026quot;toe\u0026quot;);\rlet s = format!(\u0026quot;{}-{}-{}\u0026quot;, s1, s2, s3);\rThis code also sets s to tic-tac-toe. The format! macro works in the same way as println!, but instead of printing the output to the screen, it returns a String with the contents. The version of the code using format! is much easier to read and doesn’t take ownership of any of its parameters.\nIndexing into Strings In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a String using indexing syntax in Rust, you’ll get an error. Consider the invalid code in Listing 8-19.\nThis code does not compile! let s1 = String::from(\u0026ldquo;hello\u0026rdquo;); let h = s1[0]; Listing 8-19: Attempting to use indexing syntax with a String\nThis code will result in the following error:\n$ cargo run Compiling collections v0.1.0 (file:///projects/collections) error[E0277]: the type std::string::String cannot be indexed by {integer} \u0026ndash;\u0026gt; src/main.rs:3:13 | 3 | let h = s1[0]; | ^^^^^ std::string::String cannot be indexed by {integer} | = help: the trait std::ops::Index\u0026lt;{integer}\u0026gt; is not implemented for std::string::String\nerror: aborting due to previous error\nFor more information about this error, try rustc --explain E0277. error: could not compile collections.\nTo learn more, run the command again with \u0026ndash;verbose. The error and the note tell the story: Rust strings don’t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.\nInternal Representation A String is a wrapper over a Vec. Let’s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:\nlet hello = String::from(\u0026quot;Hola\u0026quot;);\rIn this case, len will be 4, which means the vector storing the string “Hola” is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But what about the following line? (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)\nlet hello = String::from(\u0026quot;Здравствуйте\u0026quot;);\rAsked how long the string is, you might say 12. However, Rust’s answer is 24: that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string’s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:\nlet hello = \u0026ldquo;Здравствуйте\u0026rdquo;; let answer = \u0026amp;hello[0]; What should the value of answer be? Should it be З, the first letter? When encoded in UTF-8, the first byte of З is 208 and the second is 151, so answer should in fact be 208, but 208 is not a valid character on its own. Returning 208 is likely not what a user would want if they asked for the first letter of this string; however, that’s the only data that Rust has at byte index 0. Users generally don’t want the byte value returned, even if the string contains only Latin letters: if \u0026amp;\u0026ldquo;hello\u0026rdquo;[0] were valid code that returned the byte value, it would return 104, not h. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn’t compile this code at all and prevents misunderstandings early in the development process.\nBytes and Scalar Values and Grapheme Clusters! Oh My! Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust’s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call letters).\nIf we look at the Hindi word “नमस्ते” written in the Devanagari script, it is stored as a vector of u8 values that looks like this:\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135] That’s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust’s char type is, those bytes look like this:\n[\u0026lsquo;न\u0026rsquo;, \u0026lsquo;म\u0026rsquo;, \u0026lsquo;स\u0026rsquo;, \u0026lsquo;्\u0026rsquo;, \u0026lsquo;त\u0026rsquo;, \u0026lsquo;े\u0026rsquo;] There are six char values here, but the fourth and sixth are not letters: they’re diacritics that don’t make sense on their own. Finally, if we look at them as grapheme clusters, we’d get what a person would call the four letters that make up the Hindi word:\n[\u0026ldquo;न\u0026rdquo;, \u0026ldquo;म\u0026rdquo;, \u0026ldquo;स्\u0026rdquo;, \u0026ldquo;ते\u0026rdquo;] Rust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.\nA final reason Rust doesn’t allow us to index into a String to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a String, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.\nSlicing Strings Indexing into a string is often a bad idea because it’s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. Therefore, Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using [] with a single number, you can use [] with a range to create a string slice containing particular bytes:\nlet hello = \u0026ldquo;Здравствуйте\u0026rdquo;;\nlet s = \u0026amp;hello[0..4]; Here, s will be a \u0026amp;str that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means s will be Зд.\nWhat would happen if we used \u0026amp;hello[0..1]? The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:\n$ cargo run Compiling collections v0.1.0 (file:///projects/collections) Finished dev [unoptimized + debuginfo] target(s) in 0.43s Running target/debug/collections thread \u0026lsquo;main\u0026rsquo; panicked at \u0026lsquo;byte index 1 is not a char boundary; it is inside \u0026lsquo;З\u0026rsquo; (bytes 0..2) of Здравствуйте\u0026rsquo;, src/libcore/str/mod.rs:2069:5 note: run with RUST_BACKTRACE=1 environment variable to display a backtrace. You should use ranges to create string slices with caution, because doing so can crash your program.\nMethods for Iterating Over Strings Fortunately, you can access elements in a string in other ways.\nIf you need to perform operations on individual Unicode scalar values, the best way to do so is to use the chars method. Calling chars on “नमस्ते” separates out and returns six values of type char, and you can iterate over the result to access each element:\nfor c in \u0026ldquo;नमस्ते\u0026rdquo;.chars() { println!(\u0026quot;{}\u0026quot;, c); } This code will print the following:\nन म स ् त े The bytes method returns each raw byte, which might be appropriate for your domain:\nfor b in \u0026ldquo;नमस्ते\u0026rdquo;.bytes() { println!(\u0026quot;{}\u0026quot;, b); } This code will print the 18 bytes that make up this String:\n224 164 // \u0026ndash;snip\u0026ndash; 165 135 But be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.\nGetting grapheme clusters from strings is complex, so this functionality is not provided by the standard library. Crates are available on crates.io if this is the functionality you need.\nStrings Are Not So Simple To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of String data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.\nLet’s switch to something a bit less complex: hash maps!\n8.3。在哈希图中存储具有关联值的键 "},{"id":134,"href":"/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-9%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","title":"The Rust Programming Language 第 9章 错误处理","parent":"The Rust Programming Language","content":" 第 9章 错误处理 9.1。不可挽回的错误与恐慌！ 9.2。结果可恢复错误 9.3。恐慌！还是不要慌！ "},{"id":135,"href":"/Tech/1Book/The-Rust-Programming-Language/%E6%A0%87%E9%A2%98/","title":"标题","parent":"The Rust Programming Language","content":" Rust编程语言 标签：Rust、基础、 时间：2020年8月6日6:25:00 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 介绍 "},{"id":136,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC10%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F/","title":"Thinking in Java 第10章 Java Io系统","parent":"Thinking In Java","content":" 第10章 Java IO系统 由于存在大量不同的设计方案，所以该任务的困难性是很容易证明的。其中最大的挑战似乎是如何覆盖所有可能的因素。不仅有三种不同的种类的IO需要考虑（文件、控制台、网络连接），而且需要通过大量不同的方式与它们通信（顺序、随机访问、二进制、字符、按行、按字等等）。\nJava库的设计者通过创建大量类来攻克这个难题。事实上，Java的IO系统采用了如此多的类，以致刚开始会产生不知从何处入手的感觉（具有讽刺意味的是，Java的IO设计初衷实际要求避免过多的类）。从Java 1.0升级到Java 1.1后，IO库的设计也发生了显著的变化。此时并非简单地用新库替换旧库，Sun的设计人员对原来的库进行了大手笔的扩展，添加了大量新的内容。因此，我们有时不得不混合使用新库与旧库，产生令人无奈的复杂代码。\n10.1 输入和输出 装饰者模式，处理不同来源的输入和输出。 直接总结：\n1、能读取文件、写入文件、复制文件、利用缓冲区就行。\n2、知道完成这些操作有那些步骤就行。\n可将Java库的IO类分割为输入与输出两个部分，这一点在用Web浏览器阅读联机Java类文档时便可知道。通过继承，从InputStream（输入流）衍生的所有类都拥有名为read()的基本方法，用于读取单个字节或者字节数组。类似地，从OutputStream衍生的所有类都拥有基本方法write()，用于写入单个字节或者字节数组。然而，我们通常不会用到这些方法；它们之所以存在，是因为更复杂的类可以利用它们，以便提供一个更有用的接口。因此，我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供自己期望的功能。我们之所以感到Java的流库（Stream Library）异常复杂，正是由于为了创建单独一个结果流，却需要创建多个对象的缘故。\n很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都从InputStream继承，而与输出有关的所有类都从OutputStream继承。\n10.1.1 InputStream的类型 InputStream的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream子类）：\n(1) 字节数组 (2) String对象 (3) 文件 (4) “管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。 (5) 一系列其他流，以便我们将其统一收集到单独一个流内。 (6) 其他起源地，如Internet连接等（将在本书后面的部分讲述）。 除此以外，FilterInputStream也属于InputStream的一种类型，用它可为“破坏器”类提供一个基础类，以便将属性或者有用的接口同输入流连接到一起。 具体哪种类型有何特性，自己查找API吧。\n10.1.2 OutputStream的类型 具体哪种类型有何特性，自己查找API吧。\n10.2 增添属性和有用的接口 利用层次化对象动态和透明地添加单个对象的能力的做法叫作“装饰器”（Decorator）方案——“方案”属于本书第16章的主题（注释①）。装饰器方案规定封装于初始化对象中的所有对象都拥有相同的接口，以便利用装饰器的“透明”性质——我们将相同的消息发给一个对象，无论它是否已被“装饰”。这正是在Java IO库里存在“过滤器”（Filter）类的原因：抽象的“过滤器”类是所有装饰器的基础类（装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中）。\n子类处理要求大量子类对每种可能的组合提供支持时，便经常会用到装饰器——由于组合形式太多，造成子类处理变得不切实际。Java IO库要求许多不同的特性组合方案，这正是装饰器方案显得特别有用的原因。但是，装饰器方案也有自己的一个缺点。在我们写一个程序的时候，装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于Java IO库操作不便，我们必须创建许多类——“核心”IO类型加上所有装饰器——才能得到自己希望的单个IO对象。\nFilterInputStream和FilteOutputStream分别是过滤输入流和过滤输出流,他们的作用是为基础流提供一些额外的功能\nFilterInputStream和FilterOutputStream（这两个名字不十分直观）提供了相应的装饰器接口，用于控制一个特定的输入流（InputStream）或者输出流（OutputStream）。它们分别是从InputStream和OutputStream衍生出来的。此外，它们都属于抽象类，在理论上为我们与一个流的不同通信手段都提供了一个通用的接口。事实上，FilterInputStream和FilterOutputStream只是简单地模仿了自己的基础类，它们是一个装饰器的基本要求。\n10.2.1 通过FilterInputStream从InputStream里读入数据 FilterInputStream类要完成两件全然不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，比如readByte()，readFloat()等等）。伴随对应的DataOutputStream，我们可通过数据“流”将基本类型的数据从一个地方搬到另一个地方。这些“地方”是由表10.1总结的那些类决定的。若读取块内的数据，并自己进行解析，就不需要用到DataInputStream。但在其他许多情况下，我们一般都想用它对自己读入的数据进行自动格式化。 剩下的类用于修改InputStream的内部行为方式：是否进行缓冲，是否跟踪自己读入的数据行，以及是否能够推回一个字符等等。后两种类看起来特别象提供对构建一个编译器的支持（换言之，添加它们为了支持Java编译器的构建），所以在常规编程中一般都用不着它们。\n也许几乎每次都要缓冲自己的输入，无论连接的是哪个IO设备。所以IO库最明智的做法就是将未缓冲输入作为一种特殊情况处理，同时将缓冲输入接纳为标准做法。\n10.2.2 通过FilterOutputStream向OutputStream里写入数据 与DataInputStream对应的是DataOutputStream，后者对各个基本数据类型以及String对象进行格式化，并将其置入一个数据“流”中，以便任何机器上的DataInputStream都能正常地读取它们。所有方法都以“wirte”开头，例如writeByte()，writeFloat()等等。\n若想进行一些真正的格式化输出，比如输出到控制台，请使用PrintStream。利用它可以打印出所有基本数据类型以及String对象，并可采用一种易于查看的格式。这与DataOutputStream正好相反，后者的目标是将那些数据置入一个数据流中，以便DataInputStream能够方便地重新构造它们。System.out静态对象是一个PrintStream。\nPrintStream内两个重要的方法是print()和println()。它们已进行了覆盖处理，可打印出所有数据类型。print()和println()之间的差异是后者在操作完毕后会自动添加一个新行。\nBufferedOutputStream属于一种“修改器”，用于指示数据流使用缓冲技术，使自己不必每次都向流内物理性地写入数据。通常都应将它应用于文件处理和控制器IO。 表10.4 FilterOutputStream的类型\n10.3 本身的缺陷：RandomAccessFile RandomAccessFile用于包含了已知长度记录的文件，以便我们能用seek()从一条记录移至另一条；然后读取或修改那些记录。各记录的长度并不一定相同；只要知道它们有多大以及置于文件何处即可。\n首先，我们有点难以相信RandomAccessFile不属于InputStream或者OutputStream分层结构的一部分。除了恰巧实现了DataInput以及DataOutput（这两者亦由DataInputStream和DataOutputStream实现）接口之外，它们与那些分层结构并无什么关系。它甚至没有用到现有InputStream或OutputStream类的功能——采用的是一个完全不相干的类。该类属于全新的设计，含有自己的全部（大多数为固有）方法。之所以要这样做，是因为RandomAccessFile拥有与其他IO类型完全不同的行为，因为我们可在一个文件里向前或向后移动。不管在哪种情况下，它都是独立运作的，作为Object的一个“直接继承人”使用。\n从根本上说，RandomAccessFile类似DataInputStream和DataOutputStream的联合使用。其中，getFilePointer()用于了解当前在文件的什么地方，seek()用于移至文件内的一个新地点，而length()用于判断文件的最大长度。此外，构建器要求使用另一个自变量（与C的fopen()完全一样），指出自己只是随机读（\u0026ldquo;r\u0026rdquo;），还是读写兼施（\u0026ldquo;rw\u0026rdquo;）。这里没有提供对“只写文件”的支持。也就是说，假如是从DataInputStream继承的，那么RandomAccessFile也有可能能很好地工作。\n还有更难对付的。很容易想象我们有时要在其他类型的数据流中搜索，比如一个ByteArrayInputStream，但搜索方法只有RandomAccessFile才会提供。而后者只能针对文件才能操作，不能针对数据流操作。此时，BufferedInputStream确实允许我们标记一个位置（使用mark()，它的值容纳于单个内部变量中），并用reset()重设那个位置。但这些做法都存在限制，并不是特别有用。\n10.4 File类 File类有一个欺骗性的名字——通常会认为它对付的是一个文件，但实情并非如此。它既代表一个特定文件的名字，也代表目录内一系列文件的名字。若代表一个文件集，便可用list()方法查询这个集，返回的是一个字串数组。之所以要返回一个数组，而非某个灵活的集合类，是因为元素的数量是固定的。而且若想得到一个不同的目录列表，只需创建一个不同的File对象即可。事实上，“FilePath”（文件路径）似乎是一个更好的名字。本节将向大家完整地例示如何使用这个类，其中包括相关的FilenameFilter（文件名过滤器）接口。\n10.4.1 目录列表器 现在假设我们想观看一个目录列表。可用两种方式列出File对象。若在不含自变量（参数）的情况下调用list()，会获得File对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择File对象来完成显示。\n实现”interface FilenameFilter（关于接口的问题，已在第7章进行了详述）。下面让我们看看FilenameFilter接口有多么简单\npublic interface FilenameFilter {\rboolean accept(文件目录, 字串名);\r} 它指出这种类型的所有对象都提供了一个名为accept()的方法。之所以要创建这样的一个类，背后的全部原因就是把accept()方法提供给list()方法，使list()能够“回调”accept()，从而判断应将哪些文件名包括到列表中。因此，通常将这种技术称为“回调”，有时也称为“算子”（也就是说，DirFilter是一个算子，因为它唯一的作用就是容纳一个方法）。由于list()采用一个FilenameFilter对象作为自己的自变量使用，所以我们能传递实现了FilenameFilter的任何类的一个对象，用它决定（甚至在运行期）list()方法的行为方式。回调的目的是在代码的行为上提供更大的灵活性。\n通过DirFilter，我们看出尽管一个“接口”只包含了一系列方法，但并不局限于只能写那些方法（但是，至少必须提供一个接口内所有方法的定义。在这种情况下，DirFilter构建器也会创建）。\naccept()方法必须接纳一个File对象，用它指示用于寻找一个特定文件的目录；并接纳一个String，其中包含了要寻找之文件的名字。可决定使用或忽略这两个参数之一，但有时至少要使用文件名。记住list()方法准备为目录对象中的每个文件名调用\naccept()，核实哪个应包含在内——具体由accept()返回的“布尔”结果决定。 为确定我们操作的只是文件名，其中没有包含路径信息，必须采用String对象，并在它的外部创建一个File对象。然后调用\ngetName()，它的作用是去除所有路径信息（采用与平台无关的方式）。随后，accept()用String类的indexOf()方法检查文件名内部是否存在搜索字串\u0026quot;afn\u0026quot;。若在字串内找到afn，那么返回值就是afn的起点索引；但假如没有找到，返回值就是-1。注意这只是一个简单的字串搜索例子，未使用常见的表达式“通配符”方案，比如\u0026quot;fo?.b?r*\u0026quot;；这种方案更难实现。\nlist()方法返回的是一个数组。可查询这个数组的长度，然后在其中遍历，选定数组元素。与C和C++的类似行为相比，这种于方法内外方便游历数组的行为无疑是一个显著的进步。\n注意filter()的自变量必须是final。这一点是匿名内部类要求的，使其能使用来自本身作用域以外的一个对象。\n10.4.2 检查与创建目录 File类并不仅仅是对现有目录路径、文件或者文件组的一个表示。亦可用一个File对象新建一个目录，甚至创建一个完整的目录路径——假如它尚不存在的话。亦可用它了解文件的属性（长度、上一次修改日期、读／写属性等），检查一个File对象到底代表一个文件还是一个目录，以及删除一个文件等等。\n10.5 IO流的典型应用 尽管库内存在大量IO流类，可通过多种不同的方式组合到一起，但实际上只有几种方式才会经常用到。然而，必须小心在意才能得到正确的组合。下面这个相当长的例子展示了典型IO配置的创建与使用，可在写自己的代码时将其作为一个参考使用。注意每个配置都以一个注释形式的编号起头，并提供了适当的解释信息。\n10.5.1 输入流 缓冲的输入文件 为打开一个文件以便输入，需要使用一个FileInputStream，同时将一个String或File对象作为文件名使用。为提高速度，最好先对文件进行缓冲处理，从而获得用于一个BufferedInputStream的构建器的结果句柄。为了以格式化的形式读取输入数据，我们将那个结果句柄赋给用于一个DataInputStream的构建器。DataInputStream是我们的最终（final）对象，并是我们进行读取操作的接口。\nDataInputStream in =\rnew DataInputStream(\rnew BufferedInputStream(\rnew FileInputStream(args[0])\r)\r);\rString s, s2 = new String();\rwhile((s = in.readLine())!= null)\rs2 += s + \u0026#34;\\n\u0026#34;;\rin.close(); 在这个例子中，只用到了readLine()方法，但理所当然任何DataInputStream方法都可以采用。一旦抵达文件末尾，readLine()就会返回一个null（空），以便中止并退出while循环。\n“String s2”用于聚集完整的文件内容（包括必须添加的新行，因为readLine()去除了那些行）。随后，在本程序的后面部分中使用s2。最后，我们调用close()，用它关闭文件。从技术上说，会在运行finalize()时调用close()。而且我们希望一旦程序退出，就发生这种情况（无论是否进行垃圾收集）。然而，Java 1.0有一个非常突出的错误（Bug），造成这种情况不会发生。在Java 1.1中，必须明确调用System.runFinalizersOnExit(true)，用它保证会为系统中的每个对象调用finalize()。然而，最安全的方法还是为文件明确调用close()。\nStringBufferInputStream的接口是有限的，所以通常需要将其封装到一个DataInputStream内，从而增强它的能力。然而，若选择用readByte()每次读出一个字符，那么所有值都是有效的，所以不可再用返回值来侦测何时结束输入。相反，可用available()方法判断有多少字符可用。下面这个例子展示了如何从文件中一次读出一个字符：\nDataInputStream in = new DataInputStream(\rnew BufferedInputStream(\rnew FileInputStream(\u0026#34;TestEof.java\u0026#34;)));\rwhile(in.available() != 0)\rSystem.out.print((char)in.readByte()); 注意取决于当前从什么媒体读入，avaiable()的工作方式也是有所区别的。它在字面上意味着“可以不受阻塞读取的字节数量”。对一个文件来说，它意味着整个文件。但对一个不同种类的数据流来说，它却可能有不同的含义。因此在使用时应考虑周全。\n10.5.2 输出流 两类主要的输出流是按它们写入数据的方式划分的：一种按人的习惯写入，另一种为了以后由一个DataInputStream而写入。RandomAccessFile是独立的，尽管它的数据格式兼容于DataInputStream和DataOutputStream。\n10.5.3 快捷文件处理 这段说的是工具类，熟悉可IO的API自己写就行。\n10.5.4 从标准输入中读取数据 以Unix首先倡导的“标准输入”、“标准输出”以及“标准错误输出”概念为基础，Java提供了相应的System.in，System.out以及System.err。贯这一整本书，大家都会接触到如何用System.out进行标准输出，它已预封装成一个PrintStream对象。\nSystem.err同样是一个PrintStream，但System.in是一个原始的InputStream，未进行任何封装处理。这意味着尽管能直接使用System.out和System.err，但必须事先封装System.in，否则不能从中读取数据。 典型情况下，我们希望用readLine()每次读取一行输入信息，所以需要将System.in封装到一个DataInputStream中。这是Java 1.0进行行输入时采取的“老”办法。在本章稍后，大家还会看到Java 1.1的解决方案。\npublic static void main(String[] args) {\rDataInputStream in =\rnew DataInputStream(\rnew BufferedInputStream(System.in));\rString s;\rtry {\rwhile((s = in.readLine()).length() != 0)\rSystem.out.println(s);\r// An empty line terminates the program\r} catch(IOException e) {\re.printStackTrace();\r}\r} 10.5.5 管道数据流 本章已简要介绍了PipedInputStream（管道输入流）和PipedOutputStream（管道输出流）。尽管描述不十分详细，但并不是说它们作用不大。然而，只有在掌握了多线程处理的概念后，才可真正体会它们的价值所在。原因很简单，因为管道化的数据流就是用于线程之间的通信。这方面的问题将在第14章用一个示例说明。\n10.6 StreamTokenizer 尽管StreamTokenizer并不是从InputStream或OutputStream衍生的，但它只随同InputStream工作，所以十分恰当地包括在库的IO部分中。 StreamTokenizer类用于将任何InputStream分割为一系列“记号”（Token）。这些记号实际是一些断续的文本块，中间用我们选择的任何东西分隔。例如，我们的记号可以是单词，中间用空白（空格）以及标点符号分隔。\n类java.io.StreamTokenizer可以获取输入流并将其分析为Token(标记)。StreamTokenizer的nextToken方法将读取下一个标记 默认情况下，StreamTokenizer认为下列内容是Token：字母、数字、除C和C++注释符号以外的其他符号。如符号“/”不是Token，注释后的内容也不是，而“\\”是Token。单引号和双引号以及其中的内容，只能算是一个Token。 要统计文件的字符数，不能简单地统计Token数，因为字符数不等于Token，按照Token的规定，引号中的内容就算是10页也算是一个Token。如果希望引号和引号中的内容都算作Token，应该通过StreamTokenizer的ordinaryCha()方法将单引号和双引号当做普通字符处理。 StreamTokenizer用来分隔字符串。\r可以获取输入流并将其分析为Token(标记)。StreamTokenizer的nextToken方法将读取下一个标记。\r功能 1、 将输入流分解成一组标记，允许一次读一个。分解过程由一张表和一些可以设置成各种状态的标志来控制。 2、读取的每个字节被认为是“\\u0000”-“\\u00FF”之间的字符。空格(“\\u0000”-“\\u0020”)，字母(“A”-“Z”,“a”-“z”,“\\u00A0”-“\\u00FF”)，数字，串引号(“,“)，注释字符(“/”)）。 3、做法：以一个InputStream作为源，创建一个StreamTokenizer对象，设置参数,循环调用nextToken，返回流中下一个标记的类型，并处理相关的值。 4、主要用于分析Java风格的输入；不是通用的标记分析器。 ttype域：nextToken后刚读取的标记类型。六种情况： 单字符标记：表示该字符（转换成整数） 引号串标记：引号符(String类型域sval存储了串内容) TT_WORD(-3)：单词。String类型域sval存储了该单词。 TT_NUMBER(-2)：数。double类型域nval保存该数值。只能识别十进制浮点数。( ? 3.4e79,0xffff ) TT_EOL(“\\n”)：行结束。 TT_EOF(-1)：文件结束。\r//创建分析给定字符流的标记生成器\rStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\r//ordinaryChar方法指定字符参数在此标记生成器中是“普通”字符。\rst.ordinaryChar(\u0026#39;\\\u0026#39;\u0026#39;); //指定单引号、双引号和注释符号是普通字符\rst.ordinaryChar(\u0026#39;\\\u0026#34;\u0026#39;);\rst.ordinaryChar(\u0026#39;/\u0026#39;)\r//nextToken方法读取下一个Token.\r//TT_EOF指示已读到流末尾的常量。\rwhile (st.nextToken() != StreamTokenizer.TT_EOF) {\r//在调用 nextToken 方法之后，ttype字段将包含刚读取的标记的类型\rswitch (st.ttype) {\r//TT_EOL指示已读到行末尾的常量。\rcase StreamTokenizer.TT_EOL:\rbreak;\r//TT_NUMBER指示已读到一个数字标记的常量\rcase StreamTokenizer.TT_NUMBER:\r//如果当前标记是一个数字，nval字段将包含该数字的值\rs = String.valueOf((st.nval));\rSystem.out.println(s);\rnumberSum += s.length();\rbreak;\r//TT_WORD指示已读到一个文字标记的常量\rcase StreamTokenizer.TT_WORD:\r//如果当前标记是一个文字标记，sval字段包含一个给出该文字标记的字符的字符串\rs = st.sval;\rwordSum += s.length();\rbreak;\rdefault: 10.6.1 StringTokenizer 无论如何，只应将StringTokenizer看作StreamTokenizer一种简单而且特殊的简化形式。然而，如果有一个字串需要进行记号处理，而且StringTokenizer的功能实在有限，那么应该做的全部事情就是用StringBufferInputStream将其转换到一个数据流里，再用它创建一个功能更强大的StreamTokenizer。\n跟 StreamTokenizer 差不多，反正我没用过。。。\n10.7 Java 1.1的IO流 之所以在Java 1.1里添加了Reader和Writer层次，最重要的原因便是国际化的需求。老式IO流层次结构只支持8位字节流，不能很好地控制16位Unicode字符。由于Unicode主要面向的是国际化支持（Java内含的char是16位的Unicode），所以添加了Reader和Writer层次，以提供对所有IO操作中的Unicode的支持。除此之外，新库也对速度进行了优化，可比旧库更快地运行。 与本书其他地方一样，我会试着提供对类的一个概述，但假定你会利用联机文档搞定所有的细节，比如方法的详尽列表等。\n我还以为将NIO呢，但是NIO不是JDK 1.4 及以上版本里提供的咩。。。\n10.8 压缩 就是讲压缩API 的，自己看API写用例就行了。。。没啥细究的。。。\nJava 1.1也添加一个类，用以支持对压缩格式的数据流的读写。它们封装到现成的IO类中，以提供压缩功能。\nCheckedInputStream GetCheckSum()为任何InputStream产生校验和（不仅是解压）\rCheckedOutputStream GetCheckSum()为任何OutputStream产生校验和（不仅是解压）\rDeflaterOutputStream 用于压缩类的基础类\rZipOutputStream 一个DeflaterOutputStream，将数据压缩成Zip文件格式\rGZIPOutputStream 一个DeflaterOutputStream，将数据压缩成GZIP文件格式\rInflaterInputStream 用于解压类的基础类\rZipInputStream 一个DeflaterInputStream，解压用Zip文件格式保存的数据\rGZIPInputStream 一个DeflaterInputStream，解压用GZIP文件格式保存的数据 尽管存在许多种压缩算法，但是Zip和GZIP可能最常用的。所以能够很方便地用多种现成的工具来读写这些格式的压缩数据。\n10.8.1 用GZIP进行简单压缩 10.8.2 用Zip进行多文件保存 10.8.3 Java归档（jar）实用程序 Zip格式亦在Java 1.1的JAR（Java ARchive）文件格式中得到了采用。这种文件格式的作用是将一系列文件合并到单个压缩文件里，就象Zip那样。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。除了可以包括声音和图像文件以外，也可以在其中包括类文件。\n一个JAR文件由一系列采用Zip压缩格式的文件构成，同时还有一张“详情单”，对所有这些文件进行了描述（可创建自己的详情单文件；否则，jar程序会为我们代劳）。在联机用户文档中，可以找到与JAR详情单更多的资料（详情单的英语是“Manifest”）。 jar实用程序已与Sun的JDK配套提供，可以按我们的选择自动压缩文件。请在命令行调用它：\n10.9 对象序列化 对象序列化这些年养活了很多安全工程师。。。\nJava 1.1增添了一种有趣的特性，名为“对象序列化”（Object Serialization）。它面向那些实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。\n就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现“有限持久化”。请记住“持久化”意味着对象的“生存时间”并不取决于程序是否正在执行——它存在或“生存”于程序的每一次调用之间。通过序列化一个对象，将其写入磁盘，以后在程序重新调用时重新恢复那个对象，就能圆满实现一种“持久”效果。之所以称其为“有限”，是因为不能用某种“persistent”（持久）关键字简单地地定义一个对象，并让系统自动照看其他所有细节问题（尽管将来可能成为现实）。相反，必须在自己的程序中明确地序列化和组装对象。\n语言里增加了对象序列化的概念后，可提供对两种主要特性的支持。Java 1.1的“远程方法调用”（RMI）使本来存在于其他机器的对象可以表现出好象就在本地机器上的行为。将消息发给远程对象时，需要通过对象序列化来传输参数和返回值。RMI将在第15章作具体讨论。\n对象的序列化也是Java Beans必需的，后者由Java 1.1引入。使用一个Bean时，它的状态信息通常在设计期间配置好。程序启动以后，这种状态信息必须保存下来，以便程序启动以后恢复；具体工作由对象序列化完成。\n学习JSP，不可避免地你会接触到JavaBeans\n对象的序列化处理非常简单，只需对象实现了Serializable接口即可（该接口仅是一个标记，没有方法）。在Java 1.1中，许多标准库类都发生了改变，以便能够序列化——其中包括用于基本数据类型的全部封装器、所有集合类以及其他许多东西。甚至Class对象也可以序列化（第11章讲述了具体实现过程）。\n为序列化一个对象，首先要创建某些OutputStream对象，然后将其封装到ObjectOutputStream对象内。此时，只需调用writeObject()即可完成对象的序列化，并将其发送给OutputStream。相反的过程是将一个InputStream封装到ObjectInputStream内，然后调用 readObject()。和往常一样，我们最后获得的是指向一个上溯造型Object的句柄，所以必须下溯造型，以便能够直接设置。\n对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内包含的所有句柄并保存那些对象；接着又能对每个对象内包含的句柄进行追踪；以此类推。我们有时将这种情况称为“对象网”，单个对象可与之建立连接。而且它还包含了对象的句柄数组以及成员对象。若必须自行操纵一套对象序列化机制，那么在代码里追踪所有这些链接时可能会显得非常麻烦。在另一方面，由于Java对象的序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子对序列化机制进行了测试。它建立了许多链接对象的一个“Worm”（蠕虫），每个对象都与Worm中的下一段链接，同时又与属于不同类（Data）的对象句柄数组链接：\n//: Worm.java\r// Demonstrates object serialization in Java 1.1\rimport java.io.*;\rclass Data implements Serializable {\rprivate int i;\rData(int x) { i = x; }\rpublic String toString() {\rreturn Integer.toString(i);\r}\r}\rpublic class Worm implements Serializable {\r// Generate a random int value:\rprivate static int r() {\rreturn (int)(Math.random() * 10);\r}\rprivate Data[] d = {\rnew Data(r()), new Data(r()), new Data(r())\r};\rprivate Worm next;\rprivate char c;\r// Value of i == number of segments\rWorm(int i, char x) {\rSystem.out.println(\u0026#34; Worm constructor: \u0026#34; + i);\rc = x;\rif(--i \u0026gt; 0)\rnext = new Worm(i, (char)(x + 1));\r}\rWorm() {\rSystem.out.println(\u0026#34;Default constructor\u0026#34;);\r}\rpublic String toString() {\rString s = \u0026#34;:\u0026#34; + c + \u0026#34;(\u0026#34;;\rfor(int i = 0; i \u0026lt; d.length; i++)\rs += d[i].toString();\rs += \u0026#34;)\u0026#34;;\rif(next != null)\rs += next.toString();\rreturn s;\r}\rpublic static void main(String[] args) {\rWorm w = new Worm(6, \u0026#39;a\u0026#39;);\rSystem.out.println(\u0026#34;w = \u0026#34; + w);\rtry {\rObjectOutputStream out =\rnew ObjectOutputStream(\rnew FileOutputStream(\u0026#34;worm.out\u0026#34;));\rout.writeObject(\u0026#34;Worm storage\u0026#34;);\rout.writeObject(w);\rout.close(); // Also flushes output\rObjectInputStream in =\rnew ObjectInputStream(\rnew FileInputStream(\u0026#34;worm.out\u0026#34;));\rString s = (String)in.readObject();\rWorm w2 = (Worm)in.readObject();\rSystem.out.println(s + \u0026#34;, w2 = \u0026#34; + w2);\r} catch(Exception e) {\re.printStackTrace();\r}\rtry {\rByteArrayOutputStream bout =\rnew ByteArrayOutputStream();\rObjectOutputStream out =\rnew ObjectOutputStream(bout);\rout.writeObject(\u0026#34;Worm storage\u0026#34;);\rout.writeObject(w);\rout.flush();\rObjectInputStream in =\rnew ObjectInputStream(\rnew ByteArrayInputStream(\rbout.toByteArray()));\rString s = (String)in.readObject();\rWorm w3 = (Worm)in.readObject();\rSystem.out.println(s + \u0026#34;, w3 = \u0026#34; + w3);\r} catch(Exception e) {\re.printStackTrace();\r}\r}\r} ///:~ 真正的序列化过程却是非常简单的。一旦从另外某个流里创建了ObjectOutputStream，writeObject()就会序列化对象。注意也可以为一个String调用writeObject()。亦可使用与DataOutputStream相同的方法写入所有基本数据类型（它们有相同的接口）。\n有两个单独的try块看起来是类似的。第一个读写的是文件，而另一个读写的是一个ByteArray（字节数组）。可利用对任何DataInputStream或者DataOutputStream的序列化来读写特定的对象；正如在关于连网的那一章会讲到的那样，这些对象甚至包括网络。\n可以看出，装配回原状的对象确实包含了原来那个对象里包含的所有链接。\n注意在对一个Serializable（可序列化）对象进行重新装配的过程中，不会调用任何构建器（甚至默认构建器）。整个对象都是通过从InputStream中取得数据恢复的。\n作为Java 1.1特性的一种，我们注意到对象的序列化并不属于新的Reader和Writer层次结构的一部分，而是沿用老式的InputStream和OutputStream结构。所以在一些特殊的场合下，不得不混合使用两种类型的层次结构。\n10.9.1 寻找类 读者或许会奇怪为什么需要一个对象从它的序列化状态中恢复。举个例子来说，假定我们序列化一个对象，并通过网络将其作为文件传送给另一台机器。此时，位于另一台机器的程序可以只用文件目录来重新构造这个对象吗？ 回答这个问题的最好方法就是做一个实验。下面这个文件位于本章的子目录下：\n//: Alien.java\r// A serializable class\rimport java.io.*;\rpublic class Alien implements Serializable {\r} ///:~ 用于创建和序列化一个Alien对象的文件位于相同的目录下：\n//: FreezeAlien.java\r// Create a serialized output file\rimport java.io.*;\rpublic class FreezeAlien {\rpublic static void main(String[] args) throws Exception {\rObjectOutput out = new ObjectOutputStream(\rnew FileOutputStream(\u0026#34;file.x\u0026#34;));\rAlien zorcon = new Alien();\rout.writeObject(zorcon); }\r} ///:~ 该程序并不是捕获和控制违例，而是将违例简单、直接地传递到main()外部，这样便能在命令行报告它们。 程序编译并运行后，将结果产生的file.x复制到名为xfiles的子目录，代码如下：\n//: ThawAlien.java\r// Try to recover a serialized file without the // class of object that\u0026#39;s stored in that file.\rpackage c10.xfiles;\rimport java.io.*;\rpublic class ThawAlien {\rpublic static void main(String[] args) throws Exception {\rObjectInputStream in =\rnew ObjectInputStream(\rnew FileInputStream(\u0026#34;file.x\u0026#34;));\rObject mystery = in.readObject();\rSystem.out.println(\rmystery.getClass().toString());\r}\r} ///:~ 该程序能打开文件，并成功读取mystery对象中的内容。然而，一旦尝试查找与对象有关的任何资料——这要求Alien的Class对象——Java虚拟机（JVM）便找不到Alien.class（除非它正好在类路径内，而本例理应相反）。这样就会得到一个名叫ClassNotFoundException的违例（同样地，若非能够校验Alien存在的证据，否则它等于消失）。\n恢复了一个序列化的对象后，如果想对其做更多的事情，必须保证JVM能在本地类路径或者因特网的其他什么地方找到相关的.class文件。\n总结：\n这小节说啥了，是在说，通过序列化恢复产生的对象，在 JVM 中是没有.class 的，除非它正好在相同类路径内。\n10.9.2 序列化的控制 正如大家看到的那样，默认的序列化机制并不难操纵。然而，假若有特殊要求又该怎么办呢？我们可能有特殊的安全问题，不希望对象的某一部分序列化；或者某一个子对象完全不必序列化，因为对象恢复以后，那一部分需要重新创建。\n此时，通过实现Externalizable接口，用它代替Serializable接口，便可控制序列化的具体过程。这个Externalizable接口扩展了Serializable，并增添了两个方法：writeExternal()和readExternal()。在序列化和重新装配的过程中，会自动调用这两个方法，以便我们执行一些特殊操作。\n下面这个例子展示了Externalizable接口方法的简单应用。注意Blip1和Blip2几乎完全一致，除了极微小的差别（自己研究一下代码，看看是否能发现）：\n//: Blips.java // Simple use of Externalizable \u0026amp; a pitfall import java.io.*; import java.util.*; class Blip1 implements Externalizable { public Blip1() { System.out.println(\u0026#34;Blip1 Constructor\u0026#34;); } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\u0026#34;Blip1.writeExternal\u0026#34;); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;Blip1.readExternal\u0026#34;); } } class Blip2 implements Externalizable { Blip2() { System.out.println(\u0026#34;Blip2 Constructor\u0026#34;); } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\u0026#34;Blip2.writeExternal\u0026#34;); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;Blip2.readExternal\u0026#34;); } } public class Blips { public static void main(String[] args) { System.out.println(\u0026#34;Constructing objects:\u0026#34;); Blip1 b1 = new Blip1(); Blip2 b2 = new Blip2(); try { ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(\u0026#34;Blips.out\u0026#34;)); System.out.println(\u0026#34;Saving objects:\u0026#34;); o.writeObject(b1); o.writeObject(b2); o.close(); // Now get them back: ObjectInputStream in = new ObjectInputStream( new FileInputStream(\u0026#34;Blips.out\u0026#34;)); System.out.println(\u0026#34;Recovering b1:\u0026#34;); b1 = (Blip1)in.readObject(); // OOPS! Throws an exception: //! System.out.println(\u0026#34;Recovering b2:\u0026#34;); //! b2 = (Blip2)in.readObject(); } catch(Exception e) { e.printStackTrace(); } } } ///:~ 该程序输出如下：\nConstructing objects:\rBlip1 Constructor\rBlip2 Constructor\rSaving objects:\rBlip1.writeExternal\rBlip2.writeExternal\rRecovering b1:\rBlip1 Constructor\rBlip1.readExternal 未恢复Blip2对象的原因是那样做会导致一个违例。你找出了Blip1和Blip2之间的区别吗？Blip1的构建器是“公共的”（public），Blip2的构建器则不然，这样便会在恢复时造成违例。试试将Blip2的构建器属性变成“public”，然后删除//!注释标记，看看是否能得到正确的结果。\n恢复b1后，会调用Blip1默认构建器。这与恢复一个Serializable（可序列化）对象不同。在后者的情况下，对象完全以它保存下来的二进制位为基础恢复，不存在构建器调用。而对一个Externalizable对象，所有普通的默认构建行为都会发生（包括在字段定义时的初始化），而且会调用readExternal()。必须注意这一事实——特别注意所有默认的构建行为都会进行——否则很难在自己的Externalizable对象中产生正确的行为。\n下面这个例子揭示了保存和恢复一个Externalizable对象必须做的全部事情：\n//: Blip3.java // Reconstructing an externalizable object import java.io.*; import java.util.*; class Blip3 implements Externalizable { int i; String s; // No initialization public Blip3() { System.out.println(\u0026#34;Blip3 Constructor\u0026#34;); // s, i not initialized } public Blip3(String x, int a) { System.out.println(\u0026#34;Blip3(String x, int a)\u0026#34;); s = x; i = a; // s \u0026amp; i initialized only in non-default // constructor. } public String toString() { return s + i; } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\u0026#34;Blip3.writeExternal\u0026#34;); // You must do this: out.writeObject(s); out.writeInt(i); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;Blip3.readExternal\u0026#34;); // You must do this: s = (String)in.readObject(); i =in.readInt(); } public static void main(String[] args) { System.out.println(\u0026#34;Constructing objects:\u0026#34;); Blip3 b3 = new Blip3(\u0026#34;A String \u0026#34;, 47); System.out.println(b3.toString()); try { ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(\u0026#34;Blip3.out\u0026#34;)); System.out.println(\u0026#34;Saving object:\u0026#34;); o.writeObject(b3); o.close(); // Now get it back: ObjectInputStream in = new ObjectInputStream( new FileInputStream(\u0026#34;Blip3.out\u0026#34;)); System.out.println(\u0026#34;Recovering b3:\u0026#34;); b3 = (Blip3)in.readObject(); System.out.println(b3.toString()); } catch(Exception e) { e.printStackTrace(); } } } ///:~ Constructing objects:\rBlip3(String x, int a)\rA String 47\rSaving object:\rBlip3.writeExternal\rRecovering b3:\rBlip3 Constructor\rBlip3.readExternal\rA String 47 其中，字段s和i只在第二个构建器中初始化，不关默认构建器的事。这意味着假如不在readExternal中初始化s和i，它们就会成为null（因为在对象创建的第一步中已将对象的存储空间清除为1）。若注释掉跟随于“You must do this”后面的两行代码，并运行程序，就会发现当对象恢复以后，s是null，而i是零。\n若从一个Externalizable对象继承，通常需要调用writeExternal()和readExternal()的基础类版本，以便正确地保存和恢复基础类组件。\n所以为了让一切正常运作起来，千万不可仅在writeExternal()方法执行期间写入对象的重要数据（没有默认的行为可用来为一个Externalizable对象写入所有成员对象）的，而是必须在readExternal()方法中也恢复那些数据。初次操作时可能会有些不习惯，因为Externalizable对象的默认构建行为使其看起来似乎正在进行某种存储与恢复操作。但实情并非如此。\n总结：\n对象继承 Externalizable 实现序列化，需要注意 writeExternal()和readExternal() 方法， 序列化时：在 writeExternal() 方法 写入对象的重要的想恢复的数据。 反序列化时： 会先调用方法的 公开无参构造方法（不公开会报错），在readExternal()方法中恢复那些序列化时的out的数据。\ntransient（临时）关键字 控制序列化过程时，可能有一个特定的子对象不愿让Java的序列化机制自动保存与恢复。一般地，若那个子对象包含了不想序列化的敏感信息（如密码），就会面临这种情况。即使那种信息在对象中具有“private”（私有）属性，但一旦经序列化处理，人们就可以通过读取一个文件，或者拦截网络传输得到它。\n为防止对象的敏感部分被序列化，一个办法是将自己的类实现为Externalizable，就象前面展示的那样。这样一来，没有任何东西可以自动序列化，只能在writeExternal()明确序列化那些需要的部分。\n然而，若操作的是一个Serializable对象，所有序列化操作都会自动进行。为解决这个问题，可以用transient（临时）逐个字段地关闭序列化，它的意思是“不要麻烦你（指自动机制）保存或恢复它了——我会自己处理的”。\n例如，假设一个Login对象包含了与一个特定的登录会话有关的信息。校验登录的合法性时，一般都想将数据保存下来，但不包括密码。为做到这一点，最简单的办法是实现Serializable，并将password字段设为transient。\n可以看到，其中的date和username字段保持原始状态（未设成transient），所以会自动序列化。然而，password被设为transient，所以不会自动保存到磁盘；另外，自动序列化机制也不会作恢复它的尝试。输出如下：\n一旦对象恢复成原来的样子，password字段就会变成null。注意必须用toString()检查password是否为null，因为若用过载的“+”运算符来装配一个String对象，而且那个运算符遇到一个null句柄，就会造成一个名为NullPointerException的违例（新版Java可能会提供避免这个问题的代码）。\n我们也发现date字段被保存到磁盘，并从磁盘恢复，没有重新生成。\n由于Externalizable对象默认时不保存它的任何字段，所以transient关键字只能伴随Serializable使用。\nExternalizable 的替代方法 若不是特别在意要实现Externalizable接口，还有另一种方法可供选用。我们可以实现Serializable接口，并添加（注意是“添加”，而非“覆盖”或者“实现”）名为writeObject()和readObject()的方法。一旦对象被序列化或者重新装配，就会分别调用那两个方法。也就是说，只要提供了这两个方法，就会优先使用它们，而不考虑默认的序列化机制。 这些方法必须含有下列准确的签名：\nprivate void writeObject(ObjectOutputStream stream)\rthrows IOException;\rprivate void readObject(ObjectInputStream stream)\rthrows IOException, ClassNotFoundException 从设计的角度出发，情况变得有些扑朔迷离。首先，大家可能认为这些方法不属于基础类或者Serializable接口的一部分，它们应该在自己的接口中得到定义。但请注意它们被定义成“private”，这意味着它们只能由这个类的其他成员调用。然而，我们实际并不从这个类的其他成员中调用它们，而是由ObjectOutputStream和ObjectInputStream的writeObject()及readObject()方法来调用我们对象的writeObject()和readObject()方法（注意我在这里用了很大的抑制力来避免使用相同的方法名——因为怕混淆）。大家可能奇怪ObjectOutputStream和ObjectInputStream如何有权访问我们的类的private方法——只能认为这是序列化机制玩的一个把戏。\n在任何情况下，接口中的定义的任何东西都会自动具有public属性，所以假若writeObject()和readObject()必须为private，那么它们不能成为接口（interface）的一部分。但由于我们准确地加上了签名，所以最终的效果实际与实现一个接口是相同的。\n看起来似乎我们调用ObjectOutputStream.writeObject()的时候，我们传递给它的Serializable对象似乎会被检查是否实现了自己的writeObject()。若答案是肯定的是，便会跳过常规的序列化过程，并调用writeObject()。readObject()也会遇到同样的情况。\n还存在另一个问题。在我们的writeObject()内部，可以调用defaultWriteObject()，从而决定采取默认的writeObject()行动。类似地，在readObject()内部，可以调用defaultReadObject()。下面这个简单的例子演示了如何对一个Serializable对象的存储与恢复进行控制：\n//: SerialCtl.java\r// Controlling serialization by adding your own\r// writeObject() and readObject() methods.\rimport java.io.*;\rpublic class SerialCtl implements Serializable {\rString a;\rtransient String b;\rpublic SerialCtl(String aa, String bb) {\ra = \u0026#34;Not Transient: \u0026#34; + aa;\rb = \u0026#34;Transient: \u0026#34; + bb;\r}\rpublic String toString() {\rreturn a + \u0026#34;\\n\u0026#34; + b;\r}\rprivate void writeObject(ObjectOutputStream stream)\rthrows IOException {\rstream.defaultWriteObject();\rstream.writeObject(b);\r}\rprivate void readObject(ObjectInputStream stream)\rthrows IOException, ClassNotFoundException {\rstream.defaultReadObject();\rb = (String)stream.readObject();\r}\rpublic static void main(String[] args) {\rSerialCtl sc = new SerialCtl(\u0026#34;Test1\u0026#34;, \u0026#34;Test2\u0026#34;);\rSystem.out.println(\u0026#34;Before:\\n\u0026#34; + sc);\rByteArrayOutputStream buf = new ByteArrayOutputStream();\rtry {\rObjectOutputStream o =\rnew ObjectOutputStream(buf);\ro.writeObject(sc);\r// Now get it back:\rObjectInputStream in =\rnew ObjectInputStream(\rnew ByteArrayInputStream(\rbuf.toByteArray()));\rSerialCtl sc2 = (SerialCtl)in.readObject();\rSystem.out.println(\u0026#34;After:\\n\u0026#34; + sc2);\r} catch(Exception e) {\re.printStackTrace();\r}\r}\r} ///:~ 在这个例子中，一个String保持原始状态，其他设为transient（临时），以便证明非临时字段会被defaultWriteObject()方法自动保存，而transient字段必须在程序中明确保存和恢复。字段是在构建器内部初始化的，而不是在定义的时候，这证明了它们不会在重新装配的时候被某些自动化机制初始化。\n若准备通过默认机制写入对象的非transient部分，那么必须调用defaultWriteObject()，令其作为writeObject()中的第一个操作；并调用defaultReadObject()，令其作为readObject()的第一个操作。这些都是不常见的调用方法。举个例子来说，当我们为一个ObjectOutputStream调用defaultWriteObject()的时候，而且没有为其传递参数，就需要采取这种操作，使其知道对象的句柄以及如何写入所有非transient的部分。这种做法非常不便。\ntransient对象的存储与恢复采用了我们更熟悉的代码。现在考虑一下会发生一些什么事情。在main()中会创建一个SerialCtl对象，随后会序列化到一个ObjectOutputStream里（注意这种情况下使用的是一个缓冲区，而非文件——与ObjectOutputStream完全一致）。正式的序列化操作是在下面这行代码里发生的：\no.writeObject(sc); 其中，writeObject()方法必须核查sc，判断它是否有自己的writeObject()方法（不是检查它的接口——它根本就没有，也不是检查类的类型，而是利用反射方法实际搜索方法）。若答案是肯定的，就使用那个方法。类似的情况也会在readObject()上发生。或许这是解决问题唯一实际的方法，但确实显得有些古怪。\n版本问题 有时候可能想改变一个可序列化的类的版本（比如原始类的对象可能保存在数据库中）。尽管这种做法得到了支持，但一般只应在非常特殊的情况下才用它。此外，它要求操作者对背后的原理有一个比较深的认识，而我们在这里还不想达到这种深度。JDK 1.1的HTML文档对这一主题进行了非常全面的论述（可从Sun公司下载，但可能也成了Java开发包联机文档的一部分）。\n10.9.3 利用“持久性” 一个比较诱人的想法是用序列化技术保存程序的一些状态信息，从而将程序方便地恢复到以前的状态。但在具体实现以前，有些问题是必须解决的。如果两个对象都有指向第三个对象的句柄，该如何对这两个对象序列化呢？如果从两个对象序列化后的状态恢复它们，第三个对象的句柄只会出现在一个对象身上吗？如果将这两个对象序列化成独立的文件，然后在代码的不同部分重新装配它们，又会得到什么结果呢？\n下面这个例子对上述问题进行了很好的说明：\n//: MyWorld.java import java.io.*; import java.util.*; class House implements Serializable {} class Animal implements Serializable { String name; House preferredHouse; Animal(String nm, House h) { name = nm; preferredHouse = h; } public String toString() { return name + \u0026#34;[\u0026#34; + super.toString() + \u0026#34;], \u0026#34; + preferredHouse + \u0026#34;\\n\u0026#34;; } } public class MyWorld { public static void main(String[] args) { House house = new House(); Vector animals = new Vector(); animals.addElement( new Animal(\u0026#34;Bosco the dog\u0026#34;, house)); animals.addElement( new Animal(\u0026#34;Ralph the hamster\u0026#34;, house)); animals.addElement( new Animal(\u0026#34;Fronk the cat\u0026#34;, house)); System.out.println(\u0026#34;animals: \u0026#34; + animals); try { ByteArrayOutputStream buf1 = new ByteArrayOutputStream(); ObjectOutputStream o1 = new ObjectOutputStream(buf1); o1.writeObject(animals); o1.writeObject(animals); // Write a 2nd set // Write to a different stream: ByteArrayOutputStream buf2 = new ByteArrayOutputStream(); ObjectOutputStream o2 = new ObjectOutputStream(buf2); o2.writeObject(animals); // Now get them back: ObjectInputStream in1 = new ObjectInputStream( new ByteArrayInputStream( buf1.toByteArray())); ObjectInputStream in2 = new ObjectInputStream( new ByteArrayInputStream( buf2.toByteArray())); Vector animals1 = (Vector)in1.readObject(); Vector animals2 = (Vector)in1.readObject(); Vector animals3 = (Vector)in2.readObject(); System.out.println(\u0026#34;animals1: \u0026#34; + animals1); System.out.println(\u0026#34;animals2: \u0026#34; + animals2); System.out.println(\u0026#34;animals3: \u0026#34; + animals3); } catch(Exception e) { e.printStackTrace(); } } } ///:~ animals: [Bosco the dog[com.openjfx.test.io.Animal@44c8afef], com.openjfx.test.io.House@5891e32e\r, Ralph the hamster[com.openjfx.test.io.Animal@cb0ed20], com.openjfx.test.io.House@5891e32e\r, Fronk the cat[com.openjfx.test.io.Animal@8e24743], com.openjfx.test.io.House@5891e32e\r]\ranimals1: [Bosco the dog[com.openjfx.test.io.Animal@48a242ce], com.openjfx.test.io.House@1e4a7dd4\r, Ralph the hamster[com.openjfx.test.io.Animal@4f51b3e0], com.openjfx.test.io.House@1e4a7dd4\r, Fronk the cat[com.openjfx.test.io.Animal@4b9e255], com.openjfx.test.io.House@1e4a7dd4\r]\ranimals2: [Bosco the dog[com.openjfx.test.io.Animal@48a242ce], com.openjfx.test.io.House@1e4a7dd4\r, Ralph the hamster[com.openjfx.test.io.Animal@4f51b3e0], com.openjfx.test.io.House@1e4a7dd4\r, Fronk the cat[com.openjfx.test.io.Animal@4b9e255], com.openjfx.test.io.House@1e4a7dd4\r]\ranimals3: [Bosco the dog[com.openjfx.test.io.Animal@5e57643e], com.openjfx.test.io.House@133e16fd\r, Ralph the hamster[com.openjfx.test.io.Animal@51b279c9], com.openjfx.test.io.House@133e16fd\r, Fronk the cat[com.openjfx.test.io.Animal@1ad282e0], com.openjfx.test.io.House@133e16fd\r] 这里一件有趣的事情是也许是能针对一个字节数组应用对象的序列化，从而实现对任何Serializable（可序列化）对象的一个“全面复制”（全面复制意味着复制的是整个对象网，而不仅是基本对象和它的句柄）。复制问题将在第12章进行全面讲述。\nAnimal对象包含了类型为House的字段。在main()中，会创建这些Animal的一个Vector，并对其序列化两次，分别送入两个不同的数据流内。这些数据重新装配并打印出来后，可看到下面这样的结果（对象在每次运行时都会处在不同的内存位置，所以每次运行的结果有区别）：\n当然，我们希望装配好的对象有与原来不同的地址。但注意在animals1和animals2中出现了相同的地址，其中包括共享的、对House对象的引用。在另一方面，当animals3恢复以后，系统没有办法知道另一个流内的对象是第一个流内对象的化身，所以会产生一个完全不同的对象网。\n只要将所有东西都序列化到单独一个数据流里，就能恢复获得与以前写入时完全一样的对象网，不会不慎造成对象的重复。当然，在写第一个和最后一个对象的时间之间，可改变对象的状态，但那必须由我们明确采取操作——序列化时，对象会采用它们当时的任何状态（包括它们与其他对象的连接关系）写入。\n也就是说一个队形在数据流里系列化两次，会恢复为一个对象，不同的流里会复制对象\n若想保存系统状态，最安全的做法是当作一种“微观”操作序列化。如果序列化了某些东西，再去做其他一些工作，再来序列化更多的东西，以此类推，那么最终将无法安全地保存系统状态。相反，应将构成系统状态的所有对象都置入单个集合内，并在一次操作里完成那个集合的写入。这样一来，同样只需一次方法调用，即可成功恢复之。\n下面这个例子是一套假想的计算机辅助设计（CAD）系统，对这一方法进行了很好的演示。此外，它还为我们引入了static字段的问题——如留意联机文档，就会发现Class是“Serializable”（可序列化）的，所以只需简单地序列化Class对象，就能实现static字段的保存。这无论如何都是一种明智的做法。\n//: CADState.java // Saving and restoring the state of a // pretend CAD system. import java.io.*; import java.util.*; abstract class Shape implements Serializable { public static final int RED = 1, BLUE = 2, GREEN = 3; private int xPos, yPos, dimension; private static Random r = new Random(); private static int counter = 0; abstract public void setColor(int newColor); abstract public int getColor(); public Shape(int xVal, int yVal, int dim) { xPos = xVal; yPos = yVal; dimension = dim; } public String toString() { return getClass().toString() + \u0026#34; color[\u0026#34; + getColor() + \u0026#34;] xPos[\u0026#34; + xPos + \u0026#34;] yPos[\u0026#34; + yPos + \u0026#34;] dim[\u0026#34; + dimension + \u0026#34;]\\n\u0026#34;; } public static Shape randomFactory() { int xVal = r.nextInt() % 100; int yVal = r.nextInt() % 100; int dim = r.nextInt() % 100; switch(counter++ % 3) { default: case 0: return new Circle(xVal, yVal, dim); case 1: return new Square(xVal, yVal, dim); case 2: return new Line(xVal, yVal, dim); } } } class Circle extends Shape { private static int color = RED; public Circle(int xVal, int yVal, int dim) { super(xVal, yVal, dim); } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } class Square extends Shape { private static int color; public Square(int xVal, int yVal, int dim) { super(xVal, yVal, dim); color = RED; } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } class Line extends Shape { private static int color = RED; public static void serializeStaticState(ObjectOutputStream os) throws IOException { os.writeInt(color); } public static void deserializeStaticState(ObjectInputStream os) throws IOException { color = os.readInt(); } public Line(int xVal, int yVal, int dim) { super(xVal, yVal, dim); } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } public class CADState { public static void main(String[] args) throws Exception { Vector shapeTypes, shapes; if(args.length == 0) { shapeTypes = new Vector(); shapes = new Vector(); // Add handles to the class objects: shapeTypes.addElement(Circle.class); shapeTypes.addElement(Square.class); shapeTypes.addElement(Line.class); // Make some shapes: for(int i = 0; i \u0026lt; 10; i++) shapes.addElement(Shape.randomFactory()); // Set all the static colors to GREEN: for(int i = 0; i \u0026lt; 10; i++) ((Shape)shapes.elementAt(i)) .setColor(Shape.GREEN); // Save the state vector: ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\u0026#34;CADState.out\u0026#34;)); out.writeObject(shapeTypes); Line.serializeStaticState(out); out.writeObject(shapes); } else { // There\u0026#39;s a command-line argument ObjectInputStream in = new ObjectInputStream( new FileInputStream(args[0])); // Read in the same order they were written: shapeTypes = (Vector)in.readObject(); Line.deserializeStaticState(in); shapes = (Vector)in.readObject(); } // Display the shapes: System.out.println(shapes); } } ///:~ Shape（几何形状）类“实现了可序列化”（implements Serializable），所以从Shape继承的任何东西也都会自动“可序列化”。每个Shape都包含了数据，而且每个衍生的Shape类都包含了一个特殊的static字段，用于决定所有那些类型的Shape的颜色（如将一个static字段置入基础类，结果只会产生一个字段，因为static字段未在衍生类中复制）。可对基础类中的方法进行覆盖处理，以便为不同的类型设置颜色（static方法不会动态绑定，所以这些都是普通的方法）。每次调用 randomFactory()方法时，它都会创建一个不同的Shape（Shape值采用随机值）。\nCircle（圆）和Square（矩形）属于对Shape的直接扩展；唯一的差别是Circle在定义时会初始化颜色，而Square在构建器中初始化。Line（直线）的问题将留到以后讨论。\n在main()中，一个Vector用于容纳Class对象，而另一个用于容纳形状。若不提供相应的命令行参数，就会创建shapeTypes Vector，并添加Class对象。然后创建shapes Vector，并添加Shape对象。接下来，所有static color值都会设成GREEN，而且所有东西都会序列化到文件CADState.out。\n若提供了一个命令行参数（假设CADState.out），便会打开那个文件，并用它恢复程序的状态。无论在哪种情况下，结果产生的Shape的Vector都会打印出来。下面列出它某一次运行的结果：\n\u0026gt;java CADState\r[class Circle color[3] xPos[-51] yPos[-99] dim[38]\r, class Square color[3] xPos[2] yPos[61] dim[-46]\r, class Line color[3] xPos[51] yPos[73] dim[64]\r, class Circle color[3] xPos[-70] yPos[1] dim[16]\r, class Square color[3] xPos[3] yPos[94] dim[-36]\r, class Line color[3] xPos[-84] yPos[-21] dim[-35]\r, class Circle color[3] xPos[-75] yPos[-43] dim[22]\r, class Square color[3] xPos[81] yPos[30] dim[-45]\r, class Line color[3] xPos[-29] yPos[92] dim[17]\r, class Circle color[3] xPos[17] yPos[90] dim[-76]\r]\r\u0026gt;java CADState CADState.out\r[class Circle color[1] xPos[-51] yPos[-99] dim[38]\r, class Square color[0] xPos[2] yPos[61] dim[-46]\r, class Line color[3] xPos[51] yPos[73] dim[64]\r, class Circle color[1] xPos[-70] yPos[1] dim[16]\r, class Square color[0] xPos[3] yPos[94] dim[-36]\r, class Line color[3] xPos[-84] yPos[-21] dim[-35]\r, class Circle color[1] xPos[-75] yPos[-43] dim[22]\r, class Square color[0] xPos[81] yPos[30] dim[-45]\r, class Line color[3] xPos[-29] yPos[92] dim[17]\r, class Circle color[1] xPos[17] yPos[90] dim[-76]\r] 从中可以看出，xPos，yPos以及dim的值都已成功保存和恢复出来。但在获取static信息时却出现了问题。所有“3”都已进入，但没有正常地出来。Circle有一个1值（定义为RED），而Square有一个0值（记住，它们是在构建器里初始化的）。看上去似乎static根本没有得到初始化！实情正是如此——尽管类Class是“可以序列化的”，但却不能按我们希望的工作。所以假如想序列化static值，必须亲自动手。\n这正是Line中的serializeStaticState()和deserializeStaticState()两个static方法的用途。可以看到，这两个方法都是作为存储和恢复进程的一部分明确调用的（注意写入序列化文件和从中读回的顺序不能改变）。所以为了使CADState.java正确运行起来，必须采用下述三种方法之一：\n(1) 为几何形状添加一个serializeStaticState()和deserializeStaticState()。 (2) 删除Vector shapeTypes以及与之有关的所有代码 (3) 在几何形状内添加对新序列化和撤消序列化静态方法的调用 要注意的另一个问题是安全，因为序列化处理也会将private数据保存下来。若有需要保密的字段，应将其标记成transient。但在这之后，必须设计一种安全的信息保存方法。这样一来，一旦需要恢复，就可以重设那些private变量。\n10.10 总结 Java IO流库能满足我们的许多基本要求：可以通过控制台、文件、内存块甚至因特网（参见第15章）进行读写。可以创建新的输入和输出对象类型（通过从InputStream和OutputStream继承）。向一个本来预期为收到字串的方法传递一个对象时，由于Java已限制了“自动类型转换”，所以会自动调用toString()方法。而我们可以重新定义这个toString()，扩展一个数据流能接纳的对象种类。\n在IO数据流库的联机文档和设计过程中，仍有些问题没有解决。比如当我们打开一个文件以便输出时，完全可以指定一旦有人试图覆盖该文件就“掷”出一个违例——有的编程系统允许我们自行指定想打开一个输出文件，但唯一的前提是它尚不存在。但在Java中，似乎必须用一个File对象来判断某个文件是否存在，因为假如将其作为FileOutputStream或者FileWriter打开，那么肯定会被覆盖。若同时指定文件和目录路径，File类设计上的一个缺陷就会暴露出来，因为它会说“不要试图在单个类里做太多的事情”！ IO流库易使我们混淆一些概念。它确实能做许多事情，而且也可以移植。但假如假如事先没有吃透装饰器方案的概念，那么所有的设计都多少带有一点盲目性质。所以不管学它还是教它，都要特别花一些功夫才行。而且它并不完整：没有提供对输出格式化的支持，而其他几乎所有语言的IO包都提供了这方面的支持（这一点没有在Java 1.1里得以纠正，它完全错失了改变库设计方案的机会，反而增添了更特殊的一些情况，使复杂程度进一步提高）。Java 1.1转到那些尚未替换的IO库，而不是增加新库。而且库的设计人员似乎没有很好地指出哪些特性是不赞成的，哪些是首选的，造成库设计中经常都会出现一些令人恼火的反对消息。\n然而，一旦掌握了装饰器方案，并开始在一些较为灵活的环境使用库，就会认识到这种设计的好处。到那个时候，为此多付出的代码行应该不至于使你觉得太生气。\n10.11 练习 (1) 打开一个文本文件，每次读取一行内容。将每行作为一个String读入，并将那个String对象置入一个Vector里。按相反的顺序打印出Vector中的所有行。\n(2) 修改练习1，使读取那个文件的名字作为一个命令行参数提供。\n(3) 修改练习2，又打开一个文本文件，以便将文字写入其中。将Vector中的行随同行号一起写入文件。\n(4) 修改练习2，强迫Vector中的所有行都变成大写形式，将结果发给System.out。\n(5) 修改练习2，在文件中查找指定的单词。打印出包含了欲找单词的所有文本行。\n(6) 在Blips.java中复制文件，将其重命名为BlipCheck.java。然后将类Blip2重命名为BlipCheck（在进程中将其标记为public）。删除文件中的//!记号，并执行程序。接下来，将BlipCheck的默认构建器变成注释信息。运行它，并解释为什么仍然能够工作。\n(7) 在Blip3.java中，将接在“You must do this:”字样后的两行变成注释，然后运行程序。解释得到的结果为什么会与执行了那两行代码不同。\n(8) 转换SortedWordCount.java程序，以便使用Java 1.1 IO流。\n(9) 根据本章正文的说明修改程序CADState.java。\n(10) 在第7章（中间部分）找到GreenhouseControls.java示例，它应该由三个文件构成。在GreenhouseControls.java中，Restart()内部类有一个硬编码的事件集。请修改这个程序，使其能从一个文本文件里动态读取事件以及它们的相关时间。\n"},{"id":137,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC11%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/","title":"Thinking in Java 第11章 运行期类型鉴定","parent":"Thinking In Java","content":" 第11章 运行期类型鉴定 总结:\n其实 thinking in java 虽然将 RTTI 和 反射分开讲解，其实本质上我们看Java语言提供的功能：\n利用 instanceof 来在运行期检出 对象 的类型 利用 Class.forName() 方法去获得一个未 import 对象的 Class 类 利用 java.lang.reflect.* 来获得对象的 对象信息（接口、属性、方法、修饰符） 本质上是在说明一件事：Java 提供了在运行期 完整且成系统的 创建和利用类和对象。能了解这一点并能利用使程序在运行的过程中能正确的动态的构建对象创建对象就可以了。 另需要知道的一件事是：想在运行期搞这些事情，离不开 Class 对象。因为 Java 是用 Class 对象 表示 在运行期 的 类型信息 .class 文件 ==》 JVM Class 对象 ==》 JVM new()对象 运行期类型鉴定（RTTI）的概念初看非常简单——手上只有基础类型的一个句柄时，利用它判断一个对象的正确类型。 然而，对RTTI的需要暴露出了面向对象设计许多有趣（而且经常是令人困惑的）的问题，并把程序的构造问题正式摆上了桌面。 本章将讨论如何利用Java在运行期间查找对象和类信息。这主要采取两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可在运行期独立查找类信息。首先讨论“传统”的RTTI，再讨论反射问题。\n11.1 对RTTI的需要 请考虑下面这个熟悉的类结构例子，它利用了多形性。常规类型是Shape类，而特别衍生出来的类型是Circle，Square和Triangle。\n这是一个典型的类结构示意图，基础类位于顶部，衍生类向下延展。面向对象编程的基本目标是用大量代码控制基础类型（这里是Shape）的句柄，所以假如决定添加一个新类（比如Rhomboid，从Shape衍生），从而对程序进行扩展，那么不会影响到原来的代码。在这个例子中，Shape接口中的动态绑定方法是draw()，所以客户程序员要做的是通过一个普通Shape句柄调用draw()。draw()在所有衍生类里都会被覆盖。而且由于它是一个动态绑定方法，所以即使通过一个普通的Shape句柄调用它，也有表现出正确的行为。这正是多形性的作用。\n所以，我们一般创建一个特定的对象（Circle，Square，或者Triangle），把它上溯造型到一个Shape（忽略对象的特殊类型），以后便在程序的剩余部分使用匿名Shape句柄。\n作为对多形性和上溯造型的一个简要回顾，可以象下面这样为上述例子编码（若执行这个程序时出现困难，请参考第3章3.1.2小节“赋值”）：\n//: Shapes.java package c11; import java.util.*; interface Shape { void draw(); } class Circle implements Shape { public void draw() { System.out.println(\u0026#34;Circle.draw()\u0026#34;); } } class Square implements Shape { public void draw() { System.out.println(\u0026#34;Square.draw()\u0026#34;); } } class Triangle implements Shape { public void draw() { System.out.println(\u0026#34;Triangle.draw()\u0026#34;); } } public class Shapes { public static void main(String[] args) { Vector s = new Vector(); s.addElement(new Circle()); s.addElement(new Square()); s.addElement(new Triangle()); Enumeration e = s.elements(); while(e.hasMoreElements()) ((Shape)e.nextElement()).draw(); } } ///:~ 基础类可编码成一个interface（接口）、一个abstract（抽象）类或者一个普通类。由于Shape没有真正的成员（亦即有定义的成员），而且并不在意我们创建了一个纯粹的Shape对象，所以最适合和最灵活的表达方式便是用一个接口。而且由于不必设置所有那些abstract关键字，所以整个代码也显得更为清爽。\n每个衍生类都覆盖了基础类draw方法，所以具有不同的行为。在main()中创建了特定类型的Shape，然后将其添加到一个Vector。这里正是上溯造型发生的地方，因为Vector只容纳了对象。由于Java中的所有东西（除基本数据类型外）都是对象，所以Vector也能容纳Shape对象。但在上溯造型至Object的过程中，任何特殊的信息都会丢失，其中甚至包括对象是几何形状这一事实。对Vector来说，它们只是Object。\n用nextElement()将一个元素从Vector提取出来的时候，情况变得稍微有些复杂。由于Vector只容纳Object，所以nextElement()会自然地产生一个Object句柄。但我们知道它实际是个Shape句柄，而且希望将Shape消息发给那个对象。所以需要用传统的\u0026quot;(Shape)\u0026ldquo;方式造型成一个Shape。这是RTTI最基本的形式，因为在Java中，所有造型都会在运行期间得到检查，以确保其正确性。那正是RTTI的意义所在：在运行期，对象的类型会得到鉴定。\n在目前这种情况下，RTTI造型只实现了一部分：Object造型成Shape，而不是造型成Circle，Square或者Triangle。那是由于我们目前能够肯定的唯一事实就是Vector里充斥着几何形状，而不知它们的具体类别。在编译期间，我们肯定的依据是我们自己的规则；而在编译期间，却是通过造型来肯定这一点。\n现在的局面会由多形性控制，而且会为Shape调用适当的方法，以便判断句柄到底是提供Circle，Square，还是提供给Triangle。而且在一般情况下，必须保证采用多形性方案。因为我们希望自己的代码尽可能少知道一些与对象的具体类型有关的情况，只将注意力放在某一类对象（这里是Shape）的常规信息上。只有这样，我们的代码才更易实现、理解以及修改。所以说多形性是面向对象程序设计的一个常规目标。\n然而，若碰到一个特殊的程序设计问题，只有在知道常规句柄的确切类型后，才能最容易地解决这个问题，这个时候又该怎么办呢？举个例子来说，我们有时候想让自己的用户将某一具体类型的几何形状（如三角形）全都变成紫色，以便突出显示它们，并快速找出这一类型的所有形状。此时便要用到RTTI技术，用它查询某个Shape句柄引用的准确类型是什么。\n此时便要用到RTTI技术，用它查询某个Shape句柄引用的准确类型是什么。\n11.1.1 Class对象 为理解RTTI在Java里如何工作，首先必须了解类型信息在运行期是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类有关的信息（有时也把它叫作“元类”）。事实上，我们要用Class对象创建属于某个类的全部“常规”或“普通”对象。为理解RTTI在Java里如何工作，首先必须了解类型信息在运行期是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类有关的信息（有时也把它叫作“元类”）。事实上，我们要用Class对象创建属于某个类的全部“常规”或“普通”对象。\n对于作为程序一部分的每个类，它们都有一个Class对象。换言之，每次写一个新类时，同时也会创建一个Class对象（更恰当地说，是保存在一个完全同名的.class文件中）。在运行期，一旦我们想生成那个类的一个对象，用于执行程序的Java虚拟机（JVM）首先就会检查那个类型的Class对象是否已经载入。若尚未载入，JVM就会查找同名的.class文件，并将其载入。所以Java程序启动时并不是完全载入的，这一点与许多传统语言都不同。 一旦那个类型的Class对象进入内存，就用它创建那一类型的所有对象。\n若这种说法多少让你产生了一点儿迷惑，或者并没有真正理解它，下面这个示范程序或许能提供进一步的帮助：\n//: SweetShop.java // Examination of the way the class loader works class Candy { static { System.out.println(\u0026#34;Loading Candy\u0026#34;); } } class Gum { static { System.out.println(\u0026#34;Loading Gum\u0026#34;); } } class Cookie { static { System.out.println(\u0026#34;Loading Cookie\u0026#34;); } } public class SweetShop { public static void main(String[] args) { System.out.println(\u0026#34;inside main\u0026#34;); new Candy(); System.out.println(\u0026#34;After creating Candy\u0026#34;); try { Class.forName(\u0026#34;Gum\u0026#34;); } catch(ClassNotFoundException e) { e.printStackTrace(); } System.out.println( \u0026#34;After Class.forName(\\\u0026#34;Gum\\\u0026#34;)\u0026#34;); new Cookie(); System.out.println(\u0026#34;After creating Cookie\u0026#34;); } } ///:~ 对每个类来说（Candy，Gum和Cookie），它们都有一个static从句，用于在类首次载入时执行。相应的信息会打印出来，告诉我们载入是什么时候进行的。在main()中，对象的创建代码位于打印语句之间，以便侦测载入时间。 特别有趣的一行是：\nClass.forName(\u0026#34;Gum\u0026#34;); 该方法是Class（即全部Class所从属的）的一个static成员。而Class对象和其他任何对象都是类似的，所以能够获取和控制它的一个句柄（装载模块就是干这件事的）。为获得Class的一个句柄，一个办法是使用forName()。它的作用是取得包含了目标类文本名字的一个String（注意拼写和大小写）。最后返回的是一个Class句柄。\n该程序在某个JVM中的输出如下：\ninside main\rLoading Candy\rAfter creating Candy\rLoading Gum\rAfter Class.forName(\u0026#34;Gum\u0026#34;)\rLoading Cookie\rAfter creating Cookie 可以看到，每个Class只有在它需要的时候才会载入，而static初始化工作是在类载入时执行的。 非常有趣的是，另一个JVM的输出变成了另一个样子：\nLoading Candy\rLoading Cookie\rinside main\rAfter creating Candy\rLoading Gum\rAfter Class.forName(\u0026#34;Gum\u0026#34;)\rAfter creating Cookie 看来JVM通过检查main()中的代码，已经预测到了对Candy和Cookie的需要，但却看不到Gum，因为它是通过对forName()的一个调用创建的，而不是通过更典型的new调用。尽管这个JVM也达到了我们希望的效果，因为确实会在我们需要之前载入那些类，但却不能肯定这儿展示的行为百分之百正确。\n类标记 在Java 1.1中，可以采用第二种方式来产生Class对象的句柄：使用“类标记”。对上述程序来说，看起来就象下面这样： Gum.class; 这样做不仅更加简单，而且更安全，因为它会在编译期间得到检查。由于它取消了对方法调用的需要，所以执行的效率也会更高。 类标记不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。除此以外，针对每种基本数据类型的封装器类，它还存在一个名为TYPE的标准字段。TYPE字段的作用是为相关的基本数据类型产生Class对象的一个句柄，如下所示：\nheader 1 header 2 boolean.class Boolean.TYPE char .class Character.TYPE byte .class Byte.TYPE short .class Short.TYPE int .class Integer.TYPE long .class Long.TYPE float .class Float.TYPE double .class Double.TYPE void .class Void.TYPE 11.1.2 造型前的检查 迄今为止，我们已知的RTTI形式包括：\n(1) 经典造型，如\u0026rdquo;(Shape)\u0026quot;，它用RTTI确保造型的正确性，并在遇到一个失败的造型后产生一个ClassCastException违例。 (2) 代表对象类型的Class对象。可查询Class对象，获取有用的运行期资料。 在C++中，经典的\u0026quot;(Shape)\u0026ldquo;造型并不执行RTTI。它只是简单地告诉编译器将对象当作新类型处理。而Java要执行类型检查，这通常叫作“类型安全”的下溯造型。之所以叫“下溯造型”，是由于类分层结构的历史排列方式造成的。若将一个Circle（圆）造型到一个Shape（几何形状），就叫做上溯造型，因为圆只是几何形状的一个子集。反之，若将Shape造型至Circle，就叫做下溯造型。然而，尽管我们明确知道Circle也是一个Shape，所以编译器能够自动上溯造型，但却不能保证一个Shape肯定是一个Circle。因此，编译器不允许自动下溯造型，除非明确指定一次这样的造型。\nRTTI在Java中存在三种形式。关键字instanceof告诉我们对象是不是一个特定类型的实例（Instance即“实例”）。它会返回一个布尔值，以便以问题的形式使用，就象下面这样：\nif(x instanceof Dog)\r((Dog)x).bark(); 将x造型至一个Dog前，上面的if语句会检查对象x是否从属于Dog类。进行造型前，如果没有其他信息可以告诉自己对象的类型，那么instanceof的使用是非常重要的——否则会得到一个ClassCastException违例。\n我们最一般的做法是查找一种类型（比如要变成紫色的三角形），但下面这个程序却演示了如何用instanceof标记出所有对象。\n//: PetCount.java // Using instanceof package c11.petcount; import java.util.*; class Pet {} class Dog extends Pet {} class Pug extends Dog {} class Cat extends Pet {} class Rodent extends Pet {} class Gerbil extends Rodent {} class Hamster extends Rodent {} class Counter { int i; } public class PetCount { static String[] typenames = { \u0026#34;Pet\u0026#34;, \u0026#34;Dog\u0026#34;, \u0026#34;Pug\u0026#34;, \u0026#34;Cat\u0026#34;, \u0026#34;Rodent\u0026#34;, \u0026#34;Gerbil\u0026#34;, \u0026#34;Hamster\u0026#34;, }; public static void main(String[] args) { Vector pets = new Vector(); try { Class[] petTypes = { Class.forName(\u0026#34;c11.petcount.Dog\u0026#34;), Class.forName(\u0026#34;c11.petcount.Pug\u0026#34;), Class.forName(\u0026#34;c11.petcount.Cat\u0026#34;), Class.forName(\u0026#34;c11.petcount.Rodent\u0026#34;), Class.forName(\u0026#34;c11.petcount.Gerbil\u0026#34;), Class.forName(\u0026#34;c11.petcount.Hamster\u0026#34;), }; for(int i = 0; i \u0026lt; 15; i++) pets.addElement( petTypes[ (int)(Math.random()*petTypes.length)] .newInstance()); } catch(InstantiationException e) {} catch(IllegalAccessException e) {} catch(ClassNotFoundException e) {} Hashtable h = new Hashtable(); for(int i = 0; i \u0026lt; typenames.length; i++) h.put(typenames[i], new Counter()); for(int i = 0; i \u0026lt; pets.size(); i++) { Object o = pets.elementAt(i); if(o instanceof Pet) ((Counter)h.get(\u0026#34;Pet\u0026#34;)).i++; if(o instanceof Dog) ((Counter)h.get(\u0026#34;Dog\u0026#34;)).i++; if(o instanceof Pug) ((Counter)h.get(\u0026#34;Pug\u0026#34;)).i++; if(o instanceof Cat) ((Counter)h.get(\u0026#34;Cat\u0026#34;)).i++; if(o instanceof Rodent) ((Counter)h.get(\u0026#34;Rodent\u0026#34;)).i++; if(o instanceof Gerbil) ((Counter)h.get(\u0026#34;Gerbil\u0026#34;)).i++; if(o instanceof Hamster) ((Counter)h.get(\u0026#34;Hamster\u0026#34;)).i++; } for(int i = 0; i \u0026lt; pets.size(); i++) System.out.println( pets.elementAt(i).getClass().toString()); for(int i = 0; i \u0026lt; typenames.length; i++) System.out.println( typenames[i] + \u0026#34; quantity: \u0026#34; + ((Counter)h.get(typenames[i])).i); } } ///:~ 在Java 1.0中，对instanceof有一个比较小的限制：只可将其与一个已命名的类型比较，不能同Class对象作对比。在上述例子中，大家可能觉得将所有那些instanceof表达式写出来是件很麻烦的事情。实际情况正是这样。但在Java 1.0中，没有办法让这一工作自动进行——不能创建Class的一个Vector，再将其与之比较。大家最终会意识到，如编写了数量众多的instanceof表达式，整个设计都可能出现问题。\n当然，这个例子只是一个构想——最好在每个类型里添加一个static数据成员，然后在构建器中令其增值，以便跟踪计数。编写程序时，大家可能想象自己拥有类的源码控制权，能够自由改动它。但由于实际情况并非总是这样，所以RTTI显得特别方便。\n使用类标记 PetCount.java示例可用Java 1.1的类标记重写一遍。得到的结果显得更加明确易懂：\n//: PetCount2.java // Using Java 1.1 class literals package c11.petcount2; import java.util.*; class Pet {} class Dog extends Pet {} class Pug extends Dog {} class Cat extends Pet {} class Rodent extends Pet {} class Gerbil extends Rodent {} class Hamster extends Rodent {} class Counter { int i; } public class PetCount2 { public static void main(String[] args) { Vector pets = new Vector(); Class[] petTypes = { // Class literals work in Java 1.1+ only: Pet.class, Dog.class, Pug.class, Cat.class, Rodent.class, Gerbil.class, Hamster.class, }; try { for(int i = 0; i \u0026lt; 15; i++) { // Offset by one to eliminate Pet.class: int rnd = 1 + (int)( Math.random() * (petTypes.length - 1)); pets.addElement( petTypes[rnd].newInstance()); } } catch(InstantiationException e) {} catch(IllegalAccessException e) {} Hashtable h = new Hashtable(); for(int i = 0; i \u0026lt; petTypes.length; i++) h.put(petTypes[i].toString(), new Counter()); for(int i = 0; i \u0026lt; pets.size(); i++) { Object o = pets.elementAt(i); if(o instanceof Pet) ((Counter)h.get( \u0026#34;class c11.petcount2.Pet\u0026#34;)).i++; if(o instanceof Dog) ((Counter)h.get( \u0026#34;class c11.petcount2.Dog\u0026#34;)).i++; if(o instanceof Pug) ((Counter)h.get( \u0026#34;class c11.petcount2.Pug\u0026#34;)).i++; if(o instanceof Cat) ((Counter)h.get( \u0026#34;class c11.petcount2.Cat\u0026#34;)).i++; if(o instanceof Rodent) ((Counter)h.get( \u0026#34;class c11.petcount2.Rodent\u0026#34;)).i++; if(o instanceof Gerbil) ((Counter)h.get( \u0026#34;class c11.petcount2.Gerbil\u0026#34;)).i++; if(o instanceof Hamster) ((Counter)h.get( \u0026#34;class c11.petcount2.Hamster\u0026#34;)).i++; } for(int i = 0; i \u0026lt; pets.size(); i++) System.out.println( pets.elementAt(i).getClass().toString()); Enumeration keys = h.keys(); while(keys.hasMoreElements()) { String nm = (String)keys.nextElement(); Counter cnt = (Counter)h.get(nm); System.out.println( nm.substring(nm.lastIndexOf(\u0026#39;.\u0026#39;) + 1) + \u0026#34; quantity: \u0026#34; + cnt.i); } } } ///:~ 在这里，typenames（类型名）数组已被删除，改为从Class对象里获取类型名称。注意为此而额外做的工作：例如，类名不是Getbil，而是c11.petcount2.Getbil，其中已包含了包的名字。也要注意系统是能够区分类和接口的。\n也可以看到，petTypes的创建模块不需要用一个try块包围起来，因为它会在编译期得到检查，不会象Class.forName()那样“掷”出任何违例。\nPet动态创建好以后，可以看到随机数字已得到了限制，位于1和petTypes.length之间，而且不包括零。那是由于零代表的是Pet.class，而且一个普通的Pet对象可能不会有人感兴趣。然而，由于Pet.class是petTypes的一部分，所以所有Pet（宠物）都会算入计数中。\n动态的instanceof Java 1.1为Class类添加了isInstance方法。利用它可以动态调用instanceof运算符。而在Java 1.0中，只能静态地调用它（就象前面指出的那样）。因此，所有那些烦人的instanceof语句都可以从PetCount例子中删去了。如下所示： //: PetCount3.java // Using Java 1.1 isInstance() package c11.petcount3; import java.util.*; class Pet {} class Dog extends Pet {} class Pug extends Dog {} class Cat extends Pet {} class Rodent extends Pet {} class Gerbil extends Rodent {} class Hamster extends Rodent {} class Counter { int i; } public class PetCount3 { public static void main(String[] args) { Vector pets = new Vector(); Class[] petTypes = { Pet.class, Dog.class, Pug.class, Cat.class, Rodent.class, Gerbil.class, Hamster.class, }; try { for(int i = 0; i \u0026lt; 15; i++) { // Offset by one to eliminate Pet.class: int rnd = 1 + (int)( Math.random() * (petTypes.length - 1)); pets.addElement( petTypes[rnd].newInstance()); } } catch(InstantiationException e) {} catch(IllegalAccessException e) {} Hashtable h = new Hashtable(); for(int i = 0; i \u0026lt; petTypes.length; i++) h.put(petTypes[i].toString(), new Counter()); for(int i = 0; i \u0026lt; pets.size(); i++) { Object o = pets.elementAt(i); // Using isInstance to eliminate individual // instanceof expressions: for (int j = 0; j \u0026lt; petTypes.length; ++j) if (petTypes[j].isInstance(o)) { String key = petTypes[j].toString(); ((Counter)h.get(key)).i++; } } for(int i = 0; i \u0026lt; pets.size(); i++) System.out.println( pets.elementAt(i).getClass().toString()); Enumeration keys = h.keys(); while(keys.hasMoreElements()) { String nm = (String)keys.nextElement(); Counter cnt = (Counter)h.get(nm); System.out.println( nm.substring(nm.lastIndexOf(\u0026#39;.\u0026#39;) + 1) + \u0026#34; quantity: \u0026#34; + cnt.i); } } } ///:~ 可以看到，Java 1.1的isInstance()方法已取消了对instanceof表达式的需要。此外，这也意味着一旦要求添加新类型宠物，只需简单地改变petTypes数组即可；毋需改动程序剩余的部分（但在使用instanceof时却是必需的）。\n11.2 RTTI语法 Java用Class对象实现自己的RTTI功能——即便我们要做的只是象造型那样的一些工作。Class类也提供了其他大量方式，以方便我们使用RTTI。\n首先必须获得指向适当Class对象的的一个句柄。就象前例演示的那样，一个办法是用一个字串以及Class.forName()方法。这是非常方便的，因为不需要那种类型的一个对象来获取Class句柄。然而，对于自己感兴趣的类型，如果已有了它的一个对象，那么为了取得Class句柄，可调用属于Object根类一部分的一个方法：getClass()。它的作用是返回一个特定的Class句柄，用来表示对象的实际类型。Class提供了几个有趣且较为有用的方法，从下例即可看出：\n//: ToyTest.java // Testing class Class interface HasBatteries {} interface Waterproof {} interface ShootsThings {} class Toy { // Comment out the following default // constructor to see // NoSuchMethodError from (*1*) Toy() {} Toy(int i) {} } class FancyToy extends Toy implements HasBatteries, Waterproof, ShootsThings { FancyToy() { super(1); } } public class ToyTest { public static void main(String[] args) { Class c = null; try { c = Class.forName(\u0026#34;FancyToy\u0026#34;); } catch(ClassNotFoundException e) {} printInfo(c); Class[] faces = c.getInterfaces(); for(int i = 0; i \u0026lt; faces.length; i++) printInfo(faces[i]); Class cy = c.getSuperclass(); Object o = null; try { // Requires default constructor: o = cy.newInstance(); // (*1*) } catch(InstantiationException e) {} catch(IllegalAccessException e) {} printInfo(o.getClass()); } static void printInfo(Class cc) { System.out.println( \u0026#34;Class name: \u0026#34; + cc.getName() + \u0026#34; is interface? [\u0026#34; + cc.isInterface() + \u0026#34;]\u0026#34;); } } ///:~ 从中可以看出，class FancyToy相当复杂，因为它从Toy中继承，并实现了HasBatteries，Waterproof以及ShootsThings的接口。在main()中创建了一个Class句柄，并用位于相应try块内的forName()初始化成FancyToy。\nClass.getInterfaces方法会返回Class对象的一个数组，用于表示包含在Class对象内的接口。 若有一个Class对象，也可以用getSuperclass()查询该对象的直接基础类是什么。当然，这种做会返回一个Class句柄，可用它作进一步的查询。这意味着在运行期的时候，完全有机会调查到对象的完整层次结构。\n若从表面看，Class的newInstance()方法似乎是克隆（clone()）一个对象的另一种手段。但两者是有区别的。利用newInstance()，我们可在没有现成对象供“克隆”的情况下新建一个对象。就象上面的程序演示的那样，当时没有Toy对象，只有cy——即y的Class对象的一个句柄。利用它可以实现“虚拟构建器”。换言之，我们表达：“尽管我不知道你的准确类型是什么，但请你无论如何都正确地创建自己。”在上述例子中，cy只是一个Class句柄，编译期间并不知道进一步的类型信息。一旦新建了一个实例后，可以得到Object句柄。但那个句柄指向一个Toy对象。当然，如果要将除Object能够接收的其他任何消息发出去，首先必须进行一些调查研究，再进行造型。除此以外，用newInstance()创建的类必须有一个默认构建器。没有办法用newInstance()创建拥有非默认构建器的对象，所以在Java 1.0中可能存在一些限制。然而，Java 1.1的“反射”API（下一节讨论）却允许我们动态地使用类里的任何构建器。\n程序中的最后一个方法是printInfo()，它取得一个Class句柄，通过getName()获得它的名字，并用interface()调查它是不是一个接口。\n该程序的输出如下：\nClass name: FancyToy is interface? [false]\rClass name: HasBatteries is interface? [true]\rClass name: Waterproof is interface? [true]\rClass name: ShootsThings is interface? [true]\rClass name: Toy is interface? [false] 所以利用Class对象，我们几乎能将一个对象的祖宗十八代都调查出来。\n总结：\n理解RTTI在Java里如何工作，首先必须了解类型信息在运行期是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类有关的信息（有时也把它叫作“元类”）。事实上，我们要用Class对象创建属于某个类的全部“常规”或“普通”对象。\n11.3 反射：运行期类信息 如果不知道一个对象的准确类型，RTTI会帮助我们调查。但却有一个限制：类型必须是在编译期间已知的，否则就不能用RTTI调查它，进而无法展开下一步的工作。换言之，编译器必须明确知道RTTI要处理的所有类。\n从表面看，这似乎并不是一个很大的限制，但假若得到的是一个不在自己程序空间内的对象的句柄，这时又会怎样呢？事实上，对象的类即使在编译期间也不可由我们的程序使用。例如，假设我们从磁盘或者网络获得一系列字节，而且被告知那些字节代表一个类。由于编译器在编译代码时并不知道那个类的情况，所以怎样才能顺利地使用这个类呢？\n在传统的程序设计环境中，出现这种情况的概率或许很小。但当我们转移到一个规模更大的编程世界中，却必须对这个问题加以高度重视。第一个要注意的是基于组件的程序设计。在这种环境下，我们用“快速应用开发”（RAD）模型来构建程序项目。RAD一般是在应用程序构建工具中内建的。这是编制程序的一种可视途径（在屏幕上以窗体的形式出现）。可将代表不同组件的图标拖曳到窗体中。随后，通过设定这些组件的属性或者值，进行正确的配置。设计期间的配置要求任何组件都是可以“例示”的（即可以自由获得它们的实例）。这些组件也要揭示出自己的一部分内容，允许程序员读取和设置各种值。此外，用于控制GUI事件的组件必须揭示出与相应的方法有关的信息，以便RAD环境帮助程序员用自己的代码覆盖这些由事件驱动的方法。“反射”提供了一种特殊的机制，可以侦测可用的方法，并产生方法名。通过Java Beans（第13章将详细介绍），Java 1.1为这种基于组件的程序设计提供了一个基础结构。\n在运行期查询类信息的另一个原动力是通过网络创建与执行位于远程系统上的对象。这就叫作“远程方法调用”（RMI），它允许Java程序（版本1.1以上）使用由多台机器发布或分布的对象。这种对象的分布可能是由多方面的原因引起的：可能要做一件计算密集型的工作，想对它进行分割，让处于空闲状态的其他机器分担部分工作，从而加快处理进度。某些情况下，可能需要将用于控制特定类型任务（比如多层客户／服务器架构中的“运作规则”）的代码放置在一台特殊的机器上，使这台机器成为对那些行动进行描述的一个通用储藏所。而且可以方便地修改这个场所，使其对系统内的所有方面产生影响（这是一种特别有用的设计思路，因为机器是独立存在的，所以能轻易修改软件！）。分布式计算也能更充分地发挥某些专用硬件的作用，它们特别擅长执行一些特定的任务——例如矩阵逆转——但对常规编程来说却显得太夸张或者太昂贵了。\n在Java 1.1中，Class类（本章前面已有详细论述）得到了扩展，可以支持“反射”的概念。针对Field，Method以及Constructor类（每个都实现了Memberinterface——成员接口），它们都新增了一个库：java.lang.reflect。这些类型的对象都是JVM在运行期创建的，用于代表未知类里对应的成员。这样便可用构建器创建新对象，用get()和set()方法读取和修改与Field对象关联的字段，以及用invoke()方法调用与Method对象关联的方法。此外，我们可调用方法getFields()，getMethods()，getConstructors()，分别返回用于表示字段、方法以及构建器的对象数组（在联机文档中，还可找到与Class类有关的更多的资料）。因此，匿名对象的类信息可在运行期被完整的揭露出来，而在编译期间不需要知道任何东西。 大家要认识的很重要的一点是“反射”并没有什么神奇的地方。通过“反射”同一个未知类型的对象打交道时，JVM只是简单地检查那个对象，并调查它从属于哪个特定的类（就象以前的RTTI那样）。但在这之后，在我们做其他任何事情之前，Class对象必须载入。因此，用于那种特定类型的.class文件必须能由JVM调用（要么在本地机器内，要么可以通过网络取得）。\n所以RTTI和“反射”之间唯一的区别就是对RTTI来说，编译器会在编译期打开和检查.class文件。换句话说，我们可以用“普通”方式调用一个对象的所有方法；但对“反射”来说，.class文件在编译期间是不可使用的，而是由运行期环境打开和检查。\n11.3.1 一个类方法提取器 很少需要直接使用反射工具；之所以在语言中提供它们，仅仅是为了支持其他Java特性，比如对象序列化（第10章介绍）、Java Beans以及RMI（本章后面介绍）。但是，我们许多时候仍然需要动态提取与一个类有关的资料。其中特别有用的工具便是一个类方法提取器。正如前面指出的那样，若检视类定义源码或者联机文档，只能看到在那个类定义中被定义或覆盖的方法，基础类那里还有大量资料拿不到。幸运的是，“反射”做到了这一点，可用它写一个简单的工具，令其自动展示整个接口。下面便是具体的程序：\n//: ShowMethods.java // Using Java 1.1 reflection to show all the // methods of a class, even if the methods are // defined in the base class. import java.lang.reflect.*; public class ShowMethods { static final String usage = \u0026#34;usage: \\n\u0026#34; + \u0026#34;ShowMethods qualified.class.name\\n\u0026#34; + \u0026#34;To show all methods in class or: \\n\u0026#34; + \u0026#34;ShowMethods qualified.class.name word\\n\u0026#34; + \u0026#34;To search for methods involving \u0026#39;word\u0026#39;\u0026#34;; public static void main(String[] args) { if(args.length \u0026lt; 1) { System.out.println(usage); System.exit(0); } try { Class c = Class.forName(args[0]); Method[] m = c.getMethods(); Constructor[] ctor = c.getConstructors(); if(args.length == 1) { for (int i = 0; i \u0026lt; m.length; i++) System.out.println(m[i].toString()); for (int i = 0; i \u0026lt; ctor.length; i++) System.out.println(ctor[i].toString()); } else { for (int i = 0; i \u0026lt; m.length; i++) if(m[i].toString() .indexOf(args[1])!= -1) System.out.println(m[i].toString()); for (int i = 0; i \u0026lt; ctor.length; i++) if(ctor[i].toString() .indexOf(args[1])!= -1) System.out.println(ctor[i].toString()); } } catch (ClassNotFoundException e) { System.out.println(\u0026#34;No such class: \u0026#34; + e); } } } ///:~ Class方法getMethods()和getConstructors()可以分别返回Method和Constructor的一个数组。每个类都提供了进一步的方法，可解析出它们所代表的方法的名字、参数以及返回值。但也可以象这样一样只使用toString()，生成一个含有完整方法签名的字串。代码剩余的部分只是用于提取命令行信息，判断特定的签名是否与我们的目标字串相符（使用indexOf()），并打印出结果。\n这里便用到了“反射”技术，因为由Class.forName()产生的结果不能在编译期间获知，所以所有方法签名信息都会在运行期间提取。若研究一下联机文档中关于“反射”（Reflection）的那部分文字，就会发现它已提供了足够多的支持，可对一个编译期完全未知的对象进行实际的设置以及发出方法调用。同样地，这也属于几乎完全不用我们操心的一个步骤——Java自己会利用这种支持，所以程序设计环境能够控制Java Beans——但它无论如何都是非常有趣的。\n一个有趣的试验是运行java ShowMehods ShowMethods。这样做可得到一个列表，其中包括一个public默认构建器，尽管我们在代码中看见并没有定义一个构建器。我们看到的是由编译器自动合成的那一个构建器。如果随之将ShowMethods设为一个非public类（即换成“友好”类），合成的默认构建器便不会在输出结果中出现。合成的默认构建器会自动获得与类一样的访问权限。 ShowMethods的输出仍然有些“不爽”。例如，下面是通过调用java ShowMethods java.lang.String得到的输出结果的一部分：\npublic boolean java.lang.String.startsWith(java.lang.String,int)\rpublic boolean java.lang.String.startsWith(java.lang.String)\rpublic boolean\rjava.lang.String.endsWith(java.lang.String) 若能去掉象java.lang这样的限定词，结果显然会更令人满意。有鉴于此，可引入上一章介绍的StreamTokenizer类，解决这个问题：\n//: ShowMethodsClean.java // ShowMethods with the qualifiers stripped // to make the results easier to read import java.lang.reflect.*; import java.io.*; public class ShowMethodsClean { static final String usage = \u0026#34;usage: \\n\u0026#34; + \u0026#34;ShowMethodsClean qualified.class.name\\n\u0026#34; + \u0026#34;To show all methods in class or: \\n\u0026#34; + \u0026#34;ShowMethodsClean qualif.class.name word\\n\u0026#34; + \u0026#34;To search for methods involving \u0026#39;word\u0026#39;\u0026#34;; public static void main(String[] args) { if(args.length \u0026lt; 1) { System.out.println(usage); System.exit(0); } try { Class c = Class.forName(args[0]); Method[] m = c.getMethods(); Constructor[] ctor = c.getConstructors(); // Convert to an array of cleaned Strings: String[] n = new String[m.length + ctor.length]; for(int i = 0; i \u0026lt; m.length; i++) { String s = m[i].toString(); n[i] = StripQualifiers.strip(s); } for(int i = 0; i \u0026lt; ctor.length; i++) { String s = ctor[i].toString(); n[i + m.length] = StripQualifiers.strip(s); } if(args.length == 1) for (int i = 0; i \u0026lt; n.length; i++) System.out.println(n[i]); else for (int i = 0; i \u0026lt; n.length; i++) if(n[i].indexOf(args[1])!= -1) System.out.println(n[i]); } catch (ClassNotFoundException e) { System.out.println(\u0026#34;No such class: \u0026#34; + e); } } } class StripQualifiers { private StreamTokenizer st; public StripQualifiers(String qualified) { st = new StreamTokenizer( new StringReader(qualified)); st.ordinaryChar(\u0026#39; \u0026#39;); // Keep the spaces } public String getNext() { String s = null; try { if(st.nextToken() != StreamTokenizer.TT_EOF) { switch(st.ttype) { case StreamTokenizer.TT_EOL: s = null; break; case StreamTokenizer.TT_NUMBER: s = Double.toString(st.nval); break; case StreamTokenizer.TT_WORD: s = new String(st.sval); break; default: // single character in ttype s = String.valueOf((char)st.ttype); } } } catch(IOException e) { System.out.println(e); } return s; } public static String strip(String qualified) { StripQualifiers sq = new StripQualifiers(qualified); String s = \u0026#34;\u0026#34;, si; while((si = sq.getNext()) != null) { int lastDot = si.lastIndexOf(\u0026#39;.\u0026#39;); if(lastDot != -1) si = si.substring(lastDot + 1); s += si; } return s; } } ///:~ ShowMethodsClean方法非常接近前一个ShowMethods，只是它取得了Method和Constructor数组，并将它们转换成单个String数组。随后，每个这样的String对象都在StripQualifiers.Strip()里“过”一遍，删除所有方法限定词。正如大家看到的那样，此时用到了StreamTokenizer和String来完成这个工作。\n假如记不得一个类是否有一个特定的方法，而且不想在联机文档里逐步检查类结构，或者不知道那个类是否能对某个对象（如Color对象）做某件事情，该工具便可节省大量编程时间。\n第17章提供了这个程序的一个GUI版本，可在自己写代码的时候运行它，以便快速查找需要的东西。\n11.4 总结 利用RTTI可根据一个匿名的基础类句柄调查出类型信息。但正是由于这个原因，新手们极易误用它，因为有些时候多形性方法便足够了。对那些以前习惯程序化编程的人来说，极易将他们的程序组织成一系列switch语句。他们可能用RTTI做到这一点，从而在代码开发和维护中损失多形性技术的重要价值。Java的要求是让我们尽可能地采用多形性，只有在极特别的情况下才使用RTTI。 但为了利用多形性，要求我们拥有对基础类定义的控制权，因为有些时候在程序范围之内，可能发现基础类并未包括我们想要的方法。若基础类来自一个库，或者由别的什么东西控制着，RTTI便是一种很好的解决方案：可继承一个新类型，然后添加自己的额外方法。在代码的其他地方，可以侦测自己的特定类型，并调用那个特殊的方法。这样做不会破坏多形性以及程序的扩展能力，因为新类型的添加不要求查找程序中的switch语句。但在需要新特性的主体中添加新代码时，就必须用RTTI侦测自己特定的类型。\n从某个特定类的利益的角度出发，在基础类里加入一个特性后，可能意味着从那个基础类衍生的其他所有类都必须获得一些无意义的“鸡肋”。这使得接口变得含义模糊。若有人从那个基础类继承，且必须覆盖抽象方法，这一现象便会使他们陷入困扰。比如现在用一个类结构来表示乐器（Instrument）。假定我们想清洁管弦乐队中所有适当乐器的通气音栓（Spit Valve），此时的一个办法是在基础类Instrument中置入一个ClearSpitValve()方法。但这样做会造成一个误区，因为它暗示着打击乐器和电子乐器中也有音栓。针对这种情况，RTTI提供了一个更合理的解决方案，可将方法置入特定的类中（此时是Wind，即“通气口”）——这样做是可行的。但事实上一种更合理的方案是将prepareInstrument()置入基础类中。初学者刚开始时往往看不到这一点，一般会认定自己必须使用RTTI。\n最后，RTTI有时能解决效率问题。若代码大量运用了多形性，但其中的一个对象在执行效率上很有问题，便可用RTTI找出那个类型，然后写一段适当的代码，改进其效率。\n11.5 练习 "},{"id":138,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC12%E7%AB%A0-%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/","title":"Thinking in Java 第12章 传递和返回对象","parent":"Thinking In Java","content":" 第12章 传递和返回对象 到目前为止，读者应对对象的“传递”有了一个较为深刻的认识，记住实际传递的只是一个句柄。\n在许多程序设计语言中，我们可用语言的“普通”方式到处传递对象，而且大多数时候都不会遇到问题。但有些时候却不得不采取一些非常做法，使得情况突然变得稍微复杂起来（在C++中则是变得非常复杂）。Java亦不例外，我们十分有必要准确认识在对象传递和赋值时所发生的一切。这正是本章的宗旨。\n若读者是从某些特殊的程序设计环境中转移过来的，那么一般都会问到：“Java有指针吗？”有些人认为指针的操作很困难，而且十分危险，所以一厢情愿地认为它没有好处。同时由于Java有如此好的口碑，所以应该很轻易地免除自己以前编程中的麻烦，其中不可能夹带有指针这样的“危险品”。然而准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有“戒心”，运行期系统也不例外。或者换从另一个角度说，Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做“句柄”，但你可以把它想像成“安全指针”。和预备学校为学生提供的安全剪刀类似——除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。\n12.1 传递句柄 将句柄传递进入一个方法时，指向的仍然是相同的对象。\n可以在调用方法前和在方法中打印对象，可以看出是一个对象。\n12.1.1 别名问题 “别名”意味着多个句柄都试图指向同一个对象，就象前面的例子展示的那样。若有人向那个对象里写入一点什么东西，就会产生别名问题。若其他句柄的所有者不希望那个对象改变，恐怕就要失望了。\n此时最直接的一个解决办法就是干脆不这样做：不要有意将多个句柄指向同一个作用域内的同一个对象。这样做可使代码更易理解和调试。然而，一旦准备将句柄作为一个自变量或参数传递——这是Java设想的正常方法——别名问题就会自动出现，因为创建的本地句柄可能修改“外部对象”（在方法作用域之外创建的对象）。\n方法改变了自己的参数——外部对象。一旦遇到这种情况，必须判断它是否合理，用户是否愿意这样，以及是不是会造成问题。 通常，我们调用一个方法是为了产生返回值，或者用它改变为其调用方法的那个对象的状态（方法其实就是我们向那个对象“发一条消息”的方式）。很少需要调用一个方法来处理它的参数；这叫作利用方法的“副作用”（Side Effect）。所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。 若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。\n12.2 制作本地副本 Java中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，实际传递的只是指向位于方法外部的那个对象的“一个句柄”。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：\n■参数传递过程中会自动产生别名问题 ■不存在本地对象，只有本地句柄 ■句柄有自己的作用域，而对象没有 ■对象的“存在时间”在Java里不是个问题 ■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用） 若只是从对象中读取信息，而不修改它，传递句柄便是自变量传递中最有效的一种形式。 这种做非常恰当；默认的方法一般也是最有效的方法。然而，有时仍需将对象当作“本地的”对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响。许多程序设计语言都支持在方法内自动生成外部对象的一个本地副本（注释①）。尽管Java不具备这种能力，但允许我们达到同样的效果。\n①：在C语言中，通常控制的是少量数据位，默认操作是按值传递。C++也必须遵照这一形式，但按值传递对象并非肯定是一种有效的方式。此外，在C++中用于支持按值传递的代码也较难编写，是件让人头痛的事情。\n12.2.1 按值传递 首先要解决术语的问题，最适合“按值传递”的看起来是自变量。“按值传递”以及它的含义取决于如何理解程序的运行方式。最常见的意思是获得要传递的任何东西的一个本地副本，但这里真正的问题是如何看待自己准备传递的东西。对于“按值传递”的含义，目前存在两种存在明显区别的见解：\n(1) Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。但若将一个句柄传递进入方法，得到的是句柄的副本。所以人们认为“一切”都按值传递。当然，这种说法也有一个前提：句柄肯定也会被传递。但Java的设计方案似乎有些超前，允许我们忽略（大多数时候）自己处理的是一个句柄。也就是说，它允许我们将句柄假想成“对象”，因为在发出方法调用时，系统会自动照管两者间的差异。 (2) Java主要按值传递（无自变量），但对象却是按引用传递的。得到这个结论的前提是句柄只是对象的一个“别名”，所以不考虑传递句柄的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它“保留但未实现”的关键字之一便是byvalue（按值）。但没人知道那个关键字什么时候可以发挥作用。 尽管存在两种不同的见解，但其间的分歧归根到底是由于对“句柄”的不同解释造成的。我打算在本书剩下的部分里回避这个问题。大家不久就会知道，这个问题争论下去其实是没有意义的——最重要的是理解一个句柄的传递会使调用者的对象发生意外的改变。 12.2.2 克隆对象 若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用clone()方法即可。Clone是“克隆”的意思，即制作完全一模一样的副本。这个方法在基础类Object中定义成“protected”（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为“public”模式。例如，标准库类Vector覆盖了clone()，所以能为Vector调用clone()，\nclone()方法产生了一个Object，后者必须立即重新造型为正确类型。这个例子指出Vector的clone()方法不能自动尝试克隆Vector内包含的每个对象——由于别名问题，老的Vector和克隆的Vector都包含了相同的对象。我们通常把这种情况叫作“简单复制”或者“浅层复制”，因为它只复制了一个对象的“表面”部分。实际对象除包含这个“表面”以外，还包括句柄指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是“对象网”或“对象关系网”的由来。若能复制下所有这张网，便叫作“全面复制”或者“深层复制”。\n一般来说，由于不敢保证Vector里包含的对象是“可以克隆”（注释②）的，所以最好不要试图克隆那些对象。\n②：“可以克隆”用英语讲是cloneable，请留意Java库中专门保留了这样的一个关键字。\n12.2.3 使类具有克隆能力 尽管克隆方法是在所有类最基本的Object中定义的，但克隆仍然不会在每个类里自动进行。这似乎有些不可思议，因为基础类方法在衍生类里是肯定能用的。但Java确实有点儿反其道而行之；如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行。\n使用protected时的技巧 为避免我们创建的每个类都默认具有克隆能力，clone()方法在基础类Object里得到了“保留”（设为protected）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用clone()（尽管那样做在某些情况下特别有用，比如用多形性的方式克隆一系列对象）。在编译期的时候，这实际是通知我们对象不可克隆的一种方式——而且最奇怪的是，Java库中的大多数类都不能克隆。因此，假如我们执行下述代码： Integer x = new Integer(l); x = x.clone(); 那么在编译期，就有一条讨厌的错误消息弹出，告诉我们不可访问clone()——因为Integer并没有覆盖它，而且它对protected版本来说是默认的）。 但是，假若我们是在一个从Object衍生出来的类中（所有类都是从Object衍生的），就有权调用Object.clone()，因为它是“protected”，而且我们在一个继承器中。基础类clone()提供了一个有用的功能——它进行的是对衍生类对象的真正“按位”复制，所以相当于标准的克隆行动。然而，我们随后需要将自己的克隆操作设为public，否则无法访问。总之，克隆时要注意的两个关键问题是：几乎肯定要调用super.clone()，以及注意将克隆设为public。 有时还想在更深层的衍生类中覆盖clone()，否则就直接使用我们的clone()（现在已成为public），而那并不一定是我们所希望的（然而，由于Object.clone()已制作了实际对象的一个副本，所以也有可能允许这种情况）。protected的技巧在这里只能用一次：首次从一个不具备克隆能力的类继承，而且想使一个类变成“能够克隆”。而在从我们的类继承的任何场合，clone()方法都是可以使用的，因为Java不可能在衍生之后反而缩小方法的访问范围。换言之，一旦对象变得可以克隆，从它衍生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其“关闭”克隆能力。\n实现Cloneable接口 为使一个对象的克隆能力功成圆满，还需要做另一件事情：实现Cloneable接口。这个接口使人稍觉奇怪，因为它是空的！ interface Cloneable {} 之所以要实现这个空接口，显然不是因为我们准备上溯造型成一个Cloneable，以及调用它的某个方法。有些人认为在这里使用接口属于一种“欺骗”行为，因为它使用的特性打的是别的主意，而非原来的意思。Cloneable interface的实现扮演了一个标记的角色，封装到类的类型中。 两方面的原因促成了Cloneable interface的存在。首先，可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用instanceof关键字（第11章有介绍）调查句柄是否确实同一个能克隆的对象连接： if(myHandle instanceof Cloneable) // \u0026hellip; 第二个原因是考虑到我们可能不愿所有对象类型都能克隆。所以Object.clone()会验证一个类是否真的是实现了Cloneable接口。若答案是否定的，则“掷”出一个CloneNotSupportedException违例。所以在一般情况下，我们必须将“implement Cloneable”作为对克隆能力提供支持的一部分。\n12.2.4 成功的克隆 理解了实现clone()方法背后的所有细节后，便可创建出能方便复制的类，以便提供了一个本地副本:\n//: LocalCopy.java // Creating local copies with clone() import java.util.*; class MyObject implements Cloneable { int i; MyObject(int ii) { i = ii; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { System.out.println(\u0026#34;MyObject can\u0026#39;t clone\u0026#34;); } return o; } public String toString() { return Integer.toString(i); } } public class LocalCopy { static MyObject g(MyObject v) { // Passing a handle, modifies outside object: v.i++; return v; } static MyObject f(MyObject v) { v = (MyObject)v.clone(); // Local copy v.i++; return v; } public static void main(String[] args) { MyObject a = new MyObject(11); MyObject b = g(a); // Testing handle equivalence, // not object equivalence: if(a == b) System.out.println(\u0026#34;a == b\u0026#34;); else System.out.println(\u0026#34;a != b\u0026#34;); System.out.println(\u0026#34;a = \u0026#34; + a); System.out.println(\u0026#34;b = \u0026#34; + b); MyObject c = new MyObject(47); MyObject d = f(c); if(c == d) System.out.println(\u0026#34;c == d\u0026#34;); else System.out.println(\u0026#34;c != d\u0026#34;); System.out.println(\u0026#34;c = \u0026#34; + c); System.out.println(\u0026#34;d = \u0026#34; + d); } } ///:~ 不管怎样，clone()必须能够访问，所以必须将其设为public（公共的）。其次，作为clone()的初期行动，应调用clone()的基础类版本。这里调用的clone()是Object内部预先定义好的。之所以能调用它，是由于它具有protected（受到保护的）属性，所以能在衍生的类里访问。 Object.clone()会检查原先的对象有多大，再为新对象腾出足够多的内存，将所有二进制位从原来的对象复制到新对象。这叫作“按位复制”，而且按一般的想法，这个工作应该是由clone()方法来做的。但在Object.clone()正式开始操作前，首先会检查一个类是否Cloneable，即是否具有克隆能力——换言之，它是否实现了Cloneable接口。若未实现，Object.clone()就掷出一个CloneNotSupportedException违例，指出我们不能克隆它。因此，我们最好用一个try-catch块将对super.clone()的调用代码包围（或封装）起来，试图捕获一个应当永不出现的违例（因为这里确实已实现了Cloneable接口）。 在LocalCopy中，两个方法g()和f()揭示出两种参数传递方法间的差异。其中，g()演示的是按引用传递，它会修改外部对象，并返回对那个外部对象的一个引用。而f()是对自变量进行克隆，所以将其分离出来，并让原来的对象保持独立。随后，它继续做它希望的事情。甚至能返回指向这个新对象的一个句柄，而且不会对原来的对象产生任何副作用。注意下面这个多少有些古怪的语句： v = (MyObject)v.clone(); 它的作用正是创建一个本地副本。为避免被这样的一个语句搞混淆，记住这种相当奇怪的编码形式在Java中是完全允许的，因为有一个名字的所有东西实际都是一个句柄。所以句柄v用于克隆一个它所指向的副本，而且最终返回指向基础类型Object的一个句柄（因为它在Object.clone()中是那样被定义的），随后必须将其造型为正确的类型。 在main()中，两种不同参数传递方式的区别在于它们分别测试了一个不同的方法。输出结果如下：\na == b a = 12 b = 12 c != d c = 47 d = 48 大家要记住这样一个事实：Java对“是否等价”的测试并不对所比较对象的内部进行检查，从而核实它们的值是否相同。==和!=运算符只是简单地对比句柄的内容。若句柄内的地址相同，就认为句柄指向同样的对象，所以认为它们是“等价”的。所以运算符真正检测的是“由于别名问题，句柄是否指向同一个对象？”\n12.2.5 Object.clone()的效果 调用Object.clone()时，实际发生的是什么事情呢？当我们在自己的类里覆盖clone()时，什么东西对于super.clone()来说是最关键的呢？根类中的clone()方法负责建立正确的存储容量，并通过“按位复制”将二进制位从原始对象中复制到新对象的存储空间。也就是说，它并不只是预留存储空间以及复制一个对象——实际需要调查出欲复制之对象的准确大小，然后复制那个对象。由于所有这些工作都是在由根类定义之clone()方法的内部代码中进行的（根类并不知道要从自己这里继承出去什么），所以大家或许已经猜到，这个过程需要用RTTI判断欲克隆的对象的实际大小。采取这种方式，clone()方法便可建立起正确数量的存储空间，并对那个类型进行正确的按位复制。 不管我们要做什么，克隆过程的第一个部分通常都应该是调用super.clone()。通过进行一次准确的复制，这样做可为后续的克隆进程建立起一个良好的基础。随后，可采取另一些必要的操作，以完成最终的克隆。 为确切了解其他操作是什么，首先要正确理解Object.clone()为我们带来了什么。特别地，它会自动克隆所有句柄指向的目标吗？下面这个例子可完成这种形式的检测：\n//: Snake.java // Tests cloning to see if destination of // handles are also cloned. public class Snake implements Cloneable { private Snake next; private char c; // Value of i == number of segments Snake(int i, char x) { c = x; if(--i \u0026gt; 0) next = new Snake(i, (char)(x + 1)); } void increment() { c++; if(next != null) next.increment(); } public String toString() { String s = \u0026#34;:\u0026#34; + c; if(next != null) s += next.toString(); return s; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { } return o; } public static void main(String[] args) { Snake s = new Snake(5, \u0026#39;a\u0026#39;); System.out.println(\u0026#34;s = \u0026#34; + s); Snake s2 = (Snake)s.clone(); System.out.println(\u0026#34;s2 = \u0026#34; + s2); s.increment(); System.out.println( \u0026#34;after s.increment, s2 = \u0026#34; + s2); } } ///:~ 一条Snake（蛇）由数段构成，每一段的类型都是Snake。所以，这是一个一段段链接起来的列表。所有段都是以循环方式创建的，每做好一段，都会使第一个构建器参数的值递减，直至最终为零。而为给每段赋予一个独一无二的标记，第二个参数（一个Char）的值在每次循环构建器调用时都会递增。 increment()方法的作用是循环递增每个标记，使我们能看到发生的变化；而toString则循环打印出每个标记。输出如下：\ns = :a:b:c:d:e s2 = :a:b:c:d:e after s.increment, s2 = :a:c:d:e:f 这意味着只有第一段才是由Object.clone()复制的，所以此时进行的是一种“浅层复制”。若希望复制整条蛇——即进行“深层复制”——必须在被覆盖的clone()里采取附加的操作。 通常可在从一个能克隆的类里调用super.clone()，以确保所有基础类行动（包括Object.clone()）能够进行。随着是为对象内每个句柄都明确调用一个clone()；否则那些句柄会别名变成原始对象的句柄。构建器的调用也大致相同——首先构造基础类，然后是下一个衍生的构建器……以此类推，直到位于最深层的衍生构建器。区别在于clone()并不是个构建器，所以没有办法实现自动克隆。为了克隆，必须由自己明确进行。\n12.2.6 克隆合成对象 试图深层复制合成对象时会遇到一个问题。必须假定成员对象中的clone()方法也能依次对自己的句柄进行深层复制，以此类推。这使我们的操作变得复杂。为了能正常实现深层复制，必须对所有类中的代码进行控制，或者至少全面掌握深层复制中需要涉及的类，确保它们自己的深层复制能正确进行。 下面这个例子总结了面对一个合成对象进行深层复制时需要做哪些事情：\n//: DeepCopy.java // Cloning a composed object class DepthReading implements Cloneable { private double depth; public DepthReading(double depth) { this.depth = depth; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } class TemperatureReading implements Cloneable { private long time; private double temperature; public TemperatureReading(double temperature) { time = System.currentTimeMillis(); this.temperature = temperature; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } class OceanReading implements Cloneable { private DepthReading depth; private TemperatureReading temperature; public OceanReading(double tdata, double ddata){ temperature = new TemperatureReading(tdata); depth = new DepthReading(ddata); } public Object clone() { OceanReading o = null; try { o = (OceanReading)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } // Must clone handles: o.depth = (DepthReading)o.depth.clone(); o.temperature = (TemperatureReading)o.temperature.clone(); return o; // Upcasts back to Object } } public class DeepCopy { public static void main(String[] args) { OceanReading reading = new OceanReading(33.9, 100.5); // Now clone it: OceanReading r = (OceanReading)reading.clone(); } } ///:~ DepthReading和TemperatureReading非常相似；它们都只包含了基本数据类型。所以clone()方法能够非常简单：调用super.clone()并返回结果即可。注意两个类使用的clone()代码是完全一致的。 OceanReading是由DepthReading和TemperatureReading对象合并而成的。为了对其进行深层复制，clone()必须同时克隆OceanReading内的句柄。为达到这个目标，super.clone()的结果必须造型成一个OceanReading对象（以便访问depth和temperature句柄）。\n12.2.7 用Vector进行深层复制 Int3自Int2继承而来，并添加了一个新的基本类型成员int j。大家也许认为自己需要再次覆盖clone()，以确保j得到复制，但实情并非如此。将Int2的clone()当作Int3的clone()调用时，它会调用Object.clone()，判断出当前操作的是Int3，并复制Int3内的所有二进制位。只要没有新增需要克隆的句柄，对Object.clone()的一个调用就能完成所有必要的复制——无论clone()是在层次结构多深的一级定义的。 至此，大家可以总结出对Vector进行深层复制的先决条件：在克隆了Vector后，必须在其中遍历，并克隆由Vector指向的每个对象。为了对Hashtable（散列表）进行深层复制，也必须采取类似的处理。 这个例子剩余的部分显示出克隆已实际进行——证据就是在克隆了对象以后，可以自由改变它，而原来那个对象不受任何影响。\n12.2.8 通过序列化进行深层复制 若研究一下第10章介绍的那个Java 1.1对象序列化示例，可能发现若在一个对象序列化以后再撤消对它的序列化，或者说进行装配，那么实际经历的正是一个“克隆”的过程。 那么为什么不用序列化进行深层复制呢？ 其中，Thing2和Thing4包含了成员对象，所以需要进行一些深层复制。一个有趣的地方是尽管Serializable类很容易设置，但在复制它们时却要做多得多的工作。克隆涉及到大量的类设置工作，但实际的对象复制是相当简单的。结果很好地说明了一切。下面是几次运行分别得到的结果： Duplication via serialization: 3400 Milliseconds Duplication via cloning: 110 Milliseconds Duplication via serialization: 3410 Milliseconds Duplication via cloning: 110 Milliseconds Duplication via serialization: 3520 Milliseconds Duplication via cloning: 110 Milliseconds 除了序列化和克隆之间巨大的时间差异以外，我们也注意到序列化技术的运行结果并不稳定，而克隆每一次花费的时间都是相同的。\n12.2.9 使克隆具有更大的深度 若新建一个类，它的基础类会默认为Object，并默认为不具备克隆能力（就象在下一节会看到的那样）。只要不明确地添加克隆能力，这种能力便不会自动产生。但我们可以在任何层添加它，然后便可从那个层开始向下具有克隆能力。\n添加克隆能力之前，编译器会阻止我们的克隆尝试。一旦在Scientist里添加了克隆能力，那么Scientist以及它的所有“后裔”都可以克隆。\n12.2.10 为什么有这个奇怪的设计 之所以感觉这个方案的奇特，因为它事实上的确如此。也许大家会奇怪它为什么要象这样运行，而该方案背后的真正含义是什么呢？后面讲述的是一个未获证实的故事——大概是由于围绕Java的许多买卖使其成为一种设计优良的语言——但确实要花许多口舌才能讲清楚这背后发生的所有事情。 最初，Java只是作为一种用于控制硬件的语言而设计，与因特网并没有丝毫联系。象这样一类面向大众的语言一样，其意义在于程序员可以对任意一个对象进行克隆。这样一来，clone()就放置在根类Object里面，但因为它是一种公用方式，因而我们通常能够对任意一个对象进行克隆。看来这是最灵活的方式了，毕竟它不会带来任何害处。 正当Java看起来象一种终级因特网程序设计语言的时候，情况却发生了变化。突然地，人们提出了安全问题，而且理所当然，这些问题与使用对象有关，我们不愿望任何人克隆自己的保密对象。所以我们最后看到的是为原来那个简单、直观的方案添加的大量补丁：clone()在Object里被设置成“protected”。必须将其覆盖，并使用“implement Cloneable”，同时解决违例的问题。 只有在准备调用Object的clone()方法时，才没有必要使用Cloneable接口，因为那个方法会在运行期间得到检查，以确保我们的类实现了Cloneable。但为了保持连贯性（而且由于Cloneable无论如何都是空的），最好还是由自己实现Cloneable。\n12.3 克隆的控制 为消除克隆能力，大家也许认为只需将clone()方法简单地设为private（私有）即可，但这样是行不通的，因为不能采用一个基础类方法，并使其在衍生类中更“私有”。所以事情并没有这么简单。此外，我们有必要控制一个对象是否能够克隆。对于我们设计的一个类，实际有许多种方案都是可以采取的：\n(1) 保持中立，不为克隆做任何事情。也就是说，尽管不可对我们的类克隆，但从它继承的一个类却可根据实际情况决定克隆。只有Object.clone()要对类中的字段进行某些合理的操作时，才可以作这方面的决定。 (2) 支持clone()，采用实现Cloneable（可克隆）能力的标准操作，并覆盖clone()。在被覆盖的clone()中，可调用super.clone()，并捕获所有违例（这样可使clone()不“掷”出任何违例）。 (3) 有条件地支持克隆。若类容纳了其他对象的句柄，而那些对象也许能够克隆（集合类便是这样的一个例子），就可试着克隆拥有对方句柄的所有对象；如果它们“掷”出了违例，只需让这些违例通过即可。举个例子来说，假设有一个特殊的Vector，它试图克隆自己容纳的所有对象。编写这样的一个Vector时，并不知道客户程序员会把什么形式的对象置入这个Vector中，所以并不知道它们是否真的能够克隆。 (4) 不实现Cloneable()，但是将clone()覆盖成protected，使任何字段都具有正确的复制行为。这样一来，从这个类继承的所有东西都能覆盖clone()，并调用super.clone()来产生正确的复制行为。注意在我们实现方案里，可以而且应该调用super.clone()——即使那个方法本来预期的是一个Cloneable对象（否则会掷出一个违例），因为没有人会在我们这种类型的对象上直接调用它。它只有通过一个衍生类调用；对那个衍生类来说，如果要保证它正常工作，需实现Cloneable。 (5) 不实现Cloneable来试着防止克隆，并覆盖clone()，以产生一个违例。为使这一设想顺利实现，只有令从它衍生出来的任何类都调用重新定义后的clone()里的suepr.clone()。 (6) 将类设为final，从而防止克隆。若clone()尚未被我们的任何一个上级类覆盖，这一设想便不会成功。若已被覆盖，那么再一次覆盖它，并“掷”出一个CloneNotSupportedException（克隆不支持）违例。为担保克隆被禁止，将类设为final是唯一的办法。除此以外，一旦涉及保密对象或者遇到想对创建的对象数量进行控制的其他情况，应该将所有构建器都设为private，并提供一个或更多的特殊方法来创建对象。采用这种方式，这些方法就可以限制创建的对象数量以及它们的创建条件——一种特殊情况是第16章要介绍的singleton（独子）方案。 唯一安全的方法在ReallyNoMore中得到了演示，它设为final，所以不可继承。这意味着假如clone()在final类中掷出了一个违例，便不能通过继承来进行修改，并可有效地禁止克隆（不能从一个拥有任意继承级数的类中明确调用Object.clone()；只能调用super.clone()，它只可访问直接基础类）。因此，只要制作一些涉及安全问题的对象，就最好把那些类设为final。\n总之，如果希望一个类能够克隆，那么：\n(1) 实现Cloneable接口 (2) 覆盖clone() (3) 在自己的clone()中调用super.clone() (4) 在自己的clone()中捕获违例 这一系列步骤能达到最理想的效果。 12.3.1 副本构建器 非常不幸，假如想制作对象的一个本地副本，Java中的副本构建器便不是特别适合我们。\n12.4 只读类 尽管在一些特定的场合，由clone()产生的本地副本能够获得我们希望的结果，但程序员（方法的作者）不得不亲自禁止别名处理的副作用。假如想制作一个库，令其具有常规用途，但却不能担保它肯定能在正确的类中得以克隆，这时又该怎么办呢？更有可能的一种情况是，假如我们想让别名发挥积极的作用——禁止不必要的对象复制——但却不希望看到由此造成的副作用，那么又该如何处理呢？ 一个办法是创建“不变对象”，令其从属于只读类。可定义一个特殊的类，使其中没有任何方法能造成对象内部状态的改变。在这样的一个类中，别名处理是没有问题的。因为我们只能读取内部状态，所以当多处代码都读取相同的对象时，不会出现任何副作用。 作为“不变对象”一个简单例子，Java的标准库包含了“封装器”（wrapper）类，可用于所有基本数据类型。大家可能已发现了这一点，如果想在一个象Vector（只采用Object句柄）这样的集合里保存一个int数值，可以将这个int封装到标准库的Integer类内部。\nInteger类（以及基本的“封装器”类）用简单的形式实现了“不变性”：它们没有提供可以修改对象的方法。 若确实需要一个容纳了基本数据类型的对象，并想对基本数据类型进行修改，就必须亲自创建它们。幸运的是，操作非常简单\n12.4.1 创建只读类 所有数据都设为private，没有任何public方法对数据作出修改。它能保证对象不被改动。\n12.4.2 “一成不变”的弊端 从表面看，不变类的建立似乎是一个好方案。但是，一旦真的需要那种新类型的一个修改的对象，就必须辛苦地进行新对象的创建工作，同时还有可能涉及更频繁的垃圾收集。对有些类来说，这个问题并不是很大。但对其他类来说（比如String类），这一方案的代价显得太高了。 为解决这个问题，我们可以创建一个“同志”类，并使其能够修改。以后只要涉及大量的修改工作，就可换为使用能修改的同志类。完事以后，再切换回不可变的类。\n我们只创建了两个新对象（Mutable和Immutable2的结果），而不是四个。 这一方法特别适合在下述场合应用： (1) 需要不可变的对象，而且 (2) 经常需要进行大量修改，或者 (3) 创建新的不变对象代价太高\nString 和 StringBuffer 类\n12.4.3 不变字串 隐式常数 若使用下述语句： String s = \u0026ldquo;asdf\u0026rdquo;; String x = Stringer.upcase(s); 那么真的希望upcase()方法改变自变量或者参数吗？我们通常是不愿意的，因为作为提供给方法的一种信息，自变量一般是拿给代码的读者看的，而不是让他们修改。这是一个相当重要的保证，因为它使代码更易编写和理解。 为了在C++中实现这一保证，需要一个特殊关键字的帮助：const。利用这个关键字，程序员可以保证一个句柄（C++叫“指针”或者“引用”）不会被用来修改原始的对象。但这样一来，C++程序员需要用心记住在所有地方都使用const。这显然易使人混淆，也不容易记住。 覆盖\u0026quot;+\u0026ldquo;和StringBuffer 利用前面提到的技术，String类的对象被设计成“不可变”。若查阅联机文档中关于String类的内容（本章稍后还要总结它），就会发现类中能够修改String的每个方法实际都创建和返回了一个崭新的String对象，新对象里包含了修改过的信息——原来的String是原封未动的。因此，Java里没有与C++的const对应的特性可用来让编译器支持对象的不可变能力。若想获得这一能力，可以自行设置，就象String那样。 由于String对象是不可变的，所以能够根据情况对一个特定的String进行多次别名处理。因为它是只读的，所以一个句柄不可能会改变一些会影响其他句柄的东西。因此，只读对象可以很好地解决别名问题。 通过修改产生对象的一个崭新版本，似乎可以解决修改对象时的所有问题，就象String那样。但对某些操作来讲，这种方法的效率并不高。一个典型的例子便是为String对象覆盖的运算符“+”。“覆盖”意味着在与一个特定的类使用时，它的含义已发生了变化（用于String的“+”和“+=”是Java中能被覆盖的唯一运算符，Java不允许程序员覆盖其他任何运算符——注释④）。 ④：C++允许程序员随意覆盖运算符。由于这通常是一个复杂的过程（参见《Thinking in C++》，Prentice-Hall于1995年出版），所以Java的设计者认定它是一种“糟糕”的特性，决定不在Java中采用。但具有讽剌意味的是，运算符的覆盖在Java中要比在C++中容易得多。\n针对String对象使用时，“+”允许我们将不同的字串连接起来： String s = \u0026ldquo;abc\u0026rdquo; + foo + \u0026ldquo;def\u0026rdquo; + Integer.toString(47);\n可以想象出它“可能”是如何工作的：字串\u0026quot;abc\u0026quot;可以有一个方法append()，它新建了一个字串，其中包含\u0026quot;abc\u0026quot;以及foo的内容；这个新字串然后再创建另一个新字串，在其中添加\u0026quot;def\u0026rdquo;；以此类推。 这一设想是行得通的，但它要求创建大量字串对象。尽管最终的目的只是获得包含了所有内容的一个新字串，但中间却要用到大量字串对象，而且要不断地进行垃圾收集。我怀疑Java的设计者是否先试过种方法（这是软件开发的一个教训——除非自己试试代码，并让某些东西运行起来，否则不可能真正了解系统）。我还怀疑他们是否早就发现这样做获得的性能是不能接受的。 解决的方法是象前面介绍的那样制作一个可变的同志类。对字串来说，这个同志类叫作StringBuffer，编译器可以自动创建一个StringBuffer，以便计算特定的表达式，特别是面向String对象应用覆盖过的运算符+和+=时。\n创建字串s时，编译器做的工作大致等价于后面使用sb的代码——创建一个StringBuffer，并用append()将新字符直接加入StringBuffer对象（而不是每次都产生新对象）。尽管这样做更有效，但不值得每次都创建象\u0026quot;abc\u0026quot;和\u0026quot;def\u0026quot;这样的引号字串，编译器会把它们都转换成String对象。所以尽管StringBuffer提供了更高的效率，但会产生比我们希望的多得多的对象。\n12.4.4 String和StringBuffer类 这里总结一下同时适用于String和StringBuffer的方法，以便对它们相互间的沟通方式有一个印象。这些表格并未把每个单独的方法都包括进去，而是包含了与本次讨论有重要关系的方法。那些已被覆盖的方法用单独一行总结。 首先总结String类的各种方法：\n最常用的一个方法是append()。在计算包含了+和+=运算符的String表达式时，编译器便会用到这个方法。insert()方法采用类似的形式。这两个方法都能对缓冲区进行重要的操作，不需要另建新对象。\n12.4.5 字串的特殊性 现在，大家已知道String类并非仅仅是Java提供的另一个类。String里含有大量特殊的类。通过编译器和特殊的覆盖或过载运算符+和+=，可将引号字符串转换成一个String。在本章中，大家已见识了剩下的一种特殊情况：用同志StringBuffer精心构造的“不可变”能力，以及编译器中出现的一些有趣现象。\n12.5 总结 由于Java中的所有东西都是句柄，而且由于每个对象都是在内存堆中创建的——只有不再需要的时候，才会当作垃圾收集掉，所以对象的操作方式发生了变化，特别是在传递和返回对象的时候。举个例子来说，在C和C++中，如果想在一个方法里初始化一些存储空间，可能需要请求用户将那片存储区域的地址传递进入方法。否则就必须考虑由谁负责清除那片区域。因此，这些方法的接口和对它们的理解就显得要复杂一些。但在Java中，根本不必关心由谁负责清除，也不必关心在需要一个对象的时候它是否仍然存在。因为系统会为我们照料一切。我们的程序可在需要的时候创建一个对象。而且更进一步地，根本不必担心那个对象的传输机制的细节：只需简单地传递句柄即可。有些时候，这种简化非常有价值，但另一些时候却显得有些多余。 可从两个方面认识这一机制的缺点：\n(1) 肯定要为额外的内存管理付出效率上的损失（尽管损失不大），而且对于运行所需的时间，总是存在一丝不确定的因素（因为在内存不够时，垃圾收集器可能会被强制采取行动）。对大多数应用来说，优点显得比缺点重要，而且部分对时间要求非常苛刻的段落可以用native方法写成（参见附录A）。 (2) 别名处理：有时会不慎获得指向同一个对象的两个句柄。只有在这两个句柄都假定指向一个“明确”的对象时，才有可能产生问题。对这个问题，必须加以足够的重视。而且应该尽可能地“克隆”一个对象，以防止另一个句柄被不希望的改动影响。除此以外，可考虑创建“不可变”对象，使它的操作能返回同种类型或不同种类型的一个新对象，从而提高程序的执行效率。但千万不要改变原始对象，使对那个对象别名的其他任何方面都感觉不出变化。 有些人认为Java的克隆是一个笨拙的家伙，所以他们实现了自己的克隆方案（注释⑤），永远杜绝调用Object.clone()方法，从而消除了实现Cloneable和捕获CloneNotSupportException违例的需要。这一做法是合理的，而且由于clone()在Java标准库中很少得以支持，所以这显然也是一种“安全”的方法。只要不调用Object.clone()，就不必实现Cloneable或者捕获违例，所以那看起来也是能够接受的。\n⑤：Doug Lea特别重视这个问题，并把这个方法推荐给了我，他说只需为每个类都创建一个名为duplicate()的函数即可。\nJava中一个有趣的关键字是byvalue（按值），它属于那些“保留但未实现”的关键字之一。在理解了别名和克隆问题以后，大家可以想象byvalue最终有一天会在Java中用于实现一种自动化的本地副本。这样做可以解决更多复杂的克隆问题，并使这种情况下的编写的代码变得更加简单和健壮。\n12.6 练习 "},{"id":139,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC13%E7%AB%A0-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%89%87/","title":"Thinking in Java 第13章 创建窗口和程序片","parent":"Thinking In Java","content":" 第13章 创建窗口和程序片 "},{"id":140,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"Thinking in Java 第14章 多线程","parent":"Thinking In Java","content":" 第14章 多线程 利用对象，可将一个程序分割成相互独立的区域。我们通常也需要将一个程序转换成多个独立运行的子任务。\n象这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。\n这时理解一些定义对以后的学习狠有帮助。“进程”是指一种“自包容”的运行程序，有自己的地址空间。“多任务”操作系统能同时运行多个进程（程序）——但实际是由于CPU分时机制的作用，使每个进程都能循环获得自己的CPU时间片。但由于轮换速度非常快，使得所有程序好象是在“同时”运行一样。“线程”是进程内部单一的一个顺序控制流。因此，一个进程可能容纳了多个同时执行的线程。\n多线程的应用范围很广。但在一般情况下，程序的一些部分同特定的事件或资源联系在一起，同时又不想为它而暂停程序其他部分的执行。这样一来，就可考虑创建一个线程，令其与那个事件或资源关联到一起，并让它独立于主程序运行。一个很好的例子便是“Quit”或“退出”按钮——我们并不希望在程序的每一部分代码中都轮询这个按钮，同时又希望该按钮能及时地作出响应（使程序看起来似乎经常都在轮询它）。事实上，多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。\n14.1 反应灵敏的用户界面 作为我们的起点，请思考一个需要执行某些CPU密集型计算的程序。由于CPU“全心全意”为那些计算服务，所以对用户的输入十分迟钝，几乎没有什么反应。在这里，我们用一个合成的applet/application（程序片／应用程序）来简单显示出一个计数器的结果：\n//: Counter1.java // A non-responsive user interface package c14; import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter1 extends Applet { private int count = 0; private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); private TextField t = new TextField(10); private boolean runFlag = true; public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } public void go() { while (true) { try { Thread.currentThread().sleep(100); } catch (InterruptedException e){} if(runFlag) t.setText(Integer.toString(count++)); } } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { go(); } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } public static void main(String[] args) { Counter1 applet = new Counter1(); Frame aFrame = new Frame(\u0026#34;Counter1\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 在这个程序中，AWT和程序片代码都应是大家熟悉的，第13章对此已有很详细的交待。go()方法正是程序全心全意服务的对待：将当前的count（计数）值置入TextField（文本字段）t，然后使count增值。\ngo()内的部分无限循环是调用sleep()。sleep()必须同一个Thread（线程）对象关联到一起，而且似乎每个应用程序都有部分线程同它关联（事实上，Java本身就是建立在线程基础上的，肯定有一些线程会伴随我们写的应用一起运行）。所以无论我们是否明确使用了线程，都可利用Thread.currentThread()产生由程序使用的当前线程，然后为那个线程调用sleep()。注意，Thread.currentThread()是Thread类的一个静态方法。\n注意sleep()可能“掷”出一个InterruptException（中断违例）——尽管产生这样的违例被认为是中止线程的一种“恶意”手段，而且应该尽可能地杜绝这一做法。再次提醒大家，违例是为异常情况而产生的，而不是为了正常的控制流。在这里包含了对一个“睡眠”线程的中断，以支持未来的一种语言特性。\n一旦按下start按钮，就会调用go()。研究一下go()，你可能会很自然地（就象我一样）认为它该支持多线程，因为它会进入“睡眠”状态。也就是说，尽管方法本身“睡着”了，CPU仍然应该忙于监视其他按钮“按下”事件。但有一个问题，那就是go()是永远不会返回的，因为它被设计成一个无限循环。这意味着actionPerformed()根本不会返回。由于在第一个按键以后便陷入actionPerformed()中，所以程序不能再对其他任何事件进行控制（如果想出来，必须以某种方式“杀死”进程——最简便的方式就是在控制台窗口按Ctrl＋C键）。\n这里最基本的问题是go()需要继续执行自己的操作，而与此同时，它也需要返回，以便actionPerformed()能够完成，而且用户界面也能继续响应用户的操作。但对象go()这样的传统方法来说，它却不能在继续的同时将控制权返回给程序的其他部分。这听起来似乎是一件不可能做到的事情，就象CPU必须同时位于两个地方一样，但线程可以解决一切。“线程模型”（以及Java中的编程支持）是一种程序编写规范，可在单独一个程序里实现几个操作的同时进行。根据这一机制，CPU可为每个线程都分配自己的一部分时间。每个线程都“感觉”自己好象拥有整个CPU，但CPU的计算时间实际却是在所有线程间分摊的。 线程机制多少降低了一些计算效率，但无论程序的设计，资源的均衡，还是用户操作的方便性，都从中获得了巨大的利益。综合考虑，这一机制是非常有价值的。当然，如果本来就安装了多块CPU，那么操作系统能够自行决定为不同的CPU分配哪些线程，程序的总体运行速度也会变得更快（所有这些都要求操作系统以及应用程序的支持）。多线程和多任务是充分发挥多处理机系统能力的一种最有效的方式。\n14.1.1 从线程继承 为创建一个线程，最简单的方法就是从Thread类继承。这个类包含了创建和运行线程所需的一切东西。Thread最重要的方法是run()。但为了使用run()，必须对其进行过载或者覆盖，使其能充分按自己的吩咐行事。因此，run()属于那些会与程序中的其他线程“并发”或“同时”执行的代码。\n下面这个例子可创建任意数量的线程，并通过为每个线程分配一个独一无二的编号（由一个静态变量产生），从而对不同的线程进行跟踪。Thread的run()方法在这里得到了覆盖，每通过一次循环，计数就减1——计数为0时则完成循环（此时一旦返回run()，线程就中止运行）。\n//: SimpleThread.java // Very simple Threading example public class SimpleThread extends Thread { private int countDown = 5; private int threadNumber; private static int threadCount = 0; public SimpleThread() { threadNumber = ++threadCount; System.out.println(\u0026#34;Making \u0026#34; + threadNumber); } public void run() { while(true) { System.out.println(\u0026#34;Thread \u0026#34; + threadNumber + \u0026#34;(\u0026#34; + countDown + \u0026#34;)\u0026#34;); if(--countDown == 0) return; } } public static void main(String[] args) { for(int i = 0; i \u0026lt; 5; i++) new SimpleThread().start(); System.out.println(\u0026#34;All Threads Started\u0026#34;); } } ///:~ run()方法几乎肯定含有某种形式的循环——它们会一直持续到线程不再需要为止。因此，我们必须规定特定的条件，以便中断并退出这个循环（或者在上述的例子中，简单地从run()返回即可）。run()通常采用一种无限循环的形式。也就是说，通过阻止外部发出对线程的stop()或者destroy()调用，它会永远运行下去（直到程序完成）。\n在main()中，可看到创建并运行了大量线程。Thread包含了一个特殊的方法，叫作start()，它的作用是对线程进行特殊的初始化，然后调用run()。所以整个步骤包括：调用构建器来构建对象，然后用start()配置线程，再调用run()。如果不调用start()——如果适当的话，可在构建器那样做——线程便永远不会启动。\n下面是该程序某一次运行的输出（注意每次运行都会不同）：\n可注意到这个例子中到处都调用了sleep()，然而输出结果指出每个线程都获得了属于自己的那一部分CPU执行时间。从中可以看出，尽管sleep()依赖一个线程的存在来执行，但却与允许或禁止线程无关。它只不过是另一个不同的方法而已。\n亦可看出线程并不是按它们创建时的顺序运行的。事实上，CPU处理一个现有线程集的顺序是不确定的——除非我们亲自介入，并用Thread的setPriority()方法调整它们的优先级。\nmain()创建Thread对象时，它并未捕获任何一个对象的句柄。普通对象对于垃圾收集来说是一种“公平竞赛”，但线程却并非如此。每个线程都会“注册”自己，所以某处实际存在着对它的一个引用。这样一来，垃圾收集器便只好对它“瞠目以对”了。\n14.1.2 针对用户界面的多线程 现在，我们也许能用一个线程解决在Counter1.java中出现的问题。采用的一个技巧便是在一个线程的run()方法中放置“子任务”——亦即位于go()内的循环。一旦用户按下Start按钮，线程就会启动，但马上结束线程的创建。这样一来，尽管线程仍在运行，但程序的主要工作却能得以继续（等候并响应用户界面的事件）。下面是具体的代码：\n//: Counter2.java // A responsive user interface with threads import java.awt.*; import java.awt.event.*; import java.applet.*; class SeparateSubTask extends Thread { private int count = 0; private Counter2 c2; private boolean runFlag = true; public SeparateSubTask(Counter2 c2) { this.c2 = c2; start(); } public void invertFlag() { runFlag = !runFlag;} public void run() { while (true) { try { sleep(100); } catch (InterruptedException e){} if(runFlag) c2.t.setText(Integer.toString(count++)); } } } public class Counter2 extends Applet { TextField t = new TextField(10); private SeparateSubTask sp = null; private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp == null) sp = new SeparateSubTask(Counter2.this); } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp != null) sp.invertFlag(); } } public static void main(String[] args) { Counter2 applet = new Counter2(); Frame aFrame = new Frame(\u0026#34;Counter2\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 现在，Counter2变成了一个相当直接的程序，它的唯一任务就是设置并管理用户界面。但假若用户现在按下Start按钮，却不会真正调用一个方法。此时不是创建类的一个线程，而是创建SeparateSubTask，然后继续Counter2事件循环。注意此时会保存SeparateSubTask的句柄，以便我们按下onOff按钮的时候，能正常地切换位于SeparateSubTask内部的runFlag（运行标志）。随后那个线程便可启动（当它看到标志的时候），然后将自己中止（亦可将SeparateSubTask设为一个内部类来达到这一目的）。\nSeparateSubTask类是对Thread的一个简单扩展，它带有一个构建器（其中保存了Counter2句柄，然后通过调用start()来运行线程）以及一个run()——本质上包含了Counter1.java的go()内的代码。由于SeparateSubTask知道自己容纳了指向一个Counter2的句柄，所以能够在需要的时候介入，并访问Counter2的TestField（文本字段）。 按下onOff按钮，几乎立即能得到正确的响应。当然，这个响应其实并不是“立即”发生的，它毕竟和那种由“中断”驱动的系统不同。只有线程拥有CPU的执行时间，并注意到标记已发生改变，计数器才会停止。\n用内部类改善代码 下面说说题外话，请大家注意一下SeparateSubTask和Counter2类之间发生的结合行为。SeparateSubTask同Counter2“亲密”地结合到了一起——它必须持有指向自己“父”Counter2对象的一个句柄，以便自己能回调和操纵它。但两个类并不是真的合并为单独一个类（尽管在下一节中，我们会讲到Java确实提供了合并它们的方法），因为它们各自做的是不同的事情，而且是在不同的时间创建的。但不管怎样，它们依然紧密地结合到一起（更准确地说，应该叫“联合”），所以使程序代码多少显得有些笨拙。在这种情况下，一个内部类可以显著改善代码的“可读性”和执行效率：\n//: Counter2i.java // Counter2 using an inner class for the thread import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter2i extends Applet { private class SeparateSubTask extends Thread { int count = 0; boolean runFlag = true; SeparateSubTask() { start(); } public void run() { while (true) { try { sleep(100); } catch (InterruptedException e){} if(runFlag) t.setText(Integer.toString(count++)); } } } private SeparateSubTask sp = null; private TextField t = new TextField(10); private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp == null) sp = new SeparateSubTask(); } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp != null) sp.runFlag = !sp.runFlag; // invertFlag(); } } public static void main(String[] args) { Counter2i applet = new Counter2i(); Frame aFrame = new Frame(\u0026#34;Counter2i\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 这个SeparateSubTask名字不会与前例中的SeparateSubTask冲突——即使它们都在相同的目录里——因为它已作为一个内部类隐藏起来。大家亦可看到内部类被设为private（私有）属性，这意味着它的字段和方法都可获得默认的访问权限（run()除外，它必须设为public，因为它在基础类中是公开的）。除Counter2i之外，其他任何方面都不可访问private内部类。而且由于两个类紧密结合在一起，所以很容易放宽它们之间的访问限制。在SeparateSubTask中，我们可看到invertFlag()方法已被删去，因为Counter2i现在可以直接访问runFlag。\n此外，注意SeparateSubTask的构建器已得到了简化——它现在唯一的用外就是启动线程。Counter2i对象的句柄仍象以前那样得以捕获，但不再是通过人工传递和引用外部对象来达到这一目的，此时的内部类机制可以自动照料它。在run()中，可看到对t的访问是直接进行的，似乎它是SeparateSubTask的一个字段。父类中的t字段现在可以变成private，因为SeparateSubTask能在未获任何特殊许可的前提下自由地访问它——而且无论如何都该尽可能地把字段变成“私有”属性，以防来自类外的某种力量不慎地改变它们。\n无论在什么时候，只要注意到类相互之间结合得比较紧密，就可考虑利用内部类来改善代码的编写与维护。\n内部类这玩意与对应类有点像线粒体与细胞的关系，处于类内部单不仅仅是方法能代替的。以对象分类，对象与对象关系结合紧密，就可考虑利用内部类来改善代码的编写与维护。\n14.1.3 用主类合并线程 在上面的例子中，我们看到线程类（Thread）与程序的主类（Main）是分隔开的。这样做非常合理，而且易于理解。然而，还有另一种方式也是经常要用到的。尽管它不十分明确，但一般都要更简洁一些（这也解释了它为什么十分流行）。通过将主程序类变成一个线程，这种形式可将主程序类与线程类合并到一起。由于对一个GUI程序来说，主程序类必须从Frame或Applet继承，所以必须用一个接口加入额外的功能。这个接口叫作Runnable，其中包含了与Thread一致的基本方法。事实上，Thread也实现了Runnable，它只指出有一个run()方法。\n对合并后的程序／线程来说，它的用法不是十分明确。当我们启动程序时，会创建一个Runnable（可运行的）对象，但不会自行启动线程。线程的启动必须明确进行。下面这个程序向我们演示了这一点，它再现了Counter2的功能：\n//: Counter3.java // Using the Runnable interface to turn the // main class into a thread. import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter3 extends Applet implements Runnable { private int count = 0; private boolean runFlag = true; private Thread selfThread = null; private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); private TextField t = new TextField(10); public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } public void run() { while (true) { try { selfThread.sleep(100); } catch (InterruptedException e){} if(runFlag) t.setText(Integer.toString(count++)); } } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(selfThread == null) { selfThread = new Thread(Counter3.this); selfThread.start(); } } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } public static void main(String[] args) { Counter3 applet = new Counter3(); Frame aFrame = new Frame(\u0026#34;Counter3\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 现在run()位于类内，但它在init()结束以后仍处在“睡眠”状态。若按下启动按钮，线程便会用多少有些暧昧的表达方式创建（若线程尚不存在）：\nnew Thread(Counter3.this); 若某样东西有一个Runnable接口，实际只是意味着它有一个run()方法，但不存在与之相关的任何特殊东西——它不具有任何天生的线程处理能力，这与那些从Thread继承的类是不同的。所以为了从一个Runnable对象产生线程，必须单独创建一个线程，并为其传递Runnable对象；可为其使用一个特殊的构建器，并令其采用一个Runnable作为自己的参数使用。随后便可为那个线程调用start()，如下所示：\nselfThread.start(); 它的作用是执行常规初始化操作，然后调用run()。\nRunnable接口最大的一个优点是所有东西都从属于相同的类。若需访问什么东西，只需简单地访问它即可，不需要涉及一个独立的对象。但为这种便利也是要付出代价的——只可为那个特定的对象运行单独一个线程（尽管可创建那种类型的多个对象，或者在不同的类里创建其他对象）。\n注意Runnable接口本身并不是造成这一限制的罪魁祸首。它是由于Runnable与我们的主类合并造成的，因为每个应用只能主类的一个对象。\n这说的什么玩应。。。\n14.1.4 制作多个线程 现在考虑一下创建多个不同的线程的问题。我们不可用前面的例子来做到这一点，所以必须倒退回去，利用从Thread继承的多个独立类来封装run()。但这是一种更常规的方案，而且更易理解，所以尽管前例揭示了我们经常都能看到的编码样式，但并不推荐在大多数情况下都那样做，因为它只是稍微复杂一些，而且灵活性稍低一些。\n下面这个例子用计数器和切换按钮再现了前面的编码样式。但这一次，一个特定计数器的所有信息（按钮和文本字段）都位于它自己的、从Thread继承的对象内。Ticker 中的所有字段都具有private（私有）属性，这意味着Ticker的具体实现方案可根据实际情况任意修改，其中包括修改用于获取和显示信息的数据组件的数量及类型。创建好一个 Ticker 对象以后，构建器便请求一个AWT容器（Container）的句柄—— Ticker 用自己的可视组件填充那个容器。采用这种方式，以后一旦改变了可视组件，使用 Ticker 的代码便不需要另行修改一道。\n//: Counter4.java // If you separate your thread from the main // class, you can have as many threads as you // want. import java.awt.*; import java.awt.event.*; import java.applet.*; class Ticker extends Thread { private Button b = new Button(\u0026#34;Toggle\u0026#34;); private TextField t = new TextField(10); private int count = 0; private boolean runFlag = true; public Ticker(Container c) { b.addActionListener(new ToggleL()); Panel p = new Panel(); p.add(t); p.add(b); c.add(p); } class ToggleL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } public void run() { while (true) { if(runFlag) t.setText(Integer.toString(count++)); try { sleep(100); } catch (InterruptedException e){} } } } public class Counter4 extends Applet { private Button start = new Button(\u0026#34;Start\u0026#34;); private boolean started = false; private Ticker[] s; private boolean isApplet = true; private int size; public void init() { // Get parameter \u0026#34;size\u0026#34; from Web page: if(isApplet) size = Integer.parseInt(getParameter(\u0026#34;size\u0026#34;)); s = new Ticker[size]; for(int i = 0; i \u0026lt; s.length; i++) s[i] = new Ticker(this); start.addActionListener(new StartL()); add(start); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(!started) { started = true; for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } } public static void main(String[] args) { Counter4 applet = new Counter4(); // This isn\u0026#39;t an applet, so set the flag and // produce the parameter values from args: applet.isApplet = false; applet.size = (args.length == 0 ? 5 : Integer.parseInt(args[0])); Frame aFrame = new Frame(\u0026#34;Counter4\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(200, applet.size * 50); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Ticker不仅包括了自己的线程处理机制，也提供了控制与显示线程的工具。可按自己的意愿创建任意数量的线程，毋需明确地创建窗口化组件。\n在Counter4中，有一个名为s的Ticker对象的数组。为获得最大的灵活性，这个数组的长度是用程序片参数接触Web页而初始化的。下面是网页中长度参数大致的样子，它们嵌于对程序片（applet）的描述内容中：\n\u0026lt;applet code=Counter4 width=600 height=600\u0026gt;\r\u0026lt;param name=size value=\u0026#34;20\u0026#34;\u0026gt;\r\u0026lt;/applet\u0026gt; 其中，param，name和value是所有Web页都适用的关键字。name是指程序中对参数的一种引用称谓，value可以是任何字串（并不仅仅是解析成一个数字的东西）。\n我们注意到对数组s长度的判断是在init()内部完成的，它没有作为s的内嵌定义的一部分提供。换言之，不可将下述代码作为类定义的一部分使用（应该位于任何方法的外部）：\ninst size = Integer.parseInt(getParameter(\u0026#34;Size\u0026#34;));\rTicker[] s = new Ticker[size] 可把它编译出来，但会在运行期得到一个空指针违例。但若将getParameter()初始化移入init()，则可正常工作。程序片框架会进行必要的启动工作，以便在进入init()前收集好一些参数。\n此外，上述代码被同时设置成一个程序片和一个应用（程序）。在它是应用程序的情况下，size参数可从命令行里提取出来（否则就提供一个默认的值）。\n数组的长度建好以后，就可以创建新的Ticker对象；作为Ticker构建器的一部分，用于每个Ticker的按钮和文本字段就会加入程序片。\n按下Start按钮后，会在整个Ticker数组里遍历，并为每个Ticker调用start()。记住，start()会进行必要的线程初始化工作，然后为那个线程调用run()。\nToggleL监视器只是简单地切换Ticker中的标记，一旦对应线程以后需要修改这个标记，它会作出相应的反应。\n这个例子的一个好处是它使我们能够方便地创建由单独子任务构成的大型集合，并以监视它们的行为。在这种情况下，我们会发现随着子任务数量的增多，机器显示出来的数字可能会出现更大的分歧，这是由于为线程提供服务的方式造成的。\n亦可试着体验一下sleep(100)在Ticker.run()中的重要作用。若删除sleep()，那么在按下一个切换按钮前，情况仍然会进展良好。按下按钮以后，那个特定的线程就会出现一个失败的runFlag，而且run()会深深地陷入一个无限循环——很难在多任务处理期间中止退出。因此，程序对用户操作的反应灵敏度会大幅度降低。\n14.1.5 Daemon线程(守护线程) “Daemon”线程的作用是在程序的运行期间于后台提供一种“常规”服务，但它并不属于程序的一个基本部分。因此，一旦所有非 Daemon 线程完成，程序也会中止运行。相反，假若有任何非Daemon线程仍在运行（比如还有一个正在运行main()的线程），则程序的运行不会中止。\n通过调用isDaemon()，可调查一个线程是不是一个Daemon，而且能用setDaemon()打开或者关闭一个线程的Daemon状态。如果是一个Daemon线程，那么它创建的任何线程也会自动具备Daemon属性。 下面这个例子演示了Daemon线程的用法：\nJava线程中的Thread.yield( )方法，\n译为线程让步。\n顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行，注意是让自己或者其他线程运行，并不是单纯的让给其他线程。yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n//: Daemons.java // Daemonic behavior import java.io.*; class Daemon extends Thread { private static final int SIZE = 10; private Thread[] t = new Thread[SIZE]; public Daemon() { setDaemon(true); start(); } public void run() { for(int i = 0; i \u0026lt; SIZE; i++) t[i] = new DaemonSpawn(i); for(int i = 0; i \u0026lt; SIZE; i++) System.out.println( \u0026#34;t[\u0026#34; + i + \u0026#34;].isDaemon() = \u0026#34; + t[i].isDaemon()); while(true) yield(); } } class DaemonSpawn extends Thread { public DaemonSpawn(int i) { System.out.println( \u0026#34;DaemonSpawn \u0026#34; + i + \u0026#34; started\u0026#34;); start(); } public void run() { while(true) yield(); } } public class Daemons { public static void main(String[] args) { Thread d = new Daemon(); System.out.println( \u0026#34;d.isDaemon() = \u0026#34; + d.isDaemon()); // Allow the daemon threads to finish // their startup processes: BufferedReader stdin = new BufferedReader( new InputStreamReader(System.in)); System.out.println(\u0026#34;Waiting for CR\u0026#34;); try { stdin.readLine(); } catch(IOException e) {} } } ///:~ Daemon线程可将自己的Daemon标记设置成“真”，然后产生一系列其他线程，而且认为它们也具有Daemon属性。随后，它进入一个无限循环，在其中调用yield()，放弃对其他进程的控制。在这个程序早期的一个版本中，无限循环会使int计数器增值，但会使整个程序都好象陷入停顿状态。换用yield()后，却可使程序充满“活力”，不会使人产生停滞或反应迟钝的感觉。\n一旦main()完成自己的工作，便没有什么能阻止程序中断运行，因为这里运行的只有Daemon线程。所以能看到启动所有Daemon线程后显示出来的结果，System.in也进行了相应的设置，使程序中断前能等待一个回车。如果不进行这样的设置，就只能看到创建Daemon线程的一部分结果（试试将readLine()代码换成不同长度的sleep()调用，看看会有什么表现）。\n14.2 共享有限的资源 可将单线程程序想象成一种孤立的实体，它能遍历我们的问题空间，而且一次只能做一件事情。由于只有一个实体，所以永远不必担心会有两个实体同时试图使用相同的资源，就象两个人同时都想停到一个车位，同时都想通过一扇门，甚至同时发话。\n进入多线程环境后，它们则再也不是孤立的。可能会有两个甚至更多的线程试图同时同一个有限的资源。必须对这种潜在资源冲突进行预防，否则就可能发生两个线程同时访问一个银行帐号，打印到同一台计算机，以及对同一个值进行调整等等。\n14.2.1 资源访问的错误方法 现在考虑换成另一种方式来使用本章频繁见到的计数器。在下面的例子中，每个线程都包含了两个计数器，它们在run()里增值以及显示。除此以外，我们使用了Watcher类的另一个线程。它的作用是监视计数器，检查它们是否保持相等。这表面是一项无意义的行动，因为如果查看代码，就会发现计数器肯定是相同的。但实际情况却不一定如此。下面是程序的第一个版本：\n//: Sharing1.java // Problems with resource sharing while threading import java.awt.*; import java.awt.event.*; import java.applet.*; class TwoCounter extends Thread { private boolean started = false; private TextField t1 = new TextField(5), t2 = new TextField(5); private Label l = new Label(\u0026#34;count1 == count2\u0026#34;); private int count1 = 0, count2 = 0; // Add the display components as a panel // to the given container: public TwoCounter(Container c) { Panel p = new Panel(); p.add(t1); p.add(t2); p.add(l); c.add(p); } public void start() { if(!started) { started = true; super.start(); } } public void run() { while (true) { t1.setText(Integer.toString(count1++)); t2.setText(Integer.toString(count2++)); try { sleep(500); } catch (InterruptedException e){} } } public void synchTest() { Sharing1.incrementAccess(); if(count1 != count2) l.setText(\u0026#34;Unsynched\u0026#34;); } } class Watcher extends Thread { private Sharing1 p; public Watcher(Sharing1 p) { this.p = p; start(); } public void run() { while(true) { for(int i = 0; i \u0026lt; p.s.length; i++) p.s[i].synchTest(); try { sleep(500); } catch (InterruptedException e){} } } } public class Sharing1 extends Applet { TwoCounter[] s; private static int accessCount = 0; private static TextField aCount = new TextField(\u0026#34;0\u0026#34;, 10); public static void incrementAccess() { accessCount++; aCount.setText(Integer.toString(accessCount)); } private Button start = new Button(\u0026#34;Start\u0026#34;), observer = new Button(\u0026#34;Observe\u0026#34;); private boolean isApplet = true; private int numCounters = 0; private int numObservers = 0; public void init() { if(isApplet) { numCounters = Integer.parseInt(getParameter(\u0026#34;size\u0026#34;)); numObservers = Integer.parseInt( getParameter(\u0026#34;observers\u0026#34;)); } s = new TwoCounter[numCounters]; for(int i = 0; i \u0026lt; s.length; i++) s[i] = new TwoCounter(this); Panel p = new Panel(); start.addActionListener(new StartL()); p.add(start); observer.addActionListener(new ObserverL()); p.add(observer); p.add(new Label(\u0026#34;Access Count\u0026#34;)); p.add(aCount); add(p); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } class ObserverL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; numObservers; i++) new Watcher(Sharing1.this); } } public static void main(String[] args) { Sharing1 applet = new Sharing1(); // This isn\u0026#39;t an applet, so set the flag and // produce the parameter values from args: applet.isApplet = false; applet.numCounters = (args.length == 0 ? 5 : Integer.parseInt(args[0])); applet.numObservers = (args.length \u0026lt; 2 ? 5 : Integer.parseInt(args[1])); Frame aFrame = new Frame(\u0026#34;Sharing1\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(350, applet.numCounters *100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 和往常一样，每个计数器都包含了自己的显示组件：两个文本字段以及一个标签。根据它们的初始值，可知道计数是相同的。这些组件在TwoCounter构建器加入Container。由于这个线程是通过用户的一个“按下按钮”操作启动的，所以start()可能被多次调用。但对一个线程来说，对Thread.start()的多次调用是非法的（会产生违例）。在started标记和过载的start()方法中，大家可看到针对这一情况采取的防范措施。\n在run()中，count1和count2的增值与显示方式表面上似乎能保持它们完全一致。随后会调用sleep()；若没有这个调用，程序便会出错，因为那会造成CPU难于交换任务。\nsynchTest()方法采取的似乎是没有意义的行动，它检查count1是否等于count2；如果不等，就把标签设为“Unsynched”（不同步）。但是首先，它调用的是类Sharing1的一个静态成员，以便增值和显示一个访问计数器，指出这种检查已成功进行了多少次（这样做的理由会在本例的其他版本中变得非常明显）。\nWatcher类是一个线程，它的作用是为处于活动状态的所有TwoCounter对象都调用synchTest()。其间，它会对Sharing1对象中容纳的数组进行遍历。可将Watcher想象成它掠过TwoCounter对象的肩膀不断地“偷看”。\nSharing1包含了TwoCounter对象的一个数组，它通过init()进行初始化，并在我们按下“start”按钮后作为线程启动。以后若按下“Observe”（观察）按钮，就会创建一个或者多个观察器，并对毫不设防的TwoCounter进行调查。 注意为了让它作为一个程序片在浏览器中运行，Web页需要包含下面这几行：\n\u0026lt;applet code=Sharing1 width=650 height=500\u0026gt;\r\u0026lt;param name=size value=\u0026#34;20\u0026#34;\u0026gt;\r\u0026lt;param name=observers value=\u0026#34;1\u0026#34;\u0026gt;\r\u0026lt;/applet\u0026gt; 可自行改变宽度、高度以及参数，根据自己的意愿进行试验。若改变了size和observers，程序的行为也会发生变化。我们也注意到，通过从命令行接受参数（或者使用默认值），它被设计成作为一个独立的应用程序运行。\n下面才是最让人“不可思议”的。在TwoCounter.run()中，无限循环只是不断地重复相邻的行:\nt1.setText(Integer.toString(count1++));\rt2.setText(Integer.toString(count2++)); （和“睡眠”一样，不过在这里并不重要）。但在程序运行的时候，你会发现count1和count2被“观察”（用Watcher观察）的次数是不相等的！这是由线程的本质造成的——它们可在任何时候挂起（暂停）。所以在上述两行的执行时刻之间，有时会出现执行暂停现象。同时，Watcher线程也正好跟随着进来，并正好在这个时候进行比较，造成计数器出现不相等的情况。\n本例揭示了使用线程时一个非常基本的问题。我们跟无从知道一个线程什么时候运行。想象自己坐在一张桌子前面，桌上放有一把叉子，准备叉起自己的最后一块食物。当叉子要碰到食物时，食物却突然消失了（因为这个线程已被挂起，同时另一个线程进来“偷”走了食物）。这便是我们要解决的问题。\n有的时候，我们并不介意一个资源在尝试使用它的时候是否正被访问（食物在另一些盘子里）。但为了让多线程机制能够正常运转，需要采取一些措施来防止两个线程访问相同的资源——至少在关键的时期。\n为防止出现这样的冲突，只需在线程使用一个资源时为其加锁即可。访问资源的第一个线程会其加上锁以后，其他线程便不能再使用那个资源，除非被解锁。如果车子的前座是有限的资源，高喊“这是我的！”的孩子会主张把它锁起来。\n14.2.2 Java如何共享资源 对一种特殊的资源——对象中的内存——Java提供了内建的机制来防止它们的冲突。由于我们通常将数据元素设为从属于private（私有）类，然后只通过方法访问那些内存，所以只需将一个特定的方法设为synchronized（同步的），便可有效地防止冲突。在任何时刻，只可有一个线程调用特定对象的一个synchronized方法（尽管那个线程可以调用多个对象的同步方法）。下面列出简单的synchronized方法\nsynchronized void f() { /* ... */ }\rsynchronized void g() { /* ... */ } 每个对象都包含了一把锁（也叫作“监视器”），它自动成为对象的一部分（不必为此写任何特殊的代码）。调用任何synchronized方法时，对象就会被锁定，不可再调用那个对象的其他任何synchronized方法，除非第一个方法完成了自己的工作，并解除锁定。在上面的例子中，如果为一个对象调用f()，便不能再为同样的对象调用g()，除非f()完成并解除锁定。因此，一个特定对象的所有synchronized方法都共享着一把锁，而且这把锁能防止多个方法对通用内存同时进行写操作（比如同时有多个线程）。\n一个特定对象的所有synchronized方法都共享着一把锁\n每个类也有自己的一把锁（作为类的Class对象的一部分），所以synchronized static方法可在一个类的范围内被相互间锁定起来，防止与static数据的接触。\n一个类所有synchronized static 方法都共享着一把锁\n注意如果想保护其他某些资源不被多个线程同时访问，可以强制通过 synchronized 方访问那些资源。\n计数器的同步 装备了这个新关键字后，我们能够采取的方案就更灵活了：可以只为TwoCounter中的方法简单地使用synchronized关键字。下面这个例子是对前例的改版，其中加入了新的关键字：\n//: Sharing2.java // Using the synchronized keyword to prevent // multiple access to a particular resource. import java.awt.*; import java.awt.event.*; import java.applet.*; class TwoCounter2 extends Thread { private boolean started = false; private TextField t1 = new TextField(5), t2 = new TextField(5); private Label l = new Label(\u0026#34;count1 == count2\u0026#34;); private int count1 = 0, count2 = 0; public TwoCounter2(Container c) { Panel p = new Panel(); p.add(t1); p.add(t2); p.add(l); c.add(p); } public void start() { if(!started) { started = true; super.start(); } } public synchronized void run() { while (true) { t1.setText(Integer.toString(count1++)); t2.setText(Integer.toString(count2++)); try { sleep(500); } catch (InterruptedException e){} } } public synchronized void synchTest() { Sharing2.incrementAccess(); if(count1 != count2) l.setText(\u0026#34;Unsynched\u0026#34;); } } class Watcher2 extends Thread { private Sharing2 p; public Watcher2(Sharing2 p) { this.p = p; start(); } public void run() { while(true) { for(int i = 0; i \u0026lt; p.s.length; i++) p.s[i].synchTest(); try { sleep(500); } catch (InterruptedException e){} } } } public class Sharing2 extends Applet { TwoCounter2[] s; private static int accessCount = 0; private static TextField aCount = new TextField(\u0026#34;0\u0026#34;, 10); public static void incrementAccess() { accessCount++; aCount.setText(Integer.toString(accessCount)); } private Button start = new Button(\u0026#34;Start\u0026#34;), observer = new Button(\u0026#34;Observe\u0026#34;); private boolean isApplet = true; private int numCounters = 0; private int numObservers = 0; public void init() { if(isApplet) { numCounters = Integer.parseInt(getParameter(\u0026#34;size\u0026#34;)); numObservers = Integer.parseInt( getParameter(\u0026#34;observers\u0026#34;)); } s = new TwoCounter2[numCounters]; for(int i = 0; i \u0026lt; s.length; i++) s[i] = new TwoCounter2(this); Panel p = new Panel(); start.addActionListener(new StartL()); p.add(start); observer.addActionListener(new ObserverL()); p.add(observer); p.add(new Label(\u0026#34;Access Count\u0026#34;)); p.add(aCount); add(p); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } class ObserverL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; numObservers; i++) new Watcher2(Sharing2.this); } } public static void main(String[] args) { Sharing2 applet = new Sharing2(); // This isn\u0026#39;t an applet, so set the flag and // produce the parameter values from args: applet.isApplet = false; applet.numCounters = (args.length == 0 ? 5 : Integer.parseInt(args[0])); applet.numObservers = (args.length \u0026lt; 2 ? 5 : Integer.parseInt(args[1])); Frame aFrame = new Frame(\u0026#34;Sharing2\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(350, applet.numCounters *100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 我们注意到无论run()还是synchTest()都是“同步的”。如果只同步其中的一个方法，那么另一个就可以自由忽视对象的锁定，并可无碍地调用。所以必须记住一个重要的规则：对于访问某个关键共享资源的所有方法，都必须把它们设为synchronized，否则就不能正常地工作。\n现在又遇到了一个新问题。Watcher2永远都不能看到正在进行的事情，因为整个run()方法已设为“同步”。而且由于肯定要为每个对象运行run()，所以锁永远不能打开，而synchTest()永远不会得到调用。之所以能看到这一结果，是因为accessCount根本没有变化。\n为解决这个问题，我们能采取的一个办法是只将run()中的一部分代码隔离出来。想用这个办法隔离出来的那部分代码叫作“关键区域”，而且要用不同的方式来使用synchronized关键字，以设置一个关键区域。Java通过“同步块”提供对关键区域的支持；这一次，我们用synchronized关键字指出对象的锁用于对其中封闭的代码进行同步。\n在能进入同步块之前，必须在synchObject上取得锁。如果已有其他线程取得了这把锁，块便不能进入，必须等候那把锁被释放。 可从整个run()中删除synchronized关键字，换成用一个同步块包围两个关键行，从而完成对Sharing2例子的修改。但什么对象应作为锁来使用呢？那个对象已由synchTest()标记出来了——也就是当前对象（this）！所以修改过的run()方法象下面这个样子：\npublic void run() {\rwhile (true) {\rsynchronized(this) {\rt1.setText(Integer.toString(count1++));\rt2.setText(Integer.toString(count2++));\r}\rtry {\rsleep(500);\r} catch (InterruptedException e){}\r}\r} 这是必须对Sharing2.java作出的唯一修改，我们会看到尽管两个计数器永远不会脱离同步（取决于允许Watcher什么时候检查它们），但在run()执行期间，仍然向Watcher提供了足够的访问权限。\n当然，所有同步都取决于程序员是否勤奋：要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。\n同步的效率 由于要为同样的数据编写两个方法，所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做法是将所有方法都设为自动同步，并完全消除synchronized关键字（当然，含有synchronized run()的例子显示出这样做是很不通的）。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的代价（进入和退出方法，不执行方法主体）至少要累加到四倍，而且根据我们的具体现方案，这一代价还有可能变得更高。所以假如已知一个方法不会造成冲突，最明智的做法便是撤消其中的synchronized关键字。\n14.2.3 回顾 Java Beans 我们现在已理解了同步，接着可换从另一个角度来考察Java Beans。无论什么时候创建了一个Bean，就必须假定它要在一个多线程的环境中运行。这意味着：\n(1) 只要可行，Bean的所有公共方法都应同步。当然，这也带来了“同步”在运行期间的开销。若特别在意这个问题，在关键区域中不会造成问题的方法就可保留为“不同步”，但注意这通常都不是十分容易判断。有资格的方法倾向于规模很小（如下例的getCircleSize()）以及／或者“微小”。也就是说，这个方法调用在如此少的代码片里执行，以至于在执行期间对象不能改变。如果将这种方法设为“不同步”，可能对程序的执行速度不会有明显的影响。可能也将一个Bean的所有public方法都设为synchronized，并只有在保证特别必要、而且会造成一个差异的情况下，才将synchronized关键字删去。\n并只有在保证特别必要、而且会造成一个差异的情况下，才将synchronized关键字删去。\n(2) 如果将一个多造型事件送给一系列对那个事件感兴趣的“听众”，必须假在列表中移动的时候可以添加或者删除。\n第一点很容易处理，但第二点需要考虑更多的东西。让我们以前一章提供的BangBean.java为例。在那个例子中，我们忽略了synchronized关键字（那时还没有引入呢），并将造型设为单造型，从而回避了多线程的问题。在下面这个修改过的版本中，我们使其能在多线程环境中工作，并为事件采用了多造型技术：\n//: BangBean2.java // You should write your Beans this way so they // can run in a multithreaded environment. import java.awt.*; import java.awt.event.*; import java.util.*; import java.io.*; public class BangBean2 extends Canvas implements Serializable { private int xm, ym; private int cSize = 20; // Circle size private String text = \u0026#34;Bang!\u0026#34;; private int fontSize = 48; private Color tColor = Color.red; private Vector actionListeners = new Vector(); public BangBean2() { addMouseListener(new ML()); addMouseMotionListener(new MM()); } public synchronized int getCircleSize() { return cSize; } public synchronized void setCircleSize(int newSize) { cSize = newSize; } public synchronized String getBangText() { return text; } public synchronized void setBangText(String newText) { text = newText; } public synchronized int getFontSize() { return fontSize; } public synchronized void setFontSize(int newSize) { fontSize = newSize; } public synchronized Color getTextColor() { return tColor; } public synchronized void setTextColor(Color newColor) { tColor = newColor; } public void paint(Graphics g) { g.setColor(Color.black); g.drawOval(xm - cSize/2, ym - cSize/2, cSize, cSize); } // This is a multicast listener, which is // more typically used than the unicast // approach taken in BangBean.java: public synchronized void addActionListener ( ActionListener l) { actionListeners.addElement(l); } public synchronized void removeActionListener( ActionListener l) { actionListeners.removeElement(l); } // Notice this isn\u0026#39;t synchronized: public void notifyListeners() { ActionEvent a = new ActionEvent(BangBean2.this, ActionEvent.ACTION_PERFORMED, null); Vector lv = null; // Make a copy of the vector in case someone // adds a listener while we\u0026#39;re // calling listeners: synchronized(this) { lv = (Vector)actionListeners.clone(); } // Call all the listener methods: for(int i = 0; i \u0026lt; lv.size(); i++) { ActionListener al = (ActionListener)lv.elementAt(i); al.actionPerformed(a); } } class ML extends MouseAdapter { public void mousePressed(MouseEvent e) { Graphics g = getGraphics(); g.setColor(tColor); g.setFont( new Font( \u0026#34;TimesRoman\u0026#34;, Font.BOLD, fontSize)); int width = g.getFontMetrics().stringWidth(text); g.drawString(text, (getSize().width - width) /2, getSize().height/2); g.dispose(); notifyListeners(); } } class MM extends MouseMotionAdapter { public void mouseMoved(MouseEvent e) { xm = e.getX(); ym = e.getY(); repaint(); } } // Testing the BangBean2: public static void main(String[] args) { BangBean2 bb = new BangBean2(); bb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e){ System.out.println(\u0026#34;ActionEvent\u0026#34; + e); } }); bb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e){ System.out.println(\u0026#34;BangBean2 action\u0026#34;); } }); bb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e){ System.out.println(\u0026#34;More action\u0026#34;); } }); Frame aFrame = new Frame(\u0026#34;BangBean2 Test\u0026#34;); aFrame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(bb, BorderLayout.CENTER); aFrame.setSize(300,300); aFrame.setVisible(true); } } ///:~ 很容易就可以为方法添加synchronized。但注意在addActionListener()和removeActionListener()中，现在添加了ActionListener，并从一个Vector中移去，所以能够根据自己愿望使用任意多个。\n我们注意到，notifyListeners()方法并未设为“同步”。可从多个线程中发出对这个方法的调用。另外，在对notifyListeners()调用的中途，也可能发出对addActionListener()和removeActionListener()的调用。这显然会造成问题，因为它否定了Vector actionListeners。为缓解这个问题，我们在一个synchronized从句中“克隆”了Vector，并对克隆进行了否定。这样便可在不影响notifyListeners()的前提下，对Vector进行操纵。\npaint()方法也没有设为“同步”。与单纯地添加自己的方法相比，决定是否对过载的方法进行同步要困难得多。在这个例子中，无论paint()是否“同步”，它似乎都能正常地工作。但必须考虑的问题包括：\n(1) 方法会在对象内部修改“关键”变量的状态吗？为判断一个变量是否“关键”，必须知道它是否会被程序中的其他线程读取或设置（就目前的情况看，读取或设置几乎肯定是通过“同步”方法进行的，所以可以只对它们进行检查）。对paint()的情况来说，不会发生任何修改。\n(2) 方法要以这些“关键”变量的状态为基础吗？如果一个“同步”方法修改了一个变量，而我们的方法要用到这个变量，那么一般都愿意把自己的方法也设为“同步”。基于这一前提，大家可观察到cSize由“同步”方法进行了修改，所以paint()应当是“同步”的。但在这里，我们可以问：“假如cSize在paint()执行期间发生了变化，会发生的最糟糕的事情是什么呢？”如果发现情况不算太坏，而且仅仅是暂时的效果，那么最好保持paint()的“不同步”状态，以避免同步方法调用带来的额外开销。\n(3) 要留意的第三条线索是paint()基础类版本是否“同步”，在这里它不是同步的。这并不是一个非常严格的参数，仅仅是一条“线索”。比如在目前的情况下，通过同步方法（好cSize）改变的一个字段已合成到paint()公式里，而且可能已改变了情况。但请注意，synchronized不能继承——也就是说，假如一个方法在基础类中是“同步”的，那么在衍生类过载版本中，它不会自动进入“同步”状态。\nsynchronized不能继承——也就是说，假如一个方法在基础类中是“同步”的，那么在衍生类过载版本中，它不会自动进入“同步”状态。\nTestBangBean2中的测试代码已在前一章的基础上进行了修改，已在其中加入了额外的“听众”，从而演示了BangBean2的多造型能力。\n14.3 堵塞 (1) 新（New）：线程对象已经创建，但尚未启动，所以不可运行。\n(2) 可运行（Runnable）：意味着一旦时间分片机制有空闲的CPU周期提供给一个线程，那个线程便可立即开始运行。因此，线程可能在、也可能不在运行当中，但一旦条件许可，没有什么能阻止它的运行——它既没有“死”掉，也未被“堵塞”。\n(3) 死（Dead）：从自己的run()方法中返回后，一个线程便已“死”掉。亦可调用stop()令其死掉，但会产生一个违例——属于 Error的一个子类（也就是说，我们通常不捕获它）。记住一个违例的“掷”出应当是一个特殊事件，而不是正常程序运行的一部分。所以不建议你使用stop()（在Java 1.2则是坚决反对）。另外还有一个destroy()方法（它永远不会实现），应该尽可能地避免调用它，因为它非常武断，根本不会解除对象的锁定。\n(4) 堵塞（Blocked）：线程可以运行，但有某种东西阻碍了它。若线程处于堵塞状态，调度机制可以简单地跳过它，不给它分配任何CPU时间。除非线程再次进入“可运行”状态，否则不会采取任何操作。\n14.3.1 为何会堵塞 堵塞状态是前述四种状态中最有趣的，值得我们作进一步的探讨。线程被堵塞可能是由下述五方面的原因造成的：\n(1) 调用sleep(毫秒数)，使线程进入“睡眠”状态。在规定的时间内，这个线程是不会运行的。\n(2) 用suspend()暂停了线程的执行。除非线程收到resume()消息，否则不会返回“可运行”状态。\n(3) 用wait()暂停了线程的执行。除非线程收到nofify()或者notifyAll()消息，否则不会变成“可运行”（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。\n(4) 线程正在等候一些IO（输入输出）操作完成。\n(5) 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。\n亦可调用yield()（Thread类的一个方法）自动放弃CPU，以便其他线程能够运行。然而，假如调度机制觉得我们的线程已拥有足够的时间，并跳转到另一个线程，就会发生同样的事情。也就是说，没有什么能防止调度机制重新启动我们的线程。线程被堵塞后，便有一些原因造成它不能继续运行。\n下面这个例子展示了进入堵塞状态的全部五种途径。它们全都存在于名为Blocking.java的一个文件中，但在这儿采用散落的片断进行解释（大家可注意到片断前后的“Continued”以及“Continuing”标志。利用第17章介绍的工具，可将这些片断连结到一起）。首先让我们看看基本的框架：\n//: Blocking.java // Demonstrates the various ways a thread // can be blocked. import java.awt.*; import java.awt.event.*; import java.applet.*; import java.io.*; //////////// The basic framework /////////// class Blockable extends Thread { private Peeker peeker; protected TextField state = new TextField(40); protected int i; public Blockable(Container c) { c.add(state); peeker = new Peeker(this, c); } public synchronized int read() { return i; } protected synchronized void update() { state.setText(getClass().getName() + \u0026#34; state: i = \u0026#34; + i); } public void stopPeeker() { // peeker.stop(); Deprecated in Java 1.2 peeker.terminate(); // The preferred approach } } class Peeker extends Thread { private Blockable b; private int session; private TextField status = new TextField(40); private boolean stop = false; public Peeker(Blockable b, Container c) { c.add(status); this.b = b; start(); } public void terminate() { stop = true; } public void run() { while (!stop) { status.setText(b.getClass().getName() + \u0026#34; Peeker \u0026#34; + (++session) + \u0026#34;; value = \u0026#34; + b.read()); try { sleep(100); } catch (InterruptedException e){} } } } ///:Continued Blockable类打算成为本例所有类的一个基础类。一个Blockable对象包含了一个名为state的TextField（文本字段），用于显示出对象有关的信息。用于显示这些信息的方法叫作update()。我们发现它用getClass.getName()来产生类名，而不是仅仅把它打印出来；这是由于update(0不知道自己为其调用的那个类的准确名字，因为那个类是从Blockable衍生出来的。 在Blockable中，变动指示符是一个int i；衍生类的run()方法会为其增值。\n针对每个Bloackable对象，都会启动Peeker类的一个线程。Peeker的任务是调用read()方法，检查与自己关联的Blockable对象，看看i是否发生了变化，最后用它的status文本字段报告检查结果。注意read()和update()都是同步的，要求对象的锁定能自由解除，这一点非常重要。\n睡眠 这个程序的第一项测试是用sleep()作出的：\n///:Continuing ///////////// Blocking via sleep() /////////// class Sleeper1 extends Blockable { public Sleeper1(Container c) { super(c); } public synchronized void run() { while(true) { i++; update(); try { sleep(1000); } catch (InterruptedException e){} } } } class Sleeper2 extends Blockable { public Sleeper2(Container c) { super(c); } public void run() { while(true) { change(); try { sleep(1000); } catch (InterruptedException e){} } } public synchronized void change() { i++; update(); } } ///:Continued 在Sleeper1中，整个run()方法都是同步的。我们可看到与这个对象关联在一起的Peeker可以正常运行，直到我们启动线程为止，随后Peeker便会完全停止。这正是“堵塞”的一种形式：因为Sleeper1.run()是同步的，而且一旦线程启动，它就肯定在run()内部，方法永远不会放弃对象锁定，造成Peeker线程的堵塞。\nSleeper2通过设置不同步的运行，提供了一种解决方案。只有change()方法才是同步的，所以尽管run()位于sleep()内部，Peeker仍然能访问自己需要的同步方法——read()。在这里，我们可看到在启动了Sleeper2线程以后，Peeker会持续运行下去。\n暂停和恢复 这个例子接下来的一部分引入了“挂起”或者“暂停”（Suspend）的概述。Thread类提供了一个名为suspend()的方法，可临时中止线程；以及一个名为resume()的方法，用于从暂停处开始恢复线程的执行。显然，我们可以推断出resume()是由暂停线程外部的某个线程调用的。在这种情况下，需要用到一个名为Resumer（恢复器）的独立类。演示暂停／恢复过程的每个类都有一个相关的恢复器。如下所示：\n///:Continuing /////////// Blocking via suspend() /////////// class SuspendResume extends Blockable { public SuspendResume(Container c) { super(c); new Resumer(this); } } class SuspendResume1 extends SuspendResume { public SuspendResume1(Container c) { super(c);} public synchronized void run() { while(true) { i++; update(); suspend(); // Deprecated in Java 1.2 } } } class SuspendResume2 extends SuspendResume { public SuspendResume2(Container c) { super(c);} public void run() { while(true) { change(); suspend(); // Deprecated in Java 1.2 } } public synchronized void change() { i++; update(); } } class Resumer extends Thread { private SuspendResume sr; public Resumer(SuspendResume sr) { this.sr = sr; start(); } public void run() { while(true) { try { sleep(1000); } catch (InterruptedException e){} sr.resume(); // Deprecated in Java 1.2 } } } ///:Continued SuspendResume1也提供了一个同步的run()方法。同样地，当我们启动这个线程以后，就会发现与它关联的Peeker进入“堵塞”状态，等候对象锁被释放，但那永远不会发生。和往常一样，这个问题在SuspendResume2里得到了解决，它并不同步整个run()方法，而是采用了一个单独的同步change()方法。\n对于Java 1.2，大家应注意suspend()和resume()已获得强烈反对，因为suspend()包含了对象锁，所以极易出现“死锁”现象。换言之，很容易就会看到许多被锁住的对象在傻乎乎地等待对方。这会造成整个应用程序的“凝固”。尽管在一些老程序中还能看到它们的踪迹，但在你写自己的程序时，无论如何都应避免。本章稍后就会讲述正确的方案是什么。\n等待和通知 通过前两个例子的实践，我们知道无论sleep()还是suspend()都不会在自己被调用的时候解除锁定。需要用到对象锁时，请务必注意这个问题。在另一方面，wait()方法在被调用时却会解除锁定，这意味着可在执行wait()期间调用线程对象中的其他同步方法。但在接着的两个类中，我们看到run()方法都是“同步”的。在wait()期间，Peeker仍然拥有对同步方法的完全访问权限。这是由于wait()在挂起内部调用的方法时，会解除对象的锁定。\n我们也可以看到wait()的两种形式。第一种形式采用一个以毫秒为单位的参数，它具有与sleep()中相同的含义：暂停这一段规定时间。区别在于在wait()中，对象锁已被解除，而且能够自由地退出wait()，因为一个notify()可强行使时间流逝。\n第二种形式不采用任何参数，这意味着wait()会持续执行，直到notify()介入为止。而且在一段时间以后，不会自行中止。 wait()和notify()比较特别的一个地方是这两个方法都属于基础类Object的一部分，不象sleep()，suspend()以及resume()那样属于Thread的一部分。尽管这表面看有点儿奇怪——居然让专门进行线程处理的东西成为通用基础类的一部分——但仔细想想又会释然，因为它们操纵的对象锁也属于每个对象的一部分。因此，我们可将一个wait()置入任何同步方法内部，无论在那个类里是否准备进行涉及线程的处理。事实上，我们能调用wait()的唯一地方是在一个同步的方法或代码块内部。若在一个不同步的方法内调用wait()或者notify()，尽管程序仍然会编译，但在运行它的时候，就会得到一个IllegalMonitorStateException（非法监视器状态违例），而且会出现多少有点莫名其妙的一条消息：“current thread not owner”（当前线程不是所有人”。注意sleep()，suspend()以及resume()都能在不同步的方法内调用，因为它们不需要对锁定进行操作。\n只能为自己的锁定调用wait()和notify()。同样地，仍然可以编译那些试图使用错误锁定的代码，但和往常一样会产生同样的IllegalMonitorStateException违例。我们没办法用其他人的对象锁来愚弄系统，但可要求另一个对象执行相应的操作，对它自己的锁进行操作。所以一种做法是创建一个同步方法，令其为自己的对象调用notify()。但在Notifier中，我们会看到一个同步方法内部的notify()：\nsynchronized(wn2) {\rwn2.notify();\r} 其中，wn2是类型为WaitNotify2的对象。尽管并不属于WaitNotify2的一部分，这个方法仍然获得了wn2对象的锁定。在这个时候，它为wn2调用notify()是合法的，不会得到IllegalMonitorStateException违例。\n///:Continuing /////////// Blocking via wait() /////////// class WaitNotify1 extends Blockable { public WaitNotify1(Container c) { super(c); } public synchronized void run() { while(true) { i++; update(); try { wait(1000); } catch (InterruptedException e){} } } } class WaitNotify2 extends Blockable { public WaitNotify2(Container c) { super(c); new Notifier(this); } public synchronized void run() { while(true) { i++; update(); try { wait(); } catch (InterruptedException e){} } } } class Notifier extends Thread { private WaitNotify2 wn2; public Notifier(WaitNotify2 wn2) { this.wn2 = wn2; start(); } public void run() { while(true) { try { sleep(2000); } catch (InterruptedException e){} synchronized(wn2) { wn2.notify(); } } } } ///:Continued 若必须等候其他某些条件（从线程外部加以控制）发生变化，同时又不想在线程内一直傻乎乎地等下去，一般就需要用到wait()。wait()允许我们将线程置入“睡眠”状态，同时又“积极”地等待条件发生改变。而且只有在一个notify()或notifyAll()发生变化的时候，线程才会被唤醒，并检查条件是否有变。因此，我们认为它提供了在线程间进行同步的一种手段。\nIO堵塞 若一个数据流必须等候一些IO活动，便会自动进入“堵塞”状态。在本例下面列出的部分中，有两个类协同通用的Reader以及Writer对象工作（使用Java 1.1的流）。但在测试模型中，会设置一个管道化的数据流，使两个线程相互间能安全地传递数据（这正是使用管道流的目的）。\nSender将数据置入Writer，并“睡眠”随机长短的时间。然而，Receiver本身并没有包括sleep()，suspend()或者wait()方法。但在执行read()的时候，如果没有数据存在，它会自动进入“堵塞”状态。如下所示：\n///:Continuing class Sender extends Blockable { // send private Writer out; public Sender(Container c, Writer out) { super(c); this.out = out; } public void run() { while(true) { for(char c = \u0026#39;A\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) { try { i++; out.write(c); state.setText(\u0026#34;Sender sent: \u0026#34; + (char)c); sleep((int)(3000 * Math.random())); } catch (InterruptedException e){} catch (IOException e) {} } } } } class Receiver extends Blockable { private Reader in; public Receiver(Container c, Reader in) { super(c); this.in = in; } public void run() { try { while(true) { i++; // Show peeker it\u0026#39;s alive // Blocks until characters are there: state.setText(\u0026#34;Receiver read: \u0026#34; + (char)in.read()); } } catch(IOException e) { e.printStackTrace();} } } ///:Continued 这两个类也将信息送入自己的state字段，并修改i值，使Peeker知道线程仍在运行。\n测试 令人惊讶的是，主要的程序片（Applet）类非常简单，这是大多数工作都已置入Blockable框架的缘故。大概地说，我们创建了一个由Blockable对象构成的数组。而且由于每个对象都是一个线程，所以在按下“start”按钮后，它们会采取自己的行动。还有另一个按钮和actionPerformed()从句，用于中止所有Peeker对象。由于Java 1.2“反对”使用Thread的stop()方法，所以可考虑采用这种折衷形式的中止方式。\n为了在Sender和Receiver之间建立一个连接，我们创建了一个PipedWriter和一个PipedReader。注意PipedReader in必须通过一个构建器参数同PipedWriterout连接起来。在那以后，我们在out内放进去的所有东西都可从in中提取出来——似乎那些东西是通过一个“管道”传输过去的。随后将in和out对象分别传递给Receiver和Sender构建器；后者将它们当作任意类型的Reader和Writer看待（也就是说，它们被“上溯”造型了）。 Blockable句柄b的数组在定义之初并未得到初始化，因为管道化的数据流是不可在定义前设置好的（对try块的需要将成为障碍）：\n///:Continuing /////////// Testing Everything /////////// public class Blocking extends Applet { private Button start = new Button(\u0026#34;Start\u0026#34;), stopPeekers = new Button(\u0026#34;Stop Peekers\u0026#34;); private boolean started = false; private Blockable[] b; private PipedWriter out; private PipedReader in; public void init() { out = new PipedWriter(); try { in = new PipedReader(out); } catch(IOException e) {} b = new Blockable[] { new Sleeper1(this), new Sleeper2(this), new SuspendResume1(this), new SuspendResume2(this), new WaitNotify1(this), new WaitNotify2(this), new Sender(this, out), new Receiver(this, in) }; start.addActionListener(new StartL()); add(start); stopPeekers.addActionListener( new StopPeekersL()); add(stopPeekers); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(!started) { started = true; for(int i = 0; i \u0026lt; b.length; i++) b[i].start(); } } } class StopPeekersL implements ActionListener { public void actionPerformed(ActionEvent e) { // Demonstration of the preferred // alternative to Thread.stop(): for(int i = 0; i \u0026lt; b.length; i++) b[i].stopPeeker(); } } public static void main(String[] args) { Blocking applet = new Blocking(); Frame aFrame = new Frame(\u0026#34;Blocking\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(350,550); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 在init()中，注意循环会遍历整个数组，并为页添加state和peeker.status文本字段。\n首次创建好Blockable线程以后，每个这样的线程都会自动创建并启动自己的Peeker。所以我们会看到各个Peeker都在Blockable线程启动之前运行起来。这一点非常重要，因为在Blockable线程启动的时候，部分Peeker会被堵塞，并停止运行。弄懂这一点，将有助于我们加深对“堵塞”这一概念的认识。\n14.3.2 死锁 由于线程可能进入堵塞状态，而且由于对象可能拥有“同步”方法——除非同步锁定被解除，否则线程不能访问那个对象——所以一个线程完全可能等候另一个对象，而另一个对象又在等候下一个对象，以此类推。这个“等候”链最可怕的情形就是进入封闭状态——最后那个对象等候的是第一个对象！此时，所有线程都会陷入无休止的相互等待状态，大家都动弹不得。我们将这种情况称为“死锁”。尽管这种情况并非经常出现，但一旦碰到，程序的调试将变得异常艰难。 就语言本身来说，尚未直接提供防止死锁的帮助措施，需要我们通过谨慎的设计来避免。如果有谁需要调试一个死锁的程序，他是没有任何窍门可用的。\nJava 1.2对stop()，suspend()，resume()以及destroy()的反对 为减少出现死锁的可能，Java 1.2作出的一项贡献是“反对”使用Thread的stop()，suspend()，resume()以及destroy()方法。\n之所以反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态（“被破坏”），那么其他线程能在那种状态下检查和修改它们。结果便造成了一种微妙的局面，我们很难检查出真正的问题所在。所以应尽量避免使用stop()，应该采用Blocking.java那样的方法，用一个标志告诉线程什么时候通过退出自己的run()方法来中止自己的执行。\n如果一个线程被堵塞，比如在它等候输入的时候，那么一般都不能象在Blocking.java中那样轮询一个标志。但在这些情况下，我们仍然不该使用stop()，而应换用由Thread提供的interrupt()方法，以便中止并退出堵塞的代码。\n//: Interrupt.java // The alternative approach to using stop() // when a thread is blocked import java.awt.*; import java.awt.event.*; import java.applet.*; class Blocked extends Thread { public synchronized void run() { try { wait(); // Blocks } catch(InterruptedException e) { System.out.println(\u0026#34;InterruptedException\u0026#34;); } System.out.println(\u0026#34;Exiting run()\u0026#34;); } } public class Interrupt extends Applet { private Button interrupt = new Button(\u0026#34;Interrupt\u0026#34;); private Blocked blocked = new Blocked(); public void init() { add(interrupt); interrupt.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println(\u0026#34;Button pressed\u0026#34;); if(blocked == null) return; Thread remove = blocked; blocked = null; // to release it remove.interrupt(); } }); blocked.start(); } public static void main(String[] args) { Interrupt applet = new Interrupt(); Frame aFrame = new Frame(\u0026#34;Interrupt\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(200,100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Blocked.run()内部的wait()会产生堵塞的线程。当我们按下按钮以后，blocked（堵塞）的句柄就会设为null，使垃圾收集器能够将其清除，然后调用对象的interrupt()方法。如果是首次按下按钮，我们会看到线程正常退出。但在没有可供“杀死”的线程以后，看到的便只是按钮被按下而已。\nsuspend()和resume()方法天生容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成令人难堪的死锁。所以我们不应该使用suspend()和resume()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。我们可以修改前面的Counter2.java来实际体验一番。尽管两个版本的效果是差不多的，但大家会注意到代码的组织结构发生了很大的变化——为所有“听众”都使用了匿名的内部类，而且Thread是一个内部类。这使得程序的编写稍微方便一些，因为它取消了Counter2.java中一些额外的记录工作。\n//: Suspend.java // The alternative approach to using suspend() // and resume(), which have been deprecated // in Java 1.2. import java.awt.*; import java.awt.event.*; import java.applet.*; public class Suspend extends Applet { private TextField t = new TextField(10); private Button suspend = new Button(\u0026#34;Suspend\u0026#34;), resume = new Button(\u0026#34;Resume\u0026#34;); class Suspendable extends Thread { private int count = 0; private boolean suspended = false; public Suspendable() { start(); } public void fauxSuspend() { suspended = true; } public synchronized void fauxResume() { suspended = false; notify(); } public void run() { while (true) { try { sleep(100); synchronized(this) { while(suspended) wait(); } } catch (InterruptedException e){} t.setText(Integer.toString(count++)); } } } private Suspendable ss = new Suspendable(); public void init() { add(t); suspend.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent e) { ss.fauxSuspend(); } }); add(suspend); resume.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent e) { ss.fauxResume(); } }); add(resume); } public static void main(String[] args) { Suspend applet = new Suspend(); Frame aFrame = new Frame(\u0026#34;Suspend\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Suspendable中的suspended（已挂起）标志用于开关“挂起”或者“暂停”状态。为挂起一个线程，只需调用fauxSuspend()将标志设为true（真）即可。对标志状态的侦测是在run()内进行的。就象本章早些时候提到的那样，wait()必须设为“同步”（synchronized），使其能够使用对象锁。在fauxResume()中，suspended标志被设为false（假），并调用notify()——由于这会在一个“同步”从句中唤醒wait()，所以fauxResume()方法也必须同步，使其能在调用notify()之前取得对象锁（这样一来，对象锁可由要唤醍的那个wait()使用）。如果遵照本程序展示的样式，可以避免使用wait()和notify()。 Thread的destroy()方法根本没有实现；它类似一个根本不能恢复的suspend()，所以会发生与suspend()一样的死锁问题。然而，这一方法没有得到明确的“反对”，也许会在Java以后的版本（1.2版以后）实现，用于一些可以承受死锁危险的特殊场合。 大家可能会奇怪当初为什么要实现这些现在又被“反对”的方法。之所以会出现这种情况，大概是由于Sun公司主要让技术人员来决定对语言的改动，而不是那些市场销售人员。通常，技术人员比搞销售的更能理解语言的实质。当初犯下了错误以后，也能较为理智地正视它们。这意味着Java能够继续进步，即便这使Java程序员多少感到有些不便。就我自己来说，宁愿面对这些不便之处，也不愿看到语言停滞不前。\n14.4 优先级 线程的优先级（Priority）告诉调试程序该线程的重要程度有多大。如果有大量线程都被堵塞，都在等候运行，调试程序会首先运行具有最高优先级的那个线程。然而，这并不表示优先级较低的线程不会运行（换言之，不会因为存在优先级而导致死锁）。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。\n可用getPriority()方法读取一个线程的优先级，并用setPriority()改变它。在下面这个程序片中，大家会发现计数器的计数速度慢了下来，因为它们关联的线程分配了较低的优先级：\n//: Counter5.java // Adjusting the priorities of threads import java.awt.*; import java.awt.event.*; import java.applet.*; class Ticker2 extends Thread { private Button b = new Button(\u0026#34;Toggle\u0026#34;), incPriority = new Button(\u0026#34;up\u0026#34;), decPriority = new Button(\u0026#34;down\u0026#34;); private TextField t = new TextField(10), pr = new TextField(3); // Display priority private int count = 0; private boolean runFlag = true; public Ticker2(Container c) { b.addActionListener(new ToggleL()); incPriority.addActionListener(new UpL()); decPriority.addActionListener(new DownL()); Panel p = new Panel(); p.add(t); p.add(pr); p.add(b); p.add(incPriority); p.add(decPriority); c.add(p); } class ToggleL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } class UpL implements ActionListener { public void actionPerformed(ActionEvent e) { int newPriority = getPriority() + 1; if(newPriority \u0026gt; Thread.MAX_PRIORITY) newPriority = Thread.MAX_PRIORITY; setPriority(newPriority); } } class DownL implements ActionListener { public void actionPerformed(ActionEvent e) { int newPriority = getPriority() - 1; if(newPriority \u0026lt; Thread.MIN_PRIORITY) newPriority = Thread.MIN_PRIORITY; setPriority(newPriority); } } public void run() { while (true) { if(runFlag) { t.setText(Integer.toString(count++)); pr.setText( Integer.toString(getPriority())); } yield(); } } } public class Counter5 extends Applet { private Button start = new Button(\u0026#34;Start\u0026#34;), upMax = new Button(\u0026#34;Inc Max Priority\u0026#34;), downMax = new Button(\u0026#34;Dec Max Priority\u0026#34;); private boolean started = false; private static final int SIZE = 10; private Ticker2[] s = new Ticker2[SIZE]; private TextField mp = new TextField(3); public void init() { for(int i = 0; i \u0026lt; s.length; i++) s[i] = new Ticker2(this); add(new Label(\u0026#34;MAX_PRIORITY = \u0026#34; + Thread.MAX_PRIORITY)); add(new Label(\u0026#34;MIN_PRIORITY = \u0026#34; + Thread.MIN_PRIORITY)); add(new Label(\u0026#34;Group Max Priority = \u0026#34;)); add(mp); add(start); add(upMax); add(downMax); start.addActionListener(new StartL()); upMax.addActionListener(new UpMaxL()); downMax.addActionListener(new DownMaxL()); showMaxPriority(); // Recursively display parent thread groups: ThreadGroup parent = s[0].getThreadGroup().getParent(); while(parent != null) { add(new Label( \u0026#34;Parent threadgroup max priority = \u0026#34; + parent.getMaxPriority())); parent = parent.getParent(); } } public void showMaxPriority() { mp.setText(Integer.toString( s[0].getThreadGroup().getMaxPriority())); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(!started) { started = true; for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } } class UpMaxL implements ActionListener { public void actionPerformed(ActionEvent e) { int maxp = s[0].getThreadGroup().getMaxPriority(); if(++maxp \u0026gt; Thread.MAX_PRIORITY) maxp = Thread.MAX_PRIORITY; s[0].getThreadGroup().setMaxPriority(maxp); showMaxPriority(); } } class DownMaxL implements ActionListener { public void actionPerformed(ActionEvent e) { int maxp = s[0].getThreadGroup().getMaxPriority(); if(--maxp \u0026lt; Thread.MIN_PRIORITY) maxp = Thread.MIN_PRIORITY; s[0].getThreadGroup().setMaxPriority(maxp); showMaxPriority(); } } public static void main(String[] args) { Counter5 applet = new Counter5(); Frame aFrame = new Frame(\u0026#34;Counter5\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300, 600); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Ticker采用本章前面构造好的形式，但有一个额外的TextField（文本字段），用于显示线程的优先级；以及两个额外的按钮，用于人为提高及降低优先级。\n也要注意yield()的用法，它将控制权自动返回给调试程序（机制）。若不进行这样的处理，多线程机制仍会工作，但我们会发现它的运行速度慢了下来（试试删去对yield()的调用）。亦可调用sleep()，但假若那样做，计数频率就会改由sleep()的持续时间控制，而不是优先级。\nCounter5中的init()创建了由10个Ticker2构成的一个数组；它们的按钮以及输入字段（文本字段）由Ticker2构建器置入窗体。Counter5增加了新的按钮，用于启动一切，以及用于提高和降低线程组的最大优先级。除此以外，还有一些标签用于显示一个线程可以采用的最大及最小优先级；以及一个特殊的文本字段，用于显示线程组的最大优先级（在下一节里，我们将全面讨论线程组的问题）。最后，父线程组的优先级也作为标签显示出来。\n按下“up”（上）或“down”（下）按钮的时候，会先取得Ticker2当前的优先级，然后相应地提高或者降低。 运行该程序时，我们可注意到几件事情。首先，线程组的默认优先级是5。即使在启动线程之前（或者在创建线程之前，这要求对代码进行适当的修改）将最大优先级降到5以下，每个线程都会有一个5的默认优先级。\n最简单的测试是获取一个计数器，将它的优先级降低至1，此时应观察到它的计数频率显著放慢。现在试着再次提高优先级，可以升高回线程组的优先级，但不能再高了。现在将线程组的优先级降低两次。线程的优先级不会改变，但假若试图提高或者降低它，就会发现这个优先级自动变成线程组的优先级。此外，新线程仍然具有一个默认优先级，即使它比组的优先级还要高（换句话说，不要指望利用组优先级来防止新线程拥有比现有的更高的优先级）。\n最后，试着提高组的最大优先级。可以发现，这样做是没有效果的。我们只能减少线程组的最大优先级，而不能增大它。\n14.4.1 线程组 所有线程都隶属于一个线程组。那可以是一个默认线程组，亦可是一个创建线程时明确指定的组。在创建之初，线程被限制到一个组里，而且不能改变到一个不同的组。每个应用都至少有一个线程从属于系统线程组。若创建多个线程而不指定一个组，它们就会自动归属于系统线程组。\n线程组也必须从属于其他线程组。必须在构建器里指定新线程组从属于哪个线程组。若在创建一个线程组的时候没有指定它的归属，则同样会自动成为系统线程组的一名属下。因此，一个应用程序中的所有线程组最终都会将系统线程组作为自己的“父”。 之所以要提出“线程组”的概念，很难从字面上找到原因。这多少为我们讨论的主题带来了一些混乱。一般地说，我们认为是由于“安全”或者“保密”方面的理由才使用线程组的。根据Arnold和Gosling的说法：“线程组中的线程可以修改组内的其他线程，包括那些位于分层结构最深处的。一个线程不能修改位于自己所在组或者下属组之外的任何线程”（注释①）。然而，我们很难判断“修改”在这儿的具体含义是什么。下面这个例子展示了位于一个“叶子组”内的线程能修改它所在线程组树的所有线程的优先级，同时还能为这个“树”内的所有线程都调用一个方法。\n①：《The Java Programming Language》第179页。该书由Arnold和Jams Gosling编著，Addison-Wesley于1996年出版 //: TestAccess.java // How threads can access other threads // in a parent thread group public class TestAccess { public static void main(String[] args) { ThreadGroup x = new ThreadGroup(\u0026#34;x\u0026#34;), y = new ThreadGroup(x, \u0026#34;y\u0026#34;), z = new ThreadGroup(y, \u0026#34;z\u0026#34;); Thread one = new TestThread1(x, \u0026#34;one\u0026#34;), two = new TestThread2(z, \u0026#34;two\u0026#34;); } } class TestThread1 extends Thread { private int i; TestThread1(ThreadGroup g, String name) { super(g, name); } void f() { i++; // modify this thread System.out.println(getName() + \u0026#34; f()\u0026#34;); } } class TestThread2 extends TestThread1 { TestThread2(ThreadGroup g, String name) { super(g, name); start(); } public void run() { ThreadGroup g = getThreadGroup().getParent().getParent(); g.list(); Thread[] gAll = new Thread[g.activeCount()]; g.enumerate(gAll); for(int i = 0; i \u0026lt; gAll.length; i++) { gAll[i].setPriority(Thread.MIN_PRIORITY); ((TestThread1)gAll[i]).f(); } g.list(); } } ///:~ 在main()中，我们创建了几个ThreadGroup（线程组），每个都位于不同的“叶”上：x没有参数，只有它的名字（一个String），所以会自动进入“system”（系统）线程组；y位于x下方，而z位于y下方。注意初始化是按照文字顺序进行的，所以代码合法。\n有两个线程创建之后进入了不同的线程组。其中，TestThread1没有一个run()方法，但有一个f()，用于通知线程以及打印出一些东西，以便我们知道它已被调用。而TestThread2属于TestThread1的一个子类，它的run()非常详尽，要做许多事情。首先，它获得当前线程所在的线程组，然后利用getParent()在继承树中向上移动两级（这样做是有道理的，因为我想把TestThread2在分级结构中向下移动两级）。随后，我们调用方法activeCount()，查询这个线程组以及所有子线程组内有多少个线程，从而创建由指向Thread的句柄构成的一个数组。enumerate()方法将指向所有这些线程的句柄置入数组gAll里。然后在整个数组里遍历，为每个线程都调用f()方法，同时修改优先级。这样一来，位于一个“叶子”线程组里的线程就修改了位于父线程组的线程。\n调试方法list()打印出与一个线程组有关的所有信息，把它们作为标准输出。在我们对线程组的行为进行调查的时候，这样做是相当有好处的。下面是程序的输出：\njava.lang.ThreadGroup[name=x,maxpri=10]\rThread[one,5,x]\rjava.lang.ThreadGroup[name=y,maxpri=10]\rjava.lang.ThreadGroup[name=z,maxpri=10]\rThread[two,5,z]\rone f()\rtwo f()\rjava.lang.ThreadGroup[name=x,maxpri=10]\rThread[one,1,x]\rjava.lang.ThreadGroup[name=y,maxpri=10]\rjava.lang.ThreadGroup[name=z,maxpri=10]\rThread[two,1,z] list()不仅打印出ThreadGroup或者Thread的类名，也打印出了线程组的名字以及它的最高优先级。对于线程，则打印出它们的名字，并接上线程优先级以及所属的线程组。注意list()会对线程和线程组进行缩排处理，指出它们是未缩排的线程组的“子”。 大家可看到f()是由TestThread2的run()方法调用的，所以很明显，组内的所有线程都是相当脆弱的。然而，我们只能访问那些从自己的system线程组树分支出来的线程，而且或许这就是所谓“安全”的意思。我们不能访问其他任何人的系统线程树。\n线程组的控制 抛开安全问题不谈，线程组最有用的一个地方就是控制：只需用单个命令即可完成对整个线程组的操作。下面这个例子演示了这一点，并对线程组内优先级的限制进行了说明。括号内的注释数字便于大家比较输出结果：\n//: ThreadGroup1.java // How thread groups control priorities // of the threads inside them. public class ThreadGroup1 { public static void main(String[] args) { // Get the system thread \u0026amp; print its Info: ThreadGroup sys = Thread.currentThread().getThreadGroup(); sys.list(); // (1) // Reduce the system thread group priority: sys.setMaxPriority(Thread.MAX_PRIORITY - 1); // Increase the main thread priority: Thread curr = Thread.currentThread(); curr.setPriority(curr.getPriority() + 1); sys.list(); // (2) // Attempt to set a new group to the max: ThreadGroup g1 = new ThreadGroup(\u0026#34;g1\u0026#34;); g1.setMaxPriority(Thread.MAX_PRIORITY); // Attempt to set a new thread to the max: Thread t = new Thread(g1, \u0026#34;A\u0026#34;); t.setPriority(Thread.MAX_PRIORITY); g1.list(); // (3) // Reduce g1\u0026#39;s max priority, then attempt // to increase it: g1.setMaxPriority(Thread.MAX_PRIORITY - 2); g1.setMaxPriority(Thread.MAX_PRIORITY); g1.list(); // (4) // Attempt to set a new thread to the max: t = new Thread(g1, \u0026#34;B\u0026#34;); t.setPriority(Thread.MAX_PRIORITY); g1.list(); // (5) // Lower the max priority below the default // thread priority: g1.setMaxPriority(Thread.MIN_PRIORITY + 2); // Look at a new thread\u0026#39;s priority before // and after changing it: t = new Thread(g1, \u0026#34;C\u0026#34;); g1.list(); // (6) t.setPriority(t.getPriority() -1); g1.list(); // (7) // Make g2 a child Threadgroup of g1 and // try to increase its priority: ThreadGroup g2 = new ThreadGroup(g1, \u0026#34;g2\u0026#34;); g2.list(); // (8) g2.setMaxPriority(Thread.MAX_PRIORITY); g2.list(); // (9) // Add a bunch of new threads to g2: for (int i = 0; i \u0026lt; 5; i++) new Thread(g2, Integer.toString(i)); // Show information about all threadgroups // and threads: sys.list(); // (10) System.out.println(\u0026#34;Starting all threads:\u0026#34;); Thread[] all = new Thread[sys.activeCount()]; sys.enumerate(all); for(int i = 0; i \u0026lt; all.length; i++) if(!all[i].isAlive()) all[i].start(); // Suspends \u0026amp; Stops all threads in // this group and its subgroups: System.out.println(\u0026#34;All threads started\u0026#34;); sys.suspend(); // Deprecated in Java 1.2 // Never gets here... System.out.println(\u0026#34;All threads suspended\u0026#34;); sys.stop(); // Deprecated in Java 1.2 System.out.println(\u0026#34;All threads stopped\u0026#34;); } } ///:~ 下面的输出结果已进行了适当的编辑，以便用一页能够装下（java.lang.已被删去），而且添加了适当的数字，与前面程序列表中括号里的数字对应：\n(1) ThreadGroup[name=system,maxpri=10]\rThread[main,5,system]\r(2) ThreadGroup[name=system,maxpri=9]\rThread[main,6,system]\r(3) ThreadGroup[name=g1,maxpri=9]\rThread[A,9,g1]\r(4) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1]\r(5) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1]\rThread[B,8,g1]\r(6) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,6,g1]\r(7) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1]\r(8) ThreadGroup[name=g2,maxpri=3]\r(9) ThreadGroup[name=g2,maxpri=3]\r(10)ThreadGroup[name=system,maxpri=9]\rThread[main,6,system]\rThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1]\rThreadGroup[name=g2,maxpri=3]\rThread[0,6,g2]\rThread[1,6,g2]\rThread[2,6,g2]\rThread[3,6,g2]\rThread[4,6,g2]\rStarting all threads:\rAll threads started 所有程序都至少有一个线程在运行，而且main()采取的第一项行动便是调用Thread的一个static（静态）方法，名为currentThread()。从这个线程开始，线程组将被创建，而且会为结果调用list()。输出如下：\n(1) ThreadGroup[name=system,maxpri=10]\rThread[main,5,system] 我们可以看到，主线程组的名字是system，而主线程的名字是main，而且它从属于system线程组。 第二个练习显示出system组的最高优先级可以减少，而且main线程可以增大自己的优先级：\n(2) ThreadGroup[name=system,maxpri=9]\rThread[main,6,system] 第三个练习创建一个新的线程组，名为g1；它自动从属于system线程组，因为并没有明确指定它的归属关系。我们在g1内部放置了一个新线程，名为A。随后，我们试着将这个组的最大优先级设到最高的级别，并将A的优先级也设到最高一级。结果如下：\n(3) ThreadGroup[name=g1,maxpri=9]\rThread[A,9,g1] 可以看出，不可能将线程组的最大优先级设为高于它的父线程组。 第四个练习将g1的最大优先级降低两级，然后试着把它升至Thread.MAX_PRIORITY。结果如下：\n(4) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1] 同样可以看出，提高最大优先级的企图是失败的。我们只能降低一个线程组的最大优先级，而不能提高它。此外，注意线程A的优先级并未改变，而且它现在高于线程组的最大优先级。也就是说，线程组最大优先级的变化并不能对现有线程造成影响。 第五个练习试着将一个新线程设为最大优先级。如下所示：\n(5) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1]\rThread[B,8,g1] 因此，新线程不能变到比最大线程组优先级还要高的一级。 这个程序的默认线程优先级是6；若新建一个线程，那就是它的默认优先级，而且不会发生变化，除非对优先级进行了特别的处理。练习六将把线程组的最大优先级降至默认线程优先级以下，看看在这种情况下新建一个线程会发生什么事情：\n(6) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,6,g1] 尽管线程组现在的最大优先级是3，但仍然用默认优先级6来创建新线程。所以，线程组的最大优先级不会影响默认优先级（事实上，似乎没有办法可以设置新线程的默认优先级）。 改变了优先级后，接下来试试将其降低一级，结果如下：\n(7) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1] 因此，只有在试图改变优先级的时候，才会强迫遵守线程组最大优先级的限制。 我们在(8)和(9)中进行了类似的试验。在这里，我们创建了一个新的线程组，名为g2，将其作为g1的一个子组，并改变了它的最大优先级。大家可以看到，g2的优先级无论如何都不可能高于g1：\n(8) ThreadGroup[name=g2,maxpri=3]\r(9) ThreadGroup[name=g2,maxpri=3] 也要注意在g2创建的时候，它会被自动设为g1的线程组最大优先级。 经过所有这些实验以后，整个线程组和线程系统都会被打印出来，如下所示：\n(10)ThreadGroup[name=system,maxpri=9]\rThread[main,6,system]\rThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1]\rThreadGroup[name=g2,maxpri=3]\rThread[0,6,g2]\rThread[1,6,g2]\rThread[2,6,g2]\rThread[3,6,g2]\rThread[4,6,g2] 所以由线程组的规则所限，一个子组的最大优先级在任何时候都只能低于或等于它的父组的最大优先级。\n本程序的最后一个部分演示了用于整组线程的方法。程序首先遍历整个线程树，并启动每一个尚未启动的线程。例如，system组随后会被挂起（暂停），最后被中止（尽管用suspend()和stop()对整个线程组进行操作看起来似乎很有趣，但应注意这些方法在Java 1.2里都是被“反对”的）。但在挂起system组的同时，也挂起了main线程，而且整个程序都会关闭。所以永远不会达到让线程中止的那一步。实际上，假如真的中止了main线程，它会“掷”出一个ThreadDeath违例，所以我们通常不这样做。由于ThreadGroup是从Object继承的，其中包含了wait()方法，所以也能调用wait(秒数×1000)，令程序暂停运行任意秒数的时间。当然，事前必须在一个同步块里取得对象锁。\nThreadGroup类也提供了suspend()和resume()方法，所以能中止和启动整个线程组和它的所有线程，也能中止和启动它的子组，所有这些只需一个命令即可（再次提醒，suspend()和resume()都是Java 1.2所“反对”的）。 从表面看，线程组似乎有些让人摸不着头脑，但请注意我们很少需要直接使用它们。\n14.5 回顾runnable 在本章早些时候，我曾建议大家在将一个程序片或主Frame当作Runnable的实现形式之前，一定要好好地想一想。若采用那种方式，就只能在自己的程序中使用其中的一个线程。这便限制了灵活性，一旦需要用到属于那种类型的多个线程，就会遇到不必要的麻烦。\n当然，如果必须从一个类继承，而且想使类具有线程处理能力，则Runnable是一种正确的方案。本章最后一个例子对这一点进行了剖析，制作了一个RunnableCanvas类，用于为自己描绘不同的颜色（Canvas是“画布”的意思）。这个应用被设计成从命令行获得参数值，以决定颜色网格有多大，以及颜色发生变化之间的sleep()有多长。通过运用这些值，大家能体验到线程一些有趣而且可能令人费解的特性：\n//: ColorBoxes.java // Using the Runnable interface import java.awt.*; import java.awt.event.*; class CBox extends Canvas implements Runnable { private Thread t; private int pause; private static final Color[] colors = { Color.black, Color.blue, Color.cyan, Color.darkGray, Color.gray, Color.green, Color.lightGray, Color.magenta, Color.orange, Color.pink, Color.red, Color.white, Color.yellow }; private Color cColor = newColor(); private static final Color newColor() { return colors[ (int)(Math.random() * colors.length) ]; } public void paint(Graphics g) { g.setColor(cColor); Dimension s = getSize(); g.fillRect(0, 0, s.width, s.height); } public CBox(int pause) { this.pause = pause; t = new Thread(this); t.start(); } public void run() { while(true) { cColor = newColor(); repaint(); try { t.sleep(pause); } catch(InterruptedException e) {} } } } public class ColorBoxes extends Frame { public ColorBoxes(int pause, int grid) { setTitle(\u0026#34;ColorBoxes\u0026#34;); setLayout(new GridLayout(grid, grid)); for (int i = 0; i \u0026lt; grid * grid; i++) add(new CBox(pause)); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); } public static void main(String[] args) { int pause = 50; int grid = 8; if(args.length \u0026gt; 0) pause = Integer.parseInt(args[0]); if(args.length \u0026gt; 1) grid = Integer.parseInt(args[1]); Frame f = new ColorBoxes(pause, grid); f.setSize(500, 400); f.setVisible(true); } } ///:~ ColorBoxes是一个典型的应用（程序），有一个构建器用于设置GUI。这个构建器采用int grid的一个参数，用它设置GridLayout（网格布局），使每一维里都有一个grid单元。随后，它添加适当数量的CBox对象，用它们填充网格，并为每一个都传递pause值。在main()中，我们可看到如何对pause和grid的默认值进行修改（如果用命令行参数传递）。 CBox是进行正式工作的地方。它是从Canvas继承的，并实现了Runnable接口，使每个Canvas也能是一个Thread。记住在实现Runnable的时候，并没有实际产生一个Thread对象，只是一个拥有run()方法的类。因此，我们必须明确地创建一个Thread对象，并将Runnable对象传递给构建器，随后调用start()（在构建器里进行）。在CBox里，这个线程的名字叫作t。 请留意数组colors，它对Color类中的所有颜色进行了列举（枚举）。它在newColor()中用于产生一种随机选择的颜色。当前的单元（格）颜色是cColor。\npaint()则相当简单——只是将颜色设为cColor，然后用那种颜色填充整张画布（Canvas）。\n在run()中，我们看到一个无限循环，它将cColor设为一种随机颜色，然后调用repaint()把它显示出来。随后，对线程执行sleep()，使其“休眠”由命令行指定的时间长度。\n由于这种设计方案非常灵活，而且线程处理同每个Canvas元素都紧密结合在一起，所以在理论上可以生成任意多的线程（但在实际应用中，这要受到JVM能够从容对付的线程数量的限制）。\n这个程序也为我们提供了一个有趣的评测基准，因为它揭示了不同JVM机制在速度上造成的戏剧性的差异。\n14.5.1 过多的线程 有些时候，我们会发现ColorBoxes几乎陷于停顿状态。在我自己的机器上，这一情况在产生了10×10的网格之后发生了。为什么会这样呢？自然地，我们有理由怀疑AWT对它做了什么事情。所以这里有一个例子能够测试那个猜测，它产生了较少的线程。代码经过了重新组织，使一个Vector实现了Runnable，而且那个Vector容纳了数量众多的色块，并随机挑选一些进行更新。随后，我们创建大量这些Vector对象，数量大致取决于我们挑选的网格维数。结果便是我们得到比色块少得多的线程。所以假如有一个速度的加快，我们就能立即知道，因为前例的线程数量太多了。如下所示：\n//: ColorBoxes2.java // Balancing thread use import java.awt.*; import java.awt.event.*; import java.util.*; class CBox2 extends Canvas { private static final Color[] colors = { Color.black, Color.blue, Color.cyan, Color.darkGray, Color.gray, Color.green, Color.lightGray, Color.magenta, Color.orange, Color.pink, Color.red, Color.white, Color.yellow }; private Color cColor = newColor(); private static final Color newColor() { return colors[ (int)(Math.random() * colors.length) ]; } void nextColor() { cColor = newColor(); repaint(); } public void paint(Graphics g) { g.setColor(cColor); Dimension s = getSize(); g.fillRect(0, 0, s.width, s.height); } } class CBoxVector extends Vector implements Runnable { private Thread t; private int pause; public CBoxVector(int pause) { this.pause = pause; t = new Thread(this); } public void go() { t.start(); } public void run() { while(true) { int i = (int)(Math.random() * size()); ((CBox2)elementAt(i)).nextColor(); try { t.sleep(pause); } catch(InterruptedException e) {} } } } public class ColorBoxes2 extends Frame { private CBoxVector[] v; public ColorBoxes2(int pause, int grid) { setTitle(\u0026#34;ColorBoxes2\u0026#34;); setLayout(new GridLayout(grid, grid)); v = new CBoxVector[grid]; for(int i = 0; i \u0026lt; grid; i++) v[i] = new CBoxVector(pause); for (int i = 0; i \u0026lt; grid * grid; i++) { v[i % grid].addElement(new CBox2()); add((CBox2)v[i % grid].lastElement()); } for(int i = 0; i \u0026lt; grid; i++) v[i].go(); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); } public static void main(String[] args) { // Shorter default pause than ColorBoxes: int pause = 5; int grid = 8; if(args.length \u0026gt; 0) pause = Integer.parseInt(args[0]); if(args.length \u0026gt; 1) grid = Integer.parseInt(args[1]); Frame f = new ColorBoxes2(pause, grid); f.setSize(500, 400); f.setVisible(true); } } ///:~ 在ColorBoxes2中，我们创建了CBoxVector的一个数组，并对其初始化，使其容下各个CBoxVector网格。每个网格都知道自己该“睡眠”多长的时间。随后为每个CBoxVector都添加等量的Cbox2对象，而且将每个Vector都告诉给go()，用它来启动自己的线程。\nCBox2类似CBox——能用一种随机选择的颜色描绘自己。但那就是CBox2能够做的全部工作。所有涉及线程的处理都已移至CBoxVector进行。\nCBoxVector也可以拥有继承的Thread，并有一个类型为Vector的成员对象。这样设计的好处就是addElement()和elementAt()方法可以获得特定的参数以及返回值类型，而不是只能获得常规Object（它们的名字也可以变得更短）。然而，这里采用的设计表面上看需要较少的代码。除此以外，它会自动保留一个Vector的其他所有行为。由于elementAt()需要大量进行“封闭”工作，用到许多括号，所以随着代码主体的扩充，最终仍有可能需要大量代码。\n和以前一样，在我们实现Runnable的时候，并没有获得与Thread配套提供的所有功能，所以必须创建一个新的Thread，并将自己传递给它的构建器，以便正式“启动”——start()——一些东西。大家在CBoxVector构建器和go()里都可以体会到这一点。run()方法简单地选择Vector里的一个随机元素编号，并为那个元素调用nextColor()，令其挑选一种新的随机颜色。\n运行这个程序时，大家会发现它确实变得更快，响应也更迅速（比如在中断它的时候，它能更快地停下来）。而且随着网格尺寸的壮 大，它也不会经常性地陷于“停顿”状态。因此，线程的处理又多了一项新的考虑因素：必须随时检查自己有没有“太多的线程”（无论对什么程序和运行平台）。若线程太多，必须试着使用上面介绍的技术，对程序中的线程数量进行“平衡”。如果在一个多线程的程序中遇到了性能上的问题，那么现在有许多因素需要检查：\n(1) 对sleep，yield()以及／或者wait()的调用足够多吗？\n(2) sleep()的调用时间足够长吗？\n(3) 运行的线程数是不是太多？\n(4) 试过不同的平台和JVM吗？\n象这样的一些问题是造成多线程应用程序的编制成为一种“技术活”的原因之一。\n14.6 总结 何时使用多线程技术，以及何时避免用它，这是我们需要掌握的重要课题。骼它的主要目的是对大量任务进行有序的管理。通过多个任务的混合使用，可以更有效地利用计算机资源，或者对用户来说显得更方便。资源均衡的经典问题是在IO等候期间如何利用CPU。至于用户方面的方便性，最经典的问题就是如何在一个长时间的下载过程中监视并灵敏地反应一个“停止”（stop）按钮的按下。 多线程的主要缺点包括：\n(1) 等候使用共享资源时造成程序的运行速度变慢。\n(2) 对线程进行管理要求的额外CPU开销。\n(3) 复杂程度无意义的加大，比如用独立的线程来更新数组内每个元素的愚蠢主意。\n(4) 漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。\n线程另一个优点是它们用“轻度”执行切换（100条指令的顺序）取代了“重度”进程场景切换（1000条指令）。由于一个进程内的所有线程共享相同的内存空间，所以“轻度”场景切换只改变程序的执行和本地变量。而在“重度”场景切换时，一个进程的改变要求必须完整地交换内存空间。 线程处理看来好象进入了一个全新的领域，似乎要求我们学习一种全新的程序设计语言——或者至少学习一系列新的语言概念。由于大多数微机操作系统都提供了对线程的支持，所以程序设计语言或者库里也出现了对线程的扩展。不管在什么情况下，涉及线程的程序设计：\n(1) 刚开始会让人摸不着头脑，要求改换我们传统的编程思路；\n(2) 其他语言对线程的支持看来是类似的。所以一旦掌握了线程的概念，在其他环境也不会有太大的困难。尽管对线程的支持使Java语言的复杂程度多少有些增加，但请不要责怪Java。毕竟，利用线程可以做许多有益的事情。 多个线程可能共享同一个资源（比如一个对象里的内存），这是运用线程时面临的最大的一个麻烦。必须保证多个线程不会同时试图读取和修改那个资源。这要求技巧性地运用synchronized（同步）关键字。它是一个有用的工具，但必须真正掌握它，因为假若操作不当，极易出现死锁。\n除此以外，运用线程时还要注意一个非常特殊的问题。由于根据Java的设计，它允许我们根据需要创建任意数量的线程——至少理论上如此（例如，假设为一项工程方面的有限元素分析创建数以百万的线程，这对Java来说并非实际）。然而，我们一般都要控制自己创建的线程数量的上限。因为在某些情况下，大量线程会将场面变得一团糟，所以工作都会几乎陷于停顿。临界点并不象对象那样可以达到几千个，而是在100以下。一般情况下，我们只创建少数几个关键线程，用它们解决某个特定的问题。这时数量的限制问题不大。但在较常规的一些设计中，这一限制确实会使我们感到束手束脚。\n大家要注意线程处理中一个不是十分直观的问题。由于采用了线程“调度”机制，所以通过在run()的主循环中插入对sleep()的调用，一般都可以使自己的程序运行得更快一些。这使它对编程技巧的要求非常高，特别是在更长的延迟似乎反而能提高性能的时候。当然，之所以会出现这种情况，是由于在正在运行的线程准备进入“休眠”状态之前，较短的延迟可能造成“sleep()结束”调度机制的中断。这便强迫调度机制将其中止，并于稍后重新启动，以便它能做完自己的事情，再进入休眠状态。必须多想一想，才能意识到事情真正的麻烦程度。\n本章遗漏的一件事情是一个动画例子，这是目前程序片最流行的一种应用。然而，Java JDK配套提供了解决这个问题的一整套方案（并可播放声音），大家可到java.sun.com的演示区域下载。此外，我们完全有理由相信未来版本的Java会提供更好的动画支持——尽管目前的Web涌现出了与传统方式完全不同的非Java、非程序化的许多动画方案。如果想系统学习Java动画的工作原理，可参考《Core Java——核心Java》一书，由Cornell\u0026amp;Horstmann编著，Prentice-Hall于1997年出版。若欲更深入地了解线程处理，请参考《Concurrent Programming in Java——Java中的并发编程》，由Doug Lea编著，Addison-Wiseley于1997年出版；或者《Java Threads——Java线程》，Oaks\u0026amp;Wong编著，O\u0026rsquo;Reilly于1997年出版。\n14.7 练习 "},{"id":141,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Thinking in Java 第15章 网络编程","parent":"Thinking In Java","content":" 第15章 网络编程 历史上的网络编程都倾向于困难、复杂，而且极易出错。\n程序员必须掌握与网络有关的大量细节，有时甚至要对硬件有深刻的认识。一般地，我们需要理解连网协议中不同的“层”（Layer）。而且对于每个连网库，一般都包含了数量众多的函数，分别涉及信息块的连接、打包和拆包；这些块的来回运输；以及握手等等。这是一项令人痛苦的工作。\n但是，连网本身的概念并不是很难。我们想获得位于其他地方某台机器上的信息，并把它们移到这儿；或者相反。这与读写文件非常相似，只是文件存在于远程机器上，而且远程机器有权决定如何处理我们请求或者发送的数据。\nJava最出色的一个地方就是它的“无痛苦连网”概念。有关连网的基层细节已被尽可能地提取出去，并隐藏在JVM以及Java的本机安装系统里进行控制。我们使用的编程模型是一个文件的模型；事实上，网络连接（一个“套接字”）已被封装到系统对象里，所以可象对其他数据流那样采用同样的方法调用。除此以外，在我们处理另一个连网问题——同时控制多个网络连接——的时候，Java内建的多线程机制也是十分方便的。\n本章将用一系列易懂的例子解释Java的连网支持。\n15.1 机器的标识 当然，为了分辨来自别处的一台机器，以及为了保证自己连接的是希望的那台机器，必须有一种机制能独一无二地标识出网络内的每台机器。早期网络只解决了如何在本地网络环境中为机器提供唯一的名字。但Java面向的是整个因特网，这要求用一种机制对来自世界各地的机器进行标识。为达到这个目的，我们采用了IP（互联网地址）的概念。IP以两种形式存在着：\n(1) 大家最熟悉的DNS（域名服务）形式。我自己的域名是bruceeckel.com。所以假定我在自己的域内有一台名为Opus的计算机，它的域名就可以是Opus.bruceeckel.com。这正是大家向其他人发送电子函件时采用的名字，而且通常集成到一个万维网（WWW）地址里。\n(2) 此外，亦可采用“四点”格式，亦即由点号（.）分隔的四组数字，比如202.98.32.111。 不管哪种情况，IP地址在内部都表达成一个由32个二进制位（bit）构成的数字（注释①），所以IP地址的每一组数字都不能超过255。利用由java.net提供的static InetAddress.getByName()，我们可以让一个特定的Java对象表达上述任何一种形式的数字。结果是类型为InetAddress的一个对象，可用它构成一个“套接字”（Socket），大家在后面会见到这一点。\n①：这意味着最多只能得到40亿左右的数字组合，全世界的人很快就会把它用光。但根据目前正在研究的新IP编址方案，它将采用128 bit的数字，这样得到的唯一性IP地址也许在几百年的时间里都不会用完。\n作为运用InetAddress.getByName()一个简单的例子，请考虑假设自己有一家拨号连接因特网服务提供者（ISP），那么会发生什么情况。每次拨号连接的时候，都会分配得到一个临时IP地址。但在连接期间，那个IP地址拥有与因特网上其他IP地址一样的有效性。如果有人按照你的IP地址连接你的机器，他们就有可能使用在你机器上运行的Web或者FTP服务器程序。当然这有个前提，对方必须准确地知道你目前分配到的IP。由于每次拨号连接获得的IP都是随机的，怎样才能准确地掌握你的IP呢？ 下面这个程序利用InetAddress.getByName()来产生你的IP地址。为了让它运行起来，事先必须知道计算机的名字。该程序只在Windows 95中进行了测试，但大家可以依次进入自己的“开始”、“设置”、“控制面板”、“网络”，然后进入“标识”卡片。其中，“计算机名称”就是应在命令行输入的内容。\n//: WhoAmI.java // Finds out your network address when you\u0026#39;re // connected to the Internet. package c15; import java.net.*; public class WhoAmI { public static void main(String[] args) throws Exception { if(args.length != 1) { System.err.println( \u0026#34;Usage: WhoAmI MachineName\u0026#34;); System.exit(1); } InetAddress a = InetAddress.getByName(args[0]); System.out.println(a); } } ///:~ 就我自己的情况来说，机器的名字叫作“Colossus”（来自同名电影，“巨人”的意思。我在这台机器上有一个很大的硬盘）。所以一旦连通我的ISP，就象下面这样执行程序：\njava whoAmI Colossus 得到的结果象下面这个样子（当然，这个地址可能每次都是不同的）：\nColossus/202.98.41.151 假如我把这个地址告诉一位朋友，他就可以立即登录到我的个人Web服务器，只需指定目标地址 http://202.98.41.151 即可（当然，我此时不能断线）。有些时候，这是向其他人发送信息或者在自己的Web站点正式出台以前进行测试的一种方便手段。\n15.1.1 服务器和客户机 网络最基本的精神就是让两台机器连接到一起，并相互“交谈”或者“沟通”。一旦两台机器都发现了对方，就可以展开一次令人愉快的双向对话。但它们怎样才能“发现”对方呢？这就象在游乐园里那样：一台机器不得不停留在一个地方，侦听其他机器说：“嘿，你在哪里呢？”\n“停留在一个地方”的机器叫作“服务器”（Server）；到处“找人”的机器则叫作“客户机”（Client）或者“客户”。它们之间的区别只有在客户机试图同服务器连接的时候才显得非常明显。一旦连通，就变成了一种双向通信，谁来扮演服务器或者客户机便显得不那么重要了。\n所以服务器的主要任务是侦听建立连接的请求，这是由我们创建的特定服务器对象完成的。而客户机的任务是试着与一台服务器建立连接，这是由我们创建的特定客户机对象完成的。一旦连接建好，那么无论在服务器端还是客户机端，连接只是魔术般地变成了一个IO数据流对象。从这时开始，我们可以象读写一个普通的文件那样对待连接。所以一旦建好连接，我们只需象第10章那样使用自己熟悉的IO命令即可。这正是Java连网最方便的一个地方。\n在没有网络的前提下测试程序 由于多种潜在的原因，我们可能没有一台客户机、服务器以及一个网络来测试自己做好的程序。我们也许是在一个课堂环境中进行练习，或者写出的是一个不十分可靠的网络应用，还能拿到网络上去。IP的设计者注意到了这个问题，并建立了一个特殊的地址——localhost——来满足非网络环境中的测试要求。在Java中产生这个地址最一般的做法是：\nInetAddress addr = InetAddress.getByName(null); 如果向getByName()传递一个null（空）值，就默认为使用localhost。我们用InetAddress对特定的机器进行索引，而且必须在进行进一步的操作之前得到这个InetAddress（互联网地址）。我们不可以操纵一个InetAddress的内容（但可把它打印出来，就象下一个例子要演示的那样）。创建InetAddress的唯一途径就是那个类的static（静态）成员方法getByName()（这是最常用的）、getAllByName()或者getLocalHost()。\n为得到本地主机地址，亦可向其直接传递字串\u0026quot;localhost\u0026quot;：\nInetAddress.getByName(\u0026#34;localhost\u0026#34;); 或者使用它的保留IP地址（四点形式），就象下面这样：\nInetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); 这三种方法得到的结果是一样的。\n15.1.2 端口：机器内独一无二的场所 有些时候，一个IP地址并不足以完整标识一个服务器。这是由于在一台物理性的机器中，往往运行着多个服务器（程序）。由IP表达的每台机器也包含了“端口”（Port）。我们设置一个客户机或者服务器的时候，必须选择一个无论客户机还是服务器都认可连接的端口。就象我们去拜会某人时，IP地址是他居住的房子，而端口是他在的那个房间。\n注意端口并不是机器上一个物理上存在的场所，而是一种软件抽象（主要是为了表述的方便）。客户程序知道如何通过机器的IP地址同它连接，但怎样才能同自己真正需要的那种服务连接呢（一般每个端口都运行着一种服务，一台机器可能提供了多种服务，比如HTTP和FTP等等）？端口编号在这里扮演了重要的角色，它是必需的一种二级定址措施。也就是说，我们请求一个特定的端口，便相当于请求与那个端口编号关联的服务。“报时”便是服务的一个典型例子。通常，每个服务都同一台特定服务器机器上的一个独一 无二的端口编号关联在一起。客户程序必须事先知道自己要求的那项服务的运行端口号。 系统服务保留了使用端口1到端口1024的权力，所以不应让自己设计的服务占用这些以及其他任何已知正在使用的端口。本书的第一个例子将使用端口8080（为追忆我的第一台机器使用的老式8位Intel 8080芯片，那是一部使用CP/M操作系统的机子）。\n15.2 套接字 “套接字”或者“插座”（Socket）也是一种软件形式的抽象，用于表达两台机器间一个连接的“终端”。针对一个特定的连接，每台机器上都有一个“套接字”，可以想象它们之间有一条虚拟的“线缆”。线缆的每一端都插入一个“套接字”或者“插座”里。当然，机器之间的物理性硬件以及电缆连接都是完全未知的。抽象的基本宗旨是让我们尽可能不必知道那些细节。\n在Java中，我们创建一个套接字，用它建立与其他机器的连接。从套接字得到的结果是一个InputStream以及OutputStream（若使用恰当的转换器，则分别是Reader和Writer），以便将连接作为一个IO流对象对待。有两个基于数据流的套接字类：ServerSocket，服务器用它“侦听”进入的连接；以及Socket，客户用它初始一次连接。一旦客户（程序）申请建立一个套接字连接，ServerSocket就会返回（通过accept()方法）一个对应的服务器端套接字，以便进行直接通信。从此时起，我们就得到了真正的“套接字－套接字”连接，可以用同样的方式对待连接的两端，因为它们本来就是相同的！此时可以利用getInputStream()以及getOutputStream()从每个套接字产生对应的InputStream和OutputStream对象。这些数据流必须封装到缓冲区内。可按第10章介绍的方法对类进行格式化，就象对待其他任何流对象那样。\n对于Java库的命名机制，ServerSocket（服务器套接字）的使用无疑是容易产生混淆的又一个例证。大家可能认为ServerSocket最好叫作“ServerConnector”（服务器连接器），或者其他什么名字，只是不要在其中安插一个“Socket”。也可能以为ServerSocket和Socket都应从一些通用的基础类继承。事实上，这两种类确实包含了几个通用的方法，但还不够资格把它们赋给一个通用的基础类。相反，ServerSocket的主要任务是在那里耐心地等候其他机器同它连接，再返回一个实际的Socket。这正是“ServerSocket”这个命名不恰当的地方，因为它的目标不是真的成为一个Socket，而是在其他人同它连接的时候产生一个Socket对象。\n然而，ServerSocket确实会在主机上创建一个物理性的“服务器”或者侦听用的套接字。这个套接字会侦听进入的连接，然后利用accept()方法返回一个“已建立”套接字（本地和远程端点均已定义）。容易混淆的地方是这两个套接字（侦听和已建立）都与相同的服务器套接字关联在一起。侦听套接字只能接收新的连接请求，不能接收实际的数据包。所以尽管ServerSocket对于编程并无太大的意义，但它确实是“物理性”的。\n创建一个ServerSocket时，只需为其赋予一个端口编号。不必把一个IP地址分配它，因为它已经在自己代表的那台机器上了。但在创建一个Socket时，却必须同时赋予IP地址以及要连接的端口编号（另一方面，从ServerSocket.accept()返回的Socket已经包含了所有这些信息）。\n15.2.1 一个简单的服务器和客户机程序 这个例子将以最简单的方式运用套接字对服务器和客户机进行操作。服务器的全部工作就是等候建立一个连接，然后用那个连接产生的Socket创建一个InputStream以及一个OutputStream。在这之后，它从InputStream读入的所有东西都会反馈给OutputStream，直到接收到行中止（END）为止，最后关闭连接。\n客户机连接与服务器的连接，然后创建一个OutputStream。文本行通过OutputStream发送。客户机也会创建一个InputStream，用它收听服务器说些什么（本例只不过是反馈回来的同样的字句）。\n服务器与客户机（程序）都使用同样的端口号，而且客户机利用本地主机地址连接位于同一台机器中的服务器（程序），所以不必在一个物理性的网络里完成测试（在某些配置环境中，可能需要同真正的网络建立连接，否则程序不能工作——尽管实际并不通过那个网络通信）。\n下面是服务器程序：\n//: JabberServer.java // Very simple server that just // echoes whatever the client sends. import java.io.*; import java.net.*; public class JabberServer { // Choose a port outside of the range 1-1024: public static final int PORT = 8080; public static void main(String[] args) throws IOException { ServerSocket s = new ServerSocket(PORT); System.out.println(\u0026#34;Started: \u0026#34; + s); try { // Blocks until a connection occurs: Socket socket = s.accept(); try { System.out.println( \u0026#34;Connection accepted: \u0026#34;+ socket); BufferedReader in = new BufferedReader( new InputStreamReader( socket.getInputStream())); // Output is automatically flushed // by PrintWriter: PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream())),true); while (true) { String str = in.readLine(); if (str.equals(\u0026#34;END\u0026#34;)) break; System.out.println(\u0026#34;Echoing: \u0026#34; + str); out.println(str); } // Always close the two sockets... } finally { System.out.println(\u0026#34;closing...\u0026#34;); socket.close(); } } finally { s.close(); } } } ///:~ 可以看到，ServerSocket需要的只是一个端口编号，不需要IP地址（因为它就在这台机器上运行）。调用accept()时，方法会暂时陷入停顿状态（堵塞），直到某个客户尝试同它建立连接。换言之，尽管它在那里等候连接，但其他进程仍能正常运行（参考第14章）。建好一个连接以后，accept()就会返回一个Socket对象，它是那个连接的代表。\n清除套接字的责任在这里得到了很艺术的处理。假如ServerSocket构建器失败，则程序简单地退出（注意必须保证ServerSocket的构建器在失败之后不会留下任何打开的网络套接字）。针对这种情况，main()会“掷”出一个IOException违例，所以不必使用一个try块。若ServerSocket构建器成功执行，则其他所有方法调用都必须到一个try-finally代码块里寻求保护，以确保无论块以什么方式留下，ServerSocket都能正确地关闭。\n同样的道理也适用于由accept()返回的Socket。若accept()失败，那么我们必须保证Socket不再存在或者含有任何资源，以便不必清除它们。但假若执行成功，则后续的语句必须进入一个try-finally块内，以保障在它们失败的情况下，Socket仍能得到正确的清除。由于套接字使用了重要的非内存资源，所以在这里必须特别谨慎，必须自己动手将它们清除（Java中没有提供“破坏器”来帮助我们做这件事情）。\n无论ServerSocket还是由accept()产生的Socket都打印到System.out里。这意味着它们的toString方法会得到自动调用。这样便产生了：\nServerSocket[addr=0.0.0.0,PORT=0,localport=8080]\rSocket[addr=127.0.0.1,PORT=1077,localport=8080] 大家不久就会看到它们如何与客户程序做的事情配合。\n程序的下一部分看来似乎仅仅是打开文件，以便读取和写入，只是InputStream和OutputStream是从Socket对象创建的。利用两个“转换器”类InputStreamReader和OutputStreamWriter，InputStream和OutputStream对象已经分别转换成为Java 1.1的Reader和Writer对象。也可以直接使用Java1.0的InputStream和OutputStream类，但对输出来说，使用Writer方式具有明显的优势。这一优势是通过PrintWriter表现出来的，它有一个过载的构建器，能获取第二个参数——一个布尔值标志，指向是否在每一次println()结束的时候自动刷新输出（但不适用于print()语句）。每次写入了输出内容后（写进out），它的缓冲区必须刷新，使信息能正式通过网络传递出去。对目前这个例子来说，刷新显得尤为重要，因为客户和服务器在采取下一步操作之前都要等待一行文本内容的到达。若刷新没有发生，那么信息不会进入网络，除非缓冲区满（溢出），这会为本例带来许多问题。 编写网络应用程序时，需要特别注意自动刷新机制的使用。每次刷新缓冲区时，必须创建和发出一个数据包（数据封）。就目前的情况来说，这正是我们所希望的，因为假如包内包含了还没有发出的文本行，服务器和客户机之间的相互“握手”就会停止。换句话说，一行的末尾就是一条消息的末尾。但在其他许多情况下，消息并不是用行分隔的，所以不如不用自动刷新机制，而用内建的缓冲区判决机制来决定何时发送一个数据包。这样一来，我们可以发出较大的数据包，而且处理进程也能加快。\n注意和我们打开的几乎所有数据流一样，它们都要进行缓冲处理。本章末尾有一个练习，清楚展现了假如我们不对数据流进行缓冲，那么会得到什么样的后果（速度会变慢）。\n无限while循环从BufferedReader in内读取文本行，并将信息写入System.out，然后写入PrintWriter.out。注意这可以是任何数据流，它们只是在表面上同网络连接。\n客户程序发出包含了\u0026quot;END\u0026quot;的行后，程序会中止循环，并关闭Socket。\n下面是客户程序的源码：\n//: JabberClient.java // Very simple client that just sends // lines to the server and reads lines // that the server sends. import java.net.*; import java.io.*; public class JabberClient { public static void main(String[] args) throws IOException { // Passing null to getByName() produces the // special \u0026#34;Local Loopback\u0026#34; IP address, for // testing on one machine w/o a network: InetAddress addr = InetAddress.getByName(null); // Alternatively, you can use // the address or name: // InetAddress addr = // InetAddress.getByName(\u0026#34;127.0.0.1\u0026#34;); // InetAddress addr = // InetAddress.getByName(\u0026#34;localhost\u0026#34;); System.out.println(\u0026#34;addr = \u0026#34; + addr); Socket socket = new Socket(addr, JabberServer.PORT); // Guard everything in a try-finally to make // sure that the socket is closed: try { System.out.println(\u0026#34;socket = \u0026#34; + socket); BufferedReader in = new BufferedReader( new InputStreamReader( socket.getInputStream())); // Output is automatically flushed // by PrintWriter: PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream())),true); for(int i = 0; i \u0026lt; 10; i ++) { out.println(\u0026#34;howdy \u0026#34; + i); String str = in.readLine(); System.out.println(str); } out.println(\u0026#34;END\u0026#34;); } finally { System.out.println(\u0026#34;closing...\u0026#34;); socket.close(); } } } ///:~ 在main()中，大家可看到获得本地主机IP地址的InetAddress的三种途径：使用null，使用localhost，或者直接使用保留地址127.0.0.1。当然，如果想通过网络同一台远程主机连接，也可以换用那台机器的IP地址。打印出InetAddress addr后（通过对toString()方法的自动调用），结果如下：\nlocalhost/127.0.0.1 通过向getByName()传递一个null，它会默认寻找localhost，并生成特殊的保留地址127.0.0.1。注意在名为socket的套接字创建时，同时使用了InetAddress以及端口号。打印这样的某个Socket对象时，为了真正理解它的含义，请记住一次独一无二的因特网连接是用下述四种数据标识的：clientHost（客户主机）、clientPortNumber（客户端口号）、serverHost（服务主机）以及serverPortNumber（服务端口号）。服务程序启动后，会在本地主机（127.0.0.1）上建立为它分配的端口（8080）。一旦客户程序发出请求，机器上下一个可用的端口就会分配给它（这种情况下是1077），这一行动也在与服务程序相同的机器（127.0.0.1）上进行。现在，为了使数据能在客户及服务程序之间来回传送，每一端都需要知道把数据发到哪里。所以在同一个“已知”服务程序连接的时候，客户会发出一个“返回地址”，使服务器程序知道将自己的数据发到哪儿。我们在服务器端的示范输出中可以体会到这一情况：\nSocket[addr=127.0.0.1,port=1077,localport=8080] 这意味着服务器刚才已接受了来自127.0.0.1这台机器的端口1077的连接，同时监听自己的本地端口（8080）。而在客户端：\nSocket[addr=localhost/127.0.0.1,PORT=8080,localport=1077] 这意味着客户已用自己的本地端口1077与127.0.0.1机器上的端口8080建立了 连接。\n大家会注意到每次重新启动客户程序的时候，本地端口的编号都会增加。这个编号从1025（刚好在系统保留的1-1024之外）开始，并会一直增加下去，除非我们重启机器。若重新启动机器，端口号仍然会从1025开始增值（在Unix机器中，一旦超过保留的套按字范围，数字就会再次从最小的可用数字开始）。\n创建好Socket对象后，将其转换成BufferedReader和PrintWriter的过程便与在服务器中相同（同样地，两种情况下都要从一个Socket开始）。在这里，客户通过发出字串\u0026quot;howdy\u0026quot;，并在后面跟随一个数字，从而初始化通信。注意缓冲区必须再次刷新（这是自动发生的，通过传递给PrintWriter构建器的第二个参数）。若缓冲区没有刷新，那么整个会话（通信）都会被挂起，因为用于初始化的“howdy”永远不会发送出去（缓冲区不够满，不足以造成发送动作的自动进行）。从服务器返回的每一行都会写入System.out，以验证一切都在正常运转。为中止会话，需要发出一个\u0026quot;END\u0026quot;。若客户程序简单地挂起，那么服务器会“掷”出一个违例。\n大家在这里可以看到我们采用了同样的措施来确保由Socket代表的网络资源得到正确的清除，这是用一个try-finally块实现的。\n套接字建立了一个“专用”连接，它会一直持续到明确断开连接为止（专用连接也可能间接性地断开，前提是某一端或者中间的某条链路出现故障而崩溃）。这意味着参与连接的双方都被锁定在通信中，而且无论是否有数据传递，连接都会连续处于开放状态。从表面看，这似乎是一种合理的连网方式。然而，它也为网络带来了额外的开销。本章后面会介绍进行连网的另一种方式。采用那种方式，连接的建立只是暂时的。\n总结：\rService:\r// 1、此动作是开辟端口 ServerSocket s = new ServerSocket(PORT);\r// 2、监控开辟端口是否有 Clien 连接，有则创建 Socket，此时 Service 是阻塞于此的\rSocket socket = s.accept();\r// 创建成功的 Socket : localport 监控端口、port 连接端口（回信端口）\r// Socket[addr=127.0.0.1,port=1077,localport=8080] Clien:\r// 3、向指定 地址、端口 创建 Socket\rSocket socket = new Socket(addr, port);\r// 创建成功的 Socket : localport 监控端口、port 连接端口（回信端口）\r// Socket[addr=localhost/127.0.0.1,PORT=8080,localport=1077] 15.3 服务多个客户 JabberServer可以正常工作，但每次只能为一个客户程序提供服务。在典型的服务器中，我们希望同时能处理多个客户的请求。解决这个问题的关键就是多线程处理机制。而对于那些本身不支持多线程的语言，达到这个要求无疑是异常困难的。通过第14章的学习，大家已经知道Java已对多线程的处理进行了尽可能的简化。由于Java的线程处理方式非常直接，所以让服务器控制多名客户并不是件难事。\n最基本的方法是在服务器（程序）里创建单个ServerSocket，并调用accept()来等候一个新连接。一旦accept()返回，我们就取得结果获得的Socket，并用它新建一个线程，令其只为那个特定的客户服务。然后再调用accept()，等候下一次新的连接请求。\n对于下面这段服务器代码，大家可发现它与JabberServer.java例子非常相似，只是为一个特定的客户提供服务的所有操作都已移入一个独立的线程类中：\n//: MultiJabberServer.java // A server that uses multithreading to handle // any number of clients. import java.io.*; import java.net.*; class ServeOneJabber extends Thread { private Socket socket; private BufferedReader in; private PrintWriter out; public ServeOneJabber(Socket s) throws IOException { socket = s; in = new BufferedReader( new InputStreamReader( socket.getInputStream())); // Enable auto-flush: out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream())), true); // If any of the above calls throw an // exception, the caller is responsible for // closing the socket. Otherwise the thread // will close it. start(); // Calls run() } public void run() { try { while (true) { String str = in.readLine(); if (str.equals(\u0026#34;END\u0026#34;)) break; System.out.println(\u0026#34;Echoing: \u0026#34; + str); out.println(str); } System.out.println(\u0026#34;closing...\u0026#34;); } catch (IOException e) { } finally { try { socket.close(); } catch(IOException e) {} } } } public class MultiJabberServer { static final int PORT = 8080; public static void main(String[] args) throws IOException { ServerSocket s = new ServerSocket(PORT); System.out.println(\u0026#34;Server Started\u0026#34;); try { while(true) { // Blocks until a connection occurs: Socket socket = s.accept(); try { new ServeOneJabber(socket); } catch(IOException e) { // If it fails, close the socket, // otherwise the thread will close it: socket.close(); } } } finally { s.close(); } } } ///:~ 每次有新客户请求建立一个连接时，ServeOneJabber线程都会取得由accept()在main()中生成的Socket对象。然后和往常一样，它创建一个BufferedReader，并用Socket自动刷新PrintWriter对象。最后，它调用Thread的特殊方法start()，令其进行线程的初始化，然后调用run()。这里采取的操作与前例是一样的：从套扫字读入某些东西，然后把它原样反馈回去，直到遇到一个特殊的\u0026quot;END\u0026quot;结束标志为止。\n同样地，套接字的清除必须进行谨慎的设计。就目前这种情况来说，套接字是在ServeOneJabber外部创建的，所以清除工作可以“共享”。若ServeOneJabber构建器失败，那么只需向调用者“掷”出一个违例即可，然后由调用者负责线程的清除。但假如构建器成功，那么必须由ServeOneJabber对象负责线程的清除，这是在它的run()里进行的。\n请注意MultiJabberServer有多么简单。和以前一样，我们创建一个ServerSocket，并调用accept()允许一个新连接的建立。但这一次，accept()的返回值（一个套接字）将传递给用于ServeOneJabber的构建器，由它创建一个新线程，并对那个连接进行控制。连接中断后，线程便可简单地消失。\n如果ServerSocket创建失败，则再一次通过main()掷出违例。如果成功，则位于外层的try-finally代码块可以担保正确的清除。位于内层的try-catch块只负责防范ServeOneJabber构建器的失败；若构建器成功，则ServeOneJabber线程会将对应的套接字关掉。\n为了证实服务器代码确实能为多名客户提供服务，下面这个程序将创建许多客户（使用线程），并同相同的服务器建立连接。每个线程的“存在时间”都是有限的。一旦到期，就留出空间以便创建一个新线程。允许创建的线程的最大数量是由final int maxthreads决定的。大家会注意到这个值非常关键，因为假如把它设得很大，线程便有可能耗尽资源，并产生不可预知的程序错误。\n//: MultiJabberClient.java // Client that tests the MultiJabberServer // by starting up multiple clients. import java.net.*; import java.io.*; class JabberClientThread extends Thread { private Socket socket; private BufferedReader in; private PrintWriter out; private static int counter = 0; private int id = counter++; private static int threadcount = 0; public static int threadCount() { return threadcount; } public JabberClientThread(InetAddress addr) { System.out.println(\u0026#34;Making client \u0026#34; + id); threadcount++; try { socket = new Socket(addr, MultiJabberServer.PORT); } catch(IOException e) { // If the creation of the socket fails, // nothing needs to be cleaned up. } try { in = new BufferedReader( new InputStreamReader( socket.getInputStream())); // Enable auto-flush: out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( socket.getOutputStream())), true); start(); } catch(IOException e) { // The socket should be closed on any // failures other than the socket // constructor: try { socket.close(); } catch(IOException e2) {} } // Otherwise the socket will be closed by // the run() method of the thread. } public void run() { try { for(int i = 0; i \u0026lt; 25; i++) { out.println(\u0026#34;Client \u0026#34; + id + \u0026#34;: \u0026#34; + i); String str = in.readLine(); System.out.println(str); } out.println(\u0026#34;END\u0026#34;); } catch(IOException e) { } finally { // Always close it: try { socket.close(); } catch(IOException e) {} threadcount--; // Ending this thread } } } public class MultiJabberClient { static final int MAX_THREADS = 40; public static void main(String[] args) throws IOException, InterruptedException { InetAddress addr = InetAddress.getByName(null); while(true) { if(JabberClientThread.threadCount() \u0026lt; MAX_THREADS) new JabberClientThread(addr); Thread.currentThread().sleep(100); } } } ///:~ JabberClientThread构建器获取一个InetAddress，并用它打开一个套接字。大家可能已看出了这样的一个套路：Socket肯定用于创建某种Reader以及／或者Writer（或者InputStream和／或OutputStream）对象，这是运用Socket的唯一方式（当然，我们可考虑编写一、两个类，令其自动完成这些操作，避免大量重复的代码编写工作）。同样地，start()执行线程的初始化，并调用run()。在这里，消息发送给服务器，而来自服务器的信息则在屏幕上回显出来。然而，线程的“存在时间”是有限的，最终都会结束。注意在套接字创建好以后，但在构建器完成之前，假若构建器失败，套接字会被清除。否则，为套接字调用close()的责任便落到了run()方法的头上。\nthreadcount跟踪计算目前存在的JabberClientThread对象的数量。它将作为构建器的一部分增值，并在run()退出时减值（run()退出意味着线程中止）。在MultiJabberClient.main()中，大家可以看到线程的数量会得到检查。若数量太多，则多余的暂时不创建。方法随后进入“休眠”状态。这样一来，一旦部分线程最后被中止，多作的那些线程就可以创建了。大家可试验一下逐渐增大MAX_THREADS，看看对于你使用的系统来说，建立多少线程（连接）才会使您的系统资源降低到危险程度。\n15.4 数据报 大家迄今看到的例子使用的都是“传输控制协议”（TCP），亦称作“基于数据流的套接字”。根据该协议的设计宗旨，它具有高度的可靠性，而且能保证数据顺利抵达目的地。换言之，它允许重传那些由于各种原因半路“走失”的数据。而且收到字节的顺序与它们发出来时是一样的。当然，这种控制与可靠性需要我们付出一些代价：TCP具有非常高的开销。\n还有另一种协议，名为“用户数据报协议”（UDP），它并不刻意追求数据包会完全发送出去，也不能担保它们抵达的顺序与它们发出时一样。我们认为这是一种“不可靠协议”（TCP当然是“可靠协议”）。听起来似乎很糟，但由于它的速度快得多，所以经常还是有用武之地的。对某些应用来说，比如声音信号的传输，如果少量数据包在半路上丢失了，那么用不着太在意，因为传输的速度显得更重要一些。大多数互联网游戏，如Diablo，采用的也是UDP协议通信，因为网络通信的快慢是游戏是否流畅的决定性因素。也可以想想一台报时服务器，如果某条消息丢失了，那么也真的不必过份紧张。另外，有些应用也许能向服务器传回一条UDP消息，以便以后能够恢复。如果在适当的时间里没有响应，消息就会丢失。\nJava对数据报的支持与它对TCP套接字的支持大致相同，但也存在一个明显的区别。对数据报来说，我们在客户和服务器程序都可以放置一个DatagramSocket（数据报套接字），但与ServerSocket不同，前者不会干巴巴地等待建立一个连接的请求。这是由于不再存在“连接”，取而代之的是一个数据报陈列出来。另一项本质的区别的是对TCP套接字来说，一旦我们建好了连接，便不再需要关心谁向谁“说话”——只需通过会话流来回传送数据即可。但对数据报来说，它的数据包必须知道自己来自何处，以及打算去哪里。这意味着我们必须知道每个数据报包的这些信息，否则信息就不能正常地传递。\nDatagramSocket用于收发数据包，而DatagramPacket包含了具体的信息。准备接收一个数据报时，只需提供一个缓冲区，以便安置接收到的数据。数据包抵达时，通过DatagramSocket，作为信息起源地的因特网地址以及端口编号会自动得到初化。所以一个用于接收数据报的DatagramPacket构建器是：DatagramPacket(buf, buf.length)\n其中，buf是一个字节数组。既然buf是个数组，大家可能会奇怪为什么构建器自己不能调查出数组的长度呢？实际上我也有同感，唯一能猜到的原因就是C风格的编程使然，那里的数组不能自己告诉我们它有多大。\n可以重复使用数据报的接收代码，不必每次都建一个新的。每次用它的时候（再生），缓冲区内的数据都会被覆盖。\n缓冲区的最大容量仅受限于允许的数据报包大小，这个限制位于比64KB稍小的地方。但在许多应用程序中，我们都宁愿它变得还要小一些，特别是在发送数据的时候。具体选择的数据包大小取决于应用程序的特定要求。\n发出一个数据报时，DatagramPacket不仅需要包含正式的数据，也要包含因特网地址以及端口号，以决定它的目的地。所以用于输出DatagramPacket的构建器是：\nDatagramPacket(buf, length, inetAddress, port) 这一次，buf（一个字节数组）已经包含了我们想发出的数据。length可以是buf的长度，但也可以更短一些，意味着我们只想发出那么多的字节。另两个参数分别代表数据包要到达的因特网地址以及目标机器的一个目标端口（注释②）。\n②：我们认为TCP和UDP端口是相互独立的。也就是说，可以在端口8080同时运行一个TCP和UDP服务程序，两者之间不会产生冲突。\n大家也许认为两个构建器创建了两个不同的对象：一个用于接收数据报，另一个用于发送它们。如果是好的面向对象的设计方案，会建议把它们创建成两个不同的类，而不是具有不同的行为的一个类（具体行为取决于我们如何构建对象）。这也许会成为一个严重的问题，但幸运的是，DatagramPacket的使用相当简单，我们不需要在这个问题上纠缠不清。这一点在下例里将有很明确的说明。该例类似于前面针对TCP套接字的MultiJabberServer和MultiJabberClient例子。多个客户都会将数据报发给服务器，后者会将其反馈回最初发出消息的同样的客户。\n为简化从一个String里创建DatagramPacket的工作（或者从DatagramPacket里创建String），这个例子首先用到了一个工具类，名为Dgram：\n//: Dgram.java // A utility class to convert back and forth // Between Strings and DataGramPackets. import java.net.*; public class Dgram { public static DatagramPacket toDatagram(String s, InetAddress destIA, int destPort) { // Deprecated in Java 1.1, but it works: byte[] buf = new byte[s.length() + 1]; s.getBytes(0, s.length(), buf, 0); // The correct Java 1.1 approach, but it\u0026#39;s // Broken (it truncates the String): // byte[] buf = s.getBytes(); return new DatagramPacket(buf, buf.length, destIA, destPort); } public static String toString(DatagramPacket p){ // The Java 1.0 approach: // return new String(p.getData(), // 0, 0, p.getLength()); // The Java 1.1 approach: return new String(p.getData(), 0, p.getLength()); } } ///:~ Dgram的第一个方法采用一个String、一个InetAddress以及一个端口号作为自己的参数，将String的内容复制到一个字节缓冲区，再将缓冲区传递进入DatagramPacket构建器，从而构建一个DatagramPacket。注意缓冲区分配时的\u0026quot;+1\u0026quot;——这对防止截尾现象是非常重要的。String的getByte()方法属于一种特殊操作，能将一个字串包含的char复制进入一个字节缓冲。该方法现在已被“反对”使用；Java 1.1有一个“更好”的办法来做这个工作，但在这里却被当作注释屏蔽掉了，因为它会截掉String的部分内容。所以尽管我们在Java 1.1下编译该程序时会得到一条“反对”消息，但它的行为仍然是正确无误的（这个错误应该在你读到这里的时候修正了）。\nDgram.toString()方法同时展示了Java 1.0的方法和Java 1.1的方法（两者是不同的，因为有一种新类型的String构建器）。\n下面是用于数据报演示的服务器代码：\n//: ChatterServer.java // A server that echoes datagrams import java.net.*; import java.io.*; import java.util.*; public class ChatterServer { static final int INPORT = 1711; private byte[] buf = new byte[1000]; private DatagramPacket dp = new DatagramPacket(buf, buf.length); // Can listen \u0026amp; send on the same socket: private DatagramSocket socket; public ChatterServer() { try { socket = new DatagramSocket(INPORT); System.out.println(\u0026#34;Server started\u0026#34;); while(true) { // Block until a datagram appears: socket.receive(dp); String rcvd = Dgram.toString(dp) + \u0026#34;, from address: \u0026#34; + dp.getAddress() + \u0026#34;, port: \u0026#34; + dp.getPort(); System.out.println(rcvd); String echoString = \u0026#34;Echoed: \u0026#34; + rcvd; // Extract the address and port from the // received datagram to find out where to // send it back: DatagramPacket echo = Dgram.toDatagram(echoString, dp.getAddress(), dp.getPort()); socket.send(echo); } } catch(SocketException e) { System.err.println(\u0026#34;Can\u0026#39;t open socket\u0026#34;); System.exit(1); } catch(IOException e) { System.err.println(\u0026#34;Communication error\u0026#34;); e.printStackTrace(); } } public static void main(String[] args) { new ChatterServer(); } } ///:~ ChatterServer创建了一个用来接收消息的DatagramSocket（数据报套接字），而不是在我们每次准备接收一条新消息时都新建一个。这个单一的DatagramSocket可以重复使用。它有一个端口号，因为这属于服务器，客户必须确切知道自己把数据报发到哪个地址。尽管有一个端口号，但没有为它分配因特网地址，因为它就驻留在“这”台机器内，所以知道自己的因特网地址是什么（目前是默认的localhost）。在无限while循环中，套接字被告知接收数据（receive()）。然后暂时挂起，直到一个数据报出现，再把它反馈回我们希望的接收人——DatagramPacket dp——里面。数据包（Packet）会被转换成一个字串，同时插入的还有数据包的起源因特网地址及套接字。这些信息会显示出来，然后添加一个额外的字串，指出自己已从服务器反馈回来了。\n大家可能会觉得有点儿迷惑。正如大家会看到的那样，许多不同的因特网地址和端口号都可能是消息的起源地——换言之，客户程序可能驻留在任何一台机器里（就这一次演示来说，它们都驻留在localhost里，但每个客户使用的端口编号是不同的）。为了将一条消息送回它真正的始发客户，需要知道那个客户的因特网地址以及端口号。幸运的是，所有这些资料均已非常周到地封装到发出消息的DatagramPacket内部，所以我们要做的全部事情就是用getAddress()和getPort()把它们取出来。利用这些资料，可以构建DatagramPacket echo——它通过与接收用的相同的套接字发送回来。除此以外，一旦套接字发出数据报，就会添加“这”台机器的因特网地址及端口信息，所以当客户接收消息时，它可以利用getAddress()和getPort()了解数据报来自何处。事实上，getAddress()和getPort()唯一不能告诉我们数据报来自何处的前提是：我们创建一个待发送的数据报，并在正式发出之前调用了getAddress()和getPort()。到数据报正式发送的时候，这台机器的地址以及端口才会写入数据报。所以我们得到了运用数据报时一项重要的原则：不必跟踪一条消息的来源地！因为它肯定保存在数据报里。事实上，对程序来说，最可靠的做法是我们不要试图跟踪，而是无论如何都从目标数据报里提取出地址以及端口信息（就象这里做的那样）。\n为测试服务器的运转是否正常，下面这程序将创建大量客户（线程），它们都会将数据报包发给服务器，并等候服务器把它们原样反馈回来。\n//: ChatterServer.java // A server that echoes datagrams import java.net.*; import java.io.*; import java.util.*; public class ChatterServer { static final int INPORT = 1711; private byte[] buf = new byte[1000]; private DatagramPacket dp = new DatagramPacket(buf, buf.length); // Can listen \u0026amp; send on the same socket: private DatagramSocket socket; public ChatterServer() { try { socket = new DatagramSocket(INPORT); System.out.println(\u0026#34;Server started\u0026#34;); while(true) { // Block until a datagram appears: socket.receive(dp); String rcvd = Dgram.toString(dp) + \u0026#34;, from address: \u0026#34; + dp.getAddress() + \u0026#34;, port: \u0026#34; + dp.getPort(); System.out.println(rcvd); String echoString = \u0026#34;Echoed: \u0026#34; + rcvd; // Extract the address and port from the // received datagram to find out where to // send it back: DatagramPacket echo = Dgram.toDatagram(echoString, dp.getAddress(), dp.getPort()); socket.send(echo); } } catch(SocketException e) { System.err.println(\u0026#34;Can\u0026#39;t open socket\u0026#34;); System.exit(1); } catch(IOException e) { System.err.println(\u0026#34;Communication error\u0026#34;); e.printStackTrace(); } } public static void main(String[] args) { new ChatterServer(); } } ///:~ ChatterClient被创建成一个线程（Thread），所以可以用多个客户来“骚扰”服务器。从中可以看到，用于接收的DatagramPacket和用于ChatterServer的那个是相似的。在构建器中，创建DatagramPacket时没有附带任何参数（自变量），因为它不需要明确指出自己位于哪个特定编号的端口里。用于这个套接字的因特网地址将成为“这台机器”（比如localhost），而且会自动分配端口编号，这从输出结果即可看出。同用于服务器的那个一样，这个DatagramPacket将同时用于发送和接收。\nhostAddress是我们想与之通信的那台机器的因特网地址。在程序中，如果需要创建一个准备传出去的DatagramPacket，那么必须知道一个准确的因特网地址和端口号。可以肯定的是，主机必须位于一个已知的地址和端口号上，使客户能启动与主机的“会话”。\n每个线程都有自己独一无二的标识号（尽管自动分配给线程的端口号是也会提供一个唯一的标识符）。在run()中，我们创建了一个String消息，其中包含了线程的标识编号以及该线程准备发送的消息编号。我们用这个字串创建一个数据报，发到主机上的指定地址；端口编号则直接从ChatterServer内的一个常数取得。一旦消息发出，receive()就会暂时被“堵塞”起来，直到服务器回复了这条消息。与消息附在一起的所有信息使我们知道回到这个特定线程的东西正是从始发消息中投递出去的。在这个例子中，尽管是一种“不可靠”协议，但仍然能够检查数据报是否到去过了它们该去的地方（这在localhost和LAN环境中是成立的，但在非本地连接中却可能出现一些错误）。\n运行该程序时，大家会发现每个线程都会结束。这意味着发送到服务器的每个数据报包都会回转，并反馈回正确的接收者。如果不是这样，一个或更多的线程就会挂起并进入“堵塞”状态，直到它们的输入被显露出来。\n大家或许认为将文件从一台机器传到另一台的唯一正确方式是通过TCP套接字，因为它们是“可靠”的。然而，由于数据报的速度非常快，所以它才是一种更好的选择。我们只需将文件分割成多个数据报，并为每个包编号。接收机器会取得这些数据包，并重新“组装”它们；一个“标题包”会告诉机器应该接收多少个包，以及组装所需的另一些重要信息。如果一个包在半路“走丢”了，接收机器会返回一个数据报，告诉发送者重传。\n15.5 一个Web应用 现在让我们想想如何创建一个应用，令其在真实的Web环境中运行，它将把Java的优势表现得淋漓尽致。这个应用的一部分是在Web服务器上运行的一个Java程序，另一部分则是一个“程序片”或“小应用程序”（Applet），从服务器下载至浏览器（即“客户”）。这个程序片从用户那里收集信息，并将其传回Web服务器上运行的应用程序。程序的任务非常简单：程序片会询问用户的E-mail地址，并在验证这个地址合格后（没有包含空格，而且有一个@符号），将该E-mail发送给Web服务器。服务器上运行的程序则会捕获传回的数据，检查一个包含了所有E-mail地址的数据文件。如果那个地址已包含在文件里，则向浏览器反馈一条消息，说明这一情况。该消息由程序片负责显示。若是一个新地址，则将其置入列表，并通知程序片已成功添加了电子函件地址。\n若采用传统方式来解决这个问题，我们要创建一个包含了文本字段及一个“提交”（Submit）按钮的HTML页。用户可在文本字段里键入自己喜欢的任何内容，并毫无阻碍地提交给服务器（在客户端不进行任何检查）。提交数据的同时，Web页也会告诉服务器应对数据采取什么样的操作——知会“通用网关接口”（CGI）程序，收到这些数据后立即运行服务器。这种CGI程序通常是用Perl或C写的（有时也用C++，但要求服务器支持），而且必须能控制一切可能出现的情况。它首先会检查数据，判断是否采用了正确的格式。若答案是否定的，则CGI程序必须创建一个HTML页，对遇到的问题进行描述。这个页会转交给服务器，再由服务器反馈回用户。用户看到出错提示后，必须再试一遍提交，直到通过为止。若数据正确，CGI程序会打开数据文件，要么把电子函件地址加入文件，要么指出该地址已在数据文件里了。无论哪种情况，都必须格式化一个恰当的HTML页，以便服务器返回给用户。\n作为Java程序员，上述解决问题的方法显得非常笨拙。而且很自然地，我们希望一切工作都用Java完成。首先，我们会用一个Java程序片负责客户端的数据有效性校验，避免数据在服务器和客户之间传来传去，浪费时间和带宽，同时减轻服务器额外构建HTML页的负担。然后跳过Perl CGI脚本，换成在服务器上运行一个Java应用。事实上，我们在这儿已完全跳过了Web服务器，仅仅需要从程序片到服务器上运行的Java应用之间建立一个连接即可。\n正如大家不久就会体验到的那样，尽管看起来非常简单，但实际上有一些意想不到的问题使局面显得稍微有些复杂。用Java 1.1写程序片是最理想的，但实际上却经常行不通。到本书写作的时候，拥有Java 1.1能力的浏览器仍为数不多，而且即使这类浏览器现在非常流行，仍需考虑照顾一下那些升级缓慢的人。所以从安全的角度看，程序片代码最好只用Java 1.0编写。基于这一前提，我们不能用JAR文件来合并（压缩）程序片中的.class文件。所以，我们应尽可能减少.class文件的使用数量，以缩短下载时间。 好了，再来说说我用的Web服务器（写这个示范程序时用的就是它）。它确实支持Java，但仅限于Java 1.0！所以服务器应用也必须用Java 1.0编写。\n15.5.1 服务器应用 现在讨论一下服务器应用（程序）的问题，我把它叫作NameCollecor（名字收集器）。假如多名用户同时尝试提交他们的E-mail地址，那么会发生什么情况呢？若NameCollector使用TCP/IP套接字，那么必须运用早先介绍的多线程机制来实现对多个客户的并发控制。但所有这些线程都试图把数据写到同一个文件里，其中保存了所有E-mail地址。这便要求我们设立一种锁定机制，保证多个线程不会同时访问那个文件。一个“信号机”可在这里帮助我们达到目的，但或许还有一种更简单的方式。\n如果我们换用数据报，就不必使用多线程了。用单个数据报即可“侦听”进入的所有数据报。一旦监视到有进入的消息，程序就会进行适当的处理，并将答复数据作为一个数据报传回原先发出请求的那名接收者。若数据报半路上丢失了，则用户会注意到没有答复数据传回，所以可以重新提交请求。\n服务器应用收到一个数据报，并对它进行解读的时候，必须提取出其中的电子函件地址，并检查本机保存的数据文件，看看里面是否已经包含了那个地址（如果没有，则添加之）。所以我们现在遇到了一个新的问题。Java 1.0似乎没有足够的能力来方便地处理包含了电子函件地址的文件（Java 1.1则不然）。但是，用C轻易就可以解决这个问题。因此，我们在这儿有机会学习将一个非Java程序同Java程序连接的最简便方式。程序使用的Runtime对象包含了一个名为exec()的方法，它会独立机器上一个独立的程序，并返回一个Process（进程）对象。我们可以取得一个OutputStream，它同这个单独程序的标准输入连接在一起；并取得一个InputStream，它则同标准输出连接到一起。要做的全部事情就是用任何语言写一个程序，只要它能从标准输入中取得自己的输入数据，并将输出结果写入标准输出即可。如果有些问题不能用Java简便与快速地解决（或者想利用原有代码，不想改写），就可以考虑采用这种方法。亦可使用Java的“固有方法”（Native Method），但那要求更多的技巧，大家可以参考一下附录A。\nC程序 这个非Java应用是用C写成，因为Java不适合作CGI编程；起码启动的时间不能让人满意。它的任务是管理电子函件（E-mail）地址的一个列表。标准输入会接受一个E-mail地址，程序会检查列表中的名字，判断是否存在那个地址。若不存在，就将其加入，并报告操作成功。但假如名字已在列表里了，就需要指出这一点，避免重复加入。大家不必担心自己不能完全理解下列代码的含义。它仅仅是一个演示程序，告诉你如何用其他语言写一个程序，并从Java中调用它。在这里具体采用何种语言并不重要，只要能够从标准输入中读取数据，并能写入标准输出即可。\n//: Listmgr.c // Used by NameCollector.java to manage // the email list file on the server #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define BSIZE 250 int alreadyInList(FILE* list, char* name) { char lbuf[BSIZE]; // Go to the beginning of the list: fseek(list, 0, SEEK_SET); // Read each line in the list: while(fgets(lbuf, BSIZE, list)) { // Strip off the newline: char * newline = strchr(lbuf, \u0026#39;\\n\u0026#39;); if(newline != 0) *newline = \u0026#39;\\0\u0026#39;; if(strcmp(lbuf, name) == 0) return 1; } return 0; } int main() { char buf[BSIZE]; FILE* list = fopen(\u0026#34;emlist.txt\u0026#34;, \u0026#34;a+t\u0026#34;); if(list == 0) { perror(\u0026#34;could not open emlist.txt\u0026#34;); exit(1); } while(1) { gets(buf); /* From stdin */ if(alreadyInList(list, buf)) { printf(\u0026#34;Already in list: %s\u0026#34;, buf); fflush(stdout); } else { fseek(list, 0, SEEK_END); fprintf(list, \u0026#34;%s\\n\u0026#34;, buf); fflush(list); printf(\u0026#34;%s added to list\u0026#34;, buf); fflush(stdout); } } } ///:~ 该程序假设C编译器能接受\u0026rsquo;//\u0026lsquo;样式注释（许多编译器都能，亦可换用一个C++编译器来编译这个程序）。如果你的编译器不能接受，则简单地将那些注释删掉即可。\n文件中的第一个函数检查我们作为第二个参数（指向一个char的指针）传递给它的名字是否已在文件中。在这儿，我们将文件作为一个FILE指针传递，它指向一个已打开的文件（文件是在main()中打开的）。函数fseek()在文件中遍历；我们在这儿用它移至文件开头。fgets()从文件list中读入一行内容，并将其置入缓冲区lbuf——不会超过规定的缓冲区长度BSIZE。所有这些工作都在一个while循环中进行，所以文件中的每一行都会读入。接下来，用strchr()找到新行字符，以便将其删掉。最后，用strcmp()比较我们传递给函数的名字与文件中的当前行。若找到一致的内容，strcmp()会返回0。函数随后会退出，并返回一个\n1，指出该名字已经在文件里了（注意这个函数找到相符内容后会立即返回，不会把时间浪费在检查列表剩余内容的上面）。如果找遍列表都没有发现相符的内容，则函数返回0。\n在main()中，我们用fopen()打开文件。第一个参数是文件名，第二个是打开文件的方式；a+表示“追加”，以及“打开”（或“创建”，假若文件尚不存在），以便到文件的末尾进行更新。fopen()函数返回的是一个FILE指针；若为0，表示打开操作失败。此时需要用perror()打印一条出错提示消息，并用exit()中止程序运行。\n如果文件成功打开，程序就会进入一个无限循环。调用gets(buf)的函数会从标准输入中取出一行（记住标准输入会与Java程序连接到一起），并将其置入缓冲区buf中。缓冲区的内容随后会简单地传递给alreadyInList()函数，如内容已在列表中，printf()就会将那条消息发给标准输出（Java程序正在监视它）。fflush()用于对输出缓冲区进行刷新。\n如果名字不在列表中，就用fseek()移到列表末尾，并用fprintf()将名字“打印”到列表末尾。随后，用printf()指出名字已成功加入列表（同样需要刷新标准输出），无限循环返回，继续等候一个新名字的进入。\n记住一般不能先在自己的计算机上编译此程序，再把编译好的内容上载到Web服务器，因为那台机器使用的可能是不同类的处理器和操作系统。例如，我的Web服务器安装的是Intel的CPU，但操作系统是Linux，所以必须先下载源码，再用远程命令（通过telnet）指挥Linux自带的C编译器，令其在服务器端编译好程序。\nJava程序 这个程序先启动上述的C程序，再建立必要的连接，以便同它“交谈”。随后，它创建一个数据报套接字，用它“监视”或者“侦听”来自程序片的数据报包。\n//: NameCollector.java // Extracts email names from datagrams and stores // them inside a file, using Java 1.02. import java.net.*; import java.io.*; import java.util.*; public class NameCollector { final static int COLLECTOR_PORT = 8080; final static int BUFFER_SIZE = 1000; byte[] buf = new byte[BUFFER_SIZE]; DatagramPacket dp = new DatagramPacket(buf, buf.length); // Can listen \u0026amp; send on the same socket: DatagramSocket socket; Process listmgr; PrintStream nameList; DataInputStream addResult; public NameCollector() { try { listmgr = Runtime.getRuntime().exec(\u0026#34;listmgr.exe\u0026#34;); nameList = new PrintStream( new BufferedOutputStream( listmgr.getOutputStream())); addResult = new DataInputStream( new BufferedInputStream( listmgr.getInputStream())); } catch(IOException e) { System.err.println( \u0026#34;Cannot start listmgr.exe\u0026#34;); System.exit(1); } try { socket = new DatagramSocket(COLLECTOR_PORT); System.out.println( \u0026#34;NameCollector Server started\u0026#34;); while(true) { // Block until a datagram appears: socket.receive(dp); String rcvd = new String(dp.getData(), 0, 0, dp.getLength()); // Send to listmgr.exe standard input: nameList.println(rcvd.trim()); nameList.flush(); byte[] resultBuf = new byte[BUFFER_SIZE]; int byteCount = addResult.read(resultBuf); if(byteCount != -1) { String result = new String(resultBuf, 0).trim(); // Extract the address and port from // the received datagram to find out // where to send the reply: InetAddress senderAddress = dp.getAddress(); int senderPort = dp.getPort(); byte[] echoBuf = new byte[BUFFER_SIZE]; result.getBytes( 0, byteCount, echoBuf, 0); DatagramPacket echo = new DatagramPacket( echoBuf, echoBuf.length, senderAddress, senderPort); socket.send(echo); } else System.out.println( \u0026#34;Unexpected lack of result from \u0026#34; + \u0026#34;listmgr.exe\u0026#34;); } } catch(SocketException e) { System.err.println(\u0026#34;Can\u0026#39;t open socket\u0026#34;); System.exit(1); } catch(IOException e) { System.err.println(\u0026#34;Communication error\u0026#34;); e.printStackTrace(); } } public static void main(String[] args) { new NameCollector(); } } ///:~ NameCollector中的第一个定义应该是大家所熟悉的：选定端口，创建一个数据报包，然后创建指向一个DatagramSocket的句柄。接下来的三个定义负责与C程序的连接：一个Process对象是C程序由Java程序启动之后返回的，而且那个Process对象产生了InputStream和OutputStream，分别代表C程序的标准输出和标准输入。和Java IO一样，它们理所当然地需要“封装”起来，所以我们最后得到的是一个PrintStream和DataInputStream。\n这个程序的所有工作都是在构建器内进行的。为启动C程序，需要取得当前的Runtime对象。我们用它调用exec()，再由后者返回Process对象。在Process对象中，大家可看到通过一简单的调用即可生成数据流：getOutputStream()和getInputStream()。从这个时候开始，我们需要考虑的全部事情就是将数据传给数据流nameList，并从addResult中取得结果。\n和往常一样，我们将DatagramSocket同一个端口连接到一起。在无限while循环中，程序会调用receive()——除非一个数据报到来，否则receive()会一起处于“堵塞”状态。数据报出现以后，它的内容会提取到String rcvd里。我们首先将该字串两头的空格剔除（trim），再将其发给C程序。如下所示：\nnameList.println(rcvd.trim()); 之所以能这样编码，是因为Java的exec()允许我们访问任何可执行模块，只要它能从标准输入中读，并能向标准输出中写。还有另一些方式可与非Java代码“交谈”，这将在附录A中讨论。\n从C程序中捕获结果就显得稍微麻烦一些。我们必须调用read()，并提供一个缓冲区，以便保存结果。read()的返回值是来自C程序的字节数。若这个值为-1，意味着某个地方出现了问题。否则，我们就将resultBuf（结果缓冲区）转换成一个字串，然后同样清除多余的空格。随后，这个字串会象往常一样进入一个DatagramPacket，并传回当初发出请求的那个同样的地址。注意发送方的地址也是我们接收到的DatagramPacket的一部分。\n记住尽管C程序必须在Web服务器上编译，但Java程序的编译场所可以是任意的。这是由于不管使用的是什么硬件平台和操作系统，编译得到的字节码都是一样的。就就是Java的“跨平台”兼容能力。\n15.5.2 NameSender程序片 正如早先指出的那样，程序片必须用Java 1.0编写，使其能与绝大多数的浏览器适应。也正是由于这个原因，我们产生的类数量应尽可能地少。所以我们在这儿不考虑使用前面设计好的Dgram类，而将数据报的所有维护工作都转到代码行中进行。此外，程序片要用一个线程监视由服务器传回的响应信息，而非实现Runnable接口，用集成到程序片的一个独立线程来做这件事情。当然，这样做对代码的可读性不利，但却能产生一个单类（以及单个服务器请求）程序片：\n//: NameSender.java // An applet that sends an email address // as a datagram, using Java 1.02. import java.awt.*; import java.applet.*; import java.net.*; import java.io.*; public class NameSender extends Applet implements Runnable { private Thread pl = null; private Button send = new Button( \u0026#34;Add email address to mailing list\u0026#34;); private TextField t = new TextField( \u0026#34;type your email address here\u0026#34;, 40); private String str = new String(); private Label l = new Label(), l2 = new Label(); private DatagramSocket s; private InetAddress hostAddress; private byte[] buf = new byte[NameCollector.BUFFER_SIZE]; private DatagramPacket dp = new DatagramPacket(buf, buf.length); private int vcount = 0; public void init() { setLayout(new BorderLayout()); Panel p = new Panel(); p.setLayout(new GridLayout(2, 1)); p.add(t); p.add(send); add(\u0026#34;North\u0026#34;, p); Panel labels = new Panel(); labels.setLayout(new GridLayout(2, 1)); labels.add(l); labels.add(l2); add(\u0026#34;Center\u0026#34;, labels); try { // Auto-assign port number: s = new DatagramSocket(); hostAddress = InetAddress.getByName( getCodeBase().getHost()); } catch(UnknownHostException e) { l.setText(\u0026#34;Cannot find host\u0026#34;); } catch(SocketException e) { l.setText(\u0026#34;Can\u0026#39;t open socket\u0026#34;); } l.setText(\u0026#34;Ready to send your email address\u0026#34;); } public boolean action (Event evt, Object arg) { if(evt.target.equals(send)) { if(pl != null) { // pl.stop(); Deprecated in Java 1.2 Thread remove = pl; pl = null; remove.interrupt(); } l2.setText(\u0026#34;\u0026#34;); // Check for errors in email name: str = t.getText().toLowerCase().trim(); if(str.indexOf(\u0026#39; \u0026#39;) != -1) { l.setText(\u0026#34;Spaces not allowed in name\u0026#34;); return true; } if(str.indexOf(\u0026#39;,\u0026#39;) != -1) { l.setText(\u0026#34;Commas not allowed in name\u0026#34;); return true; } if(str.indexOf(\u0026#39;@\u0026#39;) == -1) { l.setText(\u0026#34;Name must include \u0026#39;@\u0026#39;\u0026#34;); l2.setText(\u0026#34;\u0026#34;); return true; } if(str.indexOf(\u0026#39;@\u0026#39;) == 0) { l.setText(\u0026#34;Name must preceed \u0026#39;@\u0026#39;\u0026#34;); l2.setText(\u0026#34;\u0026#34;); return true; } String end = str.substring(str.indexOf(\u0026#39;@\u0026#39;)); if(end.indexOf(\u0026#39;.\u0026#39;) == -1) { l.setText(\u0026#34;Portion after \u0026#39;@\u0026#39; must \u0026#34; + \u0026#34;have an extension, such as \u0026#39;.com\u0026#39;\u0026#34;); l2.setText(\u0026#34;\u0026#34;); return true; } // Everything\u0026#39;s OK, so send the name. Get a // fresh buffer, so it\u0026#39;s zeroed. For some // reason you must use a fixed size rather // than calculating the size dynamically: byte[] sbuf = new byte[NameCollector.BUFFER_SIZE]; str.getBytes(0, str.length(), sbuf, 0); DatagramPacket toSend = new DatagramPacket( sbuf, 100, hostAddress, NameCollector.COLLECTOR_PORT); try { s.send(toSend); } catch(Exception e) { l.setText(\u0026#34;Couldn\u0026#39;t send datagram\u0026#34;); return true; } l.setText(\u0026#34;Sent: \u0026#34; + str); send.setLabel(\u0026#34;Re-send\u0026#34;); pl = new Thread(this); pl.start(); l2.setText( \u0026#34;Waiting for verification \u0026#34; + ++vcount); } else return super.action(evt, arg); return true; } // The thread portion of the applet watches for // the reply to come back from the server: public void run() { try { s.receive(dp); } catch(Exception e) { l2.setText(\u0026#34;Couldn\u0026#39;t receive datagram\u0026#34;); return; } l2.setText(new String(dp.getData(), 0, 0, dp.getLength())); } } ///:~ 程序片的UI（用户界面）非常简单。它包含了一个TestField（文本字段），以便我们键入一个电子函件地址；以及一个Button（按钮），用于将地址发给服务器。两个Label（标签）用于向用户报告状态信息。\n到现在为止，大家已能判断出DatagramSocket、InetAddress、缓冲区以及DatagramPacket都属于网络连接中比较麻烦的部分。最后，大家可看到run()方法实现了线程部分，使程序片能够“侦听”由服务器传回的响应信息。\ninit()方法用大家熟悉的布局工具设置GUI，然后创建DatagramSocket，它将同时用于数据报的收发。\naction()方法只负责监视我们是否按下了“发送”（send）按钮。记住，我们已被限制在Java 1.0上面，所以不能再用较灵活的内部类了。按钮按下以后，采取的第一项行动便是检查线程pl，看看它是否为null（空）。如果不为null，表明有一个活动线程正在运行。消息首次发出时，会启动一个新线程，用它监视来自服务器的回应。所以假若有个线程正在运行，就意味着这并非用户第一次发送消息。pl句柄被设为null，同时中止原来的监视者（这是最合理的一种做法，因为stop()已被Java 1.2“反对”，这在前一章已解释过了）。\n无论这是否按钮被第一次按下，I2中的文字都会清除。\n下一组语句将检查E-mail名字是否合格。String.indexOf()方法的作用是搜索其中的非法字符。如果找到一个，就把情况报告给用户。注意进行所有这些工作时，都不必涉及网络通信，所以速度非常快，而且不会影响带宽和服务器的性能。\n名字校验通过以后，它会打包到一个数据报里，然后采用与前面那个数据报示例一样的方式发到主机地址和端口编号。第一个标签会发生变化，指出已成功发送出去。而且按钮上的文字也会改变，变成“重发”（resend）。这时会启动线程，第二个标签则会告诉我们程序片正在等候来自服务器的回应。\n线程的run()方法会利用NameSender中包含的DatagramSocket来接收数据（receive()），除非出现来自服务器的数据报包，否则receive()会暂时处于“堵塞”或者“暂停”状态。结果得到的数据包会放进NameSender的DatagramPacketdp中。数据会从包中提取出来，并置入NameSender的第二个标签。随后，线程的执行将中断，成为一个“死”线程。若某段时间里没有收到来自服务器的回应，用户可能变得不耐烦，再次按下按钮。这样做会中断当前线程（数据发出以后，会再建一个新的）。由于用一个线程来监视回应数据，所以用户在监视期间仍然可以自由使用UI。\nWeb页 当然，程序片必须放到一个Web页里。下面列出完整的Web页源码；稍微研究一下就可看出，我用它从自己开办的邮寄列表（Mailling List）里自动收集名字。\n\u0026lt;HTML\u0026gt;\r\u0026lt;HEAD\u0026gt;\r\u0026lt;META CONTENT=\u0026#34;text/html\u0026#34;\u0026gt;\r\u0026lt;TITLE\u0026gt;\rAdd Yourself to Bruce Eckel\u0026#39;s Java Mailing List\r\u0026lt;/TITLE\u0026gt;\r\u0026lt;/HEAD\u0026gt;\r\u0026lt;BODY LINK=\u0026#34;#0000ff\u0026#34; VLINK=\u0026#34;#800080\u0026#34; BGCOLOR=\u0026#34;#ffffff\u0026#34;\u0026gt;\r\u0026lt;FONT SIZE=6\u0026gt;\u0026lt;P\u0026gt;\rAdd Yourself to Bruce Eckel\u0026#39;s Java Mailing List\r\u0026lt;/P\u0026gt;\u0026lt;/FONT\u0026gt;\rThe applet on this page will automatically add your email address to the mailing list, so you will receive update information about changes to the online version of \u0026#34;Thinking in Java,\u0026#34; notification when the book is in print, information about upcoming Java seminars, and notification about the “Hands-on Java Seminar” Multimedia CD. Type in your email address and press the button to automatically add yourself to this mailing list. \u0026lt;HR\u0026gt;\r\u0026lt;applet code=NameSender width=400 height=100\u0026gt;\r\u0026lt;/applet\u0026gt;\r\u0026lt;HR\u0026gt;\rIf after several tries, you do not get verification it means that the Java application on the server is having problems. In this case, you can add yourself to the list by sending email to \u0026lt;A HREF=\u0026#34;mailto:Bruce@EckelObjects.com\u0026#34;\u0026gt;\rBruce@EckelObjects.com\u0026lt;/A\u0026gt;\r\u0026lt;/BODY\u0026gt;\r\u0026lt;/HTML\u0026gt; 程序片标记（）的使用非常简单，和第13章展示的那一个并没有什么区别。\n15.5.3 要注意的问题 前面采取的似乎是一种完美的方法。没有CGI编程，所以在服务器启动一个CGI程序时不会出现延迟。数据报方式似乎能产生非常快的响应。此外，一旦Java 1.1得到绝大多数人的采纳，服务器端的那一部分就可完全用Java编写（尽管利用标准输入和输出同一个非Java程序连接也非常容易）。\n但必须注意到一些问题。其中一个特别容易忽略：由于Java应用在服务器上是连续运行的，而且会把大多数时间花在Datagram.receive()方法的等候上面，这样便为CPU带来了额外的开销。至少，我在自己的服务器上便发现了这个问题。另一方面，那个服务器上不会发生其他更多的事情。而且假如我们使用一个任务更为繁重的服务器，启动程序用“nice”（一个Unix程序，用于防止进程贪吃CPU资源）或其他等价程序即可解决问题。在许多情况下，都有必要留意象这样的一些应用——一个堵塞的receive()完全可能造成CPU的瘫痪。\n第二个问题涉及防火墙。可将防火墙理解成自己的本地网与因特网之间的一道墙（实际是一个专用机器或防火墙软件）。它监视进出因特网的所有通信，确保这些通信不违背预设的规则。\n防火墙显得多少有些保守，要求严格遵守所有规则。假如没有遵守，它们会无情地把它们拒之门外。例如，假设我们位于防火墙后面的一个网络中，开始用Web浏览器同因特网连接，防火墙要求所有传输都用可以接受的http端口同服务器连接，这个端口是80。现在来了这个Java程序片NameSender，它试图将一个数据报传到端口8080，这是为了越过“受保护”的端口范围0-1024而设置的。防火墙很自然地把它想象成最坏的情况——有人使用病毒或者非法扫描端口——根本不允许传输的继续进行。\n只要我们的客户建立的是与因特网的原始连接（比如通过典型的ISP接驳Internet），就不会出现此类防火墙问题。但也可能有一些重要的客户隐藏在防火墙后，他们便不能使用我们设计的程序。\n在学过有关Java的这么多东西以后，这是一件使人相当沮丧的事情，因为看来必须放弃在服务器上使用Java，改为学习如何编写C或Perl脚本程序。但请大家不要绝望。\n一个出色方案是由Sun公司提出的。如一切按计划进行，Web服务器最终都装备“小服务程序”或者“服务程序片”（Servlet）。它们负责接收来自客户的请求（经过防火墙允许的80端口）。而且不再是启动一个CGI程序，它们会启动小服务程序。根据Sun的设想，这些小服务程序都是用Java编写的，而且只能在服务器上运行。运行这种小程序的服务器会自动启动它们，令其对客户的请求进行处理。这意味着我们的所有程序都可以用Java写成（100%纯咖啡）。这显然是一种非常吸引人的想法：一旦习惯了Java，就不必换用其他语言在服务器上处理客户请求。\n由于只能在服务器上控制请求，所以小服务程序API没有提供GUI功能。这对NameCollector.java来说非常适合，它本来就不需要任何图形界面。\n在本书写作时，java.sun.com已提供了一个非常廉价的小服务程序专用服务器。Sun鼓励其他Web服务器开发者为他们的服务器软件产品加入对小服务程序的支持。\n15.6 Java与CGI的沟通 15.7 用JDBC连接数据库 15.8 远程方法 为通过网络执行其他机器上的代码，传统的方法不仅难以学习和掌握，也极易出错。思考这个问题最佳的方式是：某些对象正好位于另一台机器，我们可向它们发送一条消息，并获得返回结果，就象那些对象位于自己的本地机器一样。Java 1.1的“远程方法调用”（RMI）采用的正是这种抽象。本节将引导大家经历一些必要的步骤，创建自己的RMI对象。\n15.8.1 远程接口概念 RMI对接口有着强烈的依赖。在需要创建一个远程对象的时候，我们通过传递一个接口来隐藏基层的实施细节。所以客户得到远程对象的一个句柄时，它们真正得到的是接口句柄。这个句柄正好同一些本地的根代码连接，由后者负责通过网络通信。但我们并不关心这些事情，只需通过自己的接口句柄发送消息即可。\n创建一个远程接口时，必须遵守下列规则：\n(1) 远程接口必须为public属性（不能有“包访问”；也就是说，它不能是“友好的”）。否则，一旦客户试图装载一个实现了远程接口的远程对象，就会得到一个错误。\n(2) 远程接口必须扩展接口java.rmi.Remote。\n(3) 除与应用程序本身有关的违例之外，远程接口中的每个方法都必须在自己的throws从句中声明java.rmi.RemoteException。\n(4) 作为参数或返回值传递的一个远程对象（不管是直接的，还是在本地对象中嵌入）必须声明为远程接口，不可声明为实施类。\n下面是一个简单的远程接口示例，它代表的是一个精确计时服务：\n//: PerfectTimeI.java // The PerfectTime remote interface package c15.ptime; import java.rmi.*; interface PerfectTimeI extends Remote { long getPerfectTime() throws RemoteException; } ///:~ 它表面上与其他接口是类似的，只是对Remote进行了扩展，而且它的所有方法都会“掷”出RemoteException（远程违例）。记住接口和它所有的方法都是public的。\n15.8.2 远程接口的实施 服务器必须包含一个扩展了UnicastRemoteObject的类，并实现远程接口。这个类也可以含有附加的方法，但客户只能使用远程接口中的方法。这是显然的，因为客户得到的只是指向接口的一个句柄，而非实现它的那个类。\n必须为远程对象明确定义构建器，即使只准备定义一个默认构建器，用它调用基础类构建器。必须把它明确地编写出来，因为它必须“掷”出RemoteException违例。\n下面列出远程接口PerfectTime的实施过程：\n//: PerfectTime.java // The implementation of the PerfectTime // remote object package c15.ptime; import java.rmi.*; import java.rmi.server.*; import java.rmi.registry.*; import java.net.*; public class PerfectTime extends UnicastRemoteObject implements PerfectTimeI { // Implementation of the interface: public long getPerfectTime() throws RemoteException { return System.currentTimeMillis(); } // Must implement constructor to throw // RemoteException: public PerfectTime() throws RemoteException { // super(); // Called automatically } // Registration for RMI serving: public static void main(String[] args) { System.setSecurityManager( new RMISecurityManager()); try { PerfectTime pt = new PerfectTime(); Naming.bind( \u0026#34;//colossus:2005/PerfectTime\u0026#34;, pt); System.out.println(\u0026#34;Ready to do time\u0026#34;); } catch(Exception e) { e.printStackTrace(); } } } ///:~ 在这里，main()控制着设置服务器的全部细节。保存RMI对象时，必须在程序的某个地方采取下述操作：\n(1) 创建和安装一个安全管理器，令其支持RMI。作为Java发行包的一部分，适用于RMI唯一一个是RMISecurityManager。\n(2) 创建远程对象的一个或多个实例。在这里，大家可看到创建的是PerfectTime对象。\n(3) 向RMI远程对象注册表注册至少一个远程对象。一个远程对象拥有的方法可生成指向其他远程对象的句柄。这样一来，客户只需到注册表里访问一次，得到第一个远程对象即可。\n设置注册表 在这儿，大家可看到对静态方法Naming.bind()的一个调用。然而，这个调用要求注册表作为计算机上的一个独立进程运行。注册表服务器的名字是rmiregistry。在32位Windows环境中，可使用：\nstart rmiregistry 令其在后台运行。在Unix中，使用：\nrmiregistry \u0026amp; 和许多网络程序一样，rmiregistry 位于机器启动它所在的某个IP地址处，但它也必须监视一个端口。如果象上面那样调用 rmiregistry，不使用参数，注册表的端口就会默认为1099。若希望它位于其他某个端口，只需在命令行添加一个参数，指定那个端口编号即可。对这个例子来说，端口将位于2005，所以rmiregistry应该象下面这样启动（对于32位Windows）：\nstart rmiregistry 2005 对于Unix，则使用下述命令：\nrmiregistry 2005 \u0026amp; 与端口有关的信息必须传送给bind()命令，同时传送的还有注册表所在的那台机器的IP地址。但假若我们想在本地测试RMI程序，就象本章的网络程序一直测试的那样，这样做就会带来问题。在JDK 1.1.1版本中，存在着下述两方面的问题（注释⑦）：\n(1) localhost不能随RMI工作。所以为了在单独一台机器上完成对RMI的测试，必须提供机器的名字。为了在32位Windows环境中调查自己机器的名字，可进入控制面板，选择“网络”，选择“标识”卡片，其中列出了计算机的名字。就我自己的情况来说，我的机器叫作“Colossus”（因为我用几个大容量的硬盘保存各种不同的开发系统——Clossus是“巨人”的意思）。似乎大写形式会被忽略。\n(2) 除非计算机有一个活动的TCP/IP连接，否则RMI不能工作，即使所有组件都只需要在本地机器里互相通信。这意味着在试图运行程序之前，必须连接到自己的ISP（因特网服务提供者），否则会得到一些含义模糊的违例消息。\n⑦：为找出这些信息，我不知损伤了多少个脑细胞。\n考虑到这些因素，bind()命令变成了下面这个样子：\nNaming.bind(\u0026#34;//colossus:2005/PerfectTime\u0026#34;, pt); 若使用默认端口1099，就没有必要指定一个端口，所以可以使用：\nNaming.bind(\u0026#34;//colossus/PerfectTime\u0026#34;, pt); 在JDK未来的版本中（1.1之后），一旦改正了localhost的问题，就能正常地进行本地测试，去掉IP地址，只使用标识符： Naming.bind(\u0026ldquo;PerfectTime\u0026rdquo;, pt);\n服务名是任意的；它在这里正好为PerfectTime，和类名一样，但你可以根据情况任意修改。最重要的是确保它在注册表里是个独一无二的名字，以便客户正常地获取远程对象。若这个名字已在注册表里了，就会得到一个AlreadyBoundException违例。为防止这个问题，可考虑坚持使用rebind()，放弃bind()。这是由于rebind()要么会添加一个新条目，要么将同名的条目替换掉。 尽管main()退出，我们的对象已经创建并注册，所以会由注册表一直保持活动状态，等候客户到达并发出对它的请求。只要rmiregistry处于运行状态，而且我们没有为名字调用Naming.unbind()方法，对象就肯定位于那个地方。考虑到这个原因，在我们设计自己的代码时，需要先关闭rmiregistry，并在编译远程对象的一个新版本时重新启动它。\n并不一定要将rmiregistry作为一个外部进程启动。若事前知道自己的是要求用以注册表的唯一一个应用，就可在程序内部启动它，使用下述代码：\nLocateRegistry.createRegistry(2005); 和前面一样，2005代表我们在这个例子里选用的端口号。这等价于在命令行执行rmiregistry 2005。但在设计RMI代码时，这种做法往往显得更加方便，因为它取消了启动和中止注册表所需的额外步骤。一旦执行完这个代码，就可象以前一样使用Naming进行“绑定”——bind()。\n15.8.3 创建根与干 若编译和运行PerfectTime.java，即使rmiregistry正确运行，它也无法工作。这是由于RMI的框架尚未就位。首先必须创建根和干，以便提供网络连接操作，并使我们将远程对象伪装成自己机器内的某个本地对象。\n所有这些幕后的工作都是相当复杂的。我们从远程对象传入、传出的任何对象都必须“implement Serializable”（如果想传递 远程引用，而非整个对象，对象的参数就可以“implement Remote”）。因此可以想象，当根和干通过网络“汇集”所有参数并返回结果的时候，会自动进行序列化以及数据的重新装配。幸运的是，我们根本没必要了解这些方面的任何细节，但根和干却是必须创建的。一个简单的过程如下：在编译好的代码中调用rmic，它会创建必需的一些文件。所以唯一要做的事情就是为编译过程新添一个步骤。\n然而，rmic工具与特定的包和类路径有很大的关联。PerfectTime.java位于包c15.Ptime中，即使我们调用与PerfectTime.class同一目录内的rmic，rmic都无法找到文件。这是由于它搜索的是类路径。因此，我们必须同时指定类路径，就象下面这样：\nrmic c15.PTime.PerfectTime 执行这个命令时，并不一定非要在包含了PerfectTime.class的目录中，但结果会置于当前目录。 若rmic成功运行，目录里就会多出两个新类：\nPerfectTime_Stub.class\rPerfectTime_Skel.class 它们分别对应根（Stub）和干（Skeleton）。现在，我们已准备好让服务器与客户互相沟通了。\n15.8.4 使用远程对象 RMI全部的宗旨就是尽可能简化远程对象的使用。我们在客户程序中要做的唯一一件额外的事情就是查找并从服务器取回远程接口。自此以后，剩下的事情就是普通的Java编程：将消息发给对象。下面是使用PerfectTime的程序：\n//: DisplayPerfectTime.java // Uses remote object PerfectTime package c15.ptime; import java.rmi.*; import java.rmi.registry.*; public class DisplayPerfectTime { public static void main(String[] args) { System.setSecurityManager( new RMISecurityManager()); try { PerfectTimeI t = (PerfectTimeI)Naming.lookup( \u0026#34;//colossus:2005/PerfectTime\u0026#34;); for(int i = 0; i \u0026lt; 10; i++) System.out.println(\u0026#34;Perfect time = \u0026#34; + t.getPerfectTime()); } catch(Exception e) { e.printStackTrace(); } } } ///:~ ID字串与那个用Naming注册对象的那个字串是相同的，第一部分指出了URL和端口号。由于我们准备使用一个URL，所以也可以指定因特网上的一台机器。\n从Naming.lookup()返回的必须造型到远程接口，而不是到类。若换用类，会得到一个违例提示。 在下述方法调用中：\nt.getPerfectTime( ) 我们可看到一旦获得远程对象的句柄，用它进行的编程与用本地对象的编程是非常相似（仅有一个区别：远程方法会“掷”出一个RemoteException违例）。\n15.8.5 RMI的替选方案 RMI只是一种创建特殊对象的方式，它创建的对象可通过网络发布。它最大的优点就是提供了一种“纯Java”方案，但假如已经有许多用其他语言编写的代码，则RMI可能无法满足我们的要求。目前，两种最具竞争力的替选方案是微软的DCOM（根据微软的计划，它最终会移植到除Windows以外的其他平台）以及CORBA。CORBA自Java 1.1便开始支持，是一种全新设计的概念，面向跨平台应用。在由Orfali和Harkey编著的《Client/Server Programming with Java and CORBA》一书中（John Wiley\u0026amp;Sons 1997年出版），大家可获得对Java中的分布式对象的全面介绍（该书似乎对CORBA似乎有些偏见）。为CORBA赋予一个较公正的对待的一本书是由Andreas Vogel和Keith Duddy编写的《Java Programming with CORBA》，John Wiley\u0026amp;Sons于1997年出版。\n15.9 总结 由于篇幅所限，还有其他许多涉及连网的概念没有介绍给大家。Java也为URL提供了相当全面的支持，包括为因特网上不同类型的客户提供协议控制器等等。\n除此以外，一种正在逐步流行的技术叫作Servlet Server。它是一种因特网服务器应用，通过Java控制客户请求，而非使用以前那种速度很慢、且相当麻烦的CGI（通用网关接口）协议。这意味着为了在服务器那一端提供服务，我们可以用Java编程，不必使用自己不熟悉的其他语言。由于Java具有优秀的移植能力，所以不必关心具体容纳这个服务器是什么平台。\n所有这些以及其他特性都在《Java Network Programming》一书中得到了详细讲述。该书由Elliotte Rusty Harold编著，O\u0026rsquo;Reilly于1997年出版。\n15.10 练习 (1) 编译和运行本章中的JabberServer和JabberClient程序。接着编辑一下程序，删去为输入和输出设计的所有缓冲机制，然后再次编译和运行，观察一下结果。\n(2) 创建一个服务器，用它请求用户输入密码，然后打开一个文件，并将文件通过网络连接传送出去。创建一个同该服务器连接的客户，为其分配适当的密码，然后捕获和保存文件。在自己的机器上用localhost（通过调用InetAddress.getByName(null)生成本地IP地址127.0.0.1）测试这两个程序。\n(3) 修改练习2中的程序，令其用多线程机制对多个客户进行控制。\n(4) 修改JabberClient，禁止输出刷新，并观察结果。\n(5) 以ShowHTML.java为基础，创建一个程序片，令其成为对自己Web站点的特定部分进行密码保护的大门。\n(6) （可能有些难度）创建一对客户／服务器程序，利用数据报（Datagram）将一个文件从一台机器传到另一台（参见本章数据报小节末尾的叙述）。\n(7) （可能有些难度）对VLookup.java程序作一番修改，使我们能点击得到的结果名字，然后程序会自动取得那个名字，并把它复制到剪贴板（以便我们方便地粘贴到自己的E-mail）。可能要回过头去研究一下IO数据流的那一章，回忆该如何使用Java 1.1剪贴板。\n"},{"id":142,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC16%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/","title":"Thinking in Java 第16章 设计范式","parent":"Thinking In Java","content":" 第16章 设计范式 16.1 范式的概念 将保持不变的东西身上发生的变化孤立出来\n设计范式：可以说对问题不变的地方抽象总结\n变化的影响隔离出来\n在最开始，可将范式想象成一种特别聪明、能够自我适应的手法，它可以解决特定类型的问题。也就是说，它类似一些需要全面认识某个问题的人。在了解了问题的方方面面以后，最后提出一套最通用、最灵活的解决方案。具体问题或许是以前见到并解决过的。然而，从前的方案也许并不是最完善的，大家会看到它如何在一个范式里具体表达出来。\n尽管我们称之为“设计范式”，但它们实际上并不局限于设计领域。思考“范式”时，应脱离传统意义上分析、设计以及实施的思考方式。相反，“范式”是在一个程序里具体表达一套完整的思想，所以它有时可能出现在分析阶段或者高级设计阶段。这一点是非常有趣的，因为范式具有以代码形式直接实现的形式，所以可能不希望它在低级设计或者具体实施以前显露出来（而且事实上，除非真正进入那些阶段，否则一般意识不到自己需要一个范式来解决问题）。\n范式的基本概念亦可看成是程序设计的基本概念：添加一层新的抽象！只要我们抽象了某些东西，就相当于隔离了特定的细节。而且这后面最引人注目的动机就是“将保持不变的东西身上发生的变化孤立出来”。这样做的另一个原因是一旦发现程序的某部分由于这样或那样的原因可能发生变化，我们一般都想防止那些改变在代码内部繁衍出其他变化。这样做不仅可以降低代码的维护代价，也更便于我们理解（结果同样是降低开销）。\n为设计出功能强大且易于维护的应用项目，通常最困难的部分就是找出我称之为“领头变化”的东西。这意味着需要找出造成系统改变的最重要的东西，或者换一个角度，找出付出代价最高、开销最大的那一部分。一旦发现了“领头变化”，就可以为自己定下一个焦点，围绕它展开自己的设计。\n所以设计范式的最终目标就是将代码中变化的内容隔离开。如果从这个角度观察，就会发现本书实际已采用了一些设计范式。举个例子来说，继承可以想象成一种设计范式（类似一个由编译器实现的）。在都拥有同样接口（即保持不变的东西）的对象内部，它允许我们表达行为上的差异（即发生变化的东西）。合成亦可想象成一种范式，因为它允许我们修改——动态或静态——用于实现类的对象，所以也能修改类的运作方式。\n在《Design Patterns》一书中，大家还能看到另一种范式：“继承器”（即Iterator，Java 1.0和1.1不负责任地把它叫作Enumeration，即“枚举”；Java1.2的集合则改回了“继承器”的称呼）。当我们在集合里遍历，逐个选择不同的元素时，继承器可将集合的实施细节有效地隐藏起来。利用继承器，可以编写出通用的代码，以便对一个序列里的所有元素采取某种操作，同时不必关心这个序列是如何构建的。这样一来，我们的通用代码即可伴随任何能产生继承器的集合使用。\n16.1.1 单子 单例模式 枚举 是实现单例模式的最佳方法。它不仅能避免多线程同步问题，它更简洁，自动支持序列化机制，绝对防止多次实例化。\n或许最简单的设计范式就是“单子”（Singleton），它能提供对象的一个（而且只有一个）实例。单子在Java库中得到了应用，但下面这个例子显得更直接一些：\n//: SingletonPattern.java // The Singleton design pattern: you can // never instantiate more than one. package c16; // Since this isn\u0026#39;t inherited from a Cloneable // base class and cloneability isn\u0026#39;t added, // making it final prevents cloneability from // being added in any derived classes: final class Singleton { private static Singleton s = new Singleton(47); private int i; private Singleton(int x) { i = x; } public static Singleton getHandle() { return s; } public int getValue() { return i; } public void setValue(int x) { i = x; } } public class SingletonPattern { public static void main(String[] args) { Singleton s = Singleton.getHandle(); System.out.println(s.getValue()); Singleton s2 = Singleton.getHandle(); s2.setValue(9); System.out.println(s.getValue()); try { // Can\u0026#39;t do this: compile-time error. // Singleton s3 = (Singleton)s2.clone(); } catch(Exception e) {} } } ///:~ 创建单子的关键就是防止客户程序员采用除由我们提供的之外的任何一种方式来创建一个对象。必须将所有构建器都设为private（私有），而且至少要创建一个构建器，以防止编译器帮我们自动同步一个默认构建器（它会自做聪明地创建成为“友好的”——friendly，而非private）。\n此时应决定如何创建自己的对象。在这儿，我们选择了静态创建的方式。但亦可选择等候客户程序员发出一个创建请求，然后根据他们的要求动态创建。不管在哪种情况下，对象都应该保存为“私有”属性。我们通过公用方法提供访问途径。在这里，getHandle()会产生指向Singleton的一个句柄。剩下的接口（getValue()和setValue()）属于普通的类接口。\nJava也允许通过克隆（Clone）方式来创建一个对象。在这个例子中，将类设为final可禁止克隆的发生。由于Singleton是从Object直接继承的，所以clone()方法会保持protected（受保护）属性，不能够使用它（强行使用会造成编译期错误）。然而，假如我们是从一个类结构中继承，那个结构已经过载了clone()方法，使其具有public属性，并实现了Cloneable，那么为了禁止克隆，需要过载clone()，并掷出一个CloneNotSupportedException（不支持克隆违例），就象第12章介绍的那样。亦可过载clone()，并简单地返回this。那样做会造成一定的混淆，因为客户程序员可能错误地认为对象尚未克隆，仍然操纵的是原来的那个。\n注意我们并不限于只能创建一个对象。亦可利用该技术创建一个有限的对象池。但在那种情况下，可能需要解决池内对象的共享问题。如果不幸真的遇到这个问题，可以自己设计一套方案，实现共享对象的登记与撤消登记。\n16.1.2 范式分类\n《Design Patterns》一书讨论了23种不同的范式，并依据三个标准分类（所有标准都涉及那些可能发生变化的方面）。这三个标准是：\n(1) 创建：对象的创建方式。这通常涉及对象创建细节的隔离，这样便不必依赖具体类型的对象，所以在新添一种对象类型时也不必改动代码。\n(2) 结构：设计对象，满足特定的项目限制。这涉及对象与其他对象的连接方式，以保证系统内的改变不会影响到这些连接。\n(3) 行为：对程序中特定类型的行动进行操纵的对象。这要求我们将希望采取的操作封装起来，比如解释一种语言、实现一个请求、在一个序列中遍历（就象在继承器中那样）或者实现一种算法。本章提供了“观察器”（Observer）和“访问器”（Visitor）的范式的例子。\n《Design Patterns》为所有这23种范式都分别使用了一节，随附的还有大量示例，但大多是用C++编写的，少数用Smalltalk编写（如看过这本书，就知道这实际并不是个大问题，因为很容易即可将基本概念从两种语言翻译到Java里）。现在这本书并不打算重复《Design Patterns》介绍的所有范式，因为那是一本独立的书，大家应该单独阅读。相反，本章只准备给出一些例子，让大家先对范式有个大致的印象，并理解它们的重要性到底在哪里。\n16.2 观察器范式 观察器（Observer）范式解决的是一个相当普通的问题：由于某些对象的状态发生了改变，所以一组对象都需要更新，那么该如何解决？在Smalltalk的MVC（模型－视图－控制器）的“模型－视图”部分中，或在几乎等价的“文档－视图结构”中，大家可以看到这个问题。现在我们有一些数据（“文档”）以及多个视图，假定为一张图（Plot）和一个文本视图。若改变了数据，两个视图必须知道对自己进行更新，而那正是“观察器”要负责的工作。这是一种十分常见的问题，它的解决方案已包括进标准的java.util库中。\n在Java中，有两种类型的对象用来实现观察器范式。其中，Observable类用于跟踪那些当发生一个改变时希望收到通知的所有个体——无论“状态”是否改变。如果有人说“好了，所有人都要检查自己，并可能要进行更新”，那么Observable类会执行这个任务——为列表中的每个“人”都调用notifyObservers()方法。notifyObservers()方法属于基础类Observable的一部分。\n在观察器范式中，实际有两个方面可能发生变化：观察对象的数量以及更新的方式。也就是说，观察器范式允许我们同时修改这两个方面，不会干扰围绕在它周围的其他代码。\n下面这个例子类似于第14章的ColorBoxes示例。箱子（Boxes）置于一个屏幕网格中，每个都初始化一种随机的颜色。此外，每个箱子都“实现”（implement）了“观察器”（Observer）接口，而且随一个Observable对象进行了注册。若点击一个箱子，其他所有箱子都会收到一个通知，指出一个改变已经发生。这是由于Observable对象会自动调用每个Observer对象的update()方法。在这个方法内，箱子会检查被点中的那个箱子是否与自己紧邻。若答案是肯定的，那么也修改自己的颜色，保持与点中那个箱子的协调。\n//: BoxObserver.java // Demonstration of Observer pattern using // Java\u0026#39;s built-in observer classes. import java.awt.*; import java.awt.event.*; import java.util.*; // You must inherit a new type of Observable: class BoxObservable extends Observable { public void notifyObservers(Object b) { // Otherwise it won\u0026#39;t propagate changes: setChanged(); super.notifyObservers(b); } } public class BoxObserver extends Frame { Observable notifier = new BoxObservable(); public BoxObserver(int grid) { setTitle(\u0026#34;Demonstrates Observer pattern\u0026#34;); setLayout(new GridLayout(grid, grid)); for(int x = 0; x \u0026lt; grid; x++) for(int y = 0; y \u0026lt; grid; y++) add(new OCBox(x, y, notifier)); } public static void main(String[] args) { int grid = 8; if(args.length \u0026gt; 0) grid = Integer.parseInt(args[0]); Frame f = new BoxObserver(grid); f.setSize(500, 400); f.setVisible(true); f.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class OCBox extends Canvas implements Observer { Observable notifier; int x, y; // Locations in grid Color cColor = newColor(); static final Color[] colors = { Color.black, Color.blue, Color.cyan, Color.darkGray, Color.gray, Color.green, Color.lightGray, Color.magenta, Color.orange, Color.pink, Color.red, Color.white, Color.yellow }; static final Color newColor() { return colors[ (int)(Math.random() * colors.length) ]; } OCBox(int x, int y, Observable notifier) { this.x = x; this.y = y; notifier.addObserver(this); this.notifier = notifier; addMouseListener(new ML()); } public void paint(Graphics g) { g.setColor(cColor); Dimension s = getSize(); g.fillRect(0, 0, s.width, s.height); } class ML extends MouseAdapter { public void mousePressed(MouseEvent e) { notifier.notifyObservers(OCBox.this); } } public void update(Observable o, Object arg) { OCBox clicked = (OCBox)arg; if(nextTo(clicked)) { cColor = clicked.cColor; repaint(); } } private final boolean nextTo(OCBox b) { return Math.abs(x - b.x) \u0026lt;= 1 \u0026amp;\u0026amp; Math.abs(y - b.y) \u0026lt;= 1; } } ///:~ 如果是首次查阅Observable的联机帮助文档，可能会多少感到有些困惑，因为它似乎表明可以用一个原始的Observable对象来管理更新。但这种说法是不成立的；大家可自己试试——在BoxObserver中，创建一个Observable对象，替换BoxObservable对象，看看会有什么事情发生。事实上，什么事情也不会发生。为真正产生效果，必须从Observable继承，并在衍生类代码的某个地方调用setChanged()。这个方法需要设置“changed”（已改变）标志，它意味着当我们调用notifyObservers()的时候，所有观察器事实上都会收到通知。在上面的例子中，setChanged()只是简单地在notifyObservers()中调用，大家可依据符合实际情况的任何标准决定何时调用setChanged()。\nBoxObserver包含了单个Observable对象，名为notifier。每次创建一个OCBox对象时，它都会同notifier联系到一起。在OCBox中，只要点击鼠标，就会发出对notifyObservers()方法的调用，并将被点中的那个对象作为一个参数传递进去，使收到消息（用它们的update()方法）的所有箱子都能知道谁被点中了，并据此判断自己是否也要变动。通过notifyObservers()和update()中的代码的结合，我们可以应付一些非常复杂的局面。\n在notifyObservers()方法中，表面上似乎观察器收到通知的方式必须在编译期间固定下来。然而，只要稍微仔细研究一下上面的代码，就会发现BoxObserver或OCBox中唯一需要留意是否使用BoxObservable的地方就是创建Observable对象的时候——从那时开始，所有东西都会使用基本的Observable接口。这意味着以后若想更改通知方式，可以继承其他Observable类，并在运行期间交换它们。\n1.1 观察者模式是oo设计中经常用到的模式之一，大家在解决实际需求时，观察者模式往往都会用到，而javase中已经提供了Observer接口和Observable类让你简单快速的实现观察者模式，因此有必要去了解Observer和Observable；\n2.观察者模式概述 2.1 角色：被观察对象，观察者\n2.2 关系： 1）.被观察对象：观察者 = 1：n 2）.被观察对象状态发生变化，会通知所有观察者，观察者将做出相应的反应\n2.3 详细说明：参见【设计模式】观察者模式\n3.源码分析 3.1 Observer接口 观察者 Observer为java.util包下的一个接口，源码如下：\npublic interface Observer { void update(Observable o, Object arg); } 所有 观察者 需要在 被观察对象 发生变化时做出相应的反应，所做的具体反应就是实现Observer接口的update方法，实现update方法时你可以用到两个参数，一个参数的类型是Observable，另一个参数的类型是Object。当然如果完全由自己去实现一个观察者模式的方案，自己去设计Observer接口时，可能不会设计这两个参数。那为什么jdk设计该接口时规定接口中有这两个参数呢？那就是通用性。想想整个观察者模式有哪些类之间需要交互？使用该模式时牵扯三个类，一个是观察者，一个是被观察对象，一个是调用者(调用者可以是被观察对象本身调用，更多情况是一个具体的业务类)，当前接口代表观察者，要与被观察对象交互，因此update方法需要持有被观察对象(Observable)的引用，第一参数产生了；如何与调用者通信，则是添加了类型为Object的参数（该参数是调用者调用Observable实例的notifyObservers(Object obj)方法时传入的，当然也可以不传）；第一个参数可以说是为观察者提供了一种拉取数据的方式，update中的业务可以根据所需去拉去自己想要的被观察对象的信息(一般被观察对象中提供getter)，第二个参数则是由调用者调用notifyObservers(Object obj)将一些信息推过来。通过这两个参数，观察者，被观察对象，调用者(调用通知刷新方法的可能是被观察对象本身，此时只存在观察者与被观察者两者)三者就联系起来了。\n3.2 Observable 类 被观察对象\npublic class Observable { private boolean changed = false; private Vector obs; public Observable(){}; protected synchronized void setChanged(){}; protected synchronized void clearChanged(){}; public synchronized void addObserver(Observer o){}; public synchronized void deleteObserver(Observer o) {}; public synchronized void deleteObservers(){}; public synchronized boolean hasChanged(){}; public synchronized int countObservers(){}; public void notifyObservers(){}; public void notifyObservers(Object arg){}; } 先说成员变量： 1）该类中含有一个boolean型的变量changed，代表是否发生改变了，Observable类只提供这个boolean值来表明是否发生变化，而不定义什么叫变化，因为每个业务中对变化的具体定义不一样，因此子类自己来判断是否变化；该变量既提供了一种抽象(变与不变)，同时提供了一种观察者更新状态的可延迟加载，通过后面的notifyObservers方法分析可知观察者是否会调用update方法，依赖于changed变量，因此即使被观察者在逻辑上发生改变了，只要不调用setChanged，update是不会被调用的。如果我们在某些业务场景不需要频繁触发update，则可以适时调用setChanged方法来延迟刷新。 2）该类含有一个集合类Vector，该类泛型为Observer，主要用来存放所有观察自己的对象的引用，以便在更新时可以挨个遍历集合中的观察者，逐个调用update方法 说明： 1.8的jdk源码为Vector，有版本的源码是ArrayList的集合实现； Vector这个类和ArrayList的继承体系是一致，主要有两点不同，一是Vector是线程安全的，ArrayList不是线程安全的，Vector的操作依靠在方法上加了同步关键字来保证线程安全，与此同时ArrayList的性能是要好于Vector的；二是Vector和ArrayList扩容阀值不太一样，ArrayList较Vector更节省空间； 再来说说方法： 1）操作changed变量的方法为setChanged()，clearChanged()，hasChanged()；见名知意，第一个设置变化状态，第二清除变化状态，这两个的访问权限都是protected，表明这两个方法由子类去调用，由子类来告诉什么时候被观察者发生变化了，什么时候变化消失，而hasChanged()方法的访问权限是公有的，调用者可以使用该方法。三个方法都有同步关键字保证变量的读写操作线程安全。\n2）操作Vector类型变量obs的方法为addObserver(Observer o)， deleteObserver(Observer o)， deleteObservers()，countObservers()，这四个方法分别实现了动态添加观察者，删除观察者，删除所有观察者，获取观察者数量。四个方法的访问权限都是公有的，这是提供给调用者的方法，让调用者来实时动态的控制哪些观察者来观察该被观察对象。\n3）操作Vector型变量obs的四个方法都加有同步关键字，但是我们刚才分析成员属性Vector obs这个变量时，说Vector类型为线程安全的，而上述四个方法为什么还要加同步关键字呢，这是怎么回事？据我推测应该是程序员重构遗留问题吧，因为前面我说道，有历史版本的源码是使用的ArrayList来持有Observer的引用，而ArrayList不是线程安全的，所以上述四个操作结合的方法需要加上同步关键字来保证线程安全，而后来换成线程安全的Vector了，但这四个操作集合的方法依旧保留了同步关键字。\n4）两个对外的方法notifyObservers()，notifyObservers(Object arg)，该方法由调用者来操作，用来通知所有的观察者需要做更新操作了。\n16.3 模拟垃圾回收站 这个问题的本质是若将垃圾丢进单个垃圾筒，事实上是未经分类的。但在以后，某些特殊的信息必须恢复，以便对垃圾正确地归类。在最开始的解决方案中，RTTI扮演了关键的角色（详见第11章）。\n这并不是一种普通的设计，因为它增加了一个新的限制。正是这个限制使问题变得非常有趣——它更象我们在工作中碰到的那些非常麻烦的问题。这个额外的限制是：垃圾抵达垃圾回收站时，它们全都是混合在一起的。程序必须为那些垃圾的分类定出一个模型。这正是RTTI发挥作用的地方：我们有大量不知名的垃圾，程序将正确判断出它们所属的类型。\n//: RecycleA.java // Recycling with RTTI package c16.recyclea; import java.util.*; import java.io.*; abstract class Trash { private double weight; Trash(double wt) { weight = wt; } abstract double value(); double weight() { return weight; } // Sums the value of Trash in a bin: static void sumValue(Vector bin) { Enumeration e = bin.elements(); double val = 0.0f; while(e.hasMoreElements()) { // One kind of RTTI: // A dynamically-checked cast Trash t = (Trash)e.nextElement(); // Polymorphism in action: val += t.weight() * t.value(); System.out.println( \u0026#34;weight of \u0026#34; + // Using RTTI to get type // information about the class: t.getClass().getName() + \u0026#34; = \u0026#34; + t.weight()); } System.out.println(\u0026#34;Total value = \u0026#34; + val); } } class Aluminum extends Trash { static double val = 1.67f; Aluminum(double wt) { super(wt); } double value() { return val; } static void value(double newval) { val = newval; } } class Paper extends Trash { static double val = 0.10f; Paper(double wt) { super(wt); } double value() { return val; } static void value(double newval) { val = newval; } } class Glass extends Trash { static double val = 0.23f; Glass(double wt) { super(wt); } double value() { return val; } static void value(double newval) { val = newval; } } public class RecycleA { public static void main(String[] args) { Vector bin = new Vector(); // Fill up the Trash bin: for(int i = 0; i \u0026lt; 30; i++) switch((int)(Math.random() * 3)) { case 0 : bin.addElement(new Aluminum(Math.random() * 100)); break; case 1 : bin.addElement(new Paper(Math.random() * 100)); break; case 2 : bin.addElement(new Glass(Math.random() * 100)); } Vector glassBin = new Vector(), paperBin = new Vector(), alBin = new Vector(); Enumeration sorter = bin.elements(); // Sort the Trash: while(sorter.hasMoreElements()) { Object t = sorter.nextElement(); // RTTI to show class membership: if(t instanceof Aluminum) alBin.addElement(t); if(t instanceof Paper) paperBin.addElement(t); if(t instanceof Glass) glassBin.addElement(t); } Trash.sumValue(alBin); Trash.sumValue(paperBin); Trash.sumValue(glassBin); Trash.sumValue(bin); } } ///:~ 这意味着在本书采用的源码目录中，这个文件会被置入从c16（代表第16章的程序）分支出来的recyclea子目录中。第17章的解包工具会负责将其置入正确的子目录。之所以要这样做，是因为本章会多次改写这个特定的例子；它的每个版本都会置入自己的“包”（package）内，避免类名的冲突。\n其中创建了几个Vector对象，用于容纳Trash句柄。当然，Vector实际容纳的是Object（对象），所以它们最终能够容纳任何东西。之所以要它们容纳Trash（或者从Trash衍生出来的其他东西），唯一的理由是我们需要谨慎地避免放入除Trash以外的其他任何东西。如果真的把某些“错误”的东西置入Vector，那么不会在编译期得到出错或警告提示——只能通过运行期的一个违例知道自己已经犯了错误。\nTrash句柄加入后，它们会丢失自己的特定标识信息，只会成为简单的Object句柄（上溯造型）。然而，由于存在多形性的因素，所以在我们通过Enumeration sorter调用动态绑定方法时，一旦结果Object已经造型回Trash，仍然会发生正确的行为。sumValue()也用一个Enumeration对Vector中的每个对象进行操作。\n表面上持，先把Trash的类型上溯造型到一个集合容纳基础类型的句柄，再回过头重新下溯造型，这似乎是一种非常愚蠢的做法。为什么不只是一开始就将垃圾置入适当的容器里呢？（事实上，这正是拨开“回收”一团迷雾的关键）。在这个程序中，我们很容易就可以换成这种做法，但在某些情况下，系统的结构及灵活性都能从下溯造型中得到极大的好处。\n该程序已满足了设计的初衷：它能够正常工作！只要这是个一次性的方案，就会显得非常出色。但是，真正有用的程序应该能够在任 何时候解决问题。所以必须问自己这样一个问题：“如果情况发生了变化，它还能工作吗？”举个例子来说，厚纸板现在是一种非常有价值的可回收物品，那么如何把它集成到系统中呢（特别是程序很大很复杂的时候）？由于前面在switch语句中的类型检查编码可能散布于整个程序，所以每次加入一种新类型时，都必须找到所有那些编码。若不慎遗漏一个，编译器除了指出存在一个错误之外，不能再提供任何有价值的帮助。\nRTTI在这里使用不当的关键是“每种类型都进行了测试”。如果由于类型的子集需要特殊的对待，所以只寻找那个子集，那么情况就会变得好一些。但假如在一个switch语句中查找每一种类型，那么很可能错过一个重点，使最终的代码很难维护。在下一节中，大家会学习如何逐步对这个程序进行改进，使其显得越来越灵活。这是在程序设计中一种非常有意义的例子。\n16.4 改进设计 《Design Patterns》书内所有方案的组织都围绕“程序进化时会发生什么变化”这个问题展开。对于任何设计来说，这都可能是最重要的一个问题。若根据对这个问题的回答来构造自己的系统，就可以得到两个方面的结果：系统不仅更易维护（而且更廉价），而且能产生一些能够重复使用的对象，进而使其他相关系统的构造也变得更廉价。这正是面向对象程序设计的优势所在，但这一优势并不是自动体现出来的。它要求对我们对需要解决的问题有全面而且深入的理解。在这一节中，我们准备在系统的逐步改进过程中向大家展示如何做到这一点。\n就目前这个回收系统来说，对“什么会变化”这个问题的回答是非常普通的：更多的类型会加入系统。因此，设计的目标就是尽可能简化这种类型的添加。在回收程序中，我们准备把涉及特定类型信息的所有地方都封装起来。这样一来（如果没有别的原因），所有变化对那些封装来说都是在本地进行的。这种处理方式也使代码剩余的部分显得特别清爽。\n16.4.1 “制作更多的对象” 这样便引出了面向对象程序设计时一条常规的准则，我最早是在Grady Booch那里听说的：“若设计过于复杂，就制作更多的对象”。尽管听起来有些暧昧，且简单得可笑，但这确实是我知道的最有用一条准则（大家以后会注意到“制作更多的对象”经常等同于“添加另一个层次的迂回”）。一般情况下，如果发现一个地方充斥着大量繁复的代码，就需要考虑什么类能使它显得清爽一些。用这种方式整理系统，往往会得到一个更好的结构，也使程序更加灵活。\n首先考虑Trash对象首次创建的地方，这是main()里的一个switch语句：\nfor(int i = 0; i \u0026lt; 30; i++)\rswitch((int)(Math.random() * 3)) {\rcase 0 :\rbin.addElement(new\rAluminum(Math.random() * 100));\rbreak;\rcase 1 :\rbin.addElement(new\rPaper(Math.random() * 100));\rbreak;\rcase 2 :\rbin.addElement(new\rGlass(Math.random() * 100));\r} 这些代码显然“过于复杂”，也是新类型加入时必须改动代码的场所之一。如果经常都要加入新类型，那么更好的方案就是建立一个独立的方法，用它获取所有必需的信息，并创建一个句柄，指向正确类型的一个对象——已经上溯造型到一个Trash对象。在《Design Patterns》中，它被粗略地称呼为“创建范式”。要在这里应用的特殊范式是Factory方法的一种变体。在这里，Factory方法属于Trash的一名static（静态）成员。但更常见的一种情况是：它属于衍生类中一个被过载的方法。 Factory方法的基本原理是我们将创建对象所需的基本信息传递给它，然后返回并等候句柄（已经上溯造型至基础类型）作为返回值出现。从这时开始，就可以按多形性的方式对待对象了。因此，我们根本没必要知道所创建对象的准确类型是什么。事实上，Factory方法会把自己隐藏起来，我们是看不见它的。这样做可防止不慎的误用。如果想在没有多形性的前提下使用对象，必须明确地使用RTTI和指定造型。\n但仍然存在一个小问题，特别是在基础类中使用更复杂的方法（不是在这里展示的那种），且在衍生类里过载（覆盖）了它的前提下。如果在衍生类里请求的信息要求更多或者不同的参数，那么该怎么办呢？“创建更多的对象”解决了这个问题。为实现Factory方法，Trash类使用了一个新的方法，名为factory。为了将创建数据隐藏起来，我们用一个名为Info的新类包含factory方法创建适当的Trash对象时需要的全部信息。下面是Info一种简单的实现方式：\nclass Info {\rint type;\r// Must change this to add another type:\rstatic final int MAX_NUM = 4;\rdouble data;\rInfo(int typeNum, double dat) {\rtype = typeNum % MAX_NUM;\rdata = dat;\r}\r} Info对象唯一的任务就是容纳用于factory()方法的信息。现在，假如出现了一种特殊情况，factory()需要更多或者不同的信息来新建一种类型的Trash对象，那么再也不需要改动factory()了。通过添加新的数据和构建器，我们可以修改Info类，或者采用子类处理更典型的面向对象形式。\n用于这个简单示例的factory()方法如下：\nstatic Trash factory(Info i) {\rswitch(i.type) {\rdefault: // To quiet the compiler\rcase 0:\rreturn new Aluminum(i.data);\rcase 1:\rreturn new Paper(i.data);\rcase 2:\rreturn new Glass(i.data);\r// Two lines here:\rcase 3: return new Cardboard(i.data);\r}\r} 在这里，对象的准确类型很容易即可判断出来。但我们可以设想一些更复杂的情况，factory()将采用一种复杂的算法。无论如何，现在的关键是它已隐藏到某个地方，而且我们在添加新类型时知道去那个地方。\n新对象在main()中的创建现在变得非常简单和清爽：\nfor(int i = 0; i \u0026lt; 30; i++)\rbin.addElement(\rTrash.factory(\rnew Info(\r(int)(Math.random() * Info.MAX_NUM),\rMath.random() * 100))); 我们在这里创建了一个Info对象，用于将数据传入factory()；后者在内存堆中创建某种Trash对象，并返回添加到Vector bin内的句柄。当然，如果改变了参数的数量及类型，仍然需要修改这个语句。但假如Info对象的创建是自动进行的，也可以避免那个麻烦。例如，可将参数的一个Vector传递到Info对象的构建器中（或直接传入一个factory()调用）。这要求在运行期间对参数（自变量）进行分析与检查，但确实提供了非常高的灵活程度。\n大家从这个代码可看出Factory要负责解决的“领头变化”问题：如果向系统添加了新类型（发生了变化），唯一需要修改的代码在Factory内部，所以Factory将那种变化的影响隔离出来了。\n16.4.2 用于原型创建的一个范式 上述设计方案的一个问题是仍然需要一个中心场所，必须在那里知道所有类型的对象：在factory()方法内部。如果经常都要向系统添加新类型，factory()方法为每种新类型都要修改一遍。若确实对这个问题感到苦恼，可试试再深入一步，将与类型有关的所有信息——包括它的创建过程——都移入代表那种类型的类内部。这样一来，每次新添一种类型的时候，需要做的唯一事情就是从一个类继承。\n为将涉及类型创建的信息移入特定类型的Trash里，必须使用“原型”（prototype）范式（来自《Design Patterns》那本书）。这里最基本的想法是我们有一个主控对象序列，为自己感兴趣的每种类型都制作一个。这个序列中的对象只能用于新对象的创建，采用的操作类似内建到Java根类Object内部的clone()机制。在这种情况下，我们将克隆方法命名为tClone()。准备创建一个新对象时，要事先收集好某种形式的信息，用它建立我们希望的对象类型。然后在主控序列中遍历，将手上的信息与主控序列中原型对象内任何适当的信息作对比。若找到一个符合自己需要的，就克隆它。\n采用这种方案，我们不必用硬编码的方式植入任何创建信息。每个对象都知道如何揭示出适当的信息，以及如何对自身进行克隆。所以一种新类型加入系统的时候，factory()方法不需要任何改变。\n为解决原型的创建问题，一个方法是添加大量方法，用它们支持新对象的创建。但在Java 1.1中，如果拥有指向Class对象的一个句柄，那么它已经提供了对创建新对象的支持。利用Java 1.1的“反射”（已在第11章介绍）技术，即便我们只有指向Class对象的一个句柄，亦可正常地调用一个构建器。这对原型问题的解决无疑是个完美的方案。\n原型列表将由指向所有想创建的Class对象的一个句柄列表间接地表示。除此之外，假如原型处理失败，则factory()方法会认为由于一个特定的Class对象不在列表中，所以会尝试装载它。通过以这种方式动态装载原型，Trash类根本不需要知道自己要操纵的是什么类型。因此，在我们添加新类型时不需要作出任何形式的修改。于是，我们可在本章剩余的部分方便地重复利用它。\n//: Trash.java // Base class for Trash recycling examples package c16.trash; import java.util.*; import java.lang.reflect.*; public abstract class Trash { private double weight; Trash(double wt) { weight = wt; } Trash() {} public abstract double value(); public double weight() { return weight; } // Sums the value of Trash in a bin: public static void sumValue(Vector bin) { Enumeration e = bin.elements(); double val = 0.0f; while(e.hasMoreElements()) { // One kind of RTTI: // A dynamically-checked cast Trash t = (Trash)e.nextElement(); val += t.weight() * t.value(); System.out.println( \u0026#34;weight of \u0026#34; + // Using RTTI to get type // information about the class: t.getClass().getName() + \u0026#34; = \u0026#34; + t.weight()); } System.out.println(\u0026#34;Total value = \u0026#34; + val); } // Remainder of class provides support for // prototyping: public static class PrototypeNotFoundException extends Exception {} public static class CannotCreateTrashException extends Exception {} private static Vector trashTypes = new Vector(); public static Trash factory(Info info) throws PrototypeNotFoundException, CannotCreateTrashException { for(int i = 0; i \u0026lt; trashTypes.size(); i++) { // Somehow determine the new type // to create, and create one: Class tc = (Class)trashTypes.elementAt(i); if (tc.getName().indexOf(info.id) != -1) { try { // Get the dynamic constructor method // that takes a double argument: // 通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，适用于无参和有参构造方法。 Constructor ctor = tc.getConstructor( new Class[] {double.class}); // Call the constructor to create a // new object: return (Trash)ctor.newInstance( new Object[]{new Double(info.data)}); } catch(Exception ex) { ex.printStackTrace(); throw new CannotCreateTrashException(); } } } // Class was not in the list. Try to load it, // but it must be in your class path! try { System.out.println(\u0026#34;Loading \u0026#34; + info.id); trashTypes.addElement( Class.forName(info.id)); } catch(Exception e) { e.printStackTrace(); throw new PrototypeNotFoundException(); } // Loaded successfully. Recursive call // should work this time: return factory(info); } public static class Info { public String id; public double data; public Info(String name, double data) { id = name; this.data = data; } } } ///:~ 基本Trash类和sumValue()还是象往常一样。这个类剩下的部分支持原型范式。大家首先会看到两个内部类（被设为static属性，使其成为只为代码组织目的而存在的内部类），它们描述了可能出现的违例。在它后面跟随的是一个Vector trashTypes，用于容纳Class句柄。\n在Trash.factory()中，Info对象id（Info类的另一个版本，与前面讨论的不同）内部的String包含了要创建的那种Trash的类型名称。这个String会与列表中的Class名比较。若存在相符的，那便是要创建的对象。当然，还有很多方法可以决定我们想创建的对象。之所以要采用这种方法，是因为从一个文件读入的信息可以转换成对象。\n发现自己要创建的Trash（垃圾）种类后，接下来就轮到“反射”方法大显身手了。getConstructor()方法需要取得自己的参数——由Class句柄构成的一个数组。这个数组代表着不同的参数，并按它们正确的顺序排列，以便我们查找的构建器使用。在这儿，该数组是用Java 1.1的数组创建语法动态创建的：\nnew Class[] {double.class} 这个代码假定所有Trash类型都有一个需要double数值的构建器（注意double.class与Double.class是不同的）。若考虑一种更灵活的方案，亦可调用getConstructors()，令其返回可用构建器的一个数组。 从getConstructors()返回的是指向一个Constructor对象的句柄（该对象是java.lang.reflect的一部分）。我们用方法newInstance()动态地调用构建器。该方法需要获取包含了实际参数的一个Object数组。这个数组同样是按Java 1.1的语法创建的：\nnew Object[] {new Double(info.data)} 在这种情况下，double必须置入一个封装（容器）类的内部，使其真正成为这个对象数组的一部分。通过调用newInstance()，会提取出double，但大家可能会觉得稍微有些迷惑——参数既可能是double，也可能是Double，但在调用的时候必须用Double传递。幸运的是，这个问题只存在于基本数据类型中间。\n理解了具体的过程后，再来创建一个新对象，并且只为它提供一个Class句柄，事情就变得非常简单了。就目前的情况来说，内部循环中的return永远不会执行，我们在终点就会退出。在这儿，程序动态装载Class对象，并把它加入trashTypes（垃圾类型）列表，从而试图纠正这个问题。若仍然找不到真正有问题的地方，同时装载又是成功的，那么就重复调用factory方法，重新试一遍。\n正如大家会看到的那样，这种设计方案最大的优点就是不需要改动代码。无论在什么情况下，它都能正常地使用（假定所有Trash子类都包含了一个构建器，用以获取单个double参数）。\nTrash子类 为了与原型机制相适应，对Trash每个新子类唯一的要求就是在其中包含了一个构建器，指示它获取一个double参数。Java 1.1的“反射”机制可负责剩下的所有工作。 下面是不同类型的Trash，每种类型都有它们自己的文件里，但都属于Trash包的一部分（同样地，为了方便在本章内重复使用）：\n//: Aluminum.java // The Aluminum class with prototyping package c16.trash; public class Aluminum extends Trash { private static double val = 1.67f; public Aluminum(double wt) { super(wt); } public double value() { return val; } public static void value(double newVal) { val = newVal; } } ///:~ 下面是一种新的Trash类型：\n//: Cardboard.java // The Cardboard class with prototyping package c16.trash; public class Cardboard extends Trash { private static double val = 0.23f; public Cardboard(double wt) { super(wt); } public double value() { return val; } public static void value(double newVal) { val = newVal; } } ///:~ 可以看出，除构建器以外，这些类根本没有什么特别的地方。\n从外部文件中解析出Trash 与Trash对象有关的信息将从一个外部文件中读取。针对Trash的每个方面，文件内列出了所有必要的信息——每行都代表一个方面，采用“垃圾（废品）名称:值”的固定格式。例如：\nc16.Trash.Glass:54\rc16.Trash.Paper:22\rc16.Trash.Paper:11\rc16.Trash.Glass:17\rc16.Trash.Aluminum:89\rc16.Trash.Paper:88\rc16.Trash.Aluminum:76\rc16.Trash.Cardboard:96\rc16.Trash.Aluminum:25\rc16.Trash.Aluminum:34\rc16.Trash.Glass:11\rc16.Trash.Glass:68\rc16.Trash.Glass:43\rc16.Trash.Aluminum:27\rc16.Trash.Cardboard:44\rc16.Trash.Aluminum:18\rc16.Trash.Paper:91\rc16.Trash.Glass:63\rc16.Trash.Glass:50\rc16.Trash.Glass:80\rc16.Trash.Aluminum:81\rc16.Trash.Cardboard:12\rc16.Trash.Glass:12\rc16.Trash.Glass:54\rc16.Trash.Aluminum:36\rc16.Trash.Aluminum:93\rc16.Trash.Glass:93\rc16.Trash.Paper:80\rc16.Trash.Glass:36\rc16.Trash.Glass:12\rc16.Trash.Glass:60\rc16.Trash.Paper:66\rc16.Trash.Aluminum:36\rc16.Trash.Cardboard:22 注意在给定类名的时候，类路径必须包含在内，否则就找不到类。\n为解析它，每一行内容都会读入，并用字串方法indexOf()来建立“:”的一个索引。首先用字串方法substring()取出垃圾的类型名称，接着用一个静态方法Double.valueOf()取得相应的值，并转换成一个double值。trim()方法则用于删除字串两头的多余空格。\nTrash解析器置入单独的文件中，因为本章将不断地用到它。如下所示：\n//: ParseTrash.java // Open a file and parse its contents into // Trash objects, placing each into a Vector package c16.trash; import java.util.*; import java.io.*; public class ParseTrash { public static void fillBin(String filename, Fillable bin) { try { BufferedReader data = new BufferedReader( new FileReader(filename)); String buf; while((buf = data.readLine())!= null) { String type = buf.substring(0, buf.indexOf(\u0026#39;:\u0026#39;)).trim(); double weight = Double.valueOf( buf.substring(buf.indexOf(\u0026#39;:\u0026#39;) + 1) .trim()).doubleValue(); bin.addTrash( Trash.factory( new Trash.Info(type, weight))); } data.close(); } catch(IOException e) { e.printStackTrace(); } catch(Exception e) { e.printStackTrace(); } } // Special case to handle Vector: public static void fillBin(String filename, Vector bin) { fillBin(filename, new FillableVector(bin)); } } ///:~ 在RecycleA.java中，我们用一个Vector容纳Trash对象。然而，亦可考虑采用其他集合类型。为做到这一点，fillBin()的第一个版本将获取指向一个Fillable的句柄。后者是一个接口，用于支持一个名为addTrash()的方法：\n//: Fillable.java // Any object that can be filled with Trash package c16.trash; public interface Fillable { void addTrash(Trash t); } ///:~ 支持该接口的所有东西都能伴随fillBin使用。当然，Vector并未实现Fillable，所以它不能工作。由于Vector将在大多数例子中应用，所以最好的做法是添加另一个过载的fillBin()方法，令其以一个Vector作为参数。利用一个适配器（Adapter）类，这个Vector可作为一个Fillable对象使用：\n//: FillableVector.java // Adapter that makes a Vector Fillable package c16.trash; import java.util.*; public class FillableVector implements Fillable { private Vector v; public FillableVector(Vector vv) { v = vv; } public void addTrash(Trash t) { v.addElement(t); } } ///:~ 可以看到，这个类唯一的任务就是负责将Fillable的addTrash()同Vector的addElement()方法连接起来。利用这个类，已过载的fillBin()方法可在ParseTrash.java中伴随一个Vector使用：\npublic static void fillBin(String filename, Vector bin) {\rfillBin(filename, new FillableVector(bin));\r} 这种方案适用于任何频繁用到的集合类。除此以外，集合类还可提供它自己的适配器类，并实现Fillable（稍后即可看到，在DynaTrash.java中）。\n原型机制的重复应用 现在，大家可以看到采用原型技术的、修订过的RecycleA.java版本了： //: RecycleAP.java // Recycling with RTTI and Prototypes package c16.recycleap; import c16.trash.*; import java.util.*; public class RecycleAP { public static void main(String[] args) { Vector bin = new Vector(); // Fill up the Trash bin: ParseTrash.fillBin(\u0026#34;Trash.dat\u0026#34;, bin); Vector glassBin = new Vector(), paperBin = new Vector(), alBin = new Vector(); Enumeration sorter = bin.elements(); // Sort the Trash: while(sorter.hasMoreElements()) { Object t = sorter.nextElement(); // RTTI to show class membership: if(t instanceof Aluminum) alBin.addElement(t); if(t instanceof Paper) paperBin.addElement(t); if(t instanceof Glass) glassBin.addElement(t); } Trash.sumValue(alBin); Trash.sumValue(paperBin); Trash.sumValue(glassBin); Trash.sumValue(bin); } } ///:~ 所有Trash对象——以及ParseTrash及支撑类——现在都成为名为c16.trash的一个包的一部分，所以它们可以简单地导入。 无论打开包含了Trash描述信息的数据文件，还是对那个文件进行解析，所有涉及到的操作均已封装到static（静态）方法ParseTrash.fillBin()里。所以它现在已经不是我们设计过程中要注意的一个重点。在本章剩余的部分，大家经常都会看到无论添加的是什么类型的新类，ParseTrash.fillBin()都会持续工作，不会发生改变，这无疑是一种优良的设计方案。\n提到对象的创建，这一方案确实已将新类型加入系统所需的变动严格地“本地化”了。但在使用RTTI的过程中，却存在着一个严重的问题，这里已明确地显露出来。程序表面上工作得很好，但却永远侦测到不能“硬纸板”（Cardboard）这种新的废品类型——即使列表里确实有一个硬纸板类型！之所以会出现这种情况，完全是由于使用了RTTI的缘故。RTTI只会查找那些我们告诉它查找的东西。RTTI在这里错误的用法是“系统中的每种类型”都进行了测试，而不是仅测试一种类型或者一个类型子集。正如大家以后会看到的那样，在测试每一种类型时可换用其他方式来运用多形性特征。但假如以这种形式过多地使用RTTI，而且又在自己的系统里添加了一种新类型，很容易就会忘记在程序里作出适当的改动，从而埋下以后难以发现的Bug。因此，在这种情况下避免使用RTTI是很有必要的，这并不仅仅是为了表面好看——也是为了产生更易维护的代码。\n16.5 抽象的应用 走到这一步，接下来该考虑一下设计方案剩下的部分了——在哪里使用类？既然归类到垃圾箱的办法非常不雅且过于暴露，为什么不隔离那个过程，把它隐藏到一个类里呢？这就是著名的“如果必须做不雅的事情，至少应将其本地化到一个类里”规则。看起来就象下面这样：\n现在，只要一种新类型的Trash加入方法，对TrashSorter对象的初始化就必须变动。可以想象，TrashSorter类看起来应该象下面这个样子：\nclass TrashSorter extends Vector {\rvoid sort(Trash t) { /* ... */ }\r} 也就是说，TrashSorter是由一系列句柄构成的Vector（系列），而那些句柄指向的又是由Trash句柄构成的Vector；利用addElement()，可以安装新的TrashSorter，如下所示：\nTrashSorter ts = new TrashSorter();\rts.addElement(new Vector()); 但是现在，sort()却成为一个问题。用静态方式编码的方法如何应付一种新类型加入的事实呢？为解决这个问题，必须从sort()里将类型信息删除，使其需要做的所有事情就是调用一个通用方法，用它照料涉及类型处理的所有细节。这当然是对一个动态绑定方法进行描述的另一种方式。所以sort()会在序列中简单地遍历，并为每个Vector都调用一个动态绑定方法。由于这个方法的任务是收集它感兴趣的垃圾片，所以称之为 grab(Trash)。结构现在变成了下面这样：\n其中，TrashSorter需要调用每个grab()方法；然后根据当前Vector容纳的是什么类型，会获得一个不同的结果。也就是说，Vector必须留意自己容纳的类型。解决这个问题的传统方法是创建一个基础“Trash bin”（垃圾筒）类，并为希望容纳的每个不同的类型都继承一个新的衍生类。若Java有一个参数化的类型机制，那就也许是最直接的方法。但对于这种机制应该为我们构建的各个类，我们不应该进行麻烦的手工编码，以后的“观察”方式提供了一种更好的编码方式。\nOOP设计一条基本的准则是“为状态的变化使用数据成员，为行为的变化使用多性形”。对于容纳Paper（纸张）的Vector，以及容纳Glass（玻璃）的Vector，大家最开始或许会认为分别用于它们的grab()方法肯定会产生不同的行为。但具体如何却完全取决于类型，而不是其他什么东西。可将其解释成一种不同的状态，而且由于Java有一个类可表示类型（Class），所以可用它判断特定的Tbin要容纳什么类型的Trash。\n用于Tbin的构建器要求我们为其传递自己选择的一个Class。这样做可告诉Vector它希望容纳的是什么类型。随后，grab()方法用Class BinType和RTTI来检查我们传递给它的Trash对象是否与它希望收集的类型相符。 下面列出完整的解决方案。设定为注释的编号（如1）便于大家对照程序后面列出的说明。\n//: RecycleB.java // Adding more objects to the recycling problem package c16.recycleb; import c16.trash.*; import java.util.*; // A vector that admits only the right type: class Tbin extends Vector { Class binType; Tbin(Class binType) { this.binType = binType; } boolean grab(Trash t) { // Comparing class types: if(t.getClass().equals(binType)) { addElement(t); return true; // Object grabbed } return false; // Object not grabbed } } class TbinList extends Vector { //(*1*) boolean sort(Trash t) { Enumeration e = elements(); while(e.hasMoreElements()) { Tbin bin = (Tbin)e.nextElement(); if(bin.grab(t)) return true; } return false; // bin not found for t } void sortBin(Tbin bin) { // (*2*) Enumeration e = bin.elements(); while(e.hasMoreElements()) if(!sort((Trash)e.nextElement())) System.out.println(\u0026#34;Bin not found\u0026#34;); } } public class RecycleB { static Tbin bin = new Tbin(Trash.class); public static void main(String[] args) { // Fill up the Trash bin: ParseTrash.fillBin(\u0026#34;Trash.dat\u0026#34;, bin); TbinList trashBins = new TbinList(); trashBins.addElement( new Tbin(Aluminum.class)); trashBins.addElement( new Tbin(Paper.class)); trashBins.addElement( new Tbin(Glass.class)); // add one line here: (*3*) trashBins.addElement( new Tbin(Cardboard.class)); trashBins.sortBin(bin); // (*4*) Enumeration e = trashBins.elements(); while(e.hasMoreElements()) { Tbin b = (Tbin)e.nextElement(); Trash.sumValue(b); } Trash.sumValue(bin); } } ///:~ (1) TbinList容纳一系列Tbin句柄，所以在查找与我们传递给它的Trash对象相符的情况时，sort()能通过Tbin继承。\n(2) sortBin()允许我们将一个完整的Tbin传递进去，而且它会在Tbin里遍历，挑选出每种Trash，并将其归类到特定的Tbin中。请注意这些代码的通用性：新类型加入时，它本身不需要任何改动。只要新类型加入（或发生其他事件）时大量代码都不需要变化，就表明我们设计的是一个容易扩展的系统。\n(3) 现在可以体会添加新类型有多么容易了。为支持添加，只需要改动几行代码。如确实有必要，甚至可以进一步地改进设计，使更多的代码都保持“固定”。\n(4) 一个方法调用使bin的内容归类到对应的、特定类型的垃圾筒里。\n16.6 多重派遣 上述设计方案肯定是令人满意的。系统内新类型的加入涉及添加或修改不同的类，但没有必要在系统内对代码作大范围的改动。除此以外，RTTI并不象它在RecycleA.java里那样被不当地使用。然而，我们仍然有可能更深入一步，以最“纯”的角度来看待RTTI， 考虑如何在垃圾分类系统中将它完全消灭。。\n为达到这个目标，首先必须认识到：对所有与不同类型有特殊关联的活动来说——比如侦测一种垃圾的具体类型，并把它置入适当的垃圾筒里——这些活动都应当通过多形性以及动态绑定加以控制。\n以前的例子都是先按类型排序，再对属于某种特殊类型的一系列元素进行操作。现在一旦需要操作特定的类型，就请先停下来想一想。事实上，多形性（动态绑定的方法调用）整个的宗旨就是帮我们管理与不同类型有特殊关联的信息。既然如此，为什么还要自己去检查类型呢？\n答案在于大家或许不以为然的一个道理：Java只执行单一派遣。也就是说，假如对多个类型未知的对象执行某项操作，Java只会为那些类型中的一种调用动态绑定机制。这当然不能解决问题，所以最后不得不人工判断某些类型，才能有效地产生自己的动态绑定行为。\n为解决这个缺陷，我们需要用到“多重派遣”机制，这意味着需要建立一个配置，使单一方法调用能产生多个动态方法调用，从而在一次处理过程中正确判断出多种类型。为达到这个要求，需要对多个类型结构进行操作：每一次派遣都需要一个类型结构。下面的例子将对两个结构进行操作：现有的Trash系列以及由垃圾筒（Trash Bin）的类型构成的一个系列——不同的垃圾或废品将置入这些筒内。第二个分级结构并非绝对显然的。在这种情况下，我们需要人为地创建它，以执行多重派遣（由于本例只涉及两次派遣，所以称为“双重派遣”）。\n16.6.1 实现双重派遣 记住多形性只能通过方法调用才能表现出来，所以假如想使双重派遣正确进行，必须执行两个方法调用：在每种结构中都用一个来判断其中的类型。在Trash结构中，将使用一个新的方法调用addToBin()，它采用的参数是由TypeBin构成的一个数组。那个方法将在数组中遍历，尝试将自己加入适当的垃圾筒，这里正是双重派遣发生的地方。\n新建立的分级结构是TypeBin，其中包含了它自己的一个方法，名为add()，而且也应用了多形性。但要注意一个新特点：add()已进行了“过载”处理，可接受不同的垃圾类型作为参数。因此，双重满足机制的一个关键点是它也要涉及到过载。 程序的重新设计也带来了一个问题：现在的基础类Trash必须包含一个addToBin()方法。为解决这个问题，一个最直接的办法是复制所有代码，并修改基础类。然而，假如没有对源码的控制权，那么还有另一个办法可以考虑：将addToBin()方法置入一个接口内部，保持Trash不变，并继承新的、特殊的类型Aluminum，Paper，Glass以及Cardboard。我们在这里准备采取后一个办法。 这个设计方案中用到的大多数类都必须设为public（公用）属性，所以它们放置于自己的类内。下面列出接口代码：\n//: TypedBinMember.java // An interface for adding the double dispatching // method to the trash hierarchy without // modifying the original hierarchy. package c16.doubledispatch; interface TypedBinMember { // The new method: boolean addToBin(TypedBin[] tb); } ///:~ 在Aluminum，Paper，Glass以及Cardboard每个特定的子类型内，都会实现接口TypeBinMember的addToBin()方法，但每种情况下使用的代码“似乎”都是完全一样的：\n//: DDAluminum.java // Aluminum for double dispatching package c16.doubledispatch; import c16.trash.*; public class DDAluminum extends Aluminum implements TypedBinMember { public DDAluminum(double wt) { super(wt); } public boolean addToBin(TypedBin[] tb) { for(int i = 0; i \u0026lt; tb.length; i++) if(tb[i].add(this)) return true; return false; } } ///:~ //: DDPaper.java // Paper for double dispatching package c16.doubledispatch; import c16.trash.*; public class DDPaper extends Paper implements TypedBinMember { public DDPaper(double wt) { super(wt); } public boolean addToBin(TypedBin[] tb) { for(int i = 0; i \u0026lt; tb.length; i++) if(tb[i].add(this)) return true; return false; } } ///:~ //: DDGlass.java // Glass for double dispatching package c16.doubledispatch; import c16.trash.*; public class DDGlass extends Glass implements TypedBinMember { public DDGlass(double wt) { super(wt); } public boolean addToBin(TypedBin[] tb) { for(int i = 0; i \u0026lt; tb.length; i++) if(tb[i].add(this)) return true; return false; } } ///:~ //: DDCardboard.java // Cardboard for double dispatching package c16.doubledispatch; import c16.trash.*; public class DDCardboard extends Cardboard implements TypedBinMember { public DDCardboard(double wt) { super(wt); } public boolean addToBin(TypedBin[] tb) { for(int i = 0; i \u0026lt; tb.length; i++) if(tb[i].add(this)) return true; return false; } } ///:~ 每个addToBin()内的代码会为数组中的每个TypeBin对象调用add()。但请注意参数：this。对Trash的每个子类来说，this的类型都是不同的，所以不能认为代码“完全”一样——尽管以后在Java里加入参数化类型机制后便可认为一样。这是双重派遣的第一个部分，因为一旦进入这个方法内部，便可知道到底是Aluminum，Paper，还是其他什么垃圾类型。在对add()的调用过程中，这种信息是通过this的类型传递的。编译器会分析出对add()正确的过载版本的调用。但由于tb[i]会产生指向基础类型TypeBin的一个句柄，所以最终会调用一个不同的方法——具体什么方法取决于当前选择的TypeBin的类型。那就是第二次派遣。\n下面是TypeBin的基础类：\n//: TypedBin.java // Vector that knows how to grab the right type package c16.doubledispatch; import c16.trash.*; import java.util.*; public abstract class TypedBin { Vector v = new Vector(); protected boolean addIt(Trash t) { v.addElement(t); return true; } public Enumeration elements() { return v.elements(); } public boolean add(DDAluminum a) { return false; } public boolean add(DDPaper a) { return false; } public boolean add(DDGlass a) { return false; } public boolean add(DDCardboard a) { return false; } } ///:~ 可以看到，过载的add()方法全都会返回false。如果未在衍生类里对方法进行过载，它就会一直返回false，而且调用者（目前是addToBin()）会认为当前Trash对象尚未成功加入一个集合，所以会继续查找正确的集合。\n在TypeBin的每一个子类中，都只有一个过载的方法会被过载——具体取决于准备创建的是什么垃圾筒类型。举个例子来说，CardboardBin会过载add(DDCardboard)。过载的方法会将垃圾对象加入它的集合，并返回true。而CardboardBin中剩余的所有add()方法都会继续返回false，因为它们尚未过载。事实上，假如在这里采用了参数化类型机制，Java代码的自动创建就要方便得多（使用C++的“模板”，我们不必费事地为子类编码，或者将addToBin()方法置入Trash里；Java在这方面尚有待改进）。\n由于对这个例子来说，垃圾的类型已经定制并置入一个不同的目录，所以需要用一个不同的垃圾数据文件令其运转起来。下面是一个示范性的DDTrash.dat：\nc16.DoubleDispatch.DDGlass:54\rc16.DoubleDispatch.DDPaper:22\rc16.DoubleDispatch.DDPaper:11\rc16.DoubleDispatch.DDGlass:17\rc16.DoubleDispatch.DDAluminum:89\rc16.DoubleDispatch.DDPaper:88\rc16.DoubleDispatch.DDAluminum:76\rc16.DoubleDispatch.DDCardboard:96\rc16.DoubleDispatch.DDAluminum:25\rc16.DoubleDispatch.DDAluminum:34\rc16.DoubleDispatch.DDGlass:11\rc16.DoubleDispatch.DDGlass:68\rc16.DoubleDispatch.DDGlass:43\rc16.DoubleDispatch.DDAluminum:27\rc16.DoubleDispatch.DDCardboard:44\rc16.DoubleDispatch.DDAluminum:18\rc16.DoubleDispatch.DDPaper:91\rc16.DoubleDispatch.DDGlass:63\rc16.DoubleDispatch.DDGlass:50\rc16.DoubleDispatch.DDGlass:80\rc16.DoubleDispatch.DDAluminum:81\rc16.DoubleDispatch.DDCardboard:12\rc16.DoubleDispatch.DDGlass:12\rc16.DoubleDispatch.DDGlass:54\rc16.DoubleDispatch.DDAluminum:36\rc16.DoubleDispatch.DDAluminum:93\rc16.DoubleDispatch.DDGlass:93\rc16.DoubleDispatch.DDPaper:80\rc16.DoubleDispatch.DDGlass:36\rc16.DoubleDispatch.DDGlass:12\rc16.DoubleDispatch.DDGlass:60\rc16.DoubleDispatch.DDPaper:66\rc16.DoubleDispatch.DDAluminum:36\rc16.DoubleDispatch.DDCardboard:22 下面列出程序剩余的部分：\n//: DoubleDispatch.java // Using multiple dispatching to handle more // than one unknown type during a method call. package c16.doubledispatch; import c16.trash.*; import java.util.*; class AluminumBin extends TypedBin { public boolean add(DDAluminum a) { return addIt(a); } } class PaperBin extends TypedBin { public boolean add(DDPaper a) { return addIt(a); } } class GlassBin extends TypedBin { public boolean add(DDGlass a) { return addIt(a); } } class CardboardBin extends TypedBin { public boolean add(DDCardboard a) { return addIt(a); } } class TrashBinSet { private TypedBin[] binSet = { new AluminumBin(), new PaperBin(), new GlassBin(), new CardboardBin() }; public void sortIntoBins(Vector bin) { Enumeration e = bin.elements(); while(e.hasMoreElements()) { TypedBinMember t = (TypedBinMember)e.nextElement(); if(!t.addToBin(binSet)) System.err.println(\u0026#34;Couldn\u0026#39;t add \u0026#34; + t); } } public TypedBin[] binSet() { return binSet; } } public class DoubleDispatch { public static void main(String[] args) { Vector bin = new Vector(); TrashBinSet bins = new TrashBinSet(); // ParseTrash still works, without changes: ParseTrash.fillBin(\u0026#34;DDTrash.dat\u0026#34;, bin); // Sort from the master bin into the // individually-typed bins: bins.sortIntoBins(bin); TypedBin[] tb = bins.binSet(); // Perform sumValue for each bin... for(int i = 0; i \u0026lt; tb.length; i++) Trash.sumValue(tb[i].v); // ... and for the master bin Trash.sumValue(bin); } } ///:~ 其中，TrashBinSet封装了各种不同类型的TypeBin，同时还有 sortIntoBins()方法。所有双重派遣事件都会在那个方法里发生。可以看到，一旦设置好结构，再归类成各种TypeBin的工作就变得十分简单了。除此以外，两个动态方法调用的效率可能也比其他排序方法高一些。\n注意这个系统的方便性主要体现在main()中，同时还要注意到任何特定的类型信息在main()中都是完全独立的。只与Trash基础类接口通信的其他所有方法都不会受到Trash类中发生的改变的干扰。\n添加新类型需要作出的改动是完全孤立的：我们随同addToBin()方法继承Trash的新类型，然后继承一个新的TypeBin（这实际只是一个副本，可以简单地编辑），最后将一种新类型加入TrashBinSet的集合初化化过程。\n16.7 访问器范式 16.8 RTTI真的有害吗 警惕滥用！！！\n16.9 总结 从表面看，由于象TrashVisitor.java这样的设计包含了比早期设计数量更多的代码，所以会留下效率不高的印象。试图用各种设计方案达到什么目的应该是我们考虑的重点。设计范式特别适合“将发生变化的东西与保持不变的东西隔离开”。而“发生变化的东西”可以代表许多种变化。之所以发生变化，可能是由于程序进入一个新环境，或者由于当前环境的一些东西发生了变化（例如“用户希望在屏幕上当前显示的图示中添加一种新的几何形状”）。或者就象本章描述的那样，变化可能是对代码主体的不断改进。尽管废品分类以前的例子强调了新型Trash向系统的加入，但TrashVisitor.java允许我们方便地添加新功能，同时不会对Trash结构造成干扰。TrashVisitor.java里确实多出了许多代码，但在Visitor里添加新功能只需要极小的代价。如果经常都要进行此类活动，那么多一些代码也是值得的。\n变化序列的发现并非一件平常事；在程序的初始设计出台以前，那些分析家一般不可能预测到这种变化。除非进入项目设计的后期，否则一些必要的信息是不会显露出来的：有时只有进入设计或最终实现阶段，才能体会到对自己系统一个更深入或更不易察觉需要。添加新类型时（这是“回收”例子最主要的一个重点），可能会意识到只有自己进入维护阶段，而且开始扩充系统时，才需要一个特定的继承结构。\n通过设计范式的学习，大家可体会到最重要的一件事情就是本书一直宣扬的一个观点——多形性是OOP（面向对象程序设计）的全部——已发生了彻底的改变。换句话说，很难“获得”多形性；而一旦获得，就需要尝试将自己的所有设计都造型到一个特定的模子里去。\n设计范式要表明的观点是“OOP并不仅仅同多形性有关”。应当与OOP有关的是“将发生变化的东西同保持不变的东西分隔开来”。多形性是达到这一目的的特别重要的手段。而且假如编程语言直接支持多形性，那么它就显得尤其有用（由于直接支持，所以不必自己动手编写，从而节省大量的精力和时间）。但设计范式向我们揭示的却是达到基本目标的另一些常规途径。而且一旦熟悉并掌握了它的用法，就会发现自己可以做出更有创新性的设计。\n由于《Design Patterns》这本书对程序员造成了如此重要的影响，所以他们纷纷开始寻找其他范式。随着的时间的推移，这类范式必然会越来越多。\n16.10 练习 "},{"id":143,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC17%E7%AB%A0-%E9%A1%B9%E7%9B%AE/","title":"Thinking in Java 第17章 项目","parent":"Thinking In Java","content":" 第17章 项目 17.1 文字处理 17.2 方法查找工具 17.3 复杂性理论 17.4 总结 17.5 练习 附录A 使用非JAVA代码 附录B 对比C++和Java 附录C Java编程规则 附录D 性能 附录E 关于垃圾收集的一些话 附录F 推荐读物 (9) 第9章：违例差错控制 (10) 第10章：Java IO系统 (11) 第11章：运行期类型鉴定 (12) 第12章：传递和返回对象 (13) 第13章：创建窗口和程序片 (14) 第14章：多线程 (15) 第15章 网络编程 (16) 第16章 设计范式 (17) 第17章 项目 (18) 附录A：使用非Java代码 (19) 附录B：对比C++和Java (20) 附录C：Java编程规则 (21) 附录D：性能 (22) 附录E：关于垃圾收集的一些话 (23) 附录F：推荐读物\n"},{"id":144,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/","title":"Thinking in Java 第1章：对象入门","parent":"Thinking In Java","content":" 第 1 章：对象入门 面向对象编程（OOP）\n1.1 抽象的进步 所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。\n1.2 对象的接口 我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做哪些事情。\n1.3 实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员。\n1.4 方案的重复使用 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。\n新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。\n轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。\n1.5 继承：重新使用接口 在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。\n1.5.1 改善基础类 改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。\n继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；\n1.6 多形对象的互换使用 通常，继承最终会以创建一系列类收场，所有类都建立在统一的基础接口上。\n对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。\n把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。\n1.6.1 动态绑定 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）（多态性）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。\n1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。\n亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。\ninterface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。\n备注：这是一段个人的总结：\rinterface（接口）更倾向于表明这个类是能干什么事，也就是说这类的类实现了哪些方法及继承与此接口的类必需要实现哪些方法；接口更像一个规范文件(协议)。\rabstract（抽象）更倾向于表明一类类的共有特性，由基础类或一个接口衍生的一系列类的共有特性，所以不仅仅表明这个类能干哪些事。\r也就是说 interface（接口）的方法都可以在接口中无实现，只规定了子类必须需要实现哪些方法，而 abstract（抽象）可以把子类相同实现的方法在抽象类里实现，子类各自特别且必须的方法用抽象方法规定然后在子类里各自实现。\rabstract（抽象）可以看为一种跟 public、static 同级别的修饰符（修饰了类（class）和方法），而 interface（接口）可以看为一种跟 class 同级别的修饰符，标志着质的改变。\rinterface（接口）可以说是对 abstract（抽象）的抽象。\rinterface（接口）帮助了对象的分层，各组件之间的松耦合。\rinterface 语法要求：\r1、接口可以包含：静态常量、方法（抽象）、内部类（接口、枚举）、默认方法（类方法）\r2、接口只可以继承多个父接口（之间用英文逗号“,”隔开），不能继承类。\r3、接口修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有相同包结构下才可以访问该接口。\r4、接口内的所有成员都是 public 访问权限，可省略，如果指定则只可使用 public 访问修饰符。\r5、接口的成员变量均为静态常量，不管是否使用 public static final 修饰符都认为只可做如此修饰。\r6、接口的方法只能是抽象、类方法、默认方法，如果不是默认方法，系统将自动为普通方法增加 public abstract 修饰符，且不能有方法实现（方法体），类方法、默认方法必须有方法实现（方法体）。\r7、定义默认方法，需要用 default 修饰且默认添加 public 修饰 ，默认方法不能用 static 修饰，所以不能直接用接口来调用默认方法，由接口的实现类的实例来调用这些默认方法。\r8、类方法需用 static 修饰 ，可用接口直接调用。\r9、接口的内部类（接口、枚举）默认采用 public static 修饰符。\r10、接口可看做为特殊的类，受限于一个源文件只能有一个 public 修饰。\r11、接口不能创建实例，作为声明引用类型变量时此接口必须有其实现类。\rabstract 语法要求：\r1、有抽象方法的类只能是抽象类\r2、抽象类里可没有抽象方法有普通方法\r3、抽象类不能被实例化\r4、抽象类可以包含：成员变量、方法（普通、抽象）、构造器、初始化快、内部类（接口、枚举）、抽象类的构造器不能用于创造实列，主要用于被其子类调用\r5、抽象不能修饰变量（成员、局部），不能修饰构造器，抽象类里的构造器只能是普通的构造器。\r总结如下：\r1、抽象类与普通类相比“一得一失”：1、“得”可包含抽象方法。2、“失”无法被实列化。\r2、抽象类是用来被它的子类继承的，方法由子类实现。而 final 修饰的类不能被继承， final 修饰的方法不能被重写，所以 final 和 abstract 是互斥的。\r3、static 修饰方法是属于这个类本身的（类Class和实列Object的区别），如果该方法被定义成抽象方法，通过类调用的时候也会出错，因为调用了一个没有方法实体的方法，所以 static 和 abstract 是互斥的（非绝对，可以同时修饰内部类）。\r4、abstract 修饰的方法必须被之类重写才有意义，因此 abstract 方法不能是私有的，所以 private 和 abstract 是互斥的。 1.7 对象的创建和存在时间 从技术角度说，OOP（面向对象程序设计）只是涉及抽象的数据类型、继承以及多形性，但另一些问题也可能显得非常重要。\n最重要的问题之一是对象的创建及破坏方式。对象需要的数据位于哪儿，及对象的“存在时间”。\n1.7.1 集合与继承器 “继续器”（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。它存在于所有集合中\n不同的集合在进行特定操作时往往有不同的效率。\n1.7.2 单根结构 所有类最终是从单独一个基础类继承（Object）。他们最终都属于相同的类型。\n所有对象都在内存堆中创建，可以极大简化参数的传递。\n可以更方便地实现一个垃圾收集器。\n由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要，比如违例控制；\n1.7.3 集合库与方便使用集合 为了使这些集合能够重复使用，或者“再生”，Java提供了一种通用类型，以前曾把它叫作“Object”。所以容纳了Object的一个集合实际可以容纳任何东西。这使我们对它的重复使用变得非常简便。\n但由于集合只能容纳Object，所以在我们向集合里添加对象句柄时，它会上溯造型成Object，这样便丢失了它的身份或者标识信息。再次使用它的时候，会得到一个Object句柄，而非指向我们早先置入的那个类型的句柄。\n（↑↑↑↑↑解释上面两个段落：为了复用将集合元素的类型设置为Object，当向集合中添加元素的时候会因为 Upcasting 而丢失 元素的实际类型，以至于无法调用元素的实际有用接口）\n我们再次用到了造型（Cast）。下溯造型成一种更“特殊”的类型。这种造型方法叫作“下溯造型”（Downcasting）。\n在从一个集合提取对象句柄时，必须用某种方式准确地记住它们是什么，以保证下溯造型的正确进行。\n我们可以采用“参数化类型”。\n（↑↑↑↑↑解释上面段落：集合泛型的原因）\n1.7.4 清除时的困境：由谁负责清除？ 每个对象都要求资源才能“生存”，其中最令人注目的资源是内存。如果不再需要使用一个对象，就必须将其清除，以便释放这些资源，以便其他对象使用。\n问题1：如何才能知道什么时间删除对象呢？\n垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。\n2.垃圾收集器对效率及灵活性的影响\n代价就是运行期的开销。\n我们不能确定它什么时候启动或者要花多长的时间。这意味着在Java程序执行期间，存在着一种不连贯的因素。所以在某些特殊的场合，我们必须避免用它——比如在一个程序的执行必须保持稳定、连贯的时候。\n1.8 违例控制：解决错误 错误必然发生\n它们严重依赖程序员的警觉性\n“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。这“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。\n违例不能被忽略，“掷”出的一个违例不同于从函数返回的错误值，那些错误值或标志的作用是指示一个错误状态，是可以忽略的。\n注意违例控制并不属于一种面向对象的特性\n1.9 多线程 在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。\n要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。\n最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。\n从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。\n一个问题：临界资源！一些支持共享，不支持并行的资源，需要在线程使用期间必须进入锁定状态。（比如“屏幕”是个共享资源，但是不能同时播放两个画面。）\nJava中对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用 synchronized 关键字。\n1.10 永久性 Java8移除永久代\n1.11 Java和因特网 1.12 分析和设计 (1) 对象是什么？（怎样将自己的项目分割成一系列单独的组件？） (2) 它们的接口是什么？（需要将什么消息发给每一个对象？） 整个过程可划分为四个阶段：\n阶段0：拟出一个计划、\n阶段1：要制作什么？\n在上一代程序设计中（即“过程化或程序化设计”），这个阶段称为“建立需求分析和系统规格”。 最有价值的工具就是一个名为“使用条件”的集合。 阶段2：如何构建？\n此时可考虑采用一种特殊的图表工具：“统一建模语言”（UML）。 包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。 阶段3：开始创建\n阶段4：校订\n1.13 Java还是 C++ "},{"id":145,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/","title":"Thinking in Java 第2章：一切都是对象","parent":"Thinking In Java","content":" 第 2 章：一切都是对象 Java语言首先便假定了我们只希望进行面向对象的程序设计。\n2.1 用句柄操纵对象 将一切都“看作”对象，操纵的 标识符 实际是指向一个对象的“句柄”（Handle）。\n创建一个String句柄：\rString s;\r这里创建的只是句柄，并不是对象。s实际并未与任何东西连接（即“没有实体”）。\r一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：\rString s = \u0026#34;asdf\u0026#34;;\r总结：\r句柄指向对象，通过句柄操作对象，句柄是句柄，对象是对象。 2.2 所有对象都必须创建 创建句柄时，我们希望它同一个新对象连接。通常用 new 关键字达到这一目的。。new的意思是：“把我变成这些对象的一种新实体”。\n2.2.1 保存到什么地方 程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：\n在Java中是不可能得到真正的内存地址的，也不会提供直接操作“内存地址”的方式。\nJava中堆是由JVM管理的不能直接操作。\n(1) 寄存器： 位于处理器内部。这是最快的保存区域。 以寄存器是根据需要由编译器分配。 我们对此没有直接的控制权。 (2) 堆栈（stack）： 驻留于常规RAM（随机访问存储器）区域，这是一种特别快、特别有效的数据保存方式，仅次于寄存器。 创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性。 有些Java数据要保存在堆栈里——基本类型数据、对象句柄，但Java对象并不放到其中。 每个线程都有自己独立的栈。 (3) 堆（Heap）： 一种常规用途的内存池（也在RAM区域），在堆里分配存储空间时会花掉更长的时间！ 编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。 保存了Java对象。 堆在整个JVM中只有一个（所以堆中的数据可被多个线程共享），堆里面的内存空间由GC来负责回收。 (4) 静态存储 ： 这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。 程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。 Java对象本身永远都不会置入静态存储空间。 (5) 常数存储 ： 常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。 (6) 非RAM存储 ： 若数据完全独立于一个程序之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。 2.2.2 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用new创建对象（特别是小的、简单的变量）并不是非常有效，因为new将对象置于“堆”里。对于这些类型，Java采纳了与C和C++相同的方法。也就是说，不是用new创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，并置于堆栈中，能够更高效地存取。\nJava决定了每种主要类型的大小。(8bit=1byte)\n主类型 大小 封装器类型 boolean 1-bit Boolean byte 8-bit Byte[11] char 16-bit Character short 16-bit Short int 32-bit Integer long 64-bit Long float 32-bit Float double 64-bit Double 注意：\n若变量是主数据类型作为类成员使用，Java可自动分配默认值，可保证主类型的成员变量肯定得到了初始化（自动初始化）（C++不具备这一功能），却并不适用于“局部”变量——那些变量并非一个类的字段，不会自动初始化，会得到一条编译期错误。 高精度数字\n用于进行高精度的计算：BigInteger和BigDecimal。尽管它们大致可以划分为“封装器”类型，但两者都没有对应的“主类型”。这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。 2.2.3 Java的数组 Java的一项主要设计目标就是安全性。一个Java可以保证被初始化，而且不可在它的范围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。\n创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的关键字：null（空）。一旦Java看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。\n2.3 所有对象都必须创建 在大多数程序设计语言中，变量的“存在时间”（Lifetime）一直是程序员需要着重考虑的问题。变量应持续多长的时间？如果想清除它，那么何时进行？在变量存在时间上纠缠不清会造成大量的程序错误。\n2.3.1 作用域（Scope） 作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。\n例子： { int x = 12; /* only x available */ { int q = 96; /* both x \u0026amp; q available */ } /* only x available */ /* q “out of scope” */ } 作为在作用域里定义的一个变量，它只有在那个作用域结束之前才可使用。\n2.3.2 对象的作用域 Java对象不具备与主类型一样的存在时间。用 new 关键字创建一个Java对象的时候，它会超出作用域的范围之外。\n例子： { String s = new String(\u0026#34;a string\u0026#34;); } /* 作用域的终点 */ 那么句柄 s会在作用域的终点处消失。然而，s 指向的 String 对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个句柄已超出了作用域的边界。 这样造成的结果便是：对于用 new 创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在 C 和 C++ 里特别突出。看来在 C++ 里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且更麻烦的是，在 C++ 里，一旦工作完成，必须保证将对象清除。\n假如 Java 让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在 C++ 里，这个问题最令程序员头痛。但 Java 以后，情况却发生了改观。Java 有一个特别的“垃圾收集器”，它会查找用new创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在 C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。\n2.4 新建数据类型：类 一切东西都是对象，那么用什么决定一个“类”（Class）的外观与行为呢？换句话说，是什么建立起了一个对象的“类型”（class）呢？通过 class 关键字。\n例如： //这样就引入了一种新类型。 class ATypeName {/*类主体置于这里} //这样就用new创建这种类型的一个新对象： ATypeName a = new ATypeName(); 2.4.1 字段和方法 定义一个类时（我们在Java里的全部工作就是定义类、制作那些类的对象以及将消息发给那些对象），可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）、成员函数（通常叫“方法”）。其中，数据成员是一种对象（通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄）之一。如果是指向对象的一个句柄，则必须初始化那个句柄，用一种名为“构建器”的特殊函数将其与一个实际对象连接起来（就象早先看到的那样，使用new关键字）。但若是一种主类型，则可在类定义位置直接初始化（正如后面会看到的那样，句柄亦可在定义位置初始化）。\n每个对象都为自己的数据成员保有存储空间；数据成员不会在对象之间共享。（这个共享是指指向一块内存位置的意思么？）\n示例： class DataOnly { int i; float f; boolean b; } 对象实例化后可值赋给数据成员，但首先必须知道如何引用一个对象的成员。首先要写上对象句柄的名字，再跟随一个点号，再跟随对象内部成员的名字。即“对象句柄.成员”。(引用 或者 说 访问权限 会受 修饰符（public、protected、default、private）影响。)\n例如： d.i = 47; d.f = 1.1f; d.b = false; 一个对象也可能包含了另一个对象，只需保持“连接句点”即可。\n例如： myPlane.leftTank.capacity = 100; 1、主成员的默认值： 若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值（自动初始化）。 主类型 默认值： Boolean false Char \u0026#39;\\u0000\u0026#39;(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 注意： 若变量是主数据类型作为类成员使用，Java可自动分配默认值，可保证主类型的成员变量肯定得到了初始化（自动初始化）（C++不具备这一功能），却并不适用于“局部”变量——那些变量并非一个类的字段，不会自动初始化，会得到一条编译期错误。 2.5 方法、自变量和返回值 我们一直用“函数”（Function）这个词指代一个已命名的子例程。但在 Java 里，更常用的一个词却是“方法”（Method），代表“完成某事的途径”。尽管它们表达的实际是同一个意思。\nJava的“方法”决定了一个对象能够接收的消息。\n方法的基本组成部分包括名字、自变量、返回类型以及主体。下面便是它最基本的形式：\n返回类型 方法名( /* 自变量列表*/ ) {/* 方法主体 */} 返回类型是指调用方法之后返回的数值类型。显然，方法名的作用是对具体的方法进行标识和引用。自变量列表列出了想传递给方法的信息类型和名称。\nJava的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（注释③），而且那个对象必须能够执行那个方法调用。\n为一个对象调用方法时，需要先列出对象的名字，在后面跟上一个句点，再跟上方法名以及它的参数列表。亦即“对象名.方法名(自变量1，自变量2，自变量3\u0026hellip;)。例如：我们有一个方法名叫f()，它没有自变量，返回的是类型为int的一个值。假设有一个名为a的对象，可为其调用方法f()，则代码如下：\nint x = a.f(); 象这样调用一个方法的行动通常叫作“向对象发送一条消息”。在上面的例子中，消息是f()，而对象是 a。面向对象的程序设计通常简单地归纳为“向对象发送消息”。\n③：正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象。 自变量 也叫 形参，是方法的局部变量。\n2.5.1 自变量列表 自变量列表规定了我们传送给方法的是什么信息。这些信息——如同Java内其他任何东西——采用的都是对象的形式。因此，我们必须在自变量列表里指定要传递的对象类型，以及每个对象的名字。正如在Java其他地方处理对象时一样，我们实际传递的是“句柄”（注释④）。然而，句柄的类型必须正确。倘若希望自变量是一个“字串”，那么传递的必须是一个字串。\n④：对于前面提及的“特殊”数据类型 boolean，char，byte，short，int，long，，float以及double来说是一个例外。但在传递对象时，通常都是指传递指向对象的句柄。（也就是说 基本类型 传递的是值本身） return 关键字的运用。它主要做两件事情。首先，它意味着“离开方法，我已完工了”。其次，假设方法生成了一个值，则那个值紧接在 return 语句的后面。可按返回 那个值，但倘若不想返回任何东西，就可指示方法返回 void（空）。\n若返回类型为 void，则 return 关键字唯一的作用就是退出方法。\n但假设已指定了一种非 void 的返回类型，那么无论从何地返回，编译器都会确保我们返回的是正确的类型。\n2.6 构建 Java 程序 2.6.1 名字的可见性 Java 的设计者鼓励程序员反转使用自己的 Internet 域名，给一个库生成明确的名字。\n2.6.2 使用其他组件 用 import 关键字准确告诉 Java 编译器我们希望的类是什么。import 的作用是指示编译器导入一个“包”——或者说一个“类库”（在其他语言里，可将“库”想象成一系列函数、数据以及类的集合。但请记住，Java的所有代码都必须写入一个类中）。\n例如： import java.util.Vector; 2.6.3 static关键字 static 修饰的成员表明它是属于这个类本(Class)身，而不是属于该类的单个实列(Object)，没有使用 static 修饰的成员只可通过实例调动，static 修饰的成员不能直接访问非静态成员（因为非静态成员没有初始化）。\n通常，用 new 创建那个类的一个对象，才会正式生成数据存储空间，并可使用相应的方法。\n但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用 static（静态）关键字。一旦将什么东西设为 static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个 static方法，或访问一些 static数据。\n例如： class StaticTest { static int i = 47; } 我们制作了两个 StaticTest对象：\nStaticTest st1 = new StaticTest(); StaticTest st2 = new StaticTest(); 但它们仍然只占据 StaticTest.i的一个存储空间。这两个对象都共享同样的i。无论st1.i还是st2.i都有同样的值47，因为它们引用的是同样的内存区域。\n所以有两个办法可引用一个 static 变量。可通过一个对象命名它，如 st2.i，亦可直接用它的类名引用，如 StaticTest.i（最好用这个办法引用 static 变量，因为它强调了那个变量的“静态”本质）。\nstatic一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法。和其他任何方法一样，static方法也能创建自己类型的命名对象。所以经常把 static方法作为一个“领头羊”使用，用它生成一系列自己类型的“实例”。\n2.7 我们的第一个Java程序 由于java.lang默认进入每个Java代码文件，所以这些类在任何时候都可直接使用。\n通过为 Runtime类调用getRuntime()方法，main()的第五行创建了一个Runtime对象，Runtime可告诉我们与内存使用有关的信息。\n2.8 注释和嵌入文档 2.8.1 注释文档 人们需要考虑程序的文档化问题。用于提取注释的工具叫作javadoc。它不仅提取由这些注释标记指示的信息，也将毗邻注释的类名或方法名提取出来。\njavadoc输出的是一个HTML文件，可用自己的Web浏览器查看。\n2.8.2 具体语法 所有javadoc命令都只能出现于 “/**” 注释中。有三种类型的注释文档，它们对应于位于注释后面的元素：类、变量或者方法。\n/** 一个类注释 */ public class docTest { /** 一个变量注释 */ public int i; /** 一个方法注释 */ public void f() {} } 注意javadoc只能为public（公共）和protected（受保护）成员处理注释文档。“private”（私有）和“友好”（详见5章）成员的注释会被忽略，我们看不到任何输出（也可以用-private标记包括private成员）。\n2.8.3 嵌入HTML javadoc 将HTML命令传递给最终生成的HTML文档。\n亦可象在其他 Web文档里那样运用HTML，对普通文本进行格式化，使其更具条理、更加美观：\n/** * 您\u0026lt;em\u0026gt;甚至\u0026lt;/em\u0026gt;可以插入一个列表： * \u0026lt;ol\u0026gt; * \u0026lt;li\u0026gt; 项目一 * \u0026lt;li\u0026gt; 项目二 * \u0026lt;li\u0026gt; 项目三 * \u0026lt;/ol\u0026gt; */ 注意在文档注释中，位于一行最开头的星号会被javadoc丢弃。同时丢弃的还有前导空格。javadoc 会对所有内容进行格式化，使其与标准的文档外观相符。不要将 \u0026lt;h1\u0026gt; 或 \u0026lt;hr\u0026gt; 这样的标题当作嵌入HTML使用，因为javadoc会插入自己的标题，我们给出的标题会与之冲撞。\n2.8.4 @see：引用其他类 所有三种类型的注释文档都可包含@see标记，它允许我们引用其他类里的文档。对于这个标记，javadoc会生成相应的HTML，将其直接链接到其他文档。格式如下：\n@see 类名 @see 完整类名 @see 完整类名#方法名 每一格式都会在生成的文档里自动加入一个超链接的“See Also”（参见）条目。注意javadoc不会检查我们指定的超链接，不会验证它们是否有效。\n2.8.5 类文档标记 1. @version 格式如下： @version 版本信息 其中，“版本信息”代表任何适合作为版本说明的资料。 2. @author 格式如下： @author 作者信息 其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。 2.8.6 变量文档标记 变量文档只能包括嵌入的HTML以及@see引用。\n2.8.7 方法文档标记 除嵌入HTML和@see引用之外，方法还允许使用针对参数、返回值以及违例的文档标记。\n1. @param 格式如下： @param 参数名 说明 其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。 2. @return 格式如下： @return 说明 其中，“说明”是指返回值的含义。它可延续到后面的行内。 3. @exception 格式如下： @exception 完整类名 说明 其中，“完整类名”明确指定了一个违例类的名字，它是在其他某个地方定义好的。而“说明”（同样可以延续到下面的行）告诉我们为什么这种特殊类型的违例会在方法调用中出现。 4. @deprecated 格式如下： @deprecated 标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。 2.8.8 文档示例 2.9 编码样式 一个非正式的Java编程标准是大写一个类名的首字母。若类名由几个单词构成，那么把它们紧靠到一起（也就是说，不要用下划线来分隔名字）。此外，每个嵌入单词的首字母都采用大写形式。\n例如： class AllTheColorsOfTheRainbow { // ...} 其他几乎所有内容：方法、字段（成员变量）以及对象句柄名称，可接受的样式与类样式差不多，只是标识符的第一个字母采用小写。\n例如： int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) { // ... } 2.10 总结 本章是基础知识。\n"},{"id":146,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC3%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/","title":"Thinking in Java 第3章 控制程序流程","parent":"Thinking In Java","content":" 第3章 控制程序流程 程序必须能操纵自己的世界，在执行过程中作出判断与选择。\n3.1 使用Java运算符 几乎所有运算符都只能操作“主类型”（Primitives）（基本类型）。唯一的例外是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。除此以外，String类支持“+”和“+=”。\n3.1.1 优先级 运算符的优先级决定了存在多个运算符时一个表达式各部分的计算顺序。\n3.1.2 赋值 赋值是用等号运算符（=）进行的。它的意思是“取得右边的值，把它复制到左边”。\n右边的值可以是任何常数、变量或者表达式，只要能产生一个值就行。但左边的值必须是一个明确的、已命名的变量。\n对主数据类型的赋值是非常直接的。由于主类型容纳了实际的值，而且并非指向一个对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。\n但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向最初只有D才指向的那个对象。\n3.1.3 算术运算符 Java的基本算术运算符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及模数（%，从整数除法中获得余数）。整数除法会直接砍掉小数，而不是进位。\n一元加、减运算符 一元减号（-）和一元加号（+）与二元加号和减号都是相同的运算符。\n例如： x = -a; 一元减号得到的运算对象的负值。一元加号的含义与一元减号相反，虽然它实际并不做任何事情。\n3.1.4 自动递增和递减 两种很不错的快捷运算方式是递增和递减运算符（常称作“自动递增”和“自动递减”运算符）。其中，递减运算符是“\u0026ndash;”，意为“减少一个单位”；递增运算符是“++”，意为“增加一个单位”。举个例子来说，假设A是一个int（整数）值，则表达式++A就等价于（A = A + 1）。\n对每种类型的运算符，都有两个版本可供选用；通常将其称为“前缀版”和“后缀版”。。对于前递增和前递减（如++A或\u0026ndash;A），会先执行运算，再生成值。而对于后递增和后递减（如A++或A\u0026ndash;），会先生成值，再执行运算。\n3.1.5 关系运算符 关系运算符生成的是一个“布尔”（Boolean）结果。它们评价的是运算对象值之间的关系。若关系是真实的，关系表达式会生成 true（真）；若关系不真实，则生成 false（假）。关系运算符包括小于（\u0026lt;）、大于（\u0026gt;）、小于或等于（\u0026lt;=）、大于或等于（\u0026gt;=）、等于（==）以及不等于（!=）。等于和不等于适用于所有内建的数据类型，但其他比较不适用于 boolean 类型。\n1、检查对象是否相等 关系运算符==和!=也适用于所有对象。 ==和!=比较的就是对象句柄。 若想对比两个对象的实际内容是否相同？此时，必须使用所有对象都适用的特殊方法equals()。 于 equals()的默认行为是比较句柄。 多数Java类库都实现了equals()，所以它实际比较的是对象的内容，而非它们的句柄。 3.1.6 逻辑运算符 逻辑运算符AND（\u0026amp;\u0026amp;）、OR（||）以及NOT（!）能生成一个布尔值（true或false）。\n短路 操作逻辑运算符时，我们会遇到一种名为“短路”的情况。这意味着只有明确得出整个表达式真或假的结论，才会对表达式进行逻辑求值。因此，一个逻辑表达式的所有部分都有可能不进行求值。\n短路就是说，当逻辑运算表达式的结果已经得出，剩余的逻辑表达式将不会得到执行。）\n3.1.7 按位运算符 二进制下用 1 表示真，0 表示假\n按位运算符允许我们操作一个整数主数据类型中的单个“比特”，即二进制位。按位运算符会对两个自变量中对应的位执行布尔代数，并最终生成一个结果。\n若两个输入位都是1，则按位AND运算符（\u0026amp;）在输出位里生成一个1；否则生成0。\n1 \u0026amp; 1 = 1 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 0 \u0026amp; 0 = 0 若两个输入位里至少有一个是1，则按位OR运算符（|）在输出位里生成一个1；只有在两个输入位都是0的情况下，它才会生成一个0。\n1 | 1 = 1 0 | 1 = 1 1 | 0 = 1 0 | 0 = 0 XOR（^，异或）:如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。\n1 ^ 1 = 0 0 ^ 1 = 1 1 ^ 0 = 1 0 ^ 0 = 0 异或的一个用法，交换两个变量的值。\nint a = 1;//01 int b = 2;//10 a=a^b;//a=11 b=b^a;//b=01 a=a^b;//a=10 NOT（~，也叫作“非”运算符）属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。按位NOT生成与输入位的相反的值——若输入0，则输出1；输入1，则输出0。\n~ 1 = 0 ~ 0 = 1 按位运算符和逻辑运算符都使用了同样的字符，只是数量不同。\n按位运算符可与等号（=）联合使用，以便合并运算及赋值\n3.1.8 移位运算符 移位运算符面向的运算对象也是二进制的“位”。可单独用它们处理整数类型（主类型的一种）。\n左移位运算符（\u0026laquo;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。\n“有符号”右移位运算符（\u0026raquo;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。“有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。\n“无符号”右移位运算符（\u0026raquo;\u0026gt;），它使用了“零扩展”：无论正负，都在高位插入0。\n若对 char，byte 或者 short 进行移位处理，那么在移位进行之前，它们会自动转换成一个int。只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。\n移位可与等号（\u0026laquo;=或\u0026raquo;=或\u0026raquo;\u0026gt;=）组合使用。此时，运算符左边的值会移动由右边的值指定的位数，再将得到的结果赋回左边的值。\n3.1.9 三元 if-else 运算符 表达式采取下述形式：\n布尔表达式 ? 值0:值1 若“布尔表达式”的结果为true，就计算“值0”，而且它的结果成为最终由运算符产生的值。但若“布尔表达式”的结果为false，计算的就是“值1”，而且它的结果成为最终由运算符产生的值。\n可将条件运算符用于自己的“副作用”，或用于它生成的值。但通常都应将其用于值，因为那样做可将运算符与if-else明确区别开。\n3.1.10 逗号运算符 在Java里需要用到逗号的唯一场所就是for循环，\n3.1.11 字串运算符+ 运算符在Java里有一项特殊用途：连接不同的字串。 3.1.12 运算符常规操作规则 3.1.13 造型运算符 “造型”（Cast）的作用是“与一个模型匹配”。\nJava允许我们将任何主类型“造型”为其他任何一种主类型，但布尔值（bollean）要除外，后者根本不允许进行任何造型处理。“类”不允许进行造型。为了将一种类转换成另一种，必须采用特殊的方法。\n1、字面值\n十六进制（Base 16）——它适用于所有整数数据类型——用一个前置的0x或0X指示。并在后面跟随采用大写或小写形式的0-9以及a-f。若试图将一个变量初始化成超出自身能力的一个值（无论这个值的数值形式如何）,最大的十六进制值只会在char，byte以及short身上出现。若超出这一限制，编译器会将值自动变成一个int，并告诉我们需要对这一次赋值进行“缩小造型”。这样一来，我们就可清楚获知自己已超载了边界。 八进制（Base 8）是用数字中的一个前置0以及0-7的数位指示的。在C，C++或者Java中，对二进制数字没有相应的“字面”表示方法。 字面值后的尾随字符标志着它的类型。若为大写或小写的L，代表long；大写或小写的F，代表float；大写或小写的D，则代表double。 指数总是采用一种我们认为很不直观的记号方法：1.39e-47f。在科学与工程学领域，“e”代表自然对数的基数，约等于2.718（Java一种更精确的double值采用Math.E的形式）。它在象“1.39×e的-47次方”这样的指数表达式中使用，意味着“1.39×2.718的-47次方”。然而，自FORTRAN语言发明后，人们自然而然地觉得e代表“10多少次幂”。这种做法显得颇为古怪，因为FORTRAN最初面向的是科学与工程设计领域。理所当然，它的设计者应对这样的混淆概念持谨慎态度（注释①）。但不管怎样，这种特别的表达方法在C，C++以及现在的Java中顽固地保留下来了。所以倘若您习惯将e作为自然对数的基数使用，那么在Java中看到象“1.39e-47f”这样的表达式时，请转换您的思维，从程序设计的角度思考它；它真正的含义是“1.39×10的-47次方”。(‘E’这个字母的含义其实很简单，就是‘Exponential’的意思，即‘指数’或‘幂数’，代表计算系统的基数——一般都是10。) 2、转型\n通常，表达式中最大的数据类型是决定了表达式最终结果大小的那个类型。若将一个float值与一个double值相乘，结果就是double；如将一个int和一个long值相加，则结果为long。 3.* Expressions, Statements, and Blocks 表达式，语句和块 运算符可用于构建表达式，这些表达式可计算值。表达式是语句的核心组成部分；语句可以分为多个块。\n一个表达式是变量，运算符和方法调用，它们根据语言的语法构造由一个构建体，计算结果为单个值。\n表达式返回的值的数据类型取决于表达式中使用的元素。\n一条语句构成了完整的执行单元。通过使用分号（;）终止表达式，可以将以下类型的表达式制成语句。\n赋值表达式 任何使用++或\u0026ndash; 方法调用 对象创建表达式 这样的语句称为表达式语句。这是一些表达式语句的例子。 //赋值语句\raValue = 8933.234; //增量语句\raValue ++; //方法调用语句\rSystem.out.println（“ H​​ello World！”）; //对象创建语句\rBicycle myBike = new Bicycle（）; 除表达式语句外，还有两种其他语句：声明语句和控制流语句。一个声明语句声明一个变量。\n代码块 代码块是一组平衡括号之间的零条或多个语句，并且可以在任何地方使用单个语句是允许的。\n3.1.14 Java没有“sizeof” Java不需要sizeof()运算符来满足这方面的需要，因为所有数据类型在所有机器的大小都是相同的。\n3.2 执行控制 Java使用了C的全部控制语句，在Java里，涉及的关键字包括if-else、while、do-while、for以及一个名为switch的选择语句。\n3.2.1 真和假 所有条件语句都利用条件表达式的真或假来决定执行流程。\n3.2.2 if-else if-else语句或许是控制程序流程最基本的形式。其中的else是可选的，可按下述两种形式来使用if：\nif(布尔表达式) 语句 或者： if(布尔表达式) 语句 else 语句 布尔表达式（条件）必须产生一个布尔结果。\n1、return return关键字有两方面的用途：指定一个方法返回什么值（假设它没有void返回值），并立即返回那个值（方法在遇到return后便不再继续）。 3.2.3 反复 while，do-while和for控制着循环，有时将其划分为“反复语句”。\nwhile循环的格式如下：\nwhile(布尔表达式) 语句 在循环刚开始时，会计算一次“布尔表达式”的值。而对于后来每一次额外的循环，都会在开始前重新计算一次。\ndo-while的格式如下：\ndo 语句 while(布尔表达式) while和do-while唯一的区别就是do-while肯定会至少执行一次；也就是说，至少会将其中的语句“过一遍”——即便表达式第一次便计算为false。而在while循环结构中，若条件第一次就为false，那么其中的语句根本不会执行。在实际应用中，while比do-while更常用一些。\nfor循环的格式如下：\nfor(初始表达式; 布尔表达式; 步进) 语句 for循环在第一次反复之前要进行初始化。随后，它会进行条件测试，而且在每一次反复的时候，进行某种形式的“步进”（Stepping）。\n无论初始表达式，布尔表达式，还是步进，都可以置空。每次反复前，都要测试一下布尔表达式。若获得的结果是false，就会继续执行紧跟在for语句后面的那行代码。在每次循环的末尾，会计算一次步进。\n初始表达式：for初始化时 只执行一次 布尔表达式：每一次反复时 当 布尔表达式 结果为 false 时， 整个 for 循环结束。 语句： 步进： 注意变量c是在需要用到它的时候定义的——在for循环的控制表达式内部，而非在由起始花括号标记的代码块的最开头。c的作用域是由for控制的表达式。\n以于象C这样传统的程序化语言，要求所有变量都在一个块的开头定义。所以在编译器创建一个块的时候，它可以为那些变量分配空间。而在Java和C++中，则可在整个块的范围内分散变量声明，在真正需要的地方才加以定义。这样便可形成更自然的编码风格，也更易理解。\n可在for语句里定义多个变量，但它们必须具有同样的类型：\nfor(int i = 0, j = 1; i \u0026lt; 10 \u0026amp;\u0026amp; j != 11; i++, j++) 只有for循环才具备在控制表达式里定义变量的能力。对于其他任何条件或循环语句，都不可采用这种方法。\n1、逗号运算符 Java里唯一用到逗号运算符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，我们可使用一系列由逗号分隔的语句。而且那些语句均会独立执行。 例子： public class CommaOperator { public static void main(String[] args) { for(int i = 1, j = i + 10; i \u0026lt; 5; i++, j = i * 2) { System.out.println(\u0026#34;i= \u0026#34; + i + \u0026#34; j= \u0026#34; + j); } } } 输出如下： i= 1 j= 11 i= 2 j= 4 i= 3 j= 6 i= 4 j= 8 无论在初始化还是在步进部分，语句都是顺序执行的。此外，尽管初始化部分可设置任意数量的定义，但都属于同一类型。\n3.2.6 中断和继续 在任何循环语句的主体部分，亦可用break和continue控制循环的流程。其中，break用于强行退出循环，不执行循环中剩余的语句。而continue则停止执行当前的反复，然后退回循环起始（布尔表达式）和，开始新的反复。\n编译器将 while(true) 与 for(;;)看作同一回事。\n臭名昭著的“goto” goto关键字很早就在程序设计语言中出现。事实上，goto是汇编语言的程序控制结构的始祖：“若条件A，则跳到这里；否则跳到那里”。事实上，goto是在源码的级别跳转的，所以招致了不好的声誉。若程序总是从一个地方跳到另一个地方，还有什么办法能识别代码的流程呢？真正的问题并不在于使用goto，而在于goto的滥用。而且在一些少见的情况下，goto是组织控制流程的最佳手段。\ngoto是Java的一个保留字，并未在语言中得到正式使用，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子。：标签。\n“标签”是后面跟一个冒号的标识符，就象下面这样：\nlabel1: 对Java来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。如下所示：\nlabel1: 外部循环{ 内部循环{ //... break; //1 //... continue; //2 //... continue label1; //3 //... break label1; //4 } } 在条件1中，break中断内部循环，并在外部循环结束。 在条件2中，continue移回内部循环的起始处。 在条件3中，continue label1却同时中断内部循环以及外部循环，并移至label1处。随后，它实际是继续循环，但却从外部循环开始。 在条件4中，break label1也会中断所有循环，并回到label1处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。 (1) 简单的一个continue会退回最内层循环的开头（顶部），并继续执行。 (2) 带有标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。 (3) break会中断当前循环，并移离当前标签的末尾。 (4) 带标签的break会中断当前循环，并移离由那个标签指示的循环的末尾 大家要记住的重点是：在Java里唯一需要用到标签的地方就是拥有嵌套循环，而且想中断或继续多个嵌套级别的时候。\n标签和goto使我们难于对程序作静态分析。这是由于它们在程序的执行流程中引入了许多“怪圈”。但幸运的是，Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：通过限制语句的能力，反而能使一项语言特性更加有用。\n3.2.7 开关 “开关”（Switch）有时也被划分为一种“选择语句”。根据一个整数表达式的值，switch语句可从一系列代码选出一段执行。\n它的格式如下： switch(整数选择因子) { case 整数值1 : 语句; break; case 整数值2 : 语句; break; case 整数值3 : 语句; break; case 整数值4 : 语句; break; case 整数值5 : 语句; break; //.. default:语句; } 其中，“整数选择因子”是一个特殊的表达式，能产生整数值。switch能将整数选择因子的结果与每个整数值比较。若发现相符的，就执行对应的语句（简单或复合语句）。若没有发现相符的，就执行default语句。\n大家会注意到每个case均以一个break结尾。这样可使执行流程跳转至switch主体的末尾。这是构建switch语句的一种传统方式，但break是可选的。若省略break，会继续执行后面的case语句的代码，直到遇到一个break为止。注意最后的default语句没有break，因为执行流程已到了break的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在default语句的末尾放置一个break，尽管它并没有任何实际的用处。\nswitch 语句是实现多路选择的一种易行方式（比如从一系列执行路径中挑选一个）。但它要求使用一个选择因子，并且必须是int或char那样的整数值。（在java中switch后的表达式的类型只能为以下几种：byte、short、char、int（在Java1.6中是这样），在java1.7后支持了对string的判断）\n将一个float或double值造型成整数值后，总是将小数部分“砍掉”，不作任何进位处理。\n3.3 总结 本章总结了大多数程序设计语言都具有的基本特性：计算、运算符优先顺序、类型转换以及选择和循环等等。现在，我们作好了相应的准备，可继续向面向对象的程序设计领域迈进。在下一章里，我们将讨论对象的初始化与清除问题，再后面则讲述隐藏的基本实现方法。\n"},{"id":147,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC4%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/","title":"Thinking in Java 第4章 初始化和清除","parent":"Thinking In Java","content":" 第4章 初始化和清除 “随着计算机的进步，‘不安全’的程序设计已成为造成编程代价高昂的罪魁祸首之一。”\n“初始化”和“清除”是这些安全问题的其中两个。\nC++为我们引入了“构建器”的概念。这是一种特殊的方法，在一个对象创建之后自动调用。Java也沿用了这个概念，但新增了自己的“垃圾收集器”，能在资源不再需要的时候自动释放它们。本章将讨论初始化和清除的问题，以及Java如何提供它们的支持。\n4.1 用构建器自动初始化 对于方法的创建，可将其想象成为自己写的每个类都调用一次initialize()。这个名字提醒我们在使用对象之前，应首先进行这样的调用。但不幸的是，这也意味着用户必须记住调用方法。在Java中，由于提供了名为“构建器”的一种特殊方法，所以类的设计者可担保每个对象都会得到正确的初始化。若某个类有一个构建器，那么在创建对象时，Java会自动调用那个构建器——甚至在用户毫不知觉的情况下。所以说这是可以担保的！（也叫：构造器）\n构建器的名字与类名相同。这样一来，可保证象这样的一个方法会在初始化期间自动调用。\n一旦创建一个对象：\nnew Rock(); 就会分配相应的存储空间，并调用构建器。请注意所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 和其他任何方法一样，构建器也能使用自变量。\n利用构建器的自变量，我们可为一个对象的初始化设定相应的参数。\n构建器属于一种较特殊的方法类型，因为它没有返回值。这与 void 返回值存在着明显的区别。对于void返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。\n4.2 方法过载（overload，也翻译成重载） 我们创建一个对象时，会分配一个名字代表这个类。我们用名字引用或描述所有对象与方法。\n在日常生活中，我们用相同的词表达多种不同的含义——即词的“过载”。\n大多数程序设计语言（特别是C）要求我们为每个函数都设定一个独一无二的标识符。在Java里，允许方法名出现过载情况。\n4.2.1 区分过载方法 规则：每个过载的方法都必须采取独一无二的自变量类型列表。\n4.2.2 主类型的过载 主（数据）类型能从一个“较小”的类型自动转变成一个“较大”的类型。涉及过载问题时，这会稍微造成一些混乱。\n分两种情况： 1、若我们的数据类型“小于”方法中使用的自变量类型，就会对那种数据类型进行“转型”处理。 2、若我们的数据类型.“大于”过载方法期望的自变量类型，就必须用括号中的类型名将其“强转”处理。这是一种缩小转换”。也就是说，在造型或转型过程中可能丢失一些信息。 4.2.3 返回值过载 我们也可能调用一个方法，同时忽略返回值；\n例如： f(); void f() {} int f() {} 所以不能根据返回值类型来区分过载的方法。\n4.2.4 默认构建器 创建一个没有构建器的类，则编译程序会帮我们自动创建一个默认无参的构建器，如果已经定义了一个构建器（无论是否有自变量），编译程序都不会帮我们自动合成一个。\n4.2.5 this关键字 假定我们在一个方法的内部，并希望获得当前对象的句柄。由于那个句柄是由编译器“秘密”传递的，所以没有标识符可用。然而，针对这一目的有个专用的关键字：this。this关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。\n1、在构建器里调用构建器\n若为一个类写了多个构建器，那么经常都需要在一个构建器里调用另一个构建器，以避免写重复的代码。可用this关键字做到这一点。\n例如： public class Test { private int petalCount = 0; private String s = new String(\u0026#34;null\u0026#34;); Test(int petals) { petalCount = petals; System.out.println( \u0026#34;Constructor w/ int arg only, petalCount= \u0026#34; + petalCount); } Test(String ss) { System.out.println( \u0026#34;Constructor w/ String arg only, s=\u0026#34; + ss); s = ss; } Test(String s, int petals) { this(petals); //this(s); // Can\u0026#39;t call two! this.s = s; // Another use of \u0026#34;this\u0026#34; System.out.println(\u0026#34;String \u0026amp; int args\u0026#34;); } Test() { this(\u0026#34;hi\u0026#34;, 47); System.out.println( \u0026#34;default constructor (no args)\u0026#34;); } void print() { //! this(11); // 必须是构造函数主体中的第一个语句 System.out.println( \u0026#34;petalCount = \u0026#34; + petalCount + \u0026#34; s = \u0026#34;+ s); } public static void main(String[] args) { Test x = new Test(); x.print(); } } 注意：尽管可用 this 调用一个构建器，但不可调用两个。除此以外，对“this”代替构造器的调用必须是构造函数主体中的第一个语句，否则会收到编译程序的报错信息。\n编译器不让我们从除了一个构建器之外的其他任何方法内部调用一个构建器。\n这个例子也向大家展示了 this 的另一项用途。由于自变量s的名字以及成员数据s的名字是相同的，所以会出现混淆。为解决这个问题，可用this.s来引用成员数据。\n1、static 的含义\n在没有任何对象的前提下，我们可针对类本身发出对一个static方法的调用。事实上，那正是static方法最基本的意义。它就好象我们创建一个全局函数的等价物（在C语言中）。除了全局函数不允许在Java中使用以外，若将一个static方法置入一个类的内部，它就可以访问其他static方法以及static字段。\n4.3 清除：收尾和垃圾收集 垃圾收集器只知道释放那些由 new 分配的内存,如何释放对象的“特殊”内存。，Java提供了一个名为 finalize()的方法，可为我们的类定义它。在理想情况下，它的工作原理应该是这样的：一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作。\n不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize 的问题]\n垃圾收集并不等于“破坏”！\n我们的对象可能不会当作垃圾被收掉！\n有时可能发现一个对象的存储空间永远都不会释放，因为自己的程序永远都接近于用光空间的临界点。若程序执行结束，而且垃圾收集器一直都没有释放我们创建的任何对象的存储空间，则随着程序的退出，那些资源会返回给操作系统。这是一件好事情，因为垃圾收集本身也要消耗一些开销。如永远都不用它，那么永远也不用支出这部分开销。\n↑↑↑如上所述，JVM可能并不进行 GC，那么 finalize() 也不会被调用！！！\n4.3.1 finalize()用途何在 此时，大家可能已相信了自己应该将 finalize()作为一种常规用途的清除方法使用。它有什么好处呢？ 要记住的第三个重点是：\n垃圾收集只跟内存有关！\n也就是说，垃圾收集器存在的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾收集有关的任何活动来说，其中最值得注意的是finalize()方法，它们也必须同内存以及它的回收有关。\n但这是否意味着假如对象包含了其他对象，finalize()就应该明确释放那些对象呢？答案是否定的——垃圾收集器会负责释放所有对象占据的内存，无论这些对象是如何创建的。它将对 finalize()的需求限制到特殊的情况。在这种情况下，我们的对象可采用与创建对象时不同的方法分配一些存储空间。但大家或许会注意到，Java中的所有东西都是对象，所以这到底是怎么一回事呢？\n之所以要使用 finalize()，看起来似乎是由于有时需要采取与Java的普通方法不同的一种方法，通过分配内存来做一些具有C风格的事情。这主要可以通过“固有方法”来进行，它是从Java里调用非Java方法的一种方式（固有方法的问题在附录A讨论）。C和C++是目前唯一获得固有方法支持的语言。但由于它们能调用通过其他语言编写的子程序，所以能够有效地调用任何东西。在非Java代码内部，也许能调用C的 malloc()系列函数，用它分配存储空间。而且除非调用了free()，否则存储空间不会得到释放，从而造成内存“漏洞”的出现。当然，free()是一个C和C++函数，所以我们需要在finalize()内部的一个固有方法中调用它。\n个人总结一下：就是说在垃圾回收中需要注意的或者说影响垃圾回收行为的代码就是 finalize()，如果一个类有 finalize() ，那么它在第一次被垃圾回收器找上门的时候并不会直接被回收，而是执行 finalize() 中的代码，第二次被垃圾回收器找上门时才会被回收，另需注意的是，只有内存不足才会触发垃圾回收，才会进一步触发 finalize() 在中的代码，可能整个程序运行期间都不会进行垃圾回收，那么在 finalize() 中的代码也不会被执行。\n4.3.2 必须执行清除 为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这听起来似乎很容易做到，但却与C++“破坏器”的概念稍有抵触。在C++中，所有对象都会破坏（清除）。或者换句话说，所有对象都“应该”破坏。若将C++对象创建成一个本地对象，比如在堆栈中创建（在Java中是不可能的），那么清除或破坏工作就会在“结束花括号”所代表的、创建这个对象的作用域的末尾进行。若对象是用new创建的（类似于Java），那么当程序员调用C++的delete命令时（Java没有这个命令），就会调用相应的破坏器。若程序员忘记了，那么永远不会调用破坏器，我们最终得到的将是一个内存“漏洞”，另外还包括对象的其他部分永远不会得到清除。\n相反，Java不允许我们创建本地（局部）对象——无论如何都要使用new。但在Java中，没有“delete”命令来释放对象，因为垃圾收集器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾收集机制，所以Java没有破坏器。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对破坏器的需要，或者说不能消除对破坏器代表的那种机制的需要（而且绝对不能直接调用finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java中的一个方法。它等价于C++的破坏器，只是没后者方便。\nfinalize()最有用处的地方之一是观察垃圾收集的过程。下面这个例子向大家展示了垃圾收集所经历的过程，并对前面的陈述进行了总结。\n//: Garbage.java // Demonstration of the garbage // collector and finalization class Chair { static boolean gcrun = false; static boolean f = false; static int created = 0; static int finalized = 0; int i; Chair() { i = ++created; if(created == 47) System.out.println(\u0026#34;Created 47\u0026#34;); } protected void finalize() { if(!gcrun) { gcrun = true; System.out.println( \u0026#34;Beginning to finalize after \u0026#34; + created + \u0026#34; Chairs have been created\u0026#34;); } if(i == 47) { System.out.println( \u0026#34;Finalizing Chair #47, \u0026#34; + \u0026#34;Setting flag to stop Chair creation\u0026#34;); f = true; } finalized++; if(finalized \u0026gt;= created) System.out.println( \u0026#34;All \u0026#34; + finalized + \u0026#34; finalized\u0026#34;); } } public class Garbage { public static void main(String[] args) { if(args.length == 0) { System.err.println(\u0026#34;Usage: \\n\u0026#34; + \u0026#34;java Garbage before\\n or:\\n\u0026#34; + \u0026#34;java Garbage after\u0026#34;); return; } while(!Chair.f) { new Chair(); new String(\u0026#34;To take up space\u0026#34;); } System.out.println( \u0026#34;After all Chairs have been created:\\n\u0026#34; + \u0026#34;total created = \u0026#34; + Chair.created + \u0026#34;, total finalized = \u0026#34; + Chair.finalized); if(args[0].equals(\u0026#34;before\u0026#34;)) { System.out.println(\u0026#34;gc():\u0026#34;); System.gc(); System.out.println(\u0026#34;runFinalization():\u0026#34;); System.runFinalization(); } System.out.println(\u0026#34;bye!\u0026#34;); if(args[0].equals(\u0026#34;after\u0026#34;)) System.runFinalizersOnExit(true); } } ///:~ 上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。\n另两个 static 变量——created以及 finalized——分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。\n所有这些都在main()的内部进行——在下面这个循环里：\nwhile(!Chair.f) { new Chair(); new String(\u0026#34;To take up space\u0026#34;); } 为强制进行收尾工作，可先调用System.gc()，再调用System.runFinalization()。这样可清除到目前为止没有使用的所有对象。若在这里首先调用runFinalization()，再调用gc()，收尾模块根本不会执行。\n有些Java虚拟机（JVM）可能已开始表现出不同的行为。为展示 GC 过程及 finalize() 作用，另寻以下示例：\n//示例代码--周志明著 Java虚拟机 public class FinalizeEscapeGC { public static FinalizeEscapeGC SAVE_HOOK = null; public String name; public FinalizeEscapeGC(String name) { this.name = name; } public void isAlive() { System.out.println(\u0026#34;yes, i am still alive\u0026#34;); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\u0026#34;finalize method executed!\u0026#34;); System.out.println(this.name); FinalizeEscapeGC.SAVE_HOOK = this; } public static void main(String[] args) throws Throwable { SAVE_HOOK = new FinalizeEscapeGC(\u0026#34;abc\u0026#34;); SAVE_HOOK =null; System.gc(); Thread.sleep(500); if(SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(\u0026#34;no, i am dead\u0026#34;); } SAVE_HOOK =null; System.gc(); Thread.sleep(500); if(SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(\u0026#34;no, i am dead\u0026#34;); } } } // 第21行，第一次垃圾回收，名为abc的FinalizeEscapeGC实例对象的finalize()方法执行，此时全局静态变量 SAVE_HOOK又重新指向了改对象，使得该对象“复活”， // 第29行，再次切断引用链，30行，第二次垃圾回收，该对象的finalize()方法不会再执行了。该对象在堆中的空间被释放。 4.4 成员初始化 一个类的所有基本类型数据成员都会保证获得一个初始值。若被定义成相对于一个方法的“局部”变量，这一保证就通过编译期的出错提示表现出来。\n4.4.1 规定初始化 想自己为变量赋予一个初始值，直接的做法是在类内部定义变量的同时也为其赋值。\n4.4.2 构建器初始化 可考虑用构建器执行初始化进程。这样便可在编程时获得更大的灵活程度。要注意这样一件事情：不可妨碍自动初始化的进行，它在构建器进入之前就会发生。例如：\nclass Counter { int i; Counter() { i = 7; } // . . . 那么i首先会初始化成零，然后变成 7。对于所有基本类型以及对象句柄，这种情况都是成立的，其中包括在定义时已进行了明确初始化的那些一些。\n初始化顺序 在一个类里，初始化的顺序是由变量在类内的定义顺序决定的。即使变量定义大量遍布于方法定义的中间，那些变量仍会在调用任何方法之前得到初始化——甚至在构建器调用之前。例如：\n//: OrderOfInitialization.java // Demonstrates initialization order. // When the constructor is called, to create a // Tag object, you\u0026#39;ll see a message: class Tag { Tag(int marker) { System.out.println(\u0026#34;Tag(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } class Card { Tag t1 = new Tag(1); // Before constructor Card() { // Indicate we\u0026#39;re in the constructor: System.out.println(\u0026#34;Card()\u0026#34;); t3 = new Tag(33); // Re-initialize t3 } Tag t2 = new Tag(2); // After constructor void f() { System.out.println(\u0026#34;f()\u0026#34;); } Tag t3 = new Tag(3); // At end } public class OrderOfInitialization { public static void main(String[] args) { Card t = new Card(); t.f(); // Shows that construction is done } } ///:~ 它的输入结果如下：\nTag(1) Tag(2) Tag(3) Card() Tag(33) f() 静态数据的初始化 若数据是静态的（static），那么同样的事情就会发生；如果它属于一个基本类型（主类型），而且未对其初始化，就会自动获得自己的标准基本类型初始值；如果它是指向一个对象的句柄，那么除非新建一个对象，并将句柄同它连接起来，否则就会得到一个空值（NULL）。\nstatic 值只有一个存储区域。如果它属于一个基本类型（主类型），而且未对其初始化，就会自动获得自己的标准基本类型初始值；如果它是指向一个对象的句柄，那么除非新建一个对象，并将句柄同它连接起来，否则就会得到一个空值（NULL）。\n//: StaticInitialization.java // Specifying initial values in a // class definition. class Bowl { Bowl(int marker) { System.out.println(\u0026#34;Bowl(\u0026#34; + marker + \u0026#34;)\u0026#34;); } void f(int marker) { System.out.println(\u0026#34;f(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } class Table { static Bowl b1 = new Bowl(1); Table() { System.out.println(\u0026#34;Table()\u0026#34;); b2.f(1); } void f2(int marker) { System.out.println(\u0026#34;f2(\u0026#34; + marker + \u0026#34;)\u0026#34;); } static Bowl b2 = new Bowl(2); } class Cupboard { Bowl b3 = new Bowl(3); static Bowl b4 = new Bowl(4); Cupboard() { System.out.println(\u0026#34;Cupboard()\u0026#34;); b4.f(2); } void f3(int marker) { System.out.println(\u0026#34;f3(\u0026#34; + marker + \u0026#34;)\u0026#34;); } static Bowl b5 = new Bowl(5); } public class StaticInitialization { public static void main(String[] args) { System.out.println( \u0026#34;Creating new Cupboard() in main\u0026#34;); new Cupboard(); System.out.println( \u0026#34;Creating new Cupboard() in main\u0026#34;); new Cupboard(); t2.f2(1); t3.f3(1); } static Table t2 = new Table(); static Cupboard t3 = new Cupboard(); } ///:~ Bowl允许我们检查一个类的创建过程，而Table和Cupboard能创建散布于类定义中的Bowl的static成员。注意在static定义之前，Cupboard先创建了一个非static的Bowl b3。它的输出结果如下：\nBowl(1) Bowl(2) Table() f(1) Bowl(4) Bowl(5) Bowl(3) Cupboard() f(2) Creating new Cupboard() in main Bowl(3) Cupboard() f(2) Creating new Cupboard() in main Bowl(3) Cupboard() f(2) f2(1) f3(1) static 初始化只有在必要的时候才会进行。如果不创建一个 Table 对象，而且永远都不引用 Table.b1或 Table.b2，那么 static Bowl b1和 b2永远都不会创建。然而，只有在创建了第一个 Table 对象之后（或者发生了第一次 static 访问），它们才会创建。在那以后，static对象不会重新初始化。 初始化的顺序是首先 static（如果它们尚未由前一次对象创建过程初始化），接着是非 static对象。大家可从输出结果中找到相应的证据。\n总结一下对象的创建过程。请考虑一个名为Dog的类：\n类型为Dog的一个对象首次创建时，或者Dog类的static方法／static字段首次访问时，Java解释器必须找到Dog.class（在事先设好的类路径里搜索）。\n找到Dog.class后（它会创建一个Class对象，这将在后面学到），它的所有static初始化模块都会运行。因此，static初始化仅发生一次——在Class对象首次载入的时候。\n创建一个new Dog()时，Dog对象的构建进程首先会在内存堆（Heap）里为一个Dog对象分配足够多的存储空间。\n这种存储空间会清为零，将Dog中的所有基本类型设为它们的默认值（零用于数字，以及boolean和char的等价设定）。\n进行字段定义时发生的所有初始化都会执行。\n执行构建器。正如第6章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。\n明确进行的静态初始化\nJava允许我们将其他static初始化工作划分到类内一个特殊的“static构建从句”（有时也叫作“静态块”）里。它看起来象下面这个样子：\nclass Spoon { static int i; static { i = 47; } } // . . . 尽管看起来象个方法，但它实际只是一个static关键字，后面跟随一个方法主体。与其他static初始化一样，这段代码仅执行一次——首次生成那个类的一个对象时，或者首次访问属于那个类的一个static成员时（即便从未生成过那个类的对象）。例如：\n//: ExplicitStatic.java // Explicit static initialization // with the \u0026#34;static\u0026#34; clause. class Cup { Cup(int marker) { System.out.println(\u0026#34;Cup(\u0026#34; + marker + \u0026#34;)\u0026#34;); } void f(int marker) { System.out.println(\u0026#34;f(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } class Cups { static Cup c1; static Cup c2; static { c1 = new Cup(1); c2 = new Cup(2); } Cups() { System.out.println(\u0026#34;Cups()\u0026#34;); } } public class ExplicitStatic { public static void main(String[] args) { System.out.println(\u0026#34;Inside main()\u0026#34;); Cups.c1.f(99); // (1) } static Cups x = new Cups(); // (2) static Cups y = new Cups(); // (2) } ///:~ 非静态实例的初始化 针对每个对象的非静态变量的初始化，Java 1.1提供了一种类似的语法格式。下面是一个例子：\n//: Mugs.java // Java 1.1 \u0026#34;Instance Initialization\u0026#34; class Mug { Mug(int marker) { System.out.println(\u0026#34;Mug(\u0026#34; + marker + \u0026#34;)\u0026#34;); } void f(int marker) { System.out.println(\u0026#34;f(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } public class Mugs { Mug c1; Mug c2; { c1 = new Mug(1); c2 = new Mug(2); System.out.println(\u0026#34;c1 \u0026amp; c2 initialized\u0026#34;); } Mugs() { System.out.println(\u0026#34;Mugs()\u0026#34;); } public static void main(String[] args) { System.out.println(\u0026#34;Inside main()\u0026#34;); Mugs x = new Mugs(); } } ///:~ 它看起来与静态初始化从句极其相似，只是static关键字从里面消失了。为支持对“匿名内部类”的初始化（参见第7章），必须采用这一语法格式。\n4.5 数组初始化 数组属于引用数据类型，所以在数组使用之前一定要开辟控件（实例化），如果使用了没有开辟空间的数组，则一定会出现 NullPointerException 异常信息。既然数组属于引用数据类型，那么也一定可以发生引用传递。\n数组先开辟内存空间，而后再使用索引进行内容的设置，实际上这种做法都叫做动态初始化，而如果希望数组在定义的时候可以同时出现设置内容，那么就可以采用静态初始化完成。\n//动态初始化 int data[] = null; data = new int[3]; //开辟一个长度为3的数组 int temp[] = null; //声明对象 data[0] = 10; data[1] = 20; data[2] = 30; //静态初始化 int data[] = {1, 2, 4, 545, 11, 32, 13131, 4444}; int data2[] = new int[] {1, 2, 4, 545, 11, 32, 13131, 4444}; 所有数组都有一个本质成员（无论它们是对象数组还是基本类型数组），可对其进行查询——但不是改变，从而获知数组内包含了多少个元素。这个成员就是length。\n基本数据类型的数组元素会自动初始化成“空”值（对于数值，空值就是零；对于char，它是null；而对于boolean，它却是false）。\n4.6 总结 作为初始化的一种具体操作形式，构建器应使大家明确感受到在语言中进行初始化的重要性。与C++的程序设计一样，判断一个程序效率如何，关键是看是否由于变量的初始化不正确而造成了严重的编程错误（臭虫）。这些形式的错误很难发现，而且类似的问题也适用于不正确的清除或收尾工作。由于构建器使我们能保证正确的初始化和清除（若没有正确的构建器调用，编译器不允许对象创建），所以能获得完全的控制权和安全性。\n在C++中，与“构建”相反的“破坏”（Destruction）工作也是相当重要的，因为用new创建的对象必须明确地清除。在Java中，垃圾收集器会自动为所有对象释放内存，所以Java中等价的清除方法并不是经常都需要用到的。如果不需要类似于构建器的行为，Java的垃圾收集器可以极大简化编程工作，而且在内存的管理过程中增加更大的安全性。有些垃圾收集器甚至能清除其他资源，比如图形和文件句柄等。然而，垃圾收集器确实也增加了运行期的开销。但这种开销到底造成了多大的影响却是很难看出的，因为到目前为止，Java解释器的总体运行速度仍然是比较慢的。随着这一情况的改观，我们应该能判断出垃圾收集器的开销是否使Java不适合做一些特定的工作（其中一个问题是垃圾收集器不可预测的性质）。\n由于所有对象都肯定能获得正确的构建，所以同这儿讲述的情况相比，构建器实际做的事情还要多得多。特别地，当我们通过“创作”或“继承”生成新类的时候，对构建的保证仍然有效，而且需要一些附加的语法来提供对它的支持。大家将在以后的章节里详细了解创作、继承以及它们对构建器造成的影响。\n"},{"id":148,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC5%E7%AB%A0-%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/","title":"Thinking in Java 第5章 隐藏实施过程","parent":"Thinking In Java","content":" 第 5 章 隐藏实施过程 “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。”\n这一点对于库来说是特别重要的。那个库的用户（客户程序员）必须能依赖自己使用的那一部分，并知道一旦新版本的库出台，自己不需要改写代码。而与此相反，库的创建者必须能自由地进行修改与改进，同时保证客户程序员代码不会受到那些变动的影响。\n为达到这个目的，需遵守一定的约定或规则。例如，库程序员在修改库内的一个类时，必须保证不删除已有的方法，因为那样做会造成客户程序员代码出现断点。然而，相反的情况却是令人痛苦的。对于一个数据成员，库的创建者怎样才能知道哪些数据成员已受到客户程序员的访问呢？若方法属于某个类唯一的一部分，而且并不一定由客户程序员直接使用，那么这种痛苦的情况同样是真实的。如果库的创建者想删除一种旧有的实施方案，并置入新代码，此时又该怎么办呢？对那些成员进行的任何改动都可能中断客户程序员的代码。所以库创建者处在一个尴尬的境地，似乎根本动弹不得。\n为解决这个问题，Java推出了“访问指示符”的概念，允许库创建者声明哪些东西是客户程序员可以使用的，哪些是不可使用的。这种访问控制的级别在“最大访问”和“最小访问”的范围之间，分别包括：public，“友好的”（无关键字），protected以及private。根据前一段的描述，大家或许已总结出作为一名库设计者，应将所有东西都尽可能保持为“private”（私有），并只展示出那些想让客户程序员使用的方法。这种思路是完全正确的，尽管它有点儿违背那些用其他语言（特别是C）编程的人的直觉，那些人习惯于在没有任何限制的情况下访问所有东西。到这一章结束时，大家应该可以深刻体会到Java访问控制的价值。\n然而，组件库以及控制谁能访问那个库的组件的概念现在仍不是完整的。仍存在这样一个问题：如何将组件绑定到单独一个统一的库单元里。这是通过Java的package（打包）关键字来实现的，而且访问指示符要受到类在相同的包还是在不同的包里的影响。所以在本章的开头，大家首先要学习库组件如何置入包里。这样才能理解访问指示符的完整含义。\n5.1 包：库单元 我们用import关键字导入一个完整的库时，就会获得“包”（Package）。例如：\nimport java.util.*; 它的作用是导入完整的实用工具（Utility）库，该库属于标准Java开发工具包的一部分。由于Vector位于java.util里，所以现在要么指定完整名称“java.util.Vector”（可省略import语句），要么简单地指定一个“Vector”（因为import是默认的）。\n若想导入单独一个类，可在import语句里指定那个类的名字：\nimport java.util.Vector; 之所以要进行这样的导入，是为了提供一种特殊的机制，以便管理“命名空间”（Name Space）。我们所有类成员的名字相互间都会隔离起来。位于类A内的一个方法f()不会与位于类B内的、拥有相同“签名”（自变量列表）的f()发生冲突。但类名会不会冲突呢？假设创建一个stack类，将它安装到已有一个stack类（由其他人编写）的机器上，这时会出现什么情况呢？对于因特网中的Java应用，这种情况会在用户毫不知晓的时候发生，因为类会在运行一个Java程序的时候自动下载。\n正是由于存在名字潜在的冲突，所以特别有必要对Java中的命名空间进行完整的控制，而且需要创建一个完全独一无二的名字，无论因特网存在什么样的限制\n迄今为止，本书的大多数例子都仅存在于单个文件中，而且设计成局部（本地）使用，没有同包名发生冲突（在这种情况下，类名置于“默认包”内）。这是一种有效的做法，而且考虑到问题的简化，本书剩下的部分也将尽可能地采用它。然而，若计划创建一个“对因特网友好”或者说“适合在因特网使用”的程序，必须考虑如何防止类名的重复。 为Java创建一个源码文件的时候，它通常叫作一个“编辑单元”（有时也叫作“翻译单元”）。每个编译单元都必须有一个以.java结尾的名字。而且在编译单元的内部，可以有一个公共（public）类，它必须拥有与文件相同的名字（包括大小写形式，但排除.java文件扩展名）。如果不这样做，编译器就会报告出错。每个编译单元内都只能有一个public类（同样地，否则编译器会报告出错）。那个编译单元剩下的类（如果有的话）可在那个包外面的世界面前隐藏起来，因为它们并非“公共”的（非public），而且它们由用于主public类的“支撑”类组成。\n编译一个.java文件时，我们会获得一个名字完全相同的输出文件；但对于.java文件中的每个类，它们都有一个.class扩展名。因此，我们最终从少量的.java文件里有可能获得数量众多的.class文件。如以前用一种汇编语言写过程序，那么可能已习惯编译器先分割出一种过渡形式（通常是一个.obj文件），再用一个链接器将其与其他东西封装到一起（生成一个可执行文件），或者与一个库封装到一起（生成一个库）。但那并不是Java的工作方式。一个有效的程序就是一系列.class文件，它们可以封装和压缩到一个JAR文件里（使用Java 1.1提供的jar工具）。Java解释器负责对这些文件的寻找、装载和解释（注释①）。\n①：Java并没有强制一定要使用解释器。一些固有代码的Java编译器可生成单独的可执行文件。\nclass 文件径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。\n当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的“机器语言”。\n与普通程序不同的是，Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。\n在cmd下使用javac 编译某一java文件则会产生.class文件,用java +类名运行。\n“库”也由一系列类文件构成。每个文件都有一个public类（并没强迫使用一个public类，但这种情况最很典型的），所以每个文件都有一个组件。如果想将所有这些组件（它们在各自独立的.java和.class文件里）都归纳到一起，那么package关键字就可以发挥作用）。\n若在一个文件的开头使用下述代码：\npackage mypackage; 那么 package 语句必须作为文件的第一个非注释语句出现。该语句的作用是指出这个编译单元属于名为mypackage的一个库的一部分。或者换句话说，它表明这个编译单元内的public类名位于mypackage这个名字的下面。如果其他人想使用这个名字，要么指出完整的名字，要么与mypackage联合使用import关键字（使用前面给出的选项）。注意根据Java包（封装）的约定，名字内的所有字母都应小写，甚至那些中间单词亦要如此。\n每个 .java 文件中只能有一个 public类\n现在，如果有人想使用 MyClass，或者想使用 mypackage 内的其他任何 public类，他们必须用 import关键字激活 mypackage内的名字，使它们能够使用。另一个办法则是指定完整的名称：\nmypackage.MyClass m = new mypackage.MyClass(); 或者\nimport mypackage.*; // . . . MyClass m = new MyClass(); 一定要记住 package 和 import 关键字允许我们做的事情就是分割单个全局命名空间，保证我们不会遇到名字的冲突——无论有多少人使用因特网，也无论多少人用Java编写自己的类。\n5.1.1 创建独一无二的包名 大家或许已注意到这样一个事实：由于一个包永远不会真的“封装”到单独一个文件里面，它可由多个.class文件构成，所以局面可能稍微有些混乱。为避免这个问题，最合理的一种做法就是将某个特定包使用的所有.class文件都置入单个目录里。也就是说，我们要利用操作系统的分级文件结构避免出现混乱局面。这正是Java所采取的方法。 它同时也解决了另两个问题：创建独一无二的包名以及找出那些可能深藏于目录结构某处的类。正如我们在第2章讲述的那样，为达到这个目的，需要将.class文件的位置路径编码到package的名字里。但根据约定，编译器强迫package名的第一部分是类创建者的因特网域名。由于因特网域名肯定是独一无二的（由InterNIC保证——注释②，它控制着域名的分配），所以假如按这一约定行事，package的名称就肯定不会重复，所以永远不会遇到名称冲突的问题。换句话说，除非将自己的域名转让给其他人，而且对方也按照相同的路径名编写Java代码，否则名字的冲突是永远不会出现的。当然，如果你没有自己的域名，那么必须创造一个非常生僻的包名（例如自己的英文姓名），以便尽最大可能创建一个独一无二的包名。如决定发行自己的Java代码，那么强烈推荐去申请自己的域名，它所需的费用是非常低廉的。\nJava解释器的工作程序如下：首先，它找到环境变量CLASSPATH（将Java或者具有Java解释能力的工具——如浏览器——安装到机器中时，通过操作系统进行设定）。CLASSPATH包含了一个或多个目录，它们作为一种特殊的“根”使用，从这里展开对.class文件的搜索。从那个根开始，解释器会寻找包名，并将每个点号（句点）替换成一个斜杠，从而生成从CLASSPATH根开始的一个路径名（所以package foo.bar.baz会变成foo\\bar\\baz或者foo/bar/baz；具体是正斜杠还是反斜杠由操作系统决定）。随后将它们连接到一起，成为CLASSPATH内的各个条目（入口）。以后搜索.class文件时，就可从这些地方开始查找与准备创建的类名对应的名字。此外，它也会搜索一些标准目录——这些目录与Java解释器驻留的地方有关。\n使用JAR文件时要注意一个问题：必须将JAR文件的名字置于类路径里，而不仅仅是它所在的路径。所以对一个名为grape.jar的JAR文件来说，我们的类路径需要包括：\nCLASSPATH=.;D:\\JAVA\\LIB;C:\\flavors\\grape.jar 自动编译: 为导入的类首次创建一个对象时（或者访问一个类的static成员时），编译器会在适当的目录里寻找同名的.class文件（所以如果创建类X的一个对象，就应该是X.class）。若只发现X.class，它就是必须使用的那一个类。然而，如果它在相同的目录中还发现了一个X.java，编译器就会比较两个文件的日期标记。如果X.java比X.class新，就会自动编译X.java，生成一个最新的X.class。 对于一个特定的类，或在与它同名的.java文件中没有找到它，就会对那个类采取上述的处理。\n5.1.2 自定义工具库 创建自己的工具库，以便减少或者完全消除重复的代码。\nCLASSPATH的陷阱 5.1.3 利用导入改变行为 Java已取消的一种特性是C的“条件编译”，它允许我们改变参数，获得不同的行为，同时不改变其他任何代码。Java之所以抛弃了这一特性，可能是由于该特性经常在C里用于解决跨平台问题：代码的不同部分根据具体的平台进行编译，否则不能在特定的平台上运行。由于Java的设计思想是成为一种自动跨平台的语言，所以这种特性是没有必要的。\n然而，条件编译还有另一些非常有价值的用途。一种很常见的用途就是调试代码。调试特性可在开发过程中使用，但在发行的产品中却无此功能。Alen Holub（www.holub.com）提出了利用包（package）来模仿条件编译的概念。根据这一概念，它创建了C“断定机制”一个非常有用的Java版本。之所以叫作“断定机制”，是由于我们可以说“它应该为真”或者“它应该为假”。如果语句不同意你的断定，就可以发现相关的情况。这种工具在调试过程中是特别有用的。\n通过改变导入的package，我们可将自己的代码从调试版本变成最终的发行版本。这种技术可应用于任何种类的条件代码。\n5.1.4 包的停用 大家应注意这样一个问题：每次创建一个包后，都在为包取名时间接地指定了一个目录结构。这个包必须存在（驻留）于由它的名字规定的目录内。而且这个目录必须能从CLASSPATH开始搜索并发现。最开始的时候，package关键字的运用可能会令人迷惑，因为除非坚持遵守根据目录路径指定包名的规则，否则就会在运行期获得大量莫名其妙的消息，指出找不到一个特定的类——即使那个类明明就在相同的目录中。若得到象这样的一条消息，请试着将package语句作为注释标记出去。如果这样做行得通，就可知道问题到底出在哪儿。\n5.2 Java 访问指示符 private -\u0026gt; default（Friendly） -\u0026gt; protected-\u0026gt; public 类中 -\u0026gt; 包内 -\u0026gt; 子类 -\u0026gt; 公开 修饰符 类内部 同包 子类 任何地方 private Yes default Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 5.2.1 default（Friendly） (4) Provide 提供“accessor／mutator”方法（亦称为“get／set”方法），以便读取和修改值。这是 OOP环境中最正规的一种方法，也是Java Beans的基础——具体情况会在第13章介绍。\n5.2.3 private private 有非常重要的用途，特别是在涉及多线程处理的时候（详情见第14章）。\n//: IceCream.java // Demonstrates \u0026#34;private\u0026#34; keyword class Sundae { private Sundae() {} static Sundae makeASundae() { return new Sundae(); } } public class IceCream { public static void main(String[] args) { //! Sundae x = new Sundae(); Sundae x = Sundae.makeASundae(); } } ///:~ 例子演示了使用private的方便：有时可能想控制对象的创建方式，并防止有人直接访问一个特定的构建器（或者所有构建器）。在上面的例子中，我们不可通过它的构建器创建一个Sundae对象；相反，必须调用makeASundae()方法来实现（注释③）。\n③：此时还会产生另一个影响：由于默认构建器是唯一获得定义的，而且它的属性是private，所以可防止对这个类的继承（这是第6章要重点讲述的主题）。\n5.3 接口与实现 我们通常认为访问控制是“隐藏实施细节”的一种方式。将数据和方法封装到类内后，可生成一种数据类型，它具有自己的特征与行为。但由于两方面重要的原因，访问为那个数据类型加上了自己的边界。第一个原因是规定客户程序员哪些能够使用，哪些不能。我们可在结构里构建自己的内部机制，不用担心客户程序员将其当作接口的一部分，从而自由地使用或者“滥用”。\n这个原因直接导致了第二个原因：我们需要将接口同实施细节分离开。若结构在一系列程序中使用，但用户除了将消息发给public接口之外，不能做其他任何事情，我们就可以改变不属于public的所有东西（如“友好的”、protected以及private），同时不要求用户对他们的代码作任何修改。\n我们现在是在一个面向对象的编程环境中，其中的一个类（class）实际是指“一类对象”，就象我们说“鱼类”或“鸟类”那样。从属于这个类的所有对象都共享这些特征与行为。“类”是对属于这一类的所有对象的外观及行为进行的一种描述。\n在一些早期OOP语言中，如Simula-67，关键字class的作用是描述一种新的数据类型。同样的关键字在大多数面向对象的编程语言里都得到了应用。它其实是整个语言的焦点：需要新建数据类型的场合比那些用于容纳数据和方法的“容器”多得多。\n在一些早期OOP语言中，如Simula-67，关键字class的作用是描述一种新的数据类型。同样的关键字在大多数面向对象的编程语言里都得到了应用。它其实是整个语言的焦点：需要新建数据类型的场合比那些用于容纳数据和方法的“容器”多得多。\n在Java中，类是最基本的OOP概念。它是本书未采用粗体印刷的关键字之一——由于数量太多，所以会造成页面排版的严重混乱。\n由于接口和实施细节仍然混合在一起，所以只是部分容易阅读。也就是说，仍然能够看到源码——实施的细节，因为它们需要保存在类里面。向一个类的消费者显示出接口实际是“类浏览器”的工作。这种工具能查找所有可用的类，总结出可对它们采取的全部操作（比如可以使用哪些成员等），并用一种清爽悦目的形式显示出来。到大家读到这本书的时候，所有优秀的Java开发工具都应推出了自己的浏览器。\n5.4 类访问 在Java中，亦可用访问指示符判断出一个库内的哪些类可由那个库的用户使用。\n我们注意到一些额外的限制： 每个编译单元（文件）都只能有一个public类。每个编译单元有一个公共接口的概念是由那个公共类表达出来的。根据自己的需要，它可拥有任意多个提供支撑的“友好”类。但若在一个编译单元里使用了多个public类，编译器就会向我们提示一条出错消息。 public类的名字必须与包含了编译单元的那个文件的名字完全相符，甚至包括它的大小写形式。 可能（但并常见）有一个编译单元根本没有任何公共类。此时，可按自己的意愿任意指定文件名。(内部使用，不希望有客户程序员依赖。) 若不愿其他任何人访问那个类，可将所有构建器设为private。这样一来，在类的一个static成员内部，除自己之外的其他所有人都无法创建属于那个类的一个对象（注释⑤）。 若不愿其他任何人访问那个类，可将所有构建器设为private。这样一来，在类的一个static成员内部，除自己之外的其他所有人都无法创建属于那个类的一个对象（注释⑤）。 5.5 总结 对于任何关系，最重要的一点都是规定好所有方面都必须遵守的界限或规则。\n有两方面的原因要求我们控制对成员的访问。第一个是防止用户接触那些他们不应碰的工具。对于数据类型的内部机制，那些工具是必需的。但它们并不属于用户接口的一部分，用户不必用它来解决自己的特定问题。所以将方法和字段变成“私有”（private）后，可极大方便用户。因为他们能轻易看出哪些对于自己来说是最重要的，以及哪些是自己需要忽略的。这样便简化了用户对一个类的理解。\n进行访问控制的第二个、也是最重要的一个原因是：允许库设计者改变类的内部工作机制，同时不必担心它会对客户程序员产生什么影响。\n一个类的公共接口是所有用户都能看见的，所以在进行分析与设计的时候，这是应尽量保证其准确性的最重要的一个部分。但也不必过于紧张，少许的误差仍然是允许的。若最初设计的接口存在少许问题，可考虑添加更多的方法，只要保证不删除客户程序员已在他们的代码里使用的东西。\n"},{"id":149,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E5%86%8D%E7%94%9F/","title":"Thinking in Java 第6章 类再生","parent":"Thinking In Java","content":" 第 6 章 类再生 代码的重复使用\n第一个最简单：在新类里简单地创建原有类的对象。我们把这种方法叫作“合成”，因为新类由现有类的对象合并而成。我们只是简单地重复利用代码的功能，而不是采用它的形式。 第二种方法则显得稍微有些技巧。它创建一个新类，将其作为现有类的一个“类型”。我们可以原样采取现有类的形式，并在其中加入新代码，同时不会对现有的类产生影响。这种魔术般的行为叫作“继承”（Inheritance），涉及的大多数工作都是由编译器完成的。对于面向对象的程序设计，“继承”是最重要的基础概念之一。 6.1 合成的语法 为进行合成，我们只需在新类里简单地置入对象句柄即可。对于非基本类型的对象来说，只需将句柄置于新类即可；而对于基本数据类型来说，则需在自己的类中定义它们。\n每种非基本类型的对象都有一个toString()方法。若编译器本来希望一个String，但却获得某个这样的对象，就会调用这个方法（意思是说，把对象当 String 用的时候就会调用这个方法）。\n在类内作为字段使用的基本数据会初始化成零，就象第2章指出的那样。但对象句柄会初始化成null。而且假若试图为它们中的任何一个调用方法，就会产生一次“违例”。这种结果实际是相当好的（而且很有用），我们可在不丢弃一次违例的前提下，仍然把它们打印出来。\n编译器并不只是为每个句柄创建一个默认对象，因为那样会在许多情况下招致不必要的开销。如希望句柄得到初始化，可在下面这些地方进行： 在对象定义的时候。这意味着它们在构建器调用之前肯定能得到初始化。 在那个类的构建器中。 紧靠在要求实际使用那个对象之前。这样做可减少不必要的开销——假如对象并不需要创建的话。 下面向大家展示了所有这三种方法： //: Bath.java // Constructor initialization with composition class Soap { private String s; Soap() { System.out.println(\u0026#34;Soap()\u0026#34;); s = new String(\u0026#34;Constructed\u0026#34;); } public String toString() { return s; } } public class Bath { private String // Initializing at point of definition: s1 = new String(\u0026#34;Happy\u0026#34;), s2 = \u0026#34;Happy\u0026#34;, s3, s4; Soap castille; int i; float toy; Bath() { System.out.println(\u0026#34;Inside Bath()\u0026#34;); s3 = new String(\u0026#34;Joy\u0026#34;); i = 47; toy = 3.14f; castille = new Soap(); } void print() { // Delayed initialization: if(s4 == null) s4 = new String(\u0026#34;Joy\u0026#34;); System.out.println(\u0026#34;s1 = \u0026#34; + s1); System.out.println(\u0026#34;s2 = \u0026#34; + s2); System.out.println(\u0026#34;s3 = \u0026#34; + s3); System.out.println(\u0026#34;s4 = \u0026#34; + s4); System.out.println(\u0026#34;i = \u0026#34; + i); System.out.println(\u0026#34;toy = \u0026#34; + toy); System.out.println(\u0026#34;castille = \u0026#34; + castille); } public static void main(String[] args) { Bath b = new Bath(); b.print(); } } ///:~ 6.2 继承的语法 继承与Java（以及其他OOP语言）非常紧密地结合在一起。创建一个类时肯定会进行继承，因为若非如此，会从Java的标准根类Object中继承。\n需要继承的时候，需要给出类名,在类主体的起始花括号之前，放置一个关键字 extends，在后面跟随“基础类”的名字。就可自动获得基础类的所有数据成员以及方法。\n我们可为自己的每个类都创建一个main()。对于在命令行请求的public类，只有main()才会得到调用。所以在这种情况下，当我们使用“java Detergent”的时候，调用的是Degergent.main()。采用这种将main()置入每个类的做法，可方便地为每个类都进行单元测试。\n倘若省略所有访问指示符，则成员默认为“友好的”。这样一来，就只允许对包成员进行访问。在这个包内，任何人都可使用那些没有访问指示符的方法。然而，假设来自另外某个包的类准备继承Cleanser，它就只能访问那些public成员。\n可以用 super 关键字，它引用当前类已从中继承的一个“超类”（Superclass）的方法。\n6.2.1 初始化基础类 由于这儿涉及到两个类——基础类及衍生类，而不再是以前的一个，所以在想象衍生类的结果对象时，可能会产生一些迷惑。从外部看，似乎新类拥有与基础类相同的接口，而且可包含一些额外的方法和字段。但继承并非仅仅简单地复制基础类的接口了事。创建衍生类的一个对象时，它在其中包含了基础类的一个“子对象”。这个子对象就象我们根据基础类本身创建了它的一个对象。从外部看，基础类的子对象已封装到衍生类的对象里了。\n当然，基础类子对象应该正确地初始化，而且只有一种方法能保证这一点：在构建器中执行初始化，通过调用基础类构建器，后者有足够的能力和权限来执行对基础类的初始化。在衍生类的构建器中，Java会自动插入对基础类构建器的调用。下面这个例子向大家展示了对这种三级继承的应用：\n//: Cartoon.java // Constructor calls during inheritance class Art { Art() { System.out.println(\u0026#34;Art constructor\u0026#34;); } } class Drawing extends Art { Drawing() { System.out.println(\u0026#34;Drawing constructor\u0026#34;); } } public class Cartoon extends Drawing { Cartoon() { System.out.println(\u0026#34;Cartoon constructor\u0026#34;); } public static void main(String[] args) { Cartoon x = new Cartoon(); } } ///:~ 该程序的输出显示了自动调用：\nArt constructor Drawing constructor Cartoon constructor 可以看出，构建是在基础类的“外部”进行的，所以基础类会在衍生类访问它之前得到正确的初始化。 即使没有为Cartoon()创建一个构建器，编译器也会为我们自动合成一个默认构建器，并发出对基础类构建器的调用。\n在衍生类构建器中，对基础类构建器的调用是必须做的第一件事情,衍生类构建器会默认调用基础类无参构造器，若基础类无默认无参构造器，编译器会报错，如果类没有默认的无参构造器，或者想调用含有一个自变量的某个基础类构建器，必须明确地编写对基础类的调用代码。用super关键字以及适当的自变量列表实现。\n6.2 合成与继承的结合 编译器会强迫我们对基础类进行初始化，并要求我们在构建器最开头做这一工作，但它并不会监视我们是否正确初始化了成员对象。所以对此必须特别加以留意。\n6.3.1 确保正确的清除 代码置于一个finally从句中，从而防范任何可能出现的违例事件。\ntry关键字指出后面跟随的块（由花括号定界）是一个“警戒区”。也就是说，它会受到特别的待遇。其中一种待遇就是：该警戒区后面跟随的finally从句的代码肯定会得以执行——不管try块到底存不存在（通过违例控制技术，try块可有多种不寻常的应用）。在这里，finally从句的意思是“总是为x调用cleanup()，无论会发生什么事情”。\n垃圾收集的顺序 不能指望自己能确切知道何时会开始垃圾收集。垃圾收集器可能永远不会得到调用。即使得到调用，它也可能以自己愿意的任何顺序回收对象。除此以外，Java 1.0实现的垃圾收集器机制通常不会调用finalize()方法。除内存的回收以外，其他任何东西都最好不要依赖垃圾收集器进行回收。若想明确地清除什么，请制作自己的清除方法，而且不要依赖finalize()。然而正如以前指出的那样，可强迫Java1.1调用所有收尾模块（Finalizer）。\n6.4 到底选择合成还是继承 如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”关系是用继承来表达的，而“包含”关系是用合成来表达的。 6.5 protected 现在我们已理解了继承的概念，protected这个关键字最后终于有了意义。在理想情况下，private成员随时都是“私有”的，任何人不得访问。但在实际应用中，经常想把某些东西深深地藏起来，但同时允许访问衍生类的成员。protected关键字可帮助我们做到这一点。它的意思是“它本身是私有的，但可由从这个类继承的任何东西或者同一个包内的其他任何东西访问”。也就是说，Java中的protected会成为进入“友好”状态。\n我们采取的最好的做法是保持成员的private状态——无论如何都应保留对基 础的实施细节进行修改的权利。在这一前提下，可通过protected方法允许类的继承者进行受到控制的访问：\n//: Orc.java // The protected keyword import java.util.*; class Villain { private int i; protected int read() { return i; } protected void set(int ii) { i = ii; } public Villain(int ii) { i = ii; } public int value(int m) { return m*i; } } public class Orc extends Villain { private int j; public Orc(int jj) { super(jj); j = jj; } public void change(int x) { set(x); } //可以看到，change()拥有对set()的访问权限，因为它的属性是protected（受到保护的） } ///:~ 6.6 累积开发 继承的一个好处是它支持“累积开发”，允许我们引入新的代码，同时不会为现有代码造成错误。这样可将新错误隔离到新代码里。通过从一个现成的、功能性的类继承，同时增添成员新的数据成员及方法（并重新定义现有方法），我们可保持现有代码原封不动（另外有人也许仍在使用它），不会为其引入自己的编程错误。一旦出现错误，就知道它肯定是由于自己的新代码造成的。这样一来，与修改现有代码的主体相比，改正错误所需的时间和精力就可以少很多。\n类的隔离效果非常好，这是许多程序员事先没有预料到的。甚至不需要方法的源代码来实现代码的再生。最多只需要导入一个包（这对于继承和合并都是成立的）。 ``` 大家要记住这样一个重点：程序开发是一个不断递增或者累积的过程，就象人们学习知识一样。当然可根据要求进行尽可能多的分析，但在一个项目的设计之初，谁都不可能提前获知所有的答案。如果能将自己的项目看作一个有机的、能不断进步的生物，从而不断地发展和改进它，就有望获得更大的成功以及更直接的反馈。\n尽管继承是一种非常有用的技术，但在某些情况下，特别是在项目稳定下来以后，仍然需要从新的角度考察自己的类结构，将其收缩成一个更灵活的结构。请记住，继承是对一种特殊关系的表达，意味着“这个新类属于那个旧类的一种类型”。我们的程序不应纠缠于一些细树末节，而应着眼于创建和操作各种类型的对象，用它们表达出来自“问题空间”的一个模型。\n6.7 上溯造型 继承最值得注意的地方就是它没有为新类提供方法。继承是对新类和基础类之间的关系的一种表达。可这样总结该关系：“新类属于现有类的一种类型”。\n这种表达并不仅仅是对继承的一种形象化解释，继承是直接由语言提供支持的。作为一个例子，大家可考虑一个名为Instrument的基础类，它用于表示乐器；另一个衍生类叫作Wind。由于继承意味着基础类的所有方法亦可在衍生出来的类中使用，所以我们发给基础类的任何消息亦可发给衍生类。若Instrument类有一个play()方法，则Wind设备也会有这个方法。这意味着我们能肯定地认为一个Wind对象也是Instrument的一种类型。下面这个例子揭示出编译器如何提供对这一概念的支持：\n//: Wind.java // Inheritance \u0026amp; upcasting import java.util.*; class Instrument { public void play() {} static void tune(Instrument i) { // ... i.play(); } } // Wind objects are instruments // because they have the same interface: class Wind extends Instrument { public static void main(String[] args) { Wind flute = new Wind(); Instrument.tune(flute); // Upcasting } } ///:~ 这个例子中最有趣的无疑是tune()方法，它能接受一个Instrument句柄。但在Wind.main()中，tune()方法是通过为其赋予一个Wind句柄来调用的。由于Java对类型检查特别严格，所以大家可能会感到很奇怪，为什么接收一种类型的方法也能接收另一种类型呢？但是，我们一定要认识到一个Wind对象也是一个Instrument对象。而且对于不在Wind中的一个Instrument（乐器），没有方法可以由tune()调用。在tune()中，代码适用于Instrument以及从Instrument衍生出来的任何东西。在这里，我们将从一个Wind句柄转换成一个Instrument句柄的行为叫作“上溯造型”。\n总结：\n我们将从一个 衍生类 句柄转换成一个 基础类 句柄的行为叫作“上溯造型” 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。 6.7.1 何谓“上溯造型”？ 之所以叫作这个名字，除了有一定的历史原因外，也是由于在传统意义上，类继承图的画法是根位于最顶部，再逐渐向下扩展（当然，可根据自己的习惯用任何方法描绘这种图）。因素，Wind.java的继承图就象下面这个样子： 由于造型的方向是从衍生类到基础类，箭头朝上，所以通常把它叫作“上溯造型”，即Upcasting。上溯造型肯定是安全的，因为我们是从一个更特殊的类型到一个更常规的类型。换言之，衍生类是基础类的一个超集。它可以包含比基础类更多的方法，但它至少包含了基础类的方法。进行上溯造型的时候，类接口可能出现的唯一一个问题是它可能丢失方法，而不是赢得这些方法。这便是在没有任何明确的造型或者其他特殊标注的情况下，编译器为什么允许上溯造型的原因所在。\n也可以执行下溯造型，但这时会面临第11章要详细讲述的一种困境。\n再论合成与继承 在面向对象的程序设计中，创建和使用代码最可能采取的一种做法是：将数据和方法统一封装到一个类里，并且使用那个类的对象。有些时候，需通过“合成”技术用现成的类来构造新类。而继承是最少见的一种做法。因此，尽管继承在学习OOP的过程中得到了大量的强调，但并不意味着应该尽可能地到处使用它。相反，使用它时要特别慎重。只有在清楚知道继承在所有方法中最有效的前提下，才可考虑它。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。在下一章里（多形性），会向大家介绍必须进行上溯造型的一种场合。但只要记住经常问自己“我真的需要上溯造型吗”，对于合成还是继承的选择就不应该是个太大的问题。\n6.8 final关键字 由于语境（应用环境）不同，final关键字的含义可能会稍微产生一些差异。但它最一般的意思就是声明“这个东西不能改变”。之所以要禁止改变，可能是考虑到两方面的因素：设计或效率。由于这两个原因颇有些区别，所以也许会造成final关键字的误用。\nfinal关键字的三种应用场合：数据、方法以及类。\n6.8.1 final数据 许多程序设计语言都有自己的办法告诉编译器某个数据是“常数”。常数主要应用于下述两个方面：\n(1) 编译期常数，它永远不会改变\n(2) 在运行期初始化的一个值，我们不希望它发生变化\n对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型（Primitives），而且要用final关键字进行表达。在对这样的一个常数进行定义的时候，必须给出一个值。\n无论static还是final字段，都只能存储一个数据，而且不得改变。\nStatic强调它们只有一个；而final表明它是一个常数。（属于类，而不是属于对象）\n不能由于某样东西的属性是final，就认定它的值能在编译时期知道。\n注意对于含有固定初始化值（即编译期常数）的 fianl static基本数据类型，它们的名字根据规则要全部采用大写。\n若随同对象句柄使用final，而不是基本数据类型，它的含义就稍微让人有点儿迷糊了。对于基本数据类型，final会将值变成一个常数；但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。Java对此未提供任何手段，可将一个对象直接变成一个常数（但是，我们可自己编写一个类，使其中的对象具有“常数”效果）。这一限制也适用于数组，它也属于对象。\n总结：\nfinal 对象类型属性的时候必须手动初始化，（初始化可以是在属性上直接初始化，也可以是在构造方法中初始化，无论哪种，必须保证其被初始化。） final 会将句柄变成一个常数，而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。 //: FinalData.java // The effect of final on fields class Value { int i = 1; } public class FinalData { // Can be compile-time constants final int i1 = 9; static final int I2 = 99; // Typical public constant: public static final int I3 = 39; // Cannot be compile-time constants: final int i4 = (int)(Math.random()*20); static final int i5 = (int)(Math.random()*20); Value v1 = new Value(); final Value v2 = new Value(); static final Value v3 = new Value(); //! final Value v4; // Pre-Java 1.1 Error: // no initializer // Arrays: final int[] a = { 1, 2, 3, 4, 5, 6 }; public void print(String id) { System.out.println( id + \u0026#34;: \u0026#34; + \u0026#34;i4 = \u0026#34; + i4 + \u0026#34;, i5 = \u0026#34; + i5); } public static void main(String[] args) { FinalData fd1 = new FinalData(); //! fd1.i1++; // Error: can\u0026#39;t change value fd1.v2.i++; // Object isn\u0026#39;t constant! fd1.v1 = new Value(); // OK -- not final for(int i = 0; i \u0026lt; fd1.a.length; i++) fd1.a[i]++; // Object isn\u0026#39;t constant! //! fd1.v2 = new Value(); // Error: Can\u0026#39;t //! fd1.v3 = new Value(); // change handle //! fd1.a = new int[3]; fd1.print(\u0026#34;fd1\u0026#34;); System.out.println(\u0026#34;Creating new FinalData\u0026#34;); FinalData fd2 = new FinalData(); fd1.print(\u0026#34;fd1\u0026#34;); fd2.print(\u0026#34;fd2\u0026#34;); } } ///:~ fd1: i4 = 15, i5 = 9 Creating new FinalData fd1: i4 = 15, i5 = 9 fd2: i4 = 10, i5 = 9 注意对于fd1和fd2来说，i4的值是唯一的(这里面的唯一大概是各自独立的意思)，但i5的值不会由于创建了另一个FinalData对象而发生改变。那是因为它的属性是static，而且在载入时初始化，而非每创建一个对象时初始化。\n从v1到v4的变量向我们揭示出final句柄的含义。正如大家在main()中看到的那样，并不能认为由于v2属于final，所以就不能再改变它的值。然而，我们确实不能再将v2绑定到一个新对象，因为它的属性是final。这便是final对于一个句柄的确切含义。我们会发现同样的含义亦适用于数组，后者只不过是另一种类型的句柄而已。将句柄变成final看起来似乎不如将基本数据类型变成final那么有用。\n空白 final Java 1.1允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。然而，对于final关键字的各种应用，空白final具有最大的灵活性。\n我们对final进行赋值处理——要么在定义字段时使用一个表达 式，要么在每个构建器中。这样就可以确保final字段在使用前获得正确的初始化。\nfinal 自变量 Java 1.1允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。\n6.8.2 final方法 之所以要使用final方法，可能是出于对两方面理由的考虑。第一个是为方法“上锁”，防止任何继承类改变它的本来含义。设计程序时，若希望一个方法的行为在继承期间保持不变，而且不可被覆盖或改写，就可以采取这种做法。 采用final方法的第二个理由是程序执行的效率。将一个方法设成final后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。只要编译器发现一个final方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。这样做可避免方法调用时的系统开销。当然，若方法体积太大，那么程序也会变得雍肿，可能受到到不到嵌入代码所带来的任何性能提升。因为任何提升都被花在方法内部的时间抵消了。Java编译器能自动侦测这些情况，并颇为“明智”地决定是否嵌入一个final方法。然而，最好还是不要完全相信编译器能正确地作出所有判断。通常，只有在方法的代码量非常少，或者想明确禁止方法被覆盖的时候，才应考虑将一个方法设为final。\n类内所有 private方法都自动成为final。由于我们不能访问一个private方法，所以它绝对不会被其他方法覆盖（若强行这样做，编译器会给出错误提示）。可为一个private方法添加final指示符，但却不能为那个方法提供任何额外的含义。\n/* 1、final方法防止覆写：防止任何继承类改变它的本来含义，方法的行为在继承期间保持不变，而且不可被覆盖或改写。 2、final方法 提高执行的效率。 3、类内所有 private方法都自动成为final。 */ 6.8.3 final 类 类是final（在它的定义前冠以final关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。\n将类定义成final后，结果只是禁止进行继承——没有更多的限制。然而，由于它禁止了继承，所以一个final类中的所有方法都默认为final。因为此时再也无法覆盖它们。所以与我们将一个方法明确声明为final一样，编译器此时有相同的效率选择。\nfinal类内的一个方法添加final指示符，但这样做没有任何意义。\n6.8.4 final 的注意事项 设计一个类时，往往需要考虑是否将一个方法设为final。可能会觉得使用自己的类时执行效率非常重要，没有人想覆盖自己的方法。这种想法在某些时候是正确的。\n但要慎重作出自己的假定。通常，我们很难预测一个类以后会以什么样的形式再生或重复利用。常规用途的类尤其如此。若将一个方法定义成final，就可能杜绝了在其他程序员的项目中对自己的类进行继承的途径，因为我们根本没有想到它会象那样使用。\n标准Java库是阐述这一观点的最好例子。其中特别常用的一个类是 Vector。如果我们考虑代码的执行效率，就会发现只有不把任何方法设为final，才能使其发挥更大的作用。我们很容易就会想到自己应继承和覆盖如此有用的一个类，但它的设计者却否定了我们的想法。但我们至少可以用两个理由来反驳他们。首先，Stack（堆栈）是从Vector继承来的，亦即Stack“是”一个Vector，这种说法是不确切的。其次，对于Vector许多重要的方法，如addElement()以及elementAt()等，它们都变成了synchronized（同步的）。正如在第14章要讲到的那样，这会造成显著的性能开销，可能会把final提供的性能改善抵销得一干二净。因此，程序员不得不猜测到底应该在哪里进行优化。在标准库里居然采用了如此笨拙的设计，真不敢想象会在程序员里引发什么样的情绪。\n另一个值得注意的是Hashtable（散列表），它是另一个重要的标准类。该类没有采用任何final方法。正如我们在本书其他地方提到的那样，显然一些类的设计人员与其他设计人员有着全然不同的素质（注意比较Hashtable极短的方法名与Vecor的方法名）。对类库的用户来说，这显然是不应该如此轻易就能看出的。一个产品的设计变得不一致后，会加大用户的工作量。这也从另一个侧面强调了代码设计与检查时需要很强的责任心。\n6.8 初始化和类装载 在许多传统语言里，程序都是作为启动过程的一部分一次性载入的。随后进行的是初始化，再是正式执行程序。在这些语言中，必须对初始化过程进行慎重的控制，保证static数据的初始化不会带来麻烦。比如在一个static数据获得初始化之前，就有另一个static数据希望它是一个有效值，那么在C++中就会造成问题。\nJava则没有这样的问题，因为它采用了不同的装载方法。由于Java中的一切东西都是对象，所以许多活动变得更加简单，这个问题便是其中的一例。正如下一章会讲到的那样，每个对象的代码都存在于独立的文件中。除非真的需要代码，否则那个文件是不会载入的。通常，我们可认为除非那个类的一个对象构造完毕，否则代码不会真的载入。由于static方法存在一些细微的歧义，所以也能认为“类代码在首次使用的时候载入”。\n首次使用的地方也是static初始化发生的地方。装载的时候，所有static对象和static代码块都会按照本来的顺序初始化（亦即它们在类定义代码里写入的顺序）。当然，static数据只会初始化一次。\n6.9.1 继承初始化 我们有必要对整个初始化过程有所认识，其中包括继承，对这个过程中发生的事情有一个整体性的概念。请观察下述代码：\n//: Beetle.java // The full process of initialization. class Insect { int i = 9; int j; Insect() { prt(\u0026#34;i = \u0026#34; + i + \u0026#34;, j = \u0026#34; + j); j = 39; } static int x1 = prt(\u0026#34;static Insect.x1 initialized\u0026#34;); static int prt(String s) { System.out.println(s); return 47; } } public class Beetle extends Insect { int k = prt(\u0026#34;Beetle.k initialized\u0026#34;); Beetle() { prt(\u0026#34;k = \u0026#34; + k); prt(\u0026#34;j = \u0026#34; + j); } static int x2 = prt(\u0026#34;static Beetle.x2 initialized\u0026#34;); static int prt(String s) { System.out.println(s); return 63; } public static void main(String[] args) { prt(\u0026#34;Beetle constructor\u0026#34;); Beetle b = new Beetle(); } } ///:~ 该程序的输出如下：\nstatic Insect.x1 initialized static Beetle.x2 initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 63 j = 39 1、对Beetle运行Java时，发生的第一件事情是装载程序到外面找到那个类。在装载过程中，装载程序注意它有一个基础类（即extends关键字要表达的意思），所以随之将其载入。无论是否准备生成那个基础类的一个对象，这个过程都会发生（可试着将对象的创建代码当作注释标注出来，自己去证实）。\n2、若基础类含有另一个基础类，则另一个基础类随即也会载入，以此类推。接下来，会在根基础类（此时是Insect）执行static初始化，再在下一个衍生类执行，以此类推。保证这个顺序是非常关键的，因为衍生类的初始化可能要依赖于对基础类成员的正确初始化。\n3、此时，必要的类已全部装载完毕，所以能够创建对象。首先，这个对象中的所有基本数据类型都会设成它们的默认值，而将对象句柄设为null。随后会调用基础类构建器。在这种情况下，调用是自动进行的。但也完全可以用super来自行指定构建器调用（就象在Beetle()构建器中的第一个操作一样）。基础类的构建采用与衍生类构建器完全相同的处理过程。基础顺构建器完成以后，实例变量会按本来的顺序得以初始化。最后，执行构建器剩余的主体部分。\n总结：初始化和类装载\n先基础后衍生 先类加载，然后立即执行static初始化 实例属性，然后构建对象 6.10 总结 先考虑采用合成技术。只有在特别必要的时候，才应考虑采用继承技术。合成显得更加灵活。\n总结：论合成与继承\n如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”或者“类似”关系是用继承来表达的，而“包含”关系是用合成来表达的。 继承 用来表达同一个系列不同种对象的行为间的差异。 句柄在运行期间可以重新与一个不同的对象绑定或结合起来,这样一来，我们在运行期间 通过改变句柄绑定的子类类型 就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。 "},{"id":150,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC7%E7%AB%A0-%E5%A4%9A%E5%BD%A2%E6%80%A7/","title":"Thinking in Java 第7章 多形性","parent":"Thinking In Java","content":" 第7章 多形性 “对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。”\n“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。\n通过合并各种特征与行为，封装技术可创建出新的数据类型。通过对具体实施细节的隐藏，可将接口与实施细节分离，使所有细节成为“private”（私有）。这种组织方式使那些有程序化编程背景人感觉颇为舒适。但多形性却涉及对“类型”的分解。通过上一章的学习，大家已知道通过继承可将一个对象当作它自己的类型或者它自己的基础类型对待。这种能力是十分重要的，因为多个类型（从相同的基础类型中衍生出来）可被当作同一种类型对待。而且只需一段代码，即可对所有不同的类型进行同样的处理。利用具有多形性的方法调用，一种类型可将自己与另一种相似的类型区分开，只要它们都是从相同的基础类型中衍生出来的。这种区分是通过各种方法在行为上的差异实现的，可通过基础类实现对那些方法的调用。\n在这一章中，大家要由浅入深地学习有关多形性的问题（也叫作动态绑定、推迟绑定或者运行期绑定）。同时举一些简单的例子，其中所有无关的部分都已剥除，只保留与多形性有关的代码。\n7.1 上溯造型 在第 6 章，大家已知道可将一个对象作为它自己的类型使用，或者作为它的基础类型的一个对象使用。取得一个对象句柄，并将其作为基础类型句柄使用的行为就叫作“上溯造型”——因为继承树的画法是基础类位于最上方。\n7.1.1 为什么要上溯造型 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。这样就不比为每种衍生类都制作对应的方法，节省大量工作。\n这正是“多形性”大显身手的地方。\n7.2 深入理解 此处有个问题：基于上溯造型，用基础类做方法 自变量时，真正调用方法时传入的自变量类型为基础类的衍生类时。它接收 基础类 句柄。所以在这种情况下，编译器怎样才能知道 基础类 句柄指向的是一个真正的 衍生类，而不是一个其他衍生类呢？编译器无从得知。为了深入了理解这个问题，我们有必要探讨一下“绑定”这个主题。\n7.2.1 方法调用的绑定 将一个方法调用 同一个方法主体 连接到一起就称为“绑定”（Binding）。若在程序运行以前执行绑定（由编译器和链接程序，如果有的话），就叫作“早期绑定”。大家以前或许从未听说过这个术语，因为它在任何程序化语言里都是不可能的。C编译器只有一种方法调用，那就是“早期绑定”。\n上述程序最令人迷惑不解的地方全与早期绑定有关，因为在只有一个 基础类 句柄的前提下，编译器不知道具体该调用哪个方法。\n解决的方法就是“后期绑定”，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。\nJava中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。\n为什么要把一个方法声明成final呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final方法调用生成效率更高的代码。\n7.2.2 产生正确的行为 知道Java里绑定的所有方法都通过后期绑定具有多形性以后，就可以相应地编写自己的代码，令其与基础类沟通。此时，所有的衍生类都保证能用相同的代码正常地工作。或者换用另一种方法，我们可以“将一条消息发给一个对象，让对象自行判断要做什么事情。”\n在面向对象的程序设计中，有一个经典的“形状”例子。由于它很容易用可视化的形式表现出来，所以经常都用它说明问题。但很不幸的是，它可能误导初学者认为OOP只是为图形化编程设计的，这种认识当然是错误的。\n形状例子有一个基础类，名为Shape；另外还有大量衍生类型：Circle（圆形），Square（方形），Triangle（三角形）等等。大家之所以喜欢这个例子，因为很容易理解“圆属于形状的一种类型”等概念。下面这幅继承图向我们展示了它们的关系：\n上溯造型可用下面这个语句简单地表现出来：\nShape s = new Circle(); 当我们调用其中一个基础类方法时（已在衍生类里覆盖）：\ns.draw(); 此时实际调用的是Circle.draw()，因为后期绑定已经介入（多形性）。\n//: Shapes.java // Polymorphism in Java class Shape { void draw() {} void erase() {} } class Circle extends Shape { void draw() { System.out.println(\u0026#34;Circle.draw()\u0026#34;); } void erase() { System.out.println(\u0026#34;Circle.erase()\u0026#34;); } } class Square extends Shape { void draw() { System.out.println(\u0026#34;Square.draw()\u0026#34;); } void erase() { System.out.println(\u0026#34;Square.erase()\u0026#34;); } } class Triangle extends Shape { void draw() { System.out.println(\u0026#34;Triangle.draw()\u0026#34;); } void erase() { System.out.println(\u0026#34;Triangle.erase()\u0026#34;); } } public class Shapes { public static Shape randShape() { switch((int)(Math.random() * 3)) { default: // To quiet the compiler case 0: return new Circle(); case 1: return new Square(); case 2: return new Triangle(); } } public static void main(String[] args) { Shape[] s = new Shape[9]; // Fill up the array with shapes: for(int i = 0; i \u0026lt; s.length; i++) s[i] = randShape(); // Make polymorphic method calls: for(int i = 0; i \u0026lt; s.length; i++) s[i].draw(); } } ///:~ main()包含了Shape句柄的一个数组，其中的数据通过对randShape()的调用填入。在这个时候，我们知道自己拥有Shape，但不知除此之外任何具体的情况（编译器同样不知）。然而，当我们在这个数组里步进，并为每个元素调用draw()的时候，与各类型有关的正确行为会魔术般地发生，就象下面这个输出示例展示的那样：\nCircle.draw() Triangle.draw() Circle.draw() Circle.draw() Circle.draw() Square.draw() Triangle.draw() Square.draw() Square.draw() 由于几何形状是每次随机选择的，所以每次运行都可能有不同的结果。之所以要突出形状的随机选择，是为了让大家深刻体会这一点：为了在编译的时候发出正确的调用，编译器毋需获得任何特殊的情报。对draw()的所有调用都是通过动态绑定进行的。\n7.2.3 扩展性 我们认为多形性是一种至关重要的技术，它允许程序员“将发生改变的东西同没有发生改变的东西区分开”。\n7.3 覆盖与过载 “过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。\n7.4 抽象类和方法 之所以要建立这个通用接口，唯一的原因就是它能为不同的子类型作出不同的表示。它为我们建立了一种基本形式，使我们能定义在所有衍生类里“通用”的一些东西。为阐述这个观念，另一个方法是把Instrument称为“抽象基础类”（简称“抽象类”）。若想通过该通用接口处理一系列类，就需要创建一个抽象类。对所有与基础类声明的签名相符的衍生类方法，都可以通过动态绑定机制进行调用（然而，正如上一节指出的那样，如果方法名与基础类相同，但自变量或参数不同，就会出现过载现象，那或许并非我们所愿意的）。\n抽象类的作用仅仅是表达接口，而不是表达一些具体的实施细节。所以创建一个抽象对象是没有意义的，而且我们通常都应禁止用户那样做。\n针对这个问题，Java专门提供了一种机制，名为“抽象方法”。它属于一种不完整的方法，只含有一个声明，没有方法主体。下面是抽象方法声明时采用的语法：\nabstract void X(); 包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。\n一个抽象类是不完整的，那么一旦有人试图生成那个类的一个对象，编译器又会采取什么行动呢？由于不能安全地为一个抽象类创建属于它的对象，所以会从编译器那里获得一条出错提示。通过这种方法，编译器可保证抽象类的“纯洁性”，我们不必担心会误用它。\n如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract关键字标志那个类的“抽象”本质。\n即使不包括任何abstract方法，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。\n使一个类抽象以后，并不会强迫我们将它的所有方法都同时变成抽象。\n创建抽象类和方法有时对我们非常有用，因为它们使一个类的抽象变成明显的事实，可明确告诉用户和编译器自己打算如何用它。\n7.5 接口 “interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static和final。接口只提供一种形式，并不提供实施的细节。\n我们常把接口用于建立类和类之间的一个“协议”。有些面向对象的程序设计语言采用了一个名为“protocol”（协议）的关键字，它做的便是与接口相同的事情。\n为创建一个接口，请使用interface关键字，而不要用class。与类相似，我们可在interface关键字的前面增加一个public关键字（但只有接口定义于同名的一个文件内）；或者将其省略，营造一种“友好的”状态。\n为了生成与一个特定的接口（或一组接口）相符的类，要使用implements（实现）关键字。\n接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java编译器不允许我们那样做。\n为了生成与一个特定的接口（或一组接口）相符的类，要使用implements（实现）关键字。我们要表达的意思是“接口看起来就象那个样子，这儿是它具体的工作细节”。除这些之外，我们其他的工作都与继承极为相似。\n具体实现了一个接口以后，就获得了一个普通的类，可用标准方式对其进行扩展。\n接口的一个方法即使没被声明为public，但它们都会自动获得public属性。\n7.5.1 Java的“多重继承” 接口只是比抽象类“更纯”的一种形式。它的用途并不止那些。由于接口根本没有具体的实施细节——也就是说，没有与存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“x从属于a，也从属于b，也从属于c”。在C++中，将多个类合并到一起的行动称作“多重继承”，而且操作较为不便，因为每个类都可能有一套自己的实施细节。在Java中，我们可采取同样的行动，但只有其中一个类拥有具体的实施细节。所以在合并多个接口的时候，C++的问题不会在Java中重演。\n在一个衍生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基础类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：\n//: Adventure.java\r// Multiple interfaces\rimport java.util.*;\rinterface CanFight {\rvoid fight();\r}\rinterface CanSwim {\rvoid swim();\r}\rinterface CanFly {\rvoid fly();\r}\rclass ActionCharacter {\rpublic void fight() {}\r}\rclass Hero extends ActionCharacter\rimplements CanFight, CanSwim, CanFly {\rpublic void swim() {}\rpublic void fly() {}\r}\rpublic class Adventure {\rstatic void t(CanFight x) { x.fight(); }\rstatic void u(CanSwim x) { x.swim(); }\rstatic void v(CanFly x) { x.fly(); }\rstatic void w(ActionCharacter x) { x.fight(); }\rpublic static void main(String[] args) {\rHero i = new Hero();\rt(i); // Treat it as a CanFight\ru(i); // Treat it as a CanSwim\rv(i); // Treat it as a CanFly\rw(i); // Treat it as an ActionCharacter\r}\r} ///:~ 从中可以看到，Hero将具体类ActionCharacter同接口CanFight，CanSwim以及CanFly合并起来。按这种形式合并一个具体类与接口的时候，具体类必须首先出现，然后才是接口（否则编译器会报错）。（先 extends 再 implements）\n接口的规则是：我们可以从它继承（稍后就会看到），但这样得到的将是另一个接口。如果想创建新类型的一个对象，它就必须是已提供所有定义的一个类。\n接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。使用接口的第二个原因与使用抽象基础类的原因是一样的：防止客户程序员制作这个类的一个对象，以及规定它仅仅是一个接口。这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。\n7.5.2 通过继承扩展接口 利用继承技术，可方便地为一个接口添加新的方法声明，也可以将几个接口合并成一个新接口。在这两种情况下，最终得到的都是一个新接口.\n通常，我们只能对单独一个类应用extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。正如大家看到的那样，接口的名字只是简单地使用逗号分隔。\n7.5.3 常数分组 由于置入一个接口的所有字段都自动具有static和final属性，所以接口是对常数值进行分组的一个好工具，它具有与C或C++的enum非常相似的效果。\n注意根据Java命名规则，拥有固定标识符的static final基本数据类型（亦即编译期常数）都全部采用大写字母（用下划线分隔单个标识符里的多个单词）。\n接口中的字段会自动具备public属性，所以没必要专门指定。\n我们可以从包的外部使用常数——就象对其他任何包进行的操作那样。与将数字强行编码（硬编码）到自己的程序中相比，这种（常用的）技术无疑已经是一个巨大的进步。我们通常把“硬编码”数字的行为称为“魔术数字”，它产生的代码是非常难以维护的。 如确实不想放弃额外的类型安全性，可构建象下面这样的一个类:\npublic final class Month2 {\rprivate String name;\rprivate Month2(String nm) { name = nm; }\rpublic String toString() { return name; }\rpublic final static Month2\rJAN = new Month2(\u0026#34;January\u0026#34;),\rFEB = new Month2(\u0026#34;February\u0026#34;),\rMAR = new Month2(\u0026#34;March\u0026#34;),\rAPR = new Month2(\u0026#34;April\u0026#34;),\rMAY = new Month2(\u0026#34;May\u0026#34;),\rJUN = new Month2(\u0026#34;June\u0026#34;),\rJUL = new Month2(\u0026#34;July\u0026#34;),\rAUG = new Month2(\u0026#34;August\u0026#34;),\rSEP = new Month2(\u0026#34;September\u0026#34;),\rOCT = new Month2(\u0026#34;October\u0026#34;),\rNOV = new Month2(\u0026#34;November\u0026#34;),\rDEC = new Month2(\u0026#34;December\u0026#34;);\rpublic final static Month2[] month = {\rJAN, JAN, FEB, MAR, APR, MAY, JUN,\rJUL, AUG, SEP, OCT, NOV, DEC\r};\rpublic static void main(String[] args) {\rMonth2 m = Month2.JAN;\rSystem.out.println(m);\rm = Month2.month[12];\rSystem.out.println(m);\rSystem.out.println(m == Month2.DEC);\rSystem.out.println(m.equals(Month2.DEC));\r}\r} ///:~ 这个类叫作Month2，因为标准Java库里已经有一个Month。它是一个final类，并含有一个private构建器，所以没有人能从它继承，或制作它的一个实例。唯一的实例就是那些final static对象，它们是在类本身内部创建的，包括：JAN，FEB，MAR等等。这些对象也在month数组中使用，后者让我们能够按数字挑选月份，而不是按名字（注意数组中提供了一个多余的JAN，使偏移量增加了1，也使December确实成为12月）。在main()中，我们可注意到类型的安全性：m是一个Month2对象，所以只能将其分配给Month2。在前面的Months.java例子中，只提供了int值，所以本来想用来代表一个月份的int变量可能实际获得一个整数值，那样做可能不十分安全。 这儿介绍的方法也允许我们交换使用==或者equals()，就象main()尾部展示的那样。\n7.5.4 初始化接口中的字段 接口中定义的字段会自动具有static和final属性。它们不能是“空白final”，但可初始化成非常数表达式。例如：\npublic interface RandVals {\rint rint = (int)(Math.random() * 10);\rlong rlong = (long)(Math.random() * 10);\rfloat rfloat = (float)(Math.random() * 10);\rdouble rdouble = Math.random() * 10;\r} ///:~ 由于字段是static的，所以它们会在首次装载类之后、以及首次访问任何字段之前获得初始化。\n当然，字段并不是接口的一部分，而是保存于那个接口的static存储区域中。\n7.6 内部类 在Java 1.1中，可将一个类定义置入另一个类定义中。这就叫作“内部类”。内部类对我们非常有用，因为利用它可对那些逻辑上相互联系的类进行分组，并可控制一个类在另一个类里的“可见性”。然而，我们必须认识到内部类与以前讲述的“合成”方法存在着根本的区别。\n通常，对内部类的需要并不是特别明显的，至少不会立即感觉到自己需要使用内部类。在本章的末尾，介绍完内部类的所有语法之后，大家会发现一个特别的例子。通过它应该可以清晰地认识到内部类的好处。\n创建内部类的过程是平淡无奇的：将类定义置入一个用于封装它的类内部。\npublic class Parcel1 {\rclass Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rclass Destination {\rprivate String label;\rDestination(String whereTo) {\rlabel = whereTo;\r}\rString readLabel() { return label; }\r}\r// Using inner classes looks just like\r// using any other class, within Parcel1:\rpublic void ship(String dest) {\rContents c = new Contents();\rDestination d = new Destination(dest);\r} public static void main(String[] args) {\rParcel1 p = new Parcel1();\rp.ship(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 若在ship()内部使用，内部类的使用看起来和其他任何类都没什么分别。在这里，唯一明显的区别就是它的名字嵌套在Parcel1里面。但大家不久就会知道，这其实并非唯一的区别。\n更典型的一种情况是，一个外部类拥有一个特殊的方法，它会返回指向一个内部类的句柄。就象下面这样：\npublic class Parcel2 {\rclass Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rclass Destination {\rprivate String label;\rDestination(String whereTo) {\rlabel = whereTo;\r}\rString readLabel() { return label; }\r}\rpublic Destination to(String s) {\rreturn new Destination(s);\r}\rpublic Contents cont() {\rreturn new Contents();\r}\rpublic void ship(String dest) {\rContents c = cont();\rDestination d = to(dest);\r} public static void main(String[] args) {\rParcel2 p = new Parcel2();\rp.ship(\u0026#34;Tanzania\u0026#34;);\rParcel2 q = new Parcel2();\r// Defining handles to inner classes:\rParcel2.Contents c = q.cont();\rParcel2.Destination d = q.to(\u0026#34;Borneo\u0026#34;);\r}\r} ///:~ 若想在除外部类非static方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”，就象main()中展示的那样。\n7.6.1 内部类和上溯造型 迄今为止，内部类看起来仍然没什么特别的地方。毕竟，用它实现隐藏显得有些大题小做。Java已经有一个非常优秀的隐藏机制——只允许类成为“友好的”（只在一个包内可见），而不是把它创建成一个内部类。\n然而，当我们准备上溯造型到一个基础类（特别是到一个接口）的时候，内部类就开始发挥其关键作用（从用于实现的对象生成一个接口句柄具有与上溯造型至一个基础类相同的效果）。这是由于内部类随后可完全进入不可见或不可用状态——对任何人都将如此。所以我们可以非常方便地隐藏实施细节。我们得到的全部回报就是一个基础类或者接口的句柄，而且甚至有可能不知道准确的类型。就象下面这样：\nabstract class Contents {\rabstract public int value();\r}\rinterface Destination {\rString readLabel();\r}\rpublic class Parcel3 {\rprivate class PContents extends Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rprotected class PDestination\rimplements Destination {\rprivate String label;\rprivate PDestination(String whereTo) {\rlabel = whereTo;\r}\rpublic String readLabel() { return label; }\r}\rpublic Destination dest(String s) {\rreturn new PDestination(s);\r}\rpublic Contents cont() {\rreturn new PContents();\r}\r}\rclass Test {\rpublic static void main(String[] args) {\rParcel3 p = new Parcel3();\rContents c = p.cont();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;);\r// Illegal -- can\u0026#39;t access private class:\r//! Parcel3.PContents c = p.new PContents();\r}\r} ///:~ 现在，Contents和Destination代表可由客户程序员使用的接口（记住接口会将自己的所有成员都变成public属性）。为方便起见，它们置于单独一个文件里，但原始的Contents和Destination在它们自己的文件中是相互public的。\n在Parcel3中，一些新东西已经加入：内部类PContents被设为private，所以除了Parcel3之外，其他任何东西都不能访问它。PDestination被设为protected，所以除了Parcel3，Parcel3包内的类（因为protected也为包赋予了访问权；也就是说，protected也是“友好的”），以及Parcel3的继承者之外，其他任何东西都不能访问PDestination。这意味着客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至不能下溯造型到一个private内部类（或者一个protected内部类，除非自己本身便是一个继承者），因为我们不能访问名字，就象在classTest里看到的那样。所以，利用private内部类，类设计人员可完全禁止其他人依赖类型编码，并可将具体的实施细节完全隐藏起来。除此以外，从客户程序员的角度来看，一个接口的范围没有意义的，因为他们不能访问不属于公共接口类的任何额外方法。这样一来，Java编译器也有机会生成效率更高的代码。\n普通（非内部）类不可设为private或protected——只允许public或者“友好的”。\n注意Contents不必成为一个抽象类。在这儿也可以使用一个普通类，但这种设计最典型的起点依然是一个“接口”。\n7.6.2 方法和作用域中的内部类 至此，我们已基本理解了内部类的典型用途。对那些涉及内部类的代码，通常表达的都是“单纯”的内部类，非常简单，且极易理解。然而，内部类的设计非常全面，不可避免地会遇到它们的其他大量用法——假若我们在一个方法甚至一个任意的作用域内创建内部类。有两方面的原因促使我们这样做：\n(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。 (2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。 在下面这个例子里，将修改前面的代码，以便使用：\n(1) 在一个方法内定义的类 (2) 在方法的一个作用域内定义的类 (3) 一个匿名类，用于实现一个接口 (4) 一个匿名类，用于扩展拥有非默认构建器的一个类 (5) 一个匿名类，用于执行字段初始化 (6) 一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器） 第一个例子展示了如何在一个方法的作用域（而不是另一个类的作用域）中创建一个完整的类：\npublic class Parcel4 {\rpublic Destination dest(String s) {\rclass PDestination\rimplements Destination {\rprivate String label;\rprivate PDestination(String whereTo) {\rlabel = whereTo;\r}\rpublic String readLabel() { return label; }\r}\rreturn new PDestination(s);\r}\rpublic static void main(String[] args) {\rParcel4 p = new Parcel4();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ PDestination类属于dest()的一部分，而不是Parcel4的一部分（同时注意可为相同目录内每个类内部的一个内部类使用类标识符PDestination，这样做不会发生命名的冲突）。因此，PDestination不可从dest()的外部访问。请注意在返回语句中发生的上溯造型——除了指向基础类Destination的一个句柄之外，没有任何东西超出dest()的边界之外。当然，不能由于类PDestination的名字置于dest()内部，就认为在dest()返回之后PDestination不是一个有效的对象。\n下面这个例子展示了如何在任意作用域内嵌套一个内部类：\npublic class Parcel5 {\rprivate void internalTracking(boolean b) {\rif(b) {\rclass TrackingSlip {\rprivate String id;\rTrackingSlip(String s) {\rid = s;\r}\rString getSlip() { return id; }\r}\rTrackingSlip ts = new TrackingSlip(\u0026#34;slip\u0026#34;);\rString s = ts.getSlip();\r}\r// Can\u0026#39;t use it here! Out of scope:\r//! TrackingSlip ts = new TrackingSlip(\u0026#34;x\u0026#34;);\r}\rpublic void track() { internalTracking(true); }\rpublic static void main(String[] args) {\rParcel5 p = new Parcel5();\rp.track();\r}\r} ///:~ TrackingSlip类嵌套于一个if语句的作用域内。这并不意味着类是有条件创建的——它会随同其他所有东西得到编译。然而，在定义它的那个作用域之外，它是不可使用的。除这些以外，它看起来和一个普通类并没有什么区别。\npublic class Parcel6 {\rpublic Contents cont() {\rreturn new Contents() {\rprivate int i = 11;\rpublic int value() { return i; }\r}; // Semicolon required in this case\r}\rpublic static void main(String[] args) {\rParcel6 p = new Parcel6();\rContents c = p.cont();\r}\r} ///:~ cont()方法同时合并了返回值的创建代码，以及用于表示那个返回值的类。除此以外，这个类是匿名的——它没有名字。而且看起来似乎更让人摸不着头脑的是，我们准备创建一个Contents对象：\nreturn new Contents() 但在这之后，在遇到分号之前，我们又说：“等一等，让我先在一个类定义里再耍一下花招”：\nreturn new Contents() {\rprivate int i = 11;\rpublic int value() { return i; }\r}; 这种奇怪的语法要表达的意思是：“创建从Contents衍生出来的匿名类的一个对象”。由new表达式返回的句柄会自动上溯造型成一个Contents句柄。匿名内部类的语法其实要表达的是：\nclass MyContents extends Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rreturn new MyContents(); 在匿名内部类中，Contents是用一个默认构建器创建的。下面这段代码展示了基础类需要含有自变量的一个构建器时做的事情：\npublic class Parcel7 {\rpublic Wrapping wrap(int x) {\r// Base constructor call:\rreturn new Wrapping(x) {\rpublic int value() {\rreturn super.value() * 47;\r}\r}; // Semicolon required\r}\rpublic static void main(String[] args) {\rParcel7 p = new Parcel7();\rWrapping w = p.wrap(10);\r}\r} ///:~ 也就是说，我们将适当的自变量简单地传递给基础类构建器，在这儿表现为在“new Wrapping(x)”中传递x。匿名类不能拥有一个构建器，这和在调用super()时的常规做法不同。 在前述的两个例子中，分号并不标志着类主体的结束（和C++不同）。相反，它标志着用于包含匿名类的那个表达式的结束。因此，它完全等价于在其他任何地方使用分号。 若想对匿名内部类的一个对象进行某种形式的初始化，此时会出现什么情况呢？由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：\npublic class Parcel8 {\r// Argument must be final to use inside\r// anonymous inner class:\rpublic Destination dest(final String dest) {\rreturn new Destination() {\rprivate String label = dest;\rpublic String readLabel() { return label; }\r};\r}\rpublic static void main(String[] args) {\rParcel8 p = new Parcel8();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是我们将dest()的自变量设为final的原因。如果忘记这样做，就会得到一条编译期出错提示。 只要自己只是想分配一个字段，上述方法就肯定可行。但假如需要采取一些类似于构建器的行动，又应怎样操作呢？通过Java 1.1的实例初始化，我们可以有效地为一个匿名内部类创建一个构建器：\npublic class Parcel9 {\rpublic Destination\rdest(final String dest, final float price) {\rreturn new Destination() {\rprivate int cost;\r// Instance initialization for each object:\r{\rcost = Math.round(price);\rif(cost \u0026gt; 100)\rSystem.out.println(\u0026#34;Over budget!\u0026#34;);\r}\rprivate String label = dest;\rpublic String readLabel() { return label; }\r};\r}\rpublic static void main(String[] args) {\rParcel9 p = new Parcel9();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;, 101.395F);\r}\r} ///:~ 在实例初始化模块中，我们可看到代码不能作为类初始化模块（即if语句）的一部分执行。所以实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们不能对实例初始化模块进行过载处理，所以只能拥有这些构建器的其中一个。\n7.6.3 链接到外部类 迄今为止，我们见到的内部类好象仅仅是一种名字隐藏以及代码组织方案。尽管这些功能非常有用，但似乎并不特别引人注目。然而，我们还忽略了另一个重要的事实。创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。下面这个例子阐示了这个问题：\ninterface Selector {\rboolean end();\rObject current();\rvoid next();\r}\rpublic class Sequence {\rprivate Object[] o;\rprivate int next = 0;\rpublic Sequence(int size) {\ro = new Object[size];\r}\rpublic void add(Object x) {\rif(next \u0026lt; o.length) {\ro[next] = x;\rnext++;\r}\r}\rprivate class SSelector implements Selector {\rint i = 0;\rpublic boolean end() {\rreturn i == o.length;\r}\rpublic Object current() {\rreturn o[i];\r}\rpublic void next() {\rif(i \u0026lt; o.length) i++;\r}\r}\rpublic Selector getSelector() {\rreturn new SSelector();\r}\rpublic static void main(String[] args) {\rSequence s = new Sequence(10);\rfor(int i = 0; i \u0026lt; 10; i++)\rs.add(Integer.toString(i));\rSelector sl = s.getSelector(); while(!sl.end()) {\rSystem.out.println((String)sl.current());\rsl.next();\r}\r}\r} ///:~ ②：这与C++“嵌套类”的设计颇有不同，后者只是一种单纯的名字隐藏机制。在C++中，没有指向一个封装对象的链接，也不存在默认的访问权限。\n其中，Sequence只是一个大小固定的对象数组，有一个类将其封装在内部。我们调用add()，以便将一个新对象添加到Sequence末尾（如果还有地方的话）。为了取得Sequence中的每一个对象，要使用一个名为Selector的接口，它使我们能够知道自己是否位于最末尾（end()），能观看当前对象（current() Object），以及能够移至Sequence内的下一个对象（next() Object）。由于Selector是一个接口，所以其他许多类都能用它们自己的方式实现接口，而且许多方法都能将接口作为一个自变量使用，从而创建一般的代码。\n在这里，SSelector是一个私有类，它提供了Selector功能。在main()中，大家可看到Sequence的创建过程，在它后面是一系列字串对象的添加。随后，通过对getSelector()的一个调用生成一个Selector。并用它在Sequence中移动，同时选择每一个项目。\n从表面看，SSelector似乎只是另一个内部类。但不要被表面现象迷惑。请注意观察end()，current()以及next()，它们每个方法都引用了o。o是个不属于SSelector一部分的句柄，而是位于封装类里的一个private字段。然而，内部类可以从封装类访问方法与字段，就象已经拥有了它们一样。这一特征对我们来说是非常方便的，就象在上面的例子中看到的那样。\n因此，我们现在知道一个内部类可以访问封装类的成员。这是如何实现的呢？内部类必须拥有对封装类的特定对象的一个引用，而封装类的作用就是创建这个内部类。随后，当我们引用封装类的一个成员时，就利用那个（隐藏）的引用来选择那个成员。幸运的是，编译器会帮助我们照管所有这些细节。但我们现在也可以理解内部类的一个对象只能与封装类的一个对象联合创建。在这个创建过程中，要求对封装类对象的句柄进行初始化。若不能访问那个句柄，编译器就会报错。进行所有这些操作的时候，大多数时候都不要求程序员的任何介入。\n7.6.4 static内部类 为正确理解static在应用于内部类时的含义，必须记住内部类的对象默认持有创建它的那个封装类的一个对象的句柄。然而，假如我们说一个内部类是static的，这种说法却是不成立的。static内部类意味着：\n(1) 为创建一个static内部类的对象，我们不需要一个外部类对象。 (2) 不能从static内部类的一个对象中访问一个外部类对象。 但在存在一些限制：由于static成员只能位于一个类的外部级别，所以内部类不可拥有static数据或static内部类。\n倘若为了创建内部类的对象而不需要创建外部类的一个对象，那么可将所有东西都设为static。为了能正常工作，同时也必须将内部类设为static。如下所示：\nabstract class Contents {\rabstract public int value();\r}\rinterface Destination {\rString readLabel();\r}\rpublic class Parcel10 {\rprivate static class PContents extends Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rprotected static class PDestination implements Destination {\rprivate String label;\rprivate PDestination(String whereTo) {\rlabel = whereTo;\r}\rpublic String readLabel() { return label; }\r}\rpublic static Destination dest(String s) {\rreturn new PDestination(s);\r}\rpublic static Contents cont() {\rreturn new PContents();\r}\rpublic static void main(String[] args) {\rContents c = cont();\rDestination d = dest(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 在main()中，我们不需要Parcel10的对象；相反，我们用常规的语法来选择一个static成员，以便调用将句柄返回Contents和Destination的方法。\n通常，我们不在一个接口里设置任何代码，但static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static内部类只位于接口的命名空间内部:\ninterface IInterface {\rstatic class Inner {\rint i, j, k;\rpublic Inner() {}\rvoid f() {}\r}\r} ///:~ 在本书早些时候，我建议大家在每个类里都设置一个main()，将其作为那个类的测试床使用。这样做的一个缺点就是额外代码的数量太多。若不愿如此，可考虑用一个static内部类容纳自己的测试代码。如下所示：\nclass TestBed {\rTestBed() {}\rvoid f() { System.out.println(\u0026#34;f()\u0026#34;); }\rpublic static class Tester {\rpublic static void main(String[] args) {\rTestBed t = new TestBed();\rt.f();\r}\r}\r} ///:~ 这样便生成一个独立的、名为TestBed$Tester的类（为运行程序，请使用“java TestBed$Tester”命令）。可将这个类用于测试，但不需在自己的最终发行版本中包含它。\n7.6.5 引用外部类对象 若想生成外部类对象的句柄，就要用一个点号以及一个this来命名外部类。举个例子来说，在Sequence.SSelector类中，它的所有方法都能产生外部类Sequence的存储句柄，方法是采用Sequence.this的形式。结果获得的句柄会自动具备正确的类型（这会在编译期间检查并核实，所以不会出现运行期的开销）。\n有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在new表达式中提供指向其他外部类对象的一个句柄，就象下面这样：\npublic class Parcel11 {\rclass Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rclass Destination {\rprivate String label;\rDestination(String whereTo) {\rlabel = whereTo;\r}\rString readLabel() { return label; }\r}\rpublic static void main(String[] args) {\rParcel11 p = new Parcel11();\r// Must use instance of outer class\r// to create an instances of the inner class:\rParcel11.Contents c = p.new Contents();\rParcel11.Destination d =\rp.new Destination(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 为直接创建内部类的一个对象，不能象大家或许猜想的那样——采用相同的形式，并引用外部类名Parcel11。此时，必须利用外部类的一个对象生成内部类的一个对象：\nParcel11.Contents c = p.new Contents(); 因此，除非已拥有外部类的一个对象，否则不可能创建内部类的一个对象。这是由于内部类的对象已同创建它的外部类的对象“默默”地连接到一起。然而，如果生成一个static内部类，就不需要指向外部类对象的一个句柄。\n7.6.6 从内部类继承 由于内部类构建器必须同封装类对象的一个句柄联系到一起，所以从一个内部类继承的时候，情况会稍微变得有些复杂。这儿的问题是封装类的“秘密”句柄必须获得初始化，而且在衍生类中不再有一个默认的对象可以连接。解决这个问题的办法是采用一种特殊的语法，明确建立这种关联：\nclass WithInner {\rclass Inner {}\r}\rpublic class InheritInner extends WithInner.Inner {\r//! InheritInner() {} // Won\u0026#39;t compile\rInheritInner(WithInner wi) {\rwi.super();\r}\rpublic static void main(String[] args) {\rWithInner wi = new WithInner();\rInheritInner ii = new InheritInner(wi);\r}\r} ///:~ 从中可以看到，InheritInner只对内部类进行了扩展，没有扩展外部类。但在需要创建一个构建器的时候，默认对象已经没有意义，我们不能只是传递封装对象的一个句柄。此外，必须在构建器中采用下述语法：\nenclosingClassHandle.super(); 它提供了必要的句柄，以便程序正确编译。\n7.6.7 内部类可以覆盖吗？ 若创建一个内部类，然后从封装类继承，并重新定义内部类，那么会出现什么情况呢？也就是说，我们有可能覆盖一个内部类吗？这看起来似乎是一个非常有用的概念，但“覆盖”一个内部类——好象它是外部类的另一个方法——这一概念实际不能做任何事情：\nclass Egg {\rprotected class Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;Egg.Yolk()\u0026#34;);\r}\r}\rprivate Yolk y;\rpublic Egg() {\rSystem.out.println(\u0026#34;New Egg()\u0026#34;);\ry = new Yolk();\r}\r}\rpublic class BigEgg extends Egg {\rpublic class Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;BigEgg.Yolk()\u0026#34;);\r}\r}\rpublic static void main(String[] args) {\rnew BigEgg();\r}\r} ///:~ 默认构建器是由编译器自动合成的，而且会调用基础类的默认构建器。大家或许会认为由于准备创建一个BigEgg，所以会使用Yolk的“被覆盖”版本。但实际情况并非如此。输出如下：\nNew Egg()\rEgg.Yolk() 这个例子简单地揭示出当我们从外部类继承的时候，没有任何额外的内部类继续下去。然而，仍然有可能“明确”地从内部类继承：\nclass Egg2 {\rprotected class Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;Egg2.Yolk()\u0026#34;);\r}\rpublic void f() {\rSystem.out.println(\u0026#34;Egg2.Yolk.f()\u0026#34;);\r}\r}\rprivate Yolk y = new Yolk();\rpublic Egg2() {\rSystem.out.println(\u0026#34;New Egg2()\u0026#34;);\r}\rpublic void insertYolk(Yolk yy) { y = yy; }\rpublic void g() { y.f(); }\r}\rpublic class BigEgg2 extends Egg2 {\rpublic class Yolk extends Egg2.Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;BigEgg2.Yolk()\u0026#34;);\r}\rpublic void f() {\rSystem.out.println(\u0026#34;BigEgg2.Yolk.f()\u0026#34;);\r}\r}\rpublic BigEgg2() { insertYolk(new Yolk()); }\rpublic static void main(String[] args) {\rEgg2 e2 = new BigEgg2();\re2.g();\r}\r} ///:~ 现在，BigEgg2.Yolk明确地扩展了Egg2.Yolk，而且覆盖了它的方法。方法insertYolk()允许BigEgg2将它自己的某个Yolk对象上溯造型至Egg2的y句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。输出结果如下：\nEgg2.Yolk() // private Yolk y = new Yolk();\rNew Egg2() // public Egg2(){}\rEgg2.Yolk() // insertYolk(new Yolk()) 中创建的是 BigEgg2.new Yolk()，而 BigEgg2.Yolk extends Egg2.Yolk，所以先要 Egg2.new Yolk()\rBigEgg2.Yolk() // insertYolk(new Yolk()) 中创建的是 BigEgg2.new Yolk()\rBigEgg2.Yolk.f() // 此时 e2.f 类型是 BigEgg2.Yolk 对Egg2.Yolk()的第二个调用是BigEgg2.Yolk构建器的基础类构建器调用。调用 g()的时候，可发现使用的是f()的被覆盖版本。\n7.6.8 内部类标识符 由于每个类都会生成一个.class文件，用于容纳与如何创建这个类型的对象有关的所有信息（这种信息产生了一个名为Class对象的元类），所以大家或许会猜到内部类也必须生成相应的.class文件，用来容纳与它们的Class对象有关的信息。这些文件或类的名字遵守一种严格的形式：先是封装类的名字，再跟随一个$，再跟随内部类的名字。例如，由InheritInner.java创建的.class文件包括：\nInheritInner.class\rWithInner$Inner.class\rWithInner.class 如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用。若内部类嵌套于其他内部类中，则它们的名字简单地追加在一个$以及外部类标识符的后面。\n这种生成内部名称的方法除了非常简单和直观以外，也非常“健壮”，可适应大多数场合的要求（注释③）。由于它是Java的标准命名机制，所以产生的文件会自动具备“与平台无关”的能力（注意Java编译器会根据情况改变内部类，使其在不同的平台中能正常工作）。\n③：但在另一方面，由于“$”也是Unix外壳的一个元字符，所以有时会在列出.class文件时遇到麻烦。对一家以Unix为基础的公司——Sun——来说，采取这种方案显得有些奇怪。我的猜测是他们根本没有仔细考虑这方面的问题，而是认为我们会将全部注意力自然地放在源码文件上。\n7.6.9 为什么要用内部类：控制框架 到目前为止，大家已接触了对内部类的运作进行描述的大量语法与概念。但这些并不能真正说明内部类存在的原因。为什么Sun要如此麻烦地在Java 1.1里添加这样的一种基本语言特性呢？答案就在于我们在这里要学习的“控制框架”。\n一个“应用程序框架”是指一个或一系列类，它们专门设计用来解决特定类型的问题。为应用应用程序框架，我们可从一个或多个类继承，并覆盖其中的部分方法。我们在覆盖方法中编写的代码用于定制由那些应用程序框架提供的常规方案，以便解决自己的实际问题。“控制框架”属于应用程序框架的一种特殊类型，受到对事件响应的需要的支配；主要用来响应事件的一个系统叫作“由事件驱动的系统”。在应用程序设计语言中，最重要的问题之一便是“图形用户界面”（GUI），它几乎完全是由事件驱动的。正如大家会在第13章学习的那样，Java 1.1 AWT属于一种控制框架，它通过内部类完美地解决了GUI的问题。\n为理解内部类如何简化控制框架的创建与使用，可认为一个控制框架的工作就是在事件“就绪”以后执行它们。尽管“就绪”的意思很多，但在目前这种情况下，我们却是以计算机时钟为基础。随后，请认识到针对控制框架需要控制的东西，框架内并未包含任何特定的信息。首先，它是一个特殊的接口，描述了所有控制事件。它可以是一个抽象类，而非一个实际的接口。由于默认行为是根据时间控制的，所以部分实施细节可能包括：\nabstract public class Event {\rprivate long evtTime;\rpublic Event(long eventTime) {\revtTime = eventTime;\r}\rpublic boolean ready() {\rreturn System.currentTimeMillis() \u0026gt;= evtTime;\r}\rabstract public void action();\rabstract public String description();\r} ///:~ 希望Event（事件）运行的时候，构建器即简单地捕获时间。同时ready()告诉我们何时该运行它。当然，ready()也可以在一个衍生类中被覆盖，将事件建立在除时间以外的其他东西上。\naction()是事件就绪后需要调用的方法，而description()提供了与事件有关的文字信息。\n下面这个文件包含了实际的控制框架，用于管理和触发事件。第一个类实际只是一个“助手”类，它的职责是容纳Event对象。可用任何适当的集合替换它。而且通过第8章的学习，大家会知道另一些集合可简化我们的工作，不需要我们编写这些额外的代码：\nclass EventSet {\rprivate Event[] events = new Event[100];\rprivate int index = 0;\rprivate int next = 0;\rpublic void add(Event e) {\rif(index \u0026gt;= events.length)\rreturn; // (In real life, throw exception)\revents[index++] = e;\r}\rpublic Event getNext() {\rboolean looped = false;\rint start = next;\rdo {\rnext = (next + 1) % events.length;\r// See if it has looped to the beginning:\rif(start == next) looped = true;\r// If it loops past start, the list\r// is empty:\rif((next == (start + 1) % events.length)\r\u0026amp;\u0026amp; looped)\rreturn null;\r} while(events[next] == null);\rreturn events[next];\r}\rpublic void removeCurrent() {\revents[next] = null;\r}\r}\rpublic class Controller {\rprivate EventSet es = new EventSet();\rpublic void addEvent(Event c) { es.add(c); }\rpublic void run() {\rEvent e;\rwhile((e = es.getNext()) != null) {\rif(e.ready()) {\re.action();\rSystem.out.println(e.description());\res.removeCurrent();\r}\r}\r}\r} ///:~ EventSet可容纳100个事件（若在这里使用来自第8章的一个“真实”集合，就不必担心它的最大尺寸，因为它会根据情况自动改变大小）。index（索引）在这里用于跟踪下一个可用的空间，而next（下一个）帮助我们寻找列表中的下一个事件，了解自己是否已经循环到头。在对getNext()的调用中，这一点是至关重要的，因为一旦运行，Event对象就会从列表中删去（使用removeCurrent()）。所以getNext()会在列表中向前移动时遇到“空洞”。\n注意removeCurrent()并不只是指示一些标志，指出对象不再使用。相反，它将句柄设为null。这一点是非常重要的，因为假如垃圾收集器发现一个句柄仍在使用，就不会清除对象。若认为自己的句柄可能象现在这样被挂起，那么最好将其设为null，使垃圾收集器能够正常地清除它们。\nController是进行实际工作的地方。它用一个EventSet容纳自己的Event对象，而且addEvent()允许我们向这个列表加入新事件。但最重要的方法是run()。该方法会在EventSet中遍历，搜索一个准备运行的Event对象——ready()。对于它发现ready()的每一个对象，都会调用action()方法，打印出description()，然后将事件从列表中删去。\n注意在迄今为止的所有设计中，我们仍然不能准确地知道一个“事件”要做什么。这正是整个设计的关键；它怎样“将发生变化的东西同没有变化的东西区分开”？或者用我的话来讲，“改变的意图”造成了各类Event对象的不同行动。我们通过创建不同的Event子类，从而表达出不同的行动。\n这里正是内部类大显身手的地方。它们允许我们做两件事情：\n(1) 在单独一个类里表达一个控制框架应用的全部实施细节，从而完整地封装与那个实施有关的所有东西。内部类用于表达多种不同类型的action()，它们用于解决实际的问题。除此以外，后续的例子使用了private内部类，所以实施细节会完全隐藏起来，可以安全地修改。\n(2) 内部类使我们具体的实施变得更加巧妙，因为能方便地访问外部类的任何成员。若不具备这种能力，代码看起来就可能没那么使人舒服，最后不得不寻找其他方法解决。\n现在要请大家思考控制框架的一种具体实施方式，它设计用来控制温室（Greenhouse）功能（注释④）。每个行动都是完全不同的：控制灯光、供水以及温度自动调节的开与关，控制响铃，以及重新启动系统。但控制框架的设计宗旨是将不同的代码方便地隔离开。对每种类型的行动，都要继承一个新的Event内部类，并在action()内编写相应的控制代码。\n④：由于某些特殊原因，这对我来说是一个经常需要解决的、非常有趣的问题；原来的例子在《C++ Inside \u0026amp; Out》一书里也出现过，但Java提供了一种更令人舒适的解决方案。\n作为应用程序框架的一种典型行为，GreenhouseControls类是从Controller继承的：\npublic class GreenhouseControls\rextends Controller {\rprivate boolean light = false;\rprivate boolean water = false;\rprivate String thermostat = \u0026#34;Day\u0026#34;;\rprivate class LightOn extends Event {\rpublic LightOn(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here to\r// physically turn on the light.\rlight = true;\r}\rpublic String description() {\rreturn \u0026#34;Light is on\u0026#34;;\r}\r}\rprivate class LightOff extends Event {\rpublic LightOff(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here to\r// physically turn off the light.\rlight = false;\r}\rpublic String description() {\rreturn \u0026#34;Light is off\u0026#34;;\r}\r}\rprivate class WaterOn extends Event {\rpublic WaterOn(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rwater = true;\r}\rpublic String description() {\rreturn \u0026#34;Greenhouse water is on\u0026#34;;\r}\r}\rprivate class WaterOff extends Event {\rpublic WaterOff(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rwater = false;\r}\rpublic String description() {\rreturn \u0026#34;Greenhouse water is off\u0026#34;;\r}\r}\rprivate class ThermostatNight extends Event {\rpublic ThermostatNight(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rthermostat = \u0026#34;Night\u0026#34;;\r}\rpublic String description() {\rreturn \u0026#34;Thermostat on night setting\u0026#34;;\r}\r}\rprivate class ThermostatDay extends Event {\rpublic ThermostatDay(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rthermostat = \u0026#34;Day\u0026#34;;\r}\rpublic String description() {\rreturn \u0026#34;Thermostat on day setting\u0026#34;;\r}\r}\r// An example of an action() that inserts a\r// new one of itself into the event list:\rprivate int rings;\rprivate class Bell extends Event {\rpublic Bell(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Ring bell every 2 seconds, rings times:\rSystem.out.println(\u0026#34;Bing!\u0026#34;);\rif(--rings \u0026gt; 0)\raddEvent(new Bell(\rSystem.currentTimeMillis() + 2000));\r}\rpublic String description() {\rreturn \u0026#34;Ring bell\u0026#34;;\r}\r}\rprivate class Restart extends Event {\rpublic Restart(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\rlong tm = System.currentTimeMillis();\r// Instead of hard-wiring, you could parse\r// configuration information from a text\r// file here:\rrings = 5;\raddEvent(new ThermostatNight(tm));\raddEvent(new LightOn(tm + 1000));\raddEvent(new LightOff(tm + 2000));\raddEvent(new WaterOn(tm + 3000));\raddEvent(new WaterOff(tm + 8000));\raddEvent(new Bell(tm + 9000));\raddEvent(new ThermostatDay(tm + 10000));\r// Can even add a Restart object!\raddEvent(new Restart(tm + 20000));\r}\rpublic String description() {\rreturn \u0026#34;Restarting system\u0026#34;;\r}\r}\rpublic static void main(String[] args) {\rGreenhouseControls gc =\rnew GreenhouseControls();\rlong tm = System.currentTimeMillis();\rgc.addEvent(gc.new Restart(tm));\rgc.run();\r}\r} ///:~ 注意light（灯光）、water（供水）、thermostat（调温）以及rings都隶属于外部类GreenhouseControls，所以内部类可以毫无阻碍地访问那些字段。此外，大多数action()方法也涉及到某些形式的硬件控制，这通常都要求发出对非Java代码的调用。\n大多数Event类看起来都是相似的，但Bell（铃）和Restart（重启）属于特殊情况。Bell会发出响声，若尚未响铃足够的次数，它会在事件列表里添加一个新的Bell对象，所以以后会再度响铃。请注意内部类看起来为什么总是类似于多重继承：Bell拥有Event的所有方法，而且也拥有外部类GreenhouseControls的所有方法。\nRestart负责对系统进行初始化，所以会添加所有必要的事件。当然，一种更灵活的做法是避免进行“硬编码”，而是从一个文件里读入它们（第10章的一个练习会要求大家修改这个例子，从而达到这个目标）。由于Restart()仅仅是另一个Event对象，所以也可以在Restart.action()里添加一个Restart对象，使系统能够定期重启。在main()中，我们需要做的全部事情就是创建一个GreenhouseControls对象，并添加一个Restart对象，令其工作起来。 这个例子应该使大家对内部类的价值有一个更加深刻的认识，特别是在一个控制框架里使用它们的时候。此外，在第13章的后半部分，大家还会看到如何巧妙地利用内部类描述一个图形用户界面的行为。完成那里的学习后，对内部类的认识将上升到一个前所未有的新高度。\n内部类总结 什么是内部类 大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有些地方也叫做嵌套类），包含内部类的类也被称为外部类（有些地方也叫做宿主类）\n作用？？ 更好的封装性 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量 匿名内部类适合用于创建那些仅需要一次使用的类 静态or非静态？？ 使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类（也可称为类内部类），这样的内部类是类级别的，static关键字的作用是把类的成员变成类相关，而不是实例相关\n注意：\n1.非静态内部类中不允许定义静态成员 2.外部类的静态成员不可以直接使用非静态内部类 3.静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员 Demo public class EmpTest {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\rpublic static final class Builder {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic Integer getEmpLevel() {\rreturn empLevel;\r}\rpublic void setEmpLevel(Integer empLevel) {\rthis.empLevel = empLevel;\r}\rpublic String getMapingOrderLevel() {\rreturn mapingOrderLevel;\r}\rpublic void setMapingOrderLevel(String mapingOrderLevel) {\rthis.mapingOrderLevel = mapingOrderLevel;\r}\rpublic String getEmpNo() {\rreturn empNo;\r}\rpublic void setEmpNo(String empNo) {\rthis.empNo = empNo;\r}\rpublic Integer getOrderNumLimit() {\rreturn orderNumLimit;\r}\rpublic void setOrderNumLimit(Integer orderNumLimit) {\rthis.orderNumLimit = orderNumLimit;\r}\r} 添加了内部类的实体定义如下：（已经不再是严格的POJP）\npublic class EmpTest {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\r//外部类私有的构造方法\rprivate EmpTest(Builder builder) {\rsetId(builder.id);\rsetEmpLevel(builder.empLevel);\rsetMapingOrderLevel(builder.mapingOrderLevel);\rsetEmpNo(builder.empNo);\rsetOrderNumLimit(builder.orderNumLimit);\r}\r//对外提供初始化EmpTest类的唯一接口，通过这个方法，获得内部类的实例\rpublic static Builder newBuilder() {\rreturn new Builder();\r}\r//静态内部类：Builder\rpublic static final class Builder {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\rpublic Builder() {\r}\rpublic Builder id(Integer val) {\rid = val;\rreturn this;\r}\rpublic Builder empLevel(Integer val) {\rempLevel = val;\rreturn this;\r}\rpublic Builder mapingOrderLevel(String val) {\rmapingOrderLevel = val;\rreturn this;\r}\rpublic Builder empNo(String val) {\rempNo = val;\rreturn this;\r}\rpublic Builder orderNumLimit(Integer val) {\rorderNumLimit = val;\rreturn this;\r}\r//通过内部类的build方法，实例化外部类，并给其实例各个字段赋值\rpublic EmpTest build() {\rreturn new EmpTest(this);\r}\r}\rpublic Integer getId() {\rreturn id;\r}\r//...下边的get set 方法省略，和第一段一样\r} //初始化20个员工实例：\rfor(int i=0;i\u0026lt;20;i++){\rempList.add(EmpTest.newBuilder().empLevel(getRandom(5)).empNo(\u0026#34;Emp_\u0026#34;+i).id(i).mapingOrderLevel(getRandomChar()).orderNumLimit(getRandom(20)).build());\r} 7.7 构建器和多形性 同往常一样，构建器与其他种类的方法是有区别的。在涉及到多形性的问题后，这种方法依然成立。尽管构建器并不具有多形性（即便可以使用一种“虚拟构建器”——将在第11章介绍），但仍然非常有必要理解构建器如何在复杂的分级结构中以及随同多形性使用。这一理解将有助于大家避免陷入一些令人不快的纠纷。\n7.7.1 构建器的调用顺序 构建器调用的顺序已在第4章进行了简要说明，但那是在继承和多形性问题引入之前说的话。\n用于基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，使每个基础类使用的构建器都能得到调用。之所以要这样做，是由于构建器负有一项特殊任务：检查对象是否得到了正确的构建。一个衍生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private属性）。只有基础类的构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。所以，必须令所有构建器都得到调用，否则整个对象的构建就可能不正确。那正是编译器为什么要强迫对衍生类的每个部分进行构建器调用的原因。在衍生类的构建器主体中，若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织一个默认构建器）。\n对于一个复杂的对象，构建器的调用遵照下面的顺序：\n(1) 调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生类，等等。直到抵达最深一层的衍生类。 (2) 按声明顺序调用成员初始化模块。 (3) 调用衍生构建器的主体。 构建器调用的顺序是非常重要的。进行继承时，我们知道关于基础类的一切，并且能访问基础类的任何public和protected成员。这意味着当我们在衍生类的时候，必须能假定基础类的所有成员都是有效的。采用一种标准方法，构建行动已经进行，所以对象所有部分的成员均已得到构建。但在构建器内部，必须保证使用的所有成员都已构建。为达到这个要求，唯一的办法就是首先调用基础类构建器。然后在进入衍生类构建器以后，我们在基础类能够访问的所有成员都已得到初始化。此外，所有成员对象（亦即通过合成方法置于类内的对象）在类内进行定义的时候（比如上例中的b，c和l），由于我们应尽可能地对它们进行初始化，所以也应保证构建器内部的所有成员均为有效。若坚持按这一规则行事，会有助于我们确定所有基础类成员以及当前对象的成员对象均已获得正确的初始化。但不幸的是，这种做法并不适用于所有情况，这将在下一节具体说明。\n7.7.2 继承和 finalize() 通过“合成”方法创建新类时，永远不必担心对那个类的成员对象的收尾工作。每个成员都是一个独立的对象，所以会得到正常的垃圾收集以及收尾处理——无论它是不是不自己某个类一个成员。但在进行初始化的时候，必须覆盖衍生类中的finalize()方法——如果已经设计了某个特殊的清除进程，要求它必须作为垃圾收集的一部分进行。覆盖衍生类的finalize()时，务必记住调用finalize()的基础类版本。否则，基础类的初始化根本不会发生。下面这个例子便是明证：\n//: Frog.java // Testing finalize with inheritance class DoBaseFinalization { public static boolean flag = false; } class Characteristic { String s; Characteristic(String c) { s = c; System.out.println( \u0026#34;Creating Characteristic \u0026#34; + s); } protected void finalize() { System.out.println( \u0026#34;finalizing Characteristic \u0026#34; + s); } } class LivingCreature { Characteristic p = new Characteristic(\u0026#34;is alive\u0026#34;); LivingCreature() { System.out.println(\u0026#34;LivingCreature()\u0026#34;); } protected void finalize() { System.out.println( \u0026#34;LivingCreature finalize\u0026#34;); // Call base-class version LAST! if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } } class Animal extends LivingCreature { Characteristic p = new Characteristic(\u0026#34;has heart\u0026#34;); Animal() { System.out.println(\u0026#34;Animal()\u0026#34;); } protected void finalize() { System.out.println(\u0026#34;Animal finalize\u0026#34;); if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } } class Amphibian extends Animal { Characteristic p = new Characteristic(\u0026#34;can live in water\u0026#34;); Amphibian() { System.out.println(\u0026#34;Amphibian()\u0026#34;); } protected void finalize() { System.out.println(\u0026#34;Amphibian finalize\u0026#34;); if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } } public class Frog extends Amphibian { Frog() { System.out.println(\u0026#34;Frog()\u0026#34;); } protected void finalize() { System.out.println(\u0026#34;Frog finalize\u0026#34;); if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } public static void main(String[] args) { if(args.length != 0 \u0026amp;\u0026amp; args[0].equals(\u0026#34;finalize\u0026#34;)) DoBaseFinalization.flag = true; else System.out.println(\u0026#34;not finalizing bases\u0026#34;); new Frog(); // Instantly becomes garbage System.out.println(\u0026#34;bye!\u0026#34;); // Must do this to guarantee that all // finalizers will be called: System.runFinalizersOnExit(true); } } ///:~ DoBasefinalization类只是简单地容纳了一个标志，向分级结构中的每个类指出是否应调用super.finalize()。这个标志的设置建立在命令行参数的基础上，所以能够在进行和不进行基础类收尾工作的前提下查看行为。 分级结构中的每个类也包含了Characteristic类的一个成员对象。大家可以看到，无论是否调用了基础类收尾模块，Characteristic成员对象都肯定会得到收尾（清除）处理。\n每个被覆盖的finalize()至少要拥有对protected成员的访问权力，因为Object类中的finalize()方法具有protected属性，而编译器不允许我们在继承过程中消除访问权限（“友好的”比“受到保护的”具有更小的访问权限）。\n在Frog.main()中，DoBaseFinalization标志会得到配置，而且会创建单独一个Frog对象。请记住垃圾收集（特别是收尾工作）可能不会针对任何特定的对象发生，所以为了强制采取这一行动，System.runFinalizersOnExit(true)添加了额外的开销，以保证收尾工作的正常进行。若没有基础类初始化 则输出结果是：\nnot finalizing bases\rCreating Characteristic is alive\rLivingCreature()\rCreating Characteristic has heart\rAnimal()\rCreating Characteristic can live in water\rAmphibian()\rFrog()\rbye!\rFrog finalize\rfinalizing Characteristic is alive\rfinalizing Characteristic has heart\rfinalizing Characteristic can live in water 从中可以看出确实没有为基础类Frog调用收尾模块。但假如在命令行加入“finalize”自变量，则会获得下述结果：\nCreating Characteristic is alive\rLivingCreature()\rCreating Characteristic has heart\rAnimal()\rCreating Characteristic can live in water\rAmphibian()\rFrog()\rbye!\rFrog finalize\rAmphibian finalize\rAnimal finalize\rLivingCreature finalize\rfinalizing Characteristic is alive\rfinalizing Characteristic has heart\rfinalizing Characteristic can live in water 尽管成员对象按照与它们创建时相同的顺序进行收尾，但从技术角度说，并没有指定对象收尾的顺序。但对于基础类，我们可对收尾的顺序进行控制。采用的最佳顺序正是在这里采用的顺序，它与初始化顺序正好相反。按照与C++中用于“破坏器”相同的形式，我们应该首先执行衍生类的收尾，再是基础类的收尾。这是由于衍生类的收尾可能调用基础类中相同的方法，要求基础类组件仍然处于活动状态。因此，必须提前将它们清除（破坏）。\n7.7.3 构建器内部的多形性方法的行为 构建器调用的分级结构（顺序）为我们带来了一个有趣的问题，或者说让我们进入了一种进退两难的局面。若当前位于一个构建器的内部，同时调用准备构建的那个对象的一个动态绑定方法，那么会出现什么情况呢？在原始的方法内部，我们完全可以想象会发生什么——动态绑定的调用会在运行期间进行解析，因为对象不知道它到底从属于方法所在的那个类，还是从属于从它衍生出来的某些类。为保持一致性，大家也许会认为这应该在构建器内部发生。 但实际情况并非完全如此。若调用构建器内部一个动态绑定的方法，会使用那个方法被覆盖的定义。然而，产生的效果可能并不如我们所愿，而且可能造成一些难于发现的程序错误。\n从概念上讲，构建器的职责是让对象实际进入存在状态。在任何构建器内部，整个对象可能只是得到部分组织——我们只知道基础类对象已得到初始化，但却不知道哪些类已经继承。然而，一个动态绑定的方法调用却会在分级结构里“向前”或者“向外”前进。它调用位于衍生类里的一个方法。如果在构建器内部做这件事情，那么对于调用的方法，它要操纵的成员可能尚未得到正确的初始化——这显然不是我们所希望的。 通过观察下面这个例子，这个问题便会昭然若揭：\nabstract class Glyph {\rabstract void draw();\rGlyph() {\rSystem.out.println(\u0026#34;Glyph() before draw()\u0026#34;);\rdraw(); System.out.println(\u0026#34;Glyph() after draw()\u0026#34;);\r}\r}\rclass RoundGlyph extends Glyph {\rint radius = 1;\rRoundGlyph(int r) {\rradius = r;\rSystem.out.println(\r\u0026#34;RoundGlyph.RoundGlyph(), radius = \u0026#34;\r+ radius);\r}\rvoid draw() { System.out.println(\r\u0026#34;RoundGlyph.draw(), radius = \u0026#34; + radius);\r}\r}\rpublic class PolyConstructors {\rpublic static void main(String[] args) {\rnew RoundGlyph(5);\r}\r} ///:~ 在Glyph中，draw()方法是“抽象的”（abstract），所以它可以被其他方法覆盖。事实上，我们在RoundGlyph中不得不对其进行覆盖。但Glyph构建器会调用这个方法，而且调用会在RoundGlyph.draw()中止，这看起来似乎是有意的。但请看看输出结果：\nGlyph() before draw()\rRoundGlyph.draw(), radius = 0\rGlyph() after draw()\rRoundGlyph.RoundGlyph(), radius = 5 当Glyph的构建器调用draw()时，radius的值甚至不是默认的初始值1，而是0。这可能是由于一个点号或者屏幕上根本什么都没有画而造成的。这样就不得不开始查找程序中的错误，试着找出程序不能工作的原因。 前一节讲述的初始化顺序并不十分完整，而那是解决问题的关键所在。初始化的实际过程是这样的：\n(1) 在采取其他任何操作之前，为对象分配的存储空间初始化成二进制零。 (2) 就象前面叙述的那样，调用基础类构建器。此时，被覆盖的draw()方法会得到调用（的确是在RoundGlyph构建器调用之前），此时会发现radius的值为0，这是由于步骤(1)造成的。 (3) 按照原先声明的顺序调用成员初始化代码。 (4) 调用衍生类构建器的主体。 采取这些操作要求有一个前提，那就是所有东西都至少要初始化成零（或者某些特殊数据类型与“零”等价的值），而不是仅仅留作垃圾。其中包括通过“合成”技术嵌入一个类内部的对象句柄。如果假若忘记初始化那个句柄，就会在运行期间出现违例事件。其他所有东西都会变成零，这在观看结果时通常是一个严重的警告信号。\n在另一方面，应对这个程序的结果提高警惕。从逻辑的角度说，我们似乎已进行了无懈可击的设计，所以它的错误行为令人非常不可思议。而且没有从编译器那里收到任何报错信息（C++在这种情况下会表现出更合理的行为）。象这样的错误会很轻易地被人忽略，而且要花很长的时间才能找出。\n因此，设计构建器时一个特别有效的规则是：用尽可能简单的方法使对象进入就绪状态；如果可能，避免调用任何方法。在构建器内唯一能够安全调用的是在基础类中具有final属性的那些方法（也适用于private方法，它们自动具有final属性）。这些方法不能被覆盖，所以不会出现上述潜在的问题。\n7.8 通过继承进行设计 学习了多形性的知识后，由于多形性是如此“聪明”的一种工具，所以看起来似乎所有东西都应该继承。但假如过度使用继承技术，也会使自己的设计变得不必要地复杂起来。事实上，当我们以一个现成类为基础建立一个新类时，如首先选择继承，会使情况变得异常复杂。\n一个更好的思路是首先选择“合成”——如果不能十分确定自己应使用哪一个。合成不会强迫我们的程序设计进入继承的分级结构中。同时，合成显得更加灵活，因为可以动态选择一种类型（以及行为），而继承要求在编译期间准确地知道一种类型。下面这个例子对此进行了阐释：\ninterface Actor { void act(); } class HappyActor implements Actor { public void act() { System.out.println(\u0026#34;HappyActor\u0026#34;); } } class SadActor implements Actor { public void act() { System.out.println(\u0026#34;SadActor\u0026#34;); } } class Stage { Actor a = new HappyActor(); void change() { a = new SadActor(); } void go() { a.act(); } } public class Transmogrify { public static void main(String[] args) { Stage s = new Stage(); s.go(); // Prints \u0026#34;HappyActor\u0026#34; s.change(); s.go(); // Prints \u0026#34;SadActor\u0026#34; } } ///:~ 在这里，一个Stage对象包含了指向一个Actor的句柄，后者被初始化成一个HappyActor对象。这意味着go()会产生特定的行为。但由于句柄在运行期间可以重新与一个不同的对象绑定或结合起来，所以SadActor对象的句柄可在a中得到替换，然后由go()产生的行为发生改变。这样一来，我们在运行期间就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。\n一条常规的设计准则是：用继承表达行为间的差异，并用成员变量表达状态的变化。在上述例子中，两者都得到了应用：继承了两个不同的类，用于表达act()方法的差异；而Stage通过合成技术允许它自己的状态发生变化。在这种情况下，那种状态的改变同时也产生了行为的变化。\n具体该如何应用“合成”、“继承”在 6.10 总结 有说明\n7.8.1 纯继承与扩展 学习继承时，为了创建继承分级结构，看来最明显的方法是采取一种“纯粹”的手段。也就是说，只有在基础类或“接口”中已建立的方法才可在衍生类中被覆盖\n可将其描述成一种纯粹的“属于”关系，因为一个类的接口已规定了它到底“是什么”或者“属于什么”。通过继承，可保证所有衍生类都只拥有基础类的接口。如果按上述示意图操作，衍生出来的类除了基础类的接口之外，也不会再拥有其他什么。\n可将其想象成一种“纯替换”，因为衍生类对象可为基础类完美地替换掉。使用它们的时候，我们根本没必要知道与子类有关的任何额外信息。\n也就是说，基础类可接收我们发给衍生类的任何消息，因为两者拥有完全一致的接口。我们要做的全部事情就是从衍生上溯造型，而且永远不需要回过头来检查对象的准确类型是什么。所有细节都已通过多形性获得了完美的控制。 若按这种思路考虑问题，那么一个纯粹的“属于”关系似乎是唯一明智的设计方法，其他任何设计方法都会导致混乱不清的思路，而且在定义上存在很大的困难。但这种想法又属于另一个极端。经过细致的研究，我们发现扩展接口对于一些特定问题来说是特别有效的方案。可将其称为“类似于”关系，因为扩展后的衍生类“类似于”基础类——它们有相同的基础接口——但它增加了一些特性，要求用额外的方法加以实现。\n尽管这是一种有用和明智的做法（由具体的环境决定），但它也有一个缺点：衍生类中对接口扩展的那一部分不可在基础类中使用。所以一旦上溯造型，就不可再调用新方法：\n若在此时不进行上溯造型，则不会出现此类问题。但在许多情况下，都需要重新核实对象的准确类型，使自己能访问那个类型的扩展方法。在后面的小节里，我们具体讲述了这是如何实现的。\n7.8.2 下溯造型与运行期类型标识 由于我们在上溯造型（在继承结构中向上移动）期间丢失了具体的类型信息，所以为了获取具体的类型信息——亦即在分级结构中向下移动——我们必须使用 “下溯造型”技术。然而，我们知道一个上溯造型肯定是安全的；基础类不可能再拥有一个比衍生类更大的接口。因此，我们通过基础类接口发送的每一条消息都肯定能够接收到。但在进行下溯造型的时候，我们（举个例子来说）并不真的知道一个几何形状实际是一个圆，它完全可能是一个三角形、方形或者其他形状。\n为解决这个问题，必须有一种办法能够保证下溯造型正确进行。只有这样，我们才不会冒然造型成一种错误的类型，然后发出一条对象不可能收到的消息。这样做是非常不安全的。\n在某些语言中（如C++），为了进行保证“类型安全”的下溯造型，必须采取特殊的操作。但在Java中，所有造型都会自动得到检查和核实！所以即使我们只是进行一次普通的括弧造型，进入运行期以后，仍然会毫无留情地对这个造型进行检查，保证它的确是我们希望的那种类型。如果不是，就会得到一个ClassCastException（类造型违例）。在运行期间对类型进行检查的行为叫作“运行期类型标识”（RTTI）。\n和在示意图中一样，MoreUseful（更有用的）对Useful（有用的）的接口进行了扩展。但由于它是继承来的，所以也能上溯造型到一个Useful。我们可看到这会在对数组x（位于main()中）进行初始化的时候发生。由于数组中的两个对象都属于Useful类，所以可将f()和g()方法同时发给它们两个。而且假如试图调用u()（它只存在于MoreUseful），就会收到一条编译期出错提示。\n若想访问一个MoreUseful对象的扩展接口，可试着进行下溯造型。如果它是正确的类型，这一行动就会成功。否则，就会得到一个ClassCastException。我们不必为这个违例编写任何特殊的代码，因为它指出的是一个可能在程序中任何地方发生的一个编程错误。\nRTTI的意义远不仅仅反映在造型处理上。例如，在试图下溯造型之前，可通过一种方法了解自己处理的是什么类型。整个第11章都在讲述Java运行期类型标识的方方面面。\n7.9 总结 “多形性”意味着“不同的形式”。在面向对象的程序设计中，我们有相同的外观（基础类的通用接口）以及使用那个外观的不同形式：动态绑定或组织的、不同版本的方法。\n通过这一章的学习，大家已知道假如不利用数据抽象以及继承技术，就不可能理解、甚至去创建多形性的一个例子。多形性是一种不可独立应用的特性（就象一个switch语句），只可与其他元素协同使用。我们应将其作为类总体关系的一部分来看待。人们经常混淆Java其他的、非面向对象的特性，比如方法过载等，这些特性有时也具有面向对象的某些特征。但不要被愚弄：如果以后没有绑定，就不成其为多形性。\n为使用多形性乃至面向对象的技术，特别是在自己的程序中，必须将自己的编程视野扩展到不仅包括单独一个类的成员和消息，也要包括类与类之间的一致性以及它们的关系。尽管这要求学习时付出更多的精力，但却是非常值得的，因为只有这样才可真正有效地加快自己的编程速度、更好地组织代码、更容易做出包容面广的程序以及更易对自己的代码进行维护与扩展。\n"},{"id":151,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/","title":"Thinking in Java 第8章 对象的容纳","parent":"Thinking In Java","content":" 第8章 对象的容纳 “如果一个程序只含有数量固定的对象，而且已知它们的存在时间，那么这个程序可以说是相当简单的。”\n通常，我们的程序需要根据程序运行时才知道的一些标准创建新对象。若非程序正式运行，否则我们根本不知道自己到底需要多少数量的对象，甚至不知道它们的准确类型。为了满足常规编程的需要，我们要求能在任何时候、任何地点创建任意数量的对象。所以不可依赖一个已命名的句柄来容纳自己的每一个对象， 因为根本不知道自己实际需要多少这样的东西。\n为解决这个非常关键的问题，Java提供了容纳对象（或者对象的句柄）的多种方式。其中内建的类型是数组，我们之前已讨论过它，本章准备加深大家对它的认识。此外，Java的工具（实用程序）库提供了一些“集合类”（亦称作“容器类”，但该术语已由AWT使用，所以这里仍采用“集合”这一称呼）。利用这些集合类，我们可以容纳乃至操纵自己的对象。本章的剩余部分会就此进行详细讨论。\n8.1 数组 数组只是容纳对象的一种方式。但由于还有其他大量方法可容纳数组，所以是哪些地方使数组显得如此特别呢？ 有两方面的问题将数组与其他集合类型区分开来：效率和类型。对于Java来说，为保存和访问一系列对象（实际是对象的句柄）数组，最有效的方法莫过于数组。数组实际代表一个简单的线性序列，它使得元素的访问速度非常快，但我们却要为这种速度付出代价：创建一个数组对象时，它的大小是固定的，而且不可在那个数组对象的“存在时间”内发生改变。可创建特定大小的一个数组，然后假如用光了存储空间，就再创建一个新数组，将所有句柄从旧数组移到新数组。这属于“矢量”（Vector）类的行为，本章稍后还会详细讨论它。然而，由于为这种大小的灵活性要付出较大的代价，所以我们认为矢量的效率并没有数组高。\nC++的矢量类知道自己容纳的是什么类型的对象，但同Java的数组相比，它却有一个明显的缺点：C++矢量类的operator[]不能进行范围检查，所以很容易超出边界（然而，它可以查询vector有多大，而且at()方法确实能进行范围检查）。在Java中，无论使用的是数组还是集合，都会进行范围检查——若超过边界，就会获得一个RuntimeException（运行期违例）错误。正如大家在第9章会学到的那样，这类违例指出的是一个程序员错误，所以不需要在代码中检查它。在另一方面，由于C++的vector不进行范围检查，所以访问速度较快——在Java中，由于对数组和集合都要进行范围检查，所以对性能有一定的影响。\n本章还要学习另外几种常见的集合类：Vector（矢量）、Stack（堆栈）以及Hashtable（散列表）。这些类都涉及对对象的处理——好象它们没有特定的类型。换言之，它们将其当作Object类型处理（Object类型是Java中所有类的“根”类）。从某个角度看，这种处理方法是非常合理的：我们仅需构建一个集合，然后任何Java对象都可以进入那个集合（除基本数据类型外——可用Java的基本类型封装类将其作为常数置入集合，或者将其封装到自己的类内，作为可以变化的值使用）。这再一次反映了数组优于常规集合：创建一个数组时，可令其容纳一种特定的类型。这意味着可进行编译期类型检查，预防自己设置了错误的类型，或者错误指定了准备提取的类型。当然，在编译期或者运行期，Java会防止我们将不当的消息发给一个对象。所以我们不必考虑自己的哪种做法更加危险，只要编译器能及时地指出错误，同时在运行期间加快速度，目的也就达到了。此外，用户很少会对一次违例事件感到非常惊讶的。\n考虑到执行效率和类型检查，应尽可能地采用数组。然而，当我们试图解决一个更常规的问题时，数组的局限也可能显得非常明显。在研究过数组以后，本章剩余的部分将把重点放到Java提供的集合类身上。\n8.1.1 数组和第一类对象 无论使用的数组属于什么类型，数组标识符实际都是指向真实对象的一个句柄。那些对象本身是在内存“堆”里创建的。堆对象既可“隐式”创建（即默认产生），亦可“显式”创建（即明确指定，用一个new表达式）。堆对象的一部分（实际是我们能访问的唯一字段或方法）是只读的length（长度）成员，它告诉我们那个数组对象里最多能容纳多少元素。对于数组对象，“[]”语法是我们能采用的唯一另类访问方法。\n下面这个例子展示了对数组进行初始化的不同方式，以及如何将数组句柄分配给不同的数组对象。它也揭示出对象数组和基本数据类型数组在使用方法上几乎是完全一致的。唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体的数值（若在执行此程序时遇到困难，请参考第3章的“赋值”小节）：\nlength只告诉我们可将多少元素置入那个数组。换言之，我们只知道数组对象的大小或容量，不知其实际容纳了多少个元素。 尽管如此，由于数组对象在创建之初会自动初始化成null，所以可检查它是否为null，判断一个特定的数组“空位”是否容纳一个对象。类似地，由基本数据类型构成的数组会自动初始化成零（针对数值类型）、null（字符类型）或者false（布尔类型）。\nJava 1.1加入了一种新的数组初始化语法，可将其想象成“动态集合初始化”。\nhide(new Weeble[] {new Weeble(), new Weeble() }); 对于由基本数据类型构成的数组，它们的运作方式与对象数组极为相似，只是前者直接包容了基本类型的数据值。\n集合类只能容纳对象句柄。但对一个数组，却既可令其直接容纳基本类型的数据，亦可容纳指向对象的句柄。\n创建和访问一个基本数据类型数组，那么比起访问一个封装数据的集合，前者的效率会高出许多。\n当然，假如准备一种基本数据类型，同时又想要集合的灵活性（在需要的时候可自动扩展，腾出更多的空间），就不宜使用数组，必须使用由封装的数据构成的一个集合。大家或许认为针对每种基本数据类型，都应有一种特殊类型的Vector。但Java并未提供这一特性。某些形式的建模机制或许会在某一天帮助Java更好地解决这个问题（注释①）。\n①：这儿是C++比Java做得好的一个地方，因为C++通过template关键字提供了对“参数化类型”的支持。\n8.1.2 数组的返回 假定我们现在想写一个方法，同时不希望它仅仅返回一样东西，而是想返回一系列东西。此时，象C和C++这样的语言会使问题复杂化，因为我们不能返回一个数组，只能返回指向数组的一个指针。这样就非常麻烦，因为很难控制数组的“存在时间”，它很容易造成内存“漏洞”的出现。\nJava采用的是类似的方法，但我们能“返回一个数组”。当然，此时返回的实际仍是指向数组的指针。但在Java里，我们永远不必担心那个数组的是否可用——只要需要，它就会自动存在。而且垃圾收集器会在我们完成后自动将其清除。\n返回数组与返回其他任何对象没什么区别——最终返回的都是一个句柄。\n8.2 集合 为容纳一组对象，最适宜的选择应当是数组。而且假如容纳的是一系列基本数据类型，更是必须采用数组。\nJava提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。与拥有集合功能的其他语言相比，尽管这儿的数量显得相当少，但仍然能用它们解决数量惊人的实际问题。\n这些集合类具有形形色色的特征。例如，Stack实现了一个LIFO（先入先出）序列，而Hashtable是一种“关联数组”，允许我们将任何对象关联起来。除此以外，所有Java集合类都能自动改变自身的大小。所以，我们在编程时可使用数量众多的对象，同时不必担心会将集合弄得有多大。\n8.2.1 缺点：类型未知 使用Java集合的“缺点”是在将对象置入一个集合时丢失了类型信息。之所以会发生这种情况，是由于当初编写集合时，那个集合的程序员根本不知道用户到底想把什么类型置入集合。若指示某个集合只允许特定的类型，会妨碍它成为一个“常规用途”的工具，为用户带来麻烦。为解决这个问题，集合实际容纳的是类型为Object的一些对象的句柄。这种类型当然代表Java中的所有对象，因为它是所有类的根。当然，也要注意这并不包括基本数据类型，因为它们并不是从“任何东西”继承来的。这是一个很好的方案，只是不适用下述场合：\n(1) 将一个对象句柄置入集合时，由于类型信息会被抛弃，所以任何类型的对象都可进入我们的集合——即便特别指示它只能容纳特定类型的对象。举个例子来说，虽然指示它只能容纳猫，但事实上任何人都可以把一条狗扔进来。 (2) 由于类型信息不复存在，所以集合能肯定的唯一事情就是自己容纳的是指向一个对象的句柄。正式使用它之前，必须对其进行造型，使其具有正确的类型。 值得欣慰的是，Java不允许人们滥用置入集合的对象。假如将一条狗扔进一个猫的集合，那么仍会将集合内的所有东西都看作猫，所以在使用那条狗时会得到一个“违例”错误。在同样的意义上，假若试图将一条狗的句柄“造型”到一只猫，那么运行期间仍会得到一个“违例”错误。\n这些处理的意义都非常深远。尽管显得有些麻烦，但却获得了安全上的保证。我们从此再难偶然造成一些隐藏得深的错误。若程序的一个部分（或几个部分）将对象插入一个集合，但我们只是通过一次违例在程序的某个部分发现一个错误的对象置入了集合，就必须找出插入错误的位置。当然，可通过检查代码达到这个目的，但这或许是最笨的调试工具。另一方面，我们可从一些标准化的集合类开始自己的编程。尽管它们在功能上存在一些不足，且显得有些笨拙，但却能保证没有隐藏的错误。\n错误有时并不显露出来 在某些情况下，程序似乎正确地工作，不造型回我们原来的类型。第一种情况是相当特殊的：String类从编译器获得了额外的帮助，使其能够正常工作。只要编译器期待的是一个String对象，但它没有得到一个，就会自动调用在Object里定义、并且能够由任何Java类覆盖的toString()方法。这个方法能生成满足要求的String对象，然后在我们需要的时候使用。\n参数化类型 这类问题并不是孤立的——我们许多时候都要在其他类型的基础上创建新类型。此时，在编译期间拥有特定的类型信息是非常有帮助的。这便是“参数化类型”的概念。在C++中，它由语言通过“模板”获得了直接支持。至少，Java保留了关键字generic，期望有一天能够支持参数化类型。但我们现在无法确定这一天何时会来临。\n8.3 枚举器（迭代器） 在任何集合类中，必须通过某种方法在其中置入对象，再用另一种方法从中取得对象。毕竟，容纳各种各样的对象正是集合的首要任务。在Vector中，addElement()便是我们插入对象采用的方法，而elementAt()是提取对象的唯一方法。Vector非常灵活，我们可在任何时候选择任何东西，并可使用不同的索引选择多个元素。\n若从更高的角度看这个问题，就会发现它的一个缺陷：需要事先知道集合的准确类型，否则无法使用。乍看来，这一点似乎没什么关系。但假若最开始决定使用Vector，后来在程序中又决定（考虑执行效率的原因）改变成一个List（属于Java1.2集合库的一部分），这时又该如何做呢？ 可利用“反复器”（Iterator）的概念达到这个目的。它可以是一个对象，作用是遍历一系列对象，并选择那个序列中的每个对象，同时不让客户程序员知道或关注那个序列的基础结构。此外，我们通常认为反复器是一种“轻量级”对象；也就是说，创建它只需付出极少的代价。但也正是由于这个原因，我们常发现反复器存在一些似乎很奇怪的限制。例如，有些反复器只能朝一个方向移动。 Java的Enumeration（枚举，注释②）便是具有这些限制的一个反复器的例子。除下面这些外，不可再用它做其他任何事情：\n(1) 用一个名为elements()的方法要求集合为我们提供一个Enumeration。我们首次调用它的nextElement()时，这个Enumeration会返回序列中的第一个元素。\n(2) 用nextElement()获得下一个对象。\n(3) 用hasMoreElements()检查序列中是否还有更多的对象。\n②：“反复器”这个词在C++和OOP的其他地方是经常出现的，所以很难确定为什么Java的开发者采用了这样一个奇怪的名字。Java 1.2的集合库修正了这个问题以及其他许多问题。\n只可用Enumeration做这些事情，不能再有更多。它属于反复器一种简单的实现方式，但功能依然十分强大。为体会它的运作过程，让我们复习一下本章早些时候提到的CatsAndDogs.java程序。在原始版本中，elementAt()方法用于选择每一个元素，但在下述修订版中，可看到使用了一个“枚举”：\n使用Enumeration，我们不必关心集合中的元素数量。所有工作均由hasMoreElements()和nextElement()自动照管了。\n注意其中没有与序列类型有关的信息。我们拥有的全部东西便是Enumeration。为了解有关序列的情况，一个Enumeration便足够了：可取得下一个对象，亦可知道是否已抵达了末尾。取得一系列对象，然后在其中遍历，从而执行一个特定的操作——这是一个颇有价值的编程概念，本书许多地方都会沿用这一思路。 这个看似特殊的例子甚至可以更为通用，因为它使用了常规的toString()方法（之所以称为常规，是由于它属于Object类的一部分）。下面是调用打印的另一个方法（尽管在效率上可能会差一些）：\n它采用了封装到Java内部的“自动转换成字串”技术。一旦编译器碰到一个字串，后面跟随一个“+”，就会希望后面又跟随一个字串，并自动调用toString()。在Java 1.1中，第一个字串是不必要的；所有对象都会转换成字串。亦可对此执行一次造型，获得与调用toString()同样的效果：\n但我们想做的事情通常并不仅仅是调用Object方法，所以会再度面临类型造型的问题。对于自己感兴趣的类型，必须假定自己已获得了一个Enumeration，然后将结果对象造型成为那种类型（若操作错误，会得到运行期违例）。\n总结：\n这章就是讲迭代器的，自己去看一下集合的迭代器实现就行了。\n8.4 集合的类型 标准Java 1.0和1.1库配套提供了非常少的一系列集合类。但对于自己的大多数编程要求，它们基本上都能胜任。正如大家到本章末尾会看到的，Java 1.2提供的是一套重新设计过的大型集合库。\n这章是讲集合的先看两张图 集合框架被设计成要满足以下几个目标。\n该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 8.4.1 Vector 矢量 8.4.2 BitSet 8.4.3 Stack Stack有时也可以称为“后入先出”（LIFO）集合。换言之，我们在堆栈里最后“压入”的东西将是以后第一个“弹出”的。和其他所有Java集合一样，我们压入和弹出的都是“对象”，所以必须对自己弹出的东西进行“造型”。\n一种很少见的做法是拒绝使用Vector作为一个Stack的基本构成元素，而是从Vector里“继承”一个Stack。这样一来，它就拥有了一个Vector的所有特征及行为，另外加上一些额外的Stack行为。很难判断出设计者到底是明确想这样做，还是属于一种固有的设计。\n8.4.4 Hashtable Vector允许我们用一个数字从一系列对象中作出选择，所以它实际是将数字同对象关联起来了。但假如我们想根据其他标准选择一系列对象呢？堆栈就是这样的一个例子：它的选择标准是“最后压入堆栈的东西”。这种“从一系列对象中选择”的概念亦可叫作一个“映射”、“字典”或者“关联数组”。从概念上讲，它看起来象一个Vector，但却不是通过数字来查找对象，而是用另一个对象来查找它们！这通常都属于一个程序中的重要进程。\n在Java中，这个概念具体反映到抽象类Dictionary身上。该类的接口是非常直观的size()告诉我们其中包含了多少元素；isEmpty()判断是否包含了元素（是则为true）；put(Object key, Object value)添加一个值（我们希望的东西），并将其同一个键关联起来（想用于搜索它的东西）；get(Object key)获得与某个键对应的值；而remove(Object Key)用于从列表中删除“键－值”对。还可以使用枚举技术：keys()产生对键的一个枚举（Enumeration）；而elements()产生对所有值的一个枚举。这便是一个Dictionary（字典）的全部。\n标准Java库只包含Dictionary的一个变种，名为Hashtable（散列表，注释③）。Java的散列表具有与AssocArray相同的接口（因为两者都是从Dictionary继承来的）。但有一个方面却反映出了差别：执行效率。若仔细想想必须为一个get()做的事情，就会发现在一个Vector里搜索键的速度要慢得多。但此时用散列表却可以加快不少速度。不必用冗长的线性搜索技术来查找一个键，而是用一个特殊的值，名为“散列码”。散列码可以获取对象中的信息，然后将其转换成那个对象“相对唯一”的整数（int）。所有对象都有一个散列码，而hashCode()是根类Object的一个方法。Hashtable获取对象的hashCode()，然后用它快速查找键。这样可使性能得到大幅度提升（④）。散列表的具体工作原理已超出了本书的范围（⑤）——大家只需要知道散列表是一种快速的“字典”（Dictionary）即可，而字典是一种非常有用的工具。\n我们用第二个实例进行检索。 大家或许认为此时要做的全部事情就是正确地覆盖hashCode()。但这样做依然行不能，除非再做另一件事情：覆盖也属于Object一部分的equals()。当散列表试图判断我们的键是否等于表内的某个键时，就会用到这个方法。同样地，默认的Object.equals()只是简单地比较对象地址，所以一个Groundhog(3)并不等于另一个Groundhog(3)。 因此，为了在散列表中将自己的类作为键使用，必须同时覆盖hashCode()和equals()。\n8.4.5 再论枚举器 我们现在可以开始演示Enumeration（枚举）的真正威力：将穿越一个序列的操作与那个序列的基础结构分隔开。在下面的例子里，PrintData类用一个Enumeration在一个序列中移动，并为每个对象都调用toString()方法。此时创建了两个不同类型的集合：一个Vector和一个Hashtable。并且在它们里面分别填充Mouse和Hamster对象（本章早些时候已定义了这些类；注意必须先编译HamsterMaze.java和WorksAnyway.java，否则下面的程序不能编译）。由于Enumeration隐藏了基层集合的结构，所以PrintData不知道或者不关心Enumeration来自于什么类型的集合：\n8.5 排序 Java 1.0和1.1库都缺少的一样东西是算术运算，甚至没有最简单的排序运算方法。因此，我们最好创建一个Vector，利用经典的Quicksort（快速排序）方法对其自身进行排序。\n编写通用的排序代码时，面临的一个问题是必须根据对象的实际类型来执行比较运算，从而实现正确的排序。当然，一个办法是为每种不同的类型都写一个不同的排序方法。然而，应认识到假若这样做，以后增加新类型时便不易实现代码的重复利用。\n程序设计一个主要的目标就是“将发生变化的东西同保持不变的东西分隔开”。在这里，保持不变的代码是通用的排序算法，而每次使用时都要变化的是对象的实际比较方法。因此，我们不可将比较代码“硬编码”到多个不同的排序例程内，而是采用“回调”技术。利用回调，经常发生变化的那部分代码会封装到它自己的类内，而总是保持相同的代码则“回调”发生变化的代码。这样一来，不同的对象就可以表达不同的比较方式，同时向它们传递相同的排序代码。\n每次调用addElement()时，都可对Vector进行排序，而且将其连续保持在一个排好序的状态。但在开始读取之前，人们总是向一个Vector添加大量元素。所以与其在每个addElement()后排序，不如一直等到有人想读取Vector，再对其进行排序。后者的效率要高得多。这种除非绝对必要，否则就不采取行动的方法叫作“懒惰求值”（还有一种类似的技术叫作“懒惰初始化”——除非真的需要一个字段值，否则不进行初始化）。\nComparator\u0026lt;Users\u0026gt; comparator = new Comparator\u0026lt;Users\u0026gt;() {\r@Override\rpublic int compare(Users s1, Users s2) {\r//先排年龄\rSystem.out.println(s1.age.compareTo(s2.age));\r//return s1.age.compareTo(s2.age);//降序\rreturn s2.age.compareTo(s1.age);//升序\r}\r};\r//这里就会自动根据规则进行排序\rCollections.sort(list, comparator); 8.6 通用集合库 8.7 新集合 对我来说，集合类属于最强大的一种工具，特别适合在原创编程中使用。大家可能已感觉到我对Java 1.1提供的集合多少有点儿失望。因此，看到Java 1.2对集合重新引起了正确的注意后，确实令人非常愉快。这个版本的集合也得到了完全的重新设计（由Sun公司的Joshua Bloch）。我认为新设计的集合是Java 1.2中两项最主要的特性之一（另一项是Swing库，将在第13章叙述），因为它们极大方便了我们的编程，也使Java变成一种更成熟的编程系统。\n有些设计使得元素间的结合变得更紧密，也更容易让人理解。例如，许多名字都变得更短、更明确了，而且更易使用；类型同样如此。有些名字进行了修改，更接近于通俗：我感觉特别好的一个是用“反复器”（Inerator）代替了“枚举”（Enumeration）。\n此次重新设计也加强了集合库的功能。现在新增的行为包括链接列表、队列以及撤消组队（即“双终点队列”）。\n新的集合库考虑到了“容纳自己对象”的问题，并将其分割成两个明确的概念： (1) 集合（Collection）：一组单独的元素，通常应用了某种规则。在这里，一个List（列表）必须按特定的顺序容纳元素，而一个Set（集）不可包含任何重复的元素。相反，“包”（Bag）的概念未在新的集合库中实现，因为“列表”已提供了类似的功能。 (2) 映射（Map）：一系列“键－值”对（这已在散列表身上得到了充分的体现）。从表面看，这似乎应该成为一个“键－值”对的“集合”，但假若试图按那种方式实现它，就会发现实现过程相当笨拙。这进一步证明了应该分离成单独的概念。另一方面，可以方便地查看Map的某个部分。只需创建一个集合，然后用它表示那一部分即可。这样一来，Map就可以返回自己键的一个Set、一个包含自己值的List或者包含自己“键－值”对的一个List。和数组相似，Map可方便扩充到多个“维”，毋需涉及任何新概念。只需简单地在一个Map里包含其他Map（后者又可以包含更多的Map，以此类推）。\nCollection和Map可通过多种形式实现，具体由编程要求决定。下面列出的是一个帮助大家理解的新集合示意图：\n这张图刚开始的时候可能让人有点儿摸不着头脑，但在通读了本章以后，相信大家会真正理解它实际只有三个集合组件：Map，List和Set。而且每个组件实际只有两、三种实现方式（注释⑥），而且通常都只有一种特别好的方式。只要看出了这一点，集合就不会再令人生畏。\n⑥：写作本章时，Java 1.2尚处于β测试阶段，所以这张示意图没有包括以后会加入的TreeSet。 虚线框代表“接口”，点线框代表“抽象”类，而实线框代表普通（实际）类。点线箭头表示一个特定的类准备实现一个接口（在抽象类的情况下，则是“部分”实现一个接口）。双线箭头表示一个类可生成箭头指向的那个类的对象。例如，任何集合都可以生成一个反复器（Iterator），而一个列表可以生成一个ListIterator（以及原始的反复器，因为列表是从集合继承的）。\n在类的分级结构中，可看到大量以“Abstract”（抽象）开头的类，这刚开始可能会使人感觉迷惑。它们实际上是一些工具，用于“部分”实现一个特定的接口。举个例子来说，假如想生成自己的Set，就不是从Set接口开始，然后自行实现所有方法。相反，我们可以从AbstractSet继承，只需极少的工作即可得到自己的新类。尽管如此，新集合库仍然包含了足够的功能，可满足我们的几乎所有需求。所以考虑到我们的目的，可忽略所有以“Abstract”开头的类。\nArrayList是一个典型的Collection，它代替了Vector的位置。\n利用iterator()方法，所有集合都能生成一个“反复器”（Iterator）。反复器其实就象一个“枚举”（Enumeration），是后者的一个替代物，只是：\n(1) 它采用了一个历史上默认、而且早在OOP中得到广泛采纳的名字（反复器）。 (2) 采用了比Enumeration更短的名字：hasNext()代替了hasMoreElement()，而next()代替了nextElement()。 (3) 添加了一个名为remove()的新方法，可删除由Iterator生成的上一个元素。所以每次调用next()的时候，只需调用remove()一次。 8.7.1 使用 Collections Collections 总结了用一个集合能做的所有事情（亦可对Set和List做同样的事情，尽管List还提供了一些额外的功能）。Map 要单独对待。\n8.7.2 使用Lists List（接口） 顺序是List最重要的特性；它可保证元素按照规定的顺序排列。List为Collection添加了大量方法，以便我们在List中部插入和删除元素（只推荐对LinkedList这样做）。List也会生成一个ListIterator（列表反复器），利用它可在一个列表里朝两个方向遍历，同时插入和删除位于列表中部的元素（同样地，只建议对LinkedList这样做）\nArrayList＊ 由一个数组后推得到的List。作为一个常规用途的对象容器使用，用于替换原先的Vector。允许我们快速访问元素，但在从列表中部插入和删除元素时，速度却嫌稍慢。一般只应该用ListIterator对一个ArrayList进行向前和向后遍历，不要用它删除和插入元素；与LinkedList相比，它的效率要低许多\nLinkedList 提供优化的顺序访问性能，同时可以高效率地在列表中部进行插入和删除操作。但在进行随机访问时，速度却相当慢，此时应换用ArrayList。也提供了addFirst()，addLast()，getFirst()，getLast()，removeFirst()以及removeLast()（未在任何接口或基础类中定义），以便将其作为一个规格、队列以及一个双向队列使用。\n8.7.3 使用Sets Set拥有与Collection完全相同的接口，所以和两种不同的List不同，它没有什么额外的功能。相反，Set完全就是一个Collection，只是具有不同的行为（这是实例和多形性最理想的应用：用于表达不同的行为）。在这里，一个Set只允许每个对象存在一个实例（正如大家以后会看到的那样，一个对象的“值”的构成是相当复杂的）。\nSet（接口） 添加到Set的每个元素都必须是独一无二的；否则Set就不会添加重复的元素。添加到Set里的对象必须定义equals()，从而建立对象的唯一性。Set拥有与Collection完全相同的接口。一个Set不能保证自己可按任何特定的顺序维持自己的元素\nHashSet＊ 用于除非常小的以外的所有Set。对象也必须定义hashCode() ArraySet 由一个数组后推得到的Set。面向非常小的Set设计，特别是那些需要频繁创建和删除的。对于小Set，与HashSet相比，ArraySet创建和反复所需付出的代价都要小得多。但随着Set的增大，它的性能也会大打折扣。不需要HashCode() TreeSet 由一个“红黑树”后推得到的顺序Set（注释⑦）。这样一来，我们就可以从一个Set里提到一个顺序集合\nHashSet维持的顺序与ArraySet是不同的。这是由于它们采用了不同的方法来保存元素，以便它们以后的定位。ArraySet保持着它们的顺序状态，而HashSet使用一个散列函数，这是特别为快速检索设计的）。创建自己的类型时，一定要注意Set需要通过一种方式来维持一种存储顺序，\n8.7.4 使用Maps Map（接口） 维持“键－值”对应关系（对），以便通过一个键查找相应的值\nHashMap＊ 基于一个散列表实现（用它代替Hashtable）。针对“键－值”对的插入和检索，这种形式具有最稳定的性能。可通过构建器对这一性能进行调整，以便设置散列表的“能力”和“装载因子”\nArrayMap 由一个ArrayList后推得到的Map。对反复的顺序提供了精确的控制。面向非常小的Map设计，特别是那些需要经常创建和删除的。对于非常小的Map，创建和反复所付出的代价要比HashMap低得多。但在Map变大以后，性能也会相应地大幅度降低\nTreeMap 在一个“红－黑”树的基础上实现。查看键或者“键－值”对时，它们会按固定的顺序排列（取决于Comparable或 Comparator，稍后即会讲到）。TreeMap最大的好处就是我们得到的是已排好序的结果。TreeMap是含有subMap()方法的唯一一种Map，利用它可以返回树的一部分\nkeySet()方法会产生一个Set，它由Map中的键后推得来。在这儿，它只被当作一个Collection对待。values()也得到了类似的对待，它的作用是产生一个List，其中包含了Map中的所有值（注意键必须是独一无二的，而值可以有重复）。由于这些Collection是由Map后推得到的，所以一个Collection中的任何改变都会在相应的Map中反映出来。\n当创建自己的类，将其作为Map中的一个键使用时，必须注意到和以前的Set相同的问题。\n8.7.5 决定实施方案 从早些时候的那幅示意图可以看出，实际上只有三个集合组件：Map，List和Set。而且每个接口只有两种或三种实施方案。若需使用由一个特定的接口提供的功能，如何才能决定到底采取哪一种方案呢？\n为理解这个问题，必须认识到每种不同的实施方案都有自己的特点、优点和缺点。比如在那张示意图中，可以看到Hashtable，Vector和Stack的“特点”是它们都属于“传统”类，所以不会干扰原有的代码。但在另一方面，应尽量避免为新的（Java 1.2）代码使用它们。\n其他集合间的差异通常都可归纳为它们具体是由什么“后推”的。换言之，取决于物理意义上用于实施目标接口的数据结构是什么。例如，ArrayList，LinkedList以及Vector（大致等价于ArrayList）都实现了List接口，所以无论选用哪一个，我们的程序都会得到类似的结果。然而，ArrayList（以及Vector）是由一个数组后推得到的；而LinkedList是根据常规的双重链接列表方式实现的，因为每个单独的对象都包含了数据以及指向列表内前后元素的句柄。正是由于这个原因，假如想在一个列表中部进行大量插入和删除操作，那么LinkedList无疑是最恰当的选择（LinkedList还有一些额外的功能，建立于AbstractSequentialList中）。若非如此，就情愿选择ArrayList，它的速度可能要快一些。\n作为另一个例子，Set既可作为一个ArraySet实现，亦可作为HashSet实现。ArraySet是由一个ArrayList后推得到的，设计成只支持少量元素，特别适合要求创建和删除大量Set对象的场合使用。然而，一旦需要在自己的Set中容纳大量元素，ArraySet的性能就会大打折扣。写一个需要Set的程序时，应默认选择HashSet。而且只有在某些特殊情况下（对性能的提升有迫切的需求），才应切换到ArraySet。\n决定使用何种List 为体会各种List实施方案间的差异，最简便的方法就是进行一次性能测验。\n可以看出，在ArrayList中进行随机访问（即get()）以及循环反复是最划得来的；但对于LinkedList却是一个不小的开销。但另一方面，在列表中部进行插入和删除操作对于LinkedList来说却比ArrayList划算得多。我们最好的做法也许是先选择一个ArrayList作为自己的默认起点。以后若发现由于大量的插入和删除造成了性能的降低，再考虑换成LinkedList不迟。\n决定使用何种Set 可在ArraySet以及HashSet间作出选择，具体取决于Set的大小（如果需要从一个Set中获得一个顺序列表，请用TreeSet；注释⑧）。\n最后对ArraySet的测试只有500个元素，而不是1000个，因为它太慢了。\n进行add()以及contains()操作时，HashSet显然要比ArraySet出色得多，而且性能明显与元素的多寡关系不大。一般编写程序的时候，几乎永远用不着使用ArraySet。\n决定使用何种Map 选择不同的Map实施方案时，注意Map的大小对于性能的影响是最大的，\n由于Map的大小是最严重的问题，所以程序的计时测试按Map的大小（或容量）来分割时间，以便得到令人信服的测试结果。\n即使大小为10，ArrayMap的性能也要比HashMap差——除反复循环时以外。而在使用Map时，反复的作用通常并不重要（get()通常是我们时间花得最多的地方）。TreeMap提供了出色的put()以及反复时间，但get()的性能并不佳。但是，我们为什么仍然需要使用TreeMap呢？这样一来，我们可以不把它作为Map使用，而作为创建顺序列表的一种途径。树的本质在于它总是顺序排列的，不必特别进行排序（它的排序方式马上就要讲到）。一旦填充了一个TreeMap，就可以调用keySet()来获得键的一个Set“景象”。然后用toArray()产生包含了那些键的一个数组。随后，可用static方法Array.binarySearch()快速查找排好序的数组中的内容。当然，也许只有在HashMap的行为不可接受的时候，才需要采用这种做法。因为HashMap的设计宗旨就是进行快速的检索操作。最后，当我们使用Map时，首要的选择应该是HashMap。只有在极少数情况下才需要考虑其他方法。 此外，在上面那张表里，有另一个性能问题没有反映出来。下述程序用于测试不同类型Map的创建速度：\n8.7.7 排序和搜索 Java 1.2添加了自己的一套实用工具，可用来对数组或列表进行排列和搜索。这些工具都属于两个新类的“静态”方法。这两个类分别是用于排序和搜索数组的Arrays，以及用于排序和搜索列表的Collections。\n数组 Arrays类为所有基本数据类型的数组提供了一个过载的sort()和binarySearch()，它们亦可用于String和Object。下面这个例子显示出如何排序和搜索一个字节数组（其他所有基本数据类型都是类似的）以及一个String数组：\npackage c08.newcollections; import java.util.*; public class Array1 { static Random r = new Random(); static String ssource = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; + \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; static char[] src = ssource.toCharArray(); // Create a random String public static String randString(int length) { char[] buf = new char[length]; int rnd; for(int i = 0; i \u0026lt; length; i++) { rnd = Math.abs(r.nextInt()) % src.length; buf[i] = src[rnd]; } return new String(buf); } // Create a random array of Strings: public static String[] randStrings(int length, int size) { String[] s = new String[size]; for(int i = 0; i \u0026lt; size; i++) s[i] = randString(length); return s; } public static void print(byte[] b) { for(int i = 0; i \u0026lt; b.length; i++) System.out.print(b[i] + \u0026#34; \u0026#34;); System.out.println(); } public static void print(String[] s) { for(int i = 0; i \u0026lt; s.length; i++) System.out.print(s[i] + \u0026#34; \u0026#34;); System.out.println(); } public static void main(String[] args) { byte[] b = new byte[15]; r.nextBytes(b); // Fill with random bytes print(b); Arrays.sort(b); print(b); int loc = Arrays.binarySearch(b, b[10]); System.out.println(\u0026#34;Location of \u0026#34; + b[10] + \u0026#34; = \u0026#34; + loc); // Test String sort \u0026amp; search: String[] s = randStrings(4, 10); print(s); Arrays.sort(s); print(s); loc = Arrays.binarySearch(s, s[4]); System.out.println(\u0026#34;Location of \u0026#34; + s[4] + \u0026#34; = \u0026#34; + loc); } } ///:~ 类的第一部分包含了用于产生随机字串对象的实用工具，可供选择的随机字母保存在一个字符数组中。randString()返回一个任意长度的字串；而readStrings()创建随机字串的一个数组，同时给定每个字串的长度以及希望的数组大小。两个print()方法简化了对示范数组的显示。在main()中，Random.nextBytes()用随机选择的字节填充数组自变量（没有对应的Random方法用于创建其他基本数据类型的数组）。获得一个数组后，便可发现为了执行sort()或者binarySearch()，只需发出一次方法调用即可。与binarySearch()有关的还有一个重要的警告：若在执行一次binarySearch()之前不调用sort()，便会发生不可预测的行为，其中甚至包括无限循环。\n对String的排序以及搜索是相似的，但在运行程序的时候，我们会注意到一个有趣的现象：排序遵守的是字典顺序，亦即大写字母在字符集中位于小写字母的前面。因此，所有大写字母都位于列表的最前面，后面再跟上小写字母——Z居然位于a的前面。似乎连电话簿也是这样排序的。\n可比较与比较器 若用自己的Comparator来进行一次sort()，那么在使用binarySearch()时必须使用那个相同的Comparator。\nArrays类提供了另一个sort()方法，它会采用单个自变量：一个Object数组，但没有Comparator。这个sort()方法也必须用同样的方式来比较两个Object。通过实现Comparable接口，它采用了赋予一个类的“自然比较方法”。这个接口含有单独一个方法——compareTo()，能分别根据它小于、等于或者大于自变量而返回负数、零或者正数，从而实现对象的比较。下面这个例子简单地阐示了这一点：\n列表 可用与数组相同的形式排序和搜索一个列表（List）。用于排序和搜索列表的静态方法包含在类Collections中，但它们拥有与Arrays中差不多的签名：sort(List)用于对一个实现了Comparable的对象列表进行排序；binarySearch(List,Object)用于查找列表中的某个对象；sort(List,Comparator)利用一个“比较器”对一个列表进行排序；\n8.7.8 实用工具 Collections类中含有其他大量有用的实用工具：\n使Collection或Map不可修改\nCollection或Map的同步\nsynchronized关键字是“多线程”机制一个非常重要的部分。我们到第14章才会对这一机制作深入的探讨。在这儿，大家只需注意到Collections类提供了对整个容器进行自动同步的一种途径。它的语法与“不可修改”的方法是类似的：\n能查出除我们的进程自己需要负责的之外的、对容器的其他任何修改。若探测到有其他方面也准备修改容器，便会立即产生一个ConcurrentModificationException（并发修改违例）。我们将这一机制称为“立即失败”——它并不用更复杂的算法在“以后”侦测问题，而是“立即”产生违例。\n8.8 总结 8.9 练习 "},{"id":152,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC9%E7%AB%A0-%E8%BF%9D%E4%BE%8B%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/","title":"Thinking in Java 第9章 违例差错控制","parent":"Thinking In Java","content":" 第9章 违例差错控制 通过先进的错误纠正与恢复机制，我们可以有效地增强代码的健壮程度。对我们编写的每个程序来说，错误恢复都属于一个基本的考虑目标。它在Java中显得尤为重要，因为该语言的一个目标就是创建不同的程序组件，以便其他用户（客户程序员）使用。为构建一套健壮的系统，每个组件都必须非常健壮。 在Java里，违例控制的目的是使用尽可能精简的代码创建大型、可靠的应用程序，同时排除程序里那些不能控制的错误。 违例的概念很难掌握。但只有很好地运用它，才可使自己的项目立即获得显著的收益。Java强迫遵守违例所有方面的问题，所以无论库设计者还是客户程序员，都能够连续一致地使用它。\n9.1 基本违例 在违例条件的情况下，却无法继续下去，因为当地没有提供解决问题所需的足够多的信息。此时，我们能做的唯一事情就是跳出当地环境，将那个问题委托给一个更高级的负责人。这便是出现违例时出现的情况。\n9.1.1 违例自变量 关键字throw\n9.2 违例的捕获 为理解违例是如何捕获的，首先必须掌握“警戒区”的概念。它代表一个特殊的代码区域，有可能产生违例，并在后面跟随用于控制那些违例的代码。\n9.2.1 try块 可在那个方法内部设置一个特殊的代码块，用它捕获违例。这就叫作“try块”，因为要在这个地方“尝试”各种方法调用。try块属于一种普通的作用域，用一个try关键字开头：\ntry {\r// 可能产生违例的代码\r} 若用一种不支持违例控制的编程语言全面检查错误，必须用设置和错误检测代码将每个方法都包围起来——即便多次调用相同的方法。而在使用了违例控制技术后，可将所有东西都置入一个try块内，在同一地点捕获所有违例。这样便可极大简化我们的代码，并使其更易辨读，因为代码本身要达到的目标再也不会与繁复的错误检查混淆。\n9.2.2 违例控制器 当然，生成的违例必须在某个地方中止。这个“地方”便是违例控制器或者违例控制模块。而且针对想捕获的每种违例类型，都必须有一个相应的违例控制器。违例控制器紧接在try块后面，且用catch（捕获）关键字标记。如下所示：\ntry {\r// Code that might generate exceptions\r} catch(Type1 id1) {\r// Handle exceptions of Type1\r} catch(Type2 id2) {\r// Handle exceptions of Type2\r} catch(Type3 id3) {\r// Handle exceptions of Type3\r} 每个catch从句——即违例控制器——都类似一个小型方法，它需要采用一个（而且只有一个）特定类型的自变量。可在控制器内部使用标识符（id1，id2等等），就象一个普通的方法自变量那样。我们有时也根本不使用标识符，因为违例类型已提供了足够的信息，可有效处理违例。但即使不用，标识符也必须就位。 控制器必须“紧接”在try块后面。若“掷”出一个违例，违例控制机制就会搜寻自变量与违例类型相符的第一个控制器。随后，它会进入那个catch从句，并认为违例已得到控制（一旦catch从句结束，对控制器的搜索也会停止）。只有相符的catch从句才会得到执行；它与switch语句不同，后者在每个case后都需要一个break命令，防止误执行其他语句。 在try块内部，请注意大量不同的方法调用可能生成相同的违例，但只需要一个控制器。\n中断与恢复 在违例控制理论中，共存在两种基本方法。在“中断”方法中（Java和C++提供了对这种方法的支持），我们假定错误非常关键，没有办法返回违例发生的地方。无论谁只要“掷”出一个违例，就表明没有办法补救错误，而且也不希望再回来。 另一种方法叫作“恢复”。它意味着违例控制器有责任来纠正当前的状况，然后取得出错的方法，假定下一次会成功执行。若使用恢复，意味着在违例得到控制以后仍然想继续执行。在这种情况下，我们的违例更象一个方法调用——我们用它在Java中设置各种各样特殊的环境，产生类似于“恢复”的行为（换言之，此时不是“掷”出一个违例，而是调用一个用于解决问题的方法）。另外，也可以将自己的try块置入一个while循环里，用它不断进入try块，直到结果满意时为止。 从历史的角度看，若程序员使用的操作系统支持可恢复的违例控制，最终都会用到类似于中断的代码，并跳过恢复进程。所以尽管“恢复”表面上十分不错，但在实际应用中却显得困难重重。其中决定性的原因可能是：我们的控制模块必须随时留意是否产生了违例，以及是否包含了由产生位置专用的代码。这便使代码很难编写和维护——大型系统尤其如此，因为违例可能在多个位置产生。\n9.2.3 违例规范 在Java中，对那些要调用方法的客户程序员，我们要通知他们可能从自己的方法里“掷”出违例。这是一种有礼貌的做法，只有它才能使客户程序员准确地知道要编写什么代码来捕获所有潜在的违例。当然，若你同时提供了源码，客户程序员甚至能全盘检查代码，找出相应的throw语句。但尽管如此，通常并不随同源码提供库。为解决这个问题，Java提供了一种特殊的语法格式（并强迫我们采用），以便礼貌地告诉客户程序员该方法会“掷”出什么违例，令对方方便地加以控制。这便是我们在这里要讲述的“违例规范”，它属于方法声明的一部分，位于自变量（参数）列表的后面。\n违例规范采用了一个额外的关键字：throws；后面跟随全部潜在的违例类型。因此，我们的方法定义看起来应象下面这个样子：\nvoid f() throws tooBig, tooSmall, divZero { //... 9.2.4 捕获所有违例 具体的做法是捕获基础类违例类型Exception（也存在其他类型的基础违例，但Exception是适用于几乎所有编程活动的基础）\n打印异常堆栈信息\nvoid printStackTrace()\rvoid printStackTrace(PrintStream) 第一个版本会打印出标准错误，第二个则打印出我们的选择流程。若在Windows下工作，就不能重定向标准错误。因此，我们一般愿意使用第二个版本，并将结果送给System.out；这样一来，输出就可重定向到我们希望的任何路径。\n9.2.5 重新“掷”出违例 catch(Exception e) {\rSystem.out.println(\u0026#34;一个违例已经产生\u0026#34;);\rthrow e;\r} 若想安装新的堆栈跟踪信息，可调用fillInStackTrace()，它会返回一个特殊的违例对象。这个违例的创建过程如下：将当前堆栈的信息填充到原来的违例对象里。\n由于使用的是fillInStackTrace()，throw 成为违例的新起点。\n永远不必关心如何清除前一个违例，或者与之有关的其他任何违例。它们都属于用new创建的、以内存堆为基础的对象，所以垃圾收集器会自动将其清除。\n9.3 标准Java违例 Java包含了一个名为Throwable的类，它对可以作为违例“掷”出的所有东西进行了描述。Throwable对象有两种常规类型（亦即“从Throwable继承”）。其中，Error代表编译期和系统错误，我们一般不必特意捕获它们（除在特殊情况以外）。Exception是可以从任何标准Java库的类方法中“掷”出的基本类型。此外，它们亦可从我们自己的方法以及运行期偶发事件中“掷”出。\n9.3.1 RuntimeException的特殊情况 这个类别里含有一系列违例类型。它们全部由Java自动生成，毋需我们亲自动手把它们包含到自己的违例规范里。最方便的是，通过将它们置入单独一个名为RuntimeException的基础类下面，它们全部组合到一起。此外，我们没必要专门写一个违例规范，指出一个方法可能会“掷”出一个RuntimeException，因为已经假定可能出现那种情况。由于它们用于指出编程中的错误，所以几乎永远不必专门捕获一个“运行期违例”——RuntimeException——它在默认情况下会自动得到处理。若必须检查RuntimeException，我们的代码就会变得相当繁复。在我们自己的包里，可选择“掷”出一部分RuntimeException。\n9.4 创建自己的违例 并不一定非要使用Java违例。这一点必须掌握，因为经常都需要创建自己的违例，以便指出自己的库可能生成的一个特殊错误——但创建Java分级结构的时候，这个错误是无法预知的。 为创建自己的违例类，必须从一个现有的违例类型继承——最好在含义上与新违例近似。继承一个违例相当简单：\n违例不过是另一种形式的对象\n9.5 违例的限制 覆盖一个方法时，只能产生已在方法的基础类版本中定义的违例。这是一个重要的限制，因为它意味着与基础类协同工作的代码也会自动应用于从基础类衍生的任何对象（当然，这属于基本的OOP概念），其中包括违例。\n对违例的限制并不适用于构建器。\n一个构建器能够“掷”出它希望的任何东西，无论基础类构建器“掷”出什么。然而，由于必须坚持按某种方式调用基础类构建器（在这里，会自动调用默认构建器），所以衍生类构建器必须在自己的违例规范中声明所有基础类构建器违例。\n通过强迫衍生类方法遵守基础类方法的违例规范，对象的替换可保持连贯性。\n覆盖过的基础类方法向我们显示出一个方法的衍生类版本可以不产生任何违例——即便基础类版本要产生违例。\n编译器就会强迫我们只捕获特定于那个类的违例。但假如我们上溯造型到基础类型，编译器就会强迫我们捕获针对基础类的违例。通过所有这些限制，违例控制代码的“健壮”程度获得了大幅度改善（注释③）。\n总结：\n1、实现抽象方法 throws 异常应与抽象方法 throws 异常一致,来声明它是实现抽象方法的。（接口的实现方法不能因为 throws 异常 而与重载的方法混淆。） 9.6 用finally清除 finally从句\n无论异常是否被捕获，finally的代码一定会被执行。 finally里适合存放释放资源、后续处理的代码 try代码块并没有得到执行，所以finally中的代码块也不会得到相应的执行。只有在try代码块得到执行的情况下，finally代码块才会得到执行。 9.6.1 用finally做什么 在没有“垃圾收集”以及“自动调用破坏器”机制的一种语言中（注释⑤），finally显得特别重要，因为程序员可用它担保内存的正确释放——无论在try块内部发生了什么状况。但Java提供了垃圾收集机制，所以内存的释放几乎绝对不会成为问题。另外，它也没有构建器可供调用。既然如此，Java里何时才会用到finally呢？\n除将内存设回原始状态以外，若要设置另一些东西，finally就是必需的。例如，我们有时需要打开一个文件或者建立一个网络连接，或者在屏幕上画一些东西，甚至设置外部世界的一个开关，等等。\n9.7 构建器 没明白它说啥，但是感觉不是很重要，不建议构建器写复杂内容。\n9.8 违例匹配 “掷”出一个违例后，违例控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为违例已得到控制，不再进行更多的搜索工作。\n在违例和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个控制器相配\n9.8.1 违例准则 用违例做下面这些事情：\n(1) 解决问题并再次调用造成违例的方法。 (2) 平息事态的发展，并在不重新尝试方法的前提下继续。 (3) 计算另一些结果，而不是希望方法产生的结果。 (4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。 (5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。 (6) 中止程序执行。 (7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。 (8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性） 9.9 总结 在Java里，违例控制的目的是使用尽可能精简的代码创建大型、可靠的应用程序，同时排除程序里那些不能控制的错误。\n9.10 练习 "},{"id":153,"href":"/Tech/1Book/Thinking-In-Java/Thinking-In-Java/","title":"Thinking in Java","parent":"Thinking In Java","content":" Thinking In Java 标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk 第 1 章：对象入门 面向对象编程（OOP）\n1.1 抽象的进步 所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。\n1.2 对象的接口 我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做哪些事情。\n1.3 实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员。\n1.4 方案的重复使用 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。\n新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。\n轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。\n1.5 继承：重新使用接口 在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。\n1.5.1 改善基础类 改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。\n继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；\n1.6 多形对象的互换使用 通常，继承最终会以创建一系列类收场，所有类都建立在统一的基础接口上。\n对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。\n把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。\n1.6.1 动态绑定 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）（多态性）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。\n1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。\n亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。\ninterface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。\n备注：这是一段个人的总结：\rinterface（接口）更倾向于表明这个类是能干什么事，也就是说这类的类实现了哪些方法及继承与此接口的类必需要实现哪些方法；接口更像一个规范文件(协议)。\rabstract（抽象）更倾向于表明一类类的共有特性，由基础类或一个接口衍生的一系列类的共有特性，所以不仅仅表明这个类能干哪些事。\r也就是说 interface（接口）的方法都可以在接口中无实现，只规定了子类必须需要实现哪些方法，而 abstract（抽象）可以把子类相同实现的方法在抽象类里实现，子类各自特别且必须的方法用抽象方法规定然后在子类里各自实现。\rabstract（抽象）可以看为一种跟 public、static 同级别的修饰符（修饰了类（class）和方法），而 interface（接口）可以看为一种跟 class 同级别的修饰符，标志着质的改变。\rinterface（接口）可以说是对 abstract（抽象）的抽象。\rinterface（接口）帮助了对象的分层，各组件之间的松耦合。\rinterface 语法要求：\r1、接口可以包含：静态常量、方法（抽象）、内部类（接口、枚举）、默认方法（类方法）\r2、接口只可以继承多个父接口（之间用英文逗号“,”隔开），不能继承类。\r3、接口修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有相同包结构下才可以访问该接口。\r4、接口内的所有成员都是 public 访问权限，可省略，如果指定则只可使用 public 访问修饰符。\r5、接口的成员变量均为静态常量，不管是否使用 public static final 修饰符都认为只可做如此修饰。\r6、接口的方法只能是抽象、类方法、默认方法，如果不是默认方法，系统将自动为普通方法增加 public abstract 修饰符，且不能有方法实现（方法体），类方法、默认方法必须有方法实现（方法体）。\r7、定义默认方法，需要用 default 修饰且默认添加 public 修饰 ，默认方法不能用 static 修饰，所以不能直接用接口来调用默认方法，由接口的实现类的实例来调用这些默认方法。\r8、类方法需用 static 修饰 ，可用接口直接调用。\r9、接口的内部类（接口、枚举）默认采用 public static 修饰符。\r10、接口可看做为特殊的类，受限于一个源文件只能有一个 public 修饰。\r11、接口不能创建实例，作为声明引用类型变量时此接口必须有其实现类。\rabstract 语法要求：\r1、有抽象方法的类只能是抽象类\r2、抽象类里可没有抽象方法有普通方法\r3、抽象类不能被实例化\r4、抽象类可以包含：成员变量、方法（普通、抽象）、构造器、初始化快、内部类（接口、枚举）、抽象类的构造器不能用于创造实列，主要用于被其子类调用\r5、抽象不能修饰变量（成员、局部），不能修饰构造器，抽象类里的构造器只能是普通的构造器。\r总结如下：\r1、抽象类与普通类相比“一得一失”：1、“得”可包含抽象方法。2、“失”无法被实列化。\r2、抽象类是用来被它的子类继承的，方法由子类实现。而 final 修饰的类不能被继承， final 修饰的方法不能被重写，所以 final 和 abstract 是互斥的。\r3、static 修饰方法是属于这个类本身的（类Class和实列Object的区别），如果该方法被定义成抽象方法，通过类调用的时候也会出错，因为调用了一个没有方法实体的方法，所以 static 和 abstract 是互斥的（非绝对，可以同时修饰内部类）。\r4、abstract 修饰的方法必须被之类重写才有意义，因此 abstract 方法不能是私有的，所以 private 和 abstract 是互斥的。 1.7 对象的创建和存在时间 从技术角度说，OOP（面向对象程序设计）只是涉及抽象的数据类型、继承以及多形性，但另一些问题也可能显得非常重要。\n最重要的问题之一是对象的创建及破坏方式。对象需要的数据位于哪儿，及对象的“存在时间”。\n1.7.1 集合与继承器 “继续器”（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。它存在于所有集合中\n不同的集合在进行特定操作时往往有不同的效率。\n1.7.2 单根结构 所有类最终是从单独一个基础类继承（Object）。他们最终都属于相同的类型。\n所有对象都在内存堆中创建，可以极大简化参数的传递。\n可以更方便地实现一个垃圾收集器。\n由于运行期的类型信息肯定存在于所有对象中，所以永远不会遇到判断不出一个对象的类型的情况。这对系统级的操作来说显得特别重要，比如违例控制；\n1.7.3 集合库与方便使用集合 为了使这些集合能够重复使用，或者“再生”，Java提供了一种通用类型，以前曾把它叫作“Object”。所以容纳了Object的一个集合实际可以容纳任何东西。这使我们对它的重复使用变得非常简便。\n但由于集合只能容纳Object，所以在我们向集合里添加对象句柄时，它会上溯造型成Object，这样便丢失了它的身份或者标识信息。再次使用它的时候，会得到一个Object句柄，而非指向我们早先置入的那个类型的句柄。\n（↑↑↑↑↑解释上面两个段落：为了复用将集合元素的类型设置为Object，当向集合中添加元素的时候会因为 Upcasting 而丢失 元素的实际类型，以至于无法调用元素的实际有用接口）\n我们再次用到了造型（Cast）。下溯造型成一种更“特殊”的类型。这种造型方法叫作“下溯造型”（Downcasting）。\n在从一个集合提取对象句柄时，必须用某种方式准确地记住它们是什么，以保证下溯造型的正确进行。\n我们可以采用“参数化类型”。\n（↑↑↑↑↑解释上面段落：集合泛型的原因）\n1.7.4 清除时的困境：由谁负责清除？ 每个对象都要求资源才能“生存”，其中最令人注目的资源是内存。如果不再需要使用一个对象，就必须将其清除，以便释放这些资源，以便其他对象使用。\n问题1：如何才能知道什么时间删除对象呢？\n垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。\n2.垃圾收集器对效率及灵活性的影响\n代价就是运行期的开销。\n我们不能确定它什么时候启动或者要花多长的时间。这意味着在Java程序执行期间，存在着一种不连贯的因素。所以在某些特殊的场合，我们必须避免用它——比如在一个程序的执行必须保持稳定、连贯的时候。\n1.8 违例控制：解决错误 错误必然发生\n它们严重依赖程序员的警觉性\n“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。这“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。\n违例不能被忽略，“掷”出的一个违例不同于从函数返回的错误值，那些错误值或标志的作用是指示一个错误状态，是可以忽略的。\n注意违例控制并不属于一种面向对象的特性\n1.9 多线程 在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。\n要求将问题划分进入独立运行的程序片断中，使整个程序能更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。\n最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。\n从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。\n一个问题：临界资源！一些支持共享，不支持并行的资源，需要在线程使用期间必须进入锁定状态。（比如“屏幕”是个共享资源，但是不能同时播放两个画面。）\nJava中对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用 synchronized 关键字。\n1.10 永久性 Java8移除永久代\n1.11 Java和因特网 1.12 分析和设计 (1) 对象是什么？（怎样将自己的项目分割成一系列单独的组件？） (2) 它们的接口是什么？（需要将什么消息发给每一个对象？） 整个过程可划分为四个阶段：\n阶段0：拟出一个计划、\n阶段1：要制作什么？\n在上一代程序设计中（即“过程化或程序化设计”），这个阶段称为“建立需求分析和系统规格”。 最有价值的工具就是一个名为“使用条件”的集合。 阶段2：如何构建？\n此时可考虑采用一种特殊的图表工具：“统一建模语言”（UML）。 包含的各类对象在外观上是什么样子，以及相互间是如何沟通的。 阶段3：开始创建\n阶段4：校订\n1.13 Java还是 C++ 第 2 章：一切都是对象 Java语言首先便假定了我们只希望进行面向对象的程序设计。\n2.1 用句柄操纵对象 将一切都“看作”对象，操纵的 标识符 实际是指向一个对象的“句柄”（Handle）。\n创建一个String句柄：\rString s;\r这里创建的只是句柄，并不是对象。s实际并未与任何东西连接（即“没有实体”）。\r一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：\rString s = \u0026#34;asdf\u0026#34;;\r总结：\r句柄指向对象，通过句柄操作对象，句柄是句柄，对象是对象。 2.2 所有对象都必须创建 创建句柄时，我们希望它同一个新对象连接。通常用 new 关键字达到这一目的。。new的意思是：“把我变成这些对象的一种新实体”。\n2.2.1 保存到什么地方 程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：\n在Java中是不可能得到真正的内存地址的，也不会提供直接操作“内存地址”的方式。\nJava中堆是由JVM管理的不能直接操作。\n(1) 寄存器： 位于处理器内部。这是最快的保存区域。 以寄存器是根据需要由编译器分配。 我们对此没有直接的控制权。 (2) 堆栈（stack）： 驻留于常规RAM（随机访问存储器）区域，这是一种特别快、特别有效的数据保存方式，仅次于寄存器。 创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性。 有些Java数据要保存在堆栈里——基本类型数据、对象句柄，但Java对象并不放到其中。 每个线程都有自己独立的栈。 (3) 堆（Heap）： 一种常规用途的内存池（也在RAM区域），在堆里分配存储空间时会花掉更长的时间！ 编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。 保存了Java对象。 堆在整个JVM中只有一个（所以堆中的数据可被多个线程共享），堆里面的内存空间由GC来负责回收。 (4) 静态存储 ： 这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。 程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。 Java对象本身永远都不会置入静态存储空间。 (5) 常数存储 ： 常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。 (6) 非RAM存储 ： 若数据完全独立于一个程序之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。 2.2.2 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用new创建对象（特别是小的、简单的变量）并不是非常有效，因为new将对象置于“堆”里。对于这些类型，Java采纳了与C和C++相同的方法。也就是说，不是用new创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，并置于堆栈中，能够更高效地存取。\nJava决定了每种主要类型的大小。(8bit=1byte)\n主类型 大小 封装器类型 boolean 1-bit Boolean byte 8-bit Byte[11] char 16-bit Character short 16-bit Short int 32-bit Integer long 64-bit Long float 32-bit Float double 64-bit Double 注意：\n若变量是主数据类型作为类成员使用，Java可自动分配默认值，可保证主类型的成员变量肯定得到了初始化（自动初始化）（C++不具备这一功能），却并不适用于“局部”变量——那些变量并非一个类的字段，不会自动初始化，会得到一条编译期错误。 高精度数字\n用于进行高精度的计算：BigInteger和BigDecimal。尽管它们大致可以划分为“封装器”类型，但两者都没有对应的“主类型”。这两个类都有自己特殊的“方法”，对应于我们针对主类型执行的操作。 2.2.3 Java的数组 Java的一项主要设计目标就是安全性。一个Java可以保证被初始化，而且不可在它的范围之外访问。由于系统自动进行范围检查，所以必然要付出一些代价：针对每个数组，以及在运行期间对索引的校验，都会造成少量的内存开销。\n创建对象数组时，实际创建的是一个句柄数组。而且每个句柄都会自动初始化成一个特殊值，并带有自己的关键字：null（空）。一旦Java看到null，就知道该句柄并未指向一个对象。正式使用前，必须为每个句柄都分配一个对象。\n2.3 所有对象都必须创建 在大多数程序设计语言中，变量的“存在时间”（Lifetime）一直是程序员需要着重考虑的问题。变量应持续多长的时间？如果想清除它，那么何时进行？在变量存在时间上纠缠不清会造成大量的程序错误。\n2.3.1 作用域（Scope） 作用域同时决定了它的“可见性”以及“存在时间”。在C，C++和Java里，作用域是由花括号的位置决定的。\n例子： { int x = 12; /* only x available */ { int q = 96; /* both x \u0026amp; q available */ } /* only x available */ /* q “out of scope” */ } 作为在作用域里定义的一个变量，它只有在那个作用域结束之前才可使用。\n2.3.2 对象的作用域 Java对象不具备与主类型一样的存在时间。用 new 关键字创建一个Java对象的时候，它会超出作用域的范围之外。\n例子： { String s = new String(\u0026#34;a string\u0026#34;); } /* 作用域的终点 */ 那么句柄 s会在作用域的终点处消失。然而，s 指向的 String 对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个句柄已超出了作用域的边界。 这样造成的结果便是：对于用 new 创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在 C 和 C++ 里特别突出。看来在 C++ 里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且更麻烦的是，在 C++ 里，一旦工作完成，必须保证将对象清除。\n假如 Java 让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在 C++ 里，这个问题最令程序员头痛。但 Java 以后，情况却发生了改观。Java 有一个特别的“垃圾收集器”，它会查找用new创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在 C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。\n2.4 新建数据类型：类 一切东西都是对象，那么用什么决定一个“类”（Class）的外观与行为呢？换句话说，是什么建立起了一个对象的“类型”（class）呢？通过 class 关键字。\n例如： //这样就引入了一种新类型。 class ATypeName {/*类主体置于这里} //这样就用new创建这种类型的一个新对象： ATypeName a = new ATypeName(); 2.4.1 字段和方法 定义一个类时（我们在Java里的全部工作就是定义类、制作那些类的对象以及将消息发给那些对象），可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）、成员函数（通常叫“方法”）。其中，数据成员是一种对象（通过它的句柄与其通信），可以为任何类型。它也可以是主类型（并不是句柄）之一。如果是指向对象的一个句柄，则必须初始化那个句柄，用一种名为“构建器”的特殊函数将其与一个实际对象连接起来（就象早先看到的那样，使用new关键字）。但若是一种主类型，则可在类定义位置直接初始化（正如后面会看到的那样，句柄亦可在定义位置初始化）。\n每个对象都为自己的数据成员保有存储空间；数据成员不会在对象之间共享。（这个共享是指指向一块内存位置的意思么？）\n示例： class DataOnly { int i; float f; boolean b; } 对象实例化后可值赋给数据成员，但首先必须知道如何引用一个对象的成员。首先要写上对象句柄的名字，再跟随一个点号，再跟随对象内部成员的名字。即“对象句柄.成员”。(引用 或者 说 访问权限 会受 修饰符（public、protected、default、private）影响。)\n例如： d.i = 47; d.f = 1.1f; d.b = false; 一个对象也可能包含了另一个对象，只需保持“连接句点”即可。\n例如： myPlane.leftTank.capacity = 100; 1、主成员的默认值： 若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值（自动初始化）。 主类型 默认值： Boolean false Char \u0026#39;\\u0000\u0026#39;(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 注意： 若变量是主数据类型作为类成员使用，Java可自动分配默认值，可保证主类型的成员变量肯定得到了初始化（自动初始化）（C++不具备这一功能），却并不适用于“局部”变量——那些变量并非一个类的字段，不会自动初始化，会得到一条编译期错误。 2.5 方法、自变量和返回值 我们一直用“函数”（Function）这个词指代一个已命名的子例程。但在 Java 里，更常用的一个词却是“方法”（Method），代表“完成某事的途径”。尽管它们表达的实际是同一个意思。\nJava的“方法”决定了一个对象能够接收的消息。\n方法的基本组成部分包括名字、自变量、返回类型以及主体。下面便是它最基本的形式：\n返回类型 方法名( /* 自变量列表*/ ) {/* 方法主体 */} 返回类型是指调用方法之后返回的数值类型。显然，方法名的作用是对具体的方法进行标识和引用。自变量列表列出了想传递给方法的信息类型和名称。\nJava的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（注释③），而且那个对象必须能够执行那个方法调用。\n为一个对象调用方法时，需要先列出对象的名字，在后面跟上一个句点，再跟上方法名以及它的参数列表。亦即“对象名.方法名(自变量1，自变量2，自变量3\u0026hellip;)。例如：我们有一个方法名叫f()，它没有自变量，返回的是类型为int的一个值。假设有一个名为a的对象，可为其调用方法f()，则代码如下：\nint x = a.f(); 象这样调用一个方法的行动通常叫作“向对象发送一条消息”。在上面的例子中，消息是f()，而对象是 a。面向对象的程序设计通常简单地归纳为“向对象发送消息”。\n③：正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象。 自变量 也叫 形参，是方法的局部变量。\n2.5.1 自变量列表 自变量列表规定了我们传送给方法的是什么信息。这些信息——如同Java内其他任何东西——采用的都是对象的形式。因此，我们必须在自变量列表里指定要传递的对象类型，以及每个对象的名字。正如在Java其他地方处理对象时一样，我们实际传递的是“句柄”（注释④）。然而，句柄的类型必须正确。倘若希望自变量是一个“字串”，那么传递的必须是一个字串。\n④：对于前面提及的“特殊”数据类型 boolean，char，byte，short，int，long，，float以及double来说是一个例外。但在传递对象时，通常都是指传递指向对象的句柄。（也就是说 基本类型 传递的是值本身） return 关键字的运用。它主要做两件事情。首先，它意味着“离开方法，我已完工了”。其次，假设方法生成了一个值，则那个值紧接在 return 语句的后面。可按返回 那个值，但倘若不想返回任何东西，就可指示方法返回 void（空）。\n若返回类型为 void，则 return 关键字唯一的作用就是退出方法。\n但假设已指定了一种非 void 的返回类型，那么无论从何地返回，编译器都会确保我们返回的是正确的类型。\n2.6 构建 Java 程序 2.6.1 名字的可见性 Java 的设计者鼓励程序员反转使用自己的 Internet 域名，给一个库生成明确的名字。\n2.6.2 使用其他组件 用 import 关键字准确告诉 Java 编译器我们希望的类是什么。import 的作用是指示编译器导入一个“包”——或者说一个“类库”（在其他语言里，可将“库”想象成一系列函数、数据以及类的集合。但请记住，Java的所有代码都必须写入一个类中）。\n例如： import java.util.Vector; 2.6.3 static关键字 static 修饰的成员表明它是属于这个类本(Class)身，而不是属于该类的单个实列(Object)，没有使用 static 修饰的成员只可通过实例调动，static 修饰的成员不能直接访问非静态成员（因为非静态成员没有初始化）。\n通常，用 new 创建那个类的一个对象，才会正式生成数据存储空间，并可使用相应的方法。\n但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用 static（静态）关键字。一旦将什么东西设为 static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个 static方法，或访问一些 static数据。\n例如： class StaticTest { static int i = 47; } 我们制作了两个 StaticTest对象：\nStaticTest st1 = new StaticTest(); StaticTest st2 = new StaticTest(); 但它们仍然只占据 StaticTest.i的一个存储空间。这两个对象都共享同样的i。无论st1.i还是st2.i都有同样的值47，因为它们引用的是同样的内存区域。\n所以有两个办法可引用一个 static 变量。可通过一个对象命名它，如 st2.i，亦可直接用它的类名引用，如 StaticTest.i（最好用这个办法引用 static 变量，因为它强调了那个变量的“静态”本质）。\nstatic一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法。和其他任何方法一样，static方法也能创建自己类型的命名对象。所以经常把 static方法作为一个“领头羊”使用，用它生成一系列自己类型的“实例”。\n2.7 我们的第一个Java程序 由于java.lang默认进入每个Java代码文件，所以这些类在任何时候都可直接使用。\n通过为 Runtime类调用getRuntime()方法，main()的第五行创建了一个Runtime对象，Runtime可告诉我们与内存使用有关的信息。\n2.8 注释和嵌入文档 2.8.1 注释文档 人们需要考虑程序的文档化问题。用于提取注释的工具叫作javadoc。它不仅提取由这些注释标记指示的信息，也将毗邻注释的类名或方法名提取出来。\njavadoc输出的是一个HTML文件，可用自己的Web浏览器查看。\n2.8.2 具体语法 所有javadoc命令都只能出现于 “/**” 注释中。有三种类型的注释文档，它们对应于位于注释后面的元素：类、变量或者方法。\n/** 一个类注释 */ public class docTest { /** 一个变量注释 */ public int i; /** 一个方法注释 */ public void f() {} } 注意javadoc只能为public（公共）和protected（受保护）成员处理注释文档。“private”（私有）和“友好”（详见5章）成员的注释会被忽略，我们看不到任何输出（也可以用-private标记包括private成员）。\n2.8.3 嵌入HTML javadoc 将HTML命令传递给最终生成的HTML文档。\n亦可象在其他 Web文档里那样运用HTML，对普通文本进行格式化，使其更具条理、更加美观：\n/** * 您\u0026lt;em\u0026gt;甚至\u0026lt;/em\u0026gt;可以插入一个列表： * \u0026lt;ol\u0026gt; * \u0026lt;li\u0026gt; 项目一 * \u0026lt;li\u0026gt; 项目二 * \u0026lt;li\u0026gt; 项目三 * \u0026lt;/ol\u0026gt; */ 注意在文档注释中，位于一行最开头的星号会被javadoc丢弃。同时丢弃的还有前导空格。javadoc 会对所有内容进行格式化，使其与标准的文档外观相符。不要将 \u0026lt;h1\u0026gt; 或 \u0026lt;hr\u0026gt; 这样的标题当作嵌入HTML使用，因为javadoc会插入自己的标题，我们给出的标题会与之冲撞。\n2.8.4 @see：引用其他类 所有三种类型的注释文档都可包含@see标记，它允许我们引用其他类里的文档。对于这个标记，javadoc会生成相应的HTML，将其直接链接到其他文档。格式如下：\n@see 类名 @see 完整类名 @see 完整类名#方法名 每一格式都会在生成的文档里自动加入一个超链接的“See Also”（参见）条目。注意javadoc不会检查我们指定的超链接，不会验证它们是否有效。\n2.8.5 类文档标记 1. @version 格式如下： @version 版本信息 其中，“版本信息”代表任何适合作为版本说明的资料。 2. @author 格式如下： @author 作者信息 其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。 2.8.6 变量文档标记 变量文档只能包括嵌入的HTML以及@see引用。\n2.8.7 方法文档标记 除嵌入HTML和@see引用之外，方法还允许使用针对参数、返回值以及违例的文档标记。\n1. @param 格式如下： @param 参数名 说明 其中，“参数名”是指参数列表内的标识符，而“说明”代表一些可延续到后续行内的说明文字。 2. @return 格式如下： @return 说明 其中，“说明”是指返回值的含义。它可延续到后面的行内。 3. @exception 格式如下： @exception 完整类名 说明 其中，“完整类名”明确指定了一个违例类的名字，它是在其他某个地方定义好的。而“说明”（同样可以延续到下面的行）告诉我们为什么这种特殊类型的违例会在方法调用中出现。 4. @deprecated 格式如下： @deprecated 标记用于指出一些旧功能已由改进过的新功能取代。该标记的作用是建议用户不必再使用一种特定的功能，因为未来改版时可能摒弃这一功能。 2.8.8 文档示例 2.9 编码样式 一个非正式的Java编程标准是大写一个类名的首字母。若类名由几个单词构成，那么把它们紧靠到一起（也就是说，不要用下划线来分隔名字）。此外，每个嵌入单词的首字母都采用大写形式。\n例如： class AllTheColorsOfTheRainbow { // ...} 其他几乎所有内容：方法、字段（成员变量）以及对象句柄名称，可接受的样式与类样式差不多，只是标识符的第一个字母采用小写。\n例如： int anIntegerRepresentingColors; void changeTheHueOfTheColor(int newHue) { // ... } 2.10 总结 本章是基础知识。\n第3章 控制程序流程 程序必须能操纵自己的世界，在执行过程中作出判断与选择。\n3.1 使用Java运算符 几乎所有运算符都只能操作“主类型”（Primitives）（基本类型）。唯一的例外是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。除此以外，String类支持“+”和“+=”。\n3.1.1 优先级 运算符的优先级决定了存在多个运算符时一个表达式各部分的计算顺序。\n3.1.2 赋值 赋值是用等号运算符（=）进行的。它的意思是“取得右边的值，把它复制到左边”。\n右边的值可以是任何常数、变量或者表达式，只要能产生一个值就行。但左边的值必须是一个明确的、已命名的变量。\n对主数据类型的赋值是非常直接的。由于主类型容纳了实际的值，而且并非指向一个对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。\n但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向最初只有D才指向的那个对象。\n3.1.3 算术运算符 Java的基本算术运算符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及模数（%，从整数除法中获得余数）。整数除法会直接砍掉小数，而不是进位。\n一元加、减运算符 一元减号（-）和一元加号（+）与二元加号和减号都是相同的运算符。\n例如： x = -a; 一元减号得到的运算对象的负值。一元加号的含义与一元减号相反，虽然它实际并不做任何事情。\n3.1.4 自动递增和递减 两种很不错的快捷运算方式是递增和递减运算符（常称作“自动递增”和“自动递减”运算符）。其中，递减运算符是“\u0026ndash;”，意为“减少一个单位”；递增运算符是“++”，意为“增加一个单位”。举个例子来说，假设A是一个int（整数）值，则表达式++A就等价于（A = A + 1）。\n对每种类型的运算符，都有两个版本可供选用；通常将其称为“前缀版”和“后缀版”。。对于前递增和前递减（如++A或\u0026ndash;A），会先执行运算，再生成值。而对于后递增和后递减（如A++或A\u0026ndash;），会先生成值，再执行运算。\n3.1.5 关系运算符 关系运算符生成的是一个“布尔”（Boolean）结果。它们评价的是运算对象值之间的关系。若关系是真实的，关系表达式会生成 true（真）；若关系不真实，则生成 false（假）。关系运算符包括小于（\u0026lt;）、大于（\u0026gt;）、小于或等于（\u0026lt;=）、大于或等于（\u0026gt;=）、等于（==）以及不等于（!=）。等于和不等于适用于所有内建的数据类型，但其他比较不适用于 boolean 类型。\n1、检查对象是否相等 关系运算符==和!=也适用于所有对象。 ==和!=比较的就是对象句柄。 若想对比两个对象的实际内容是否相同？此时，必须使用所有对象都适用的特殊方法equals()。 于 equals()的默认行为是比较句柄。 多数Java类库都实现了equals()，所以它实际比较的是对象的内容，而非它们的句柄。 3.1.6 逻辑运算符 逻辑运算符AND（\u0026amp;\u0026amp;）、OR（||）以及NOT（!）能生成一个布尔值（true或false）。\n短路 操作逻辑运算符时，我们会遇到一种名为“短路”的情况。这意味着只有明确得出整个表达式真或假的结论，才会对表达式进行逻辑求值。因此，一个逻辑表达式的所有部分都有可能不进行求值。\n短路就是说，当逻辑运算表达式的结果已经得出，剩余的逻辑表达式将不会得到执行。）\n3.1.7 按位运算符 二进制下用 1 表示真，0 表示假\n按位运算符允许我们操作一个整数主数据类型中的单个“比特”，即二进制位。按位运算符会对两个自变量中对应的位执行布尔代数，并最终生成一个结果。\n若两个输入位都是1，则按位AND运算符（\u0026amp;）在输出位里生成一个1；否则生成0。\n1 \u0026amp; 1 = 1 0 \u0026amp; 1 = 0 1 \u0026amp; 0 = 0 0 \u0026amp; 0 = 0 若两个输入位里至少有一个是1，则按位OR运算符（|）在输出位里生成一个1；只有在两个输入位都是0的情况下，它才会生成一个0。\n1 | 1 = 1 0 | 1 = 1 1 | 0 = 1 0 | 0 = 0 XOR（^，异或）:如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。\n1 ^ 1 = 0 0 ^ 1 = 1 1 ^ 0 = 1 0 ^ 0 = 0 异或的一个用法，交换两个变量的值。\nint a = 1;//01 int b = 2;//10 a=a^b;//a=11 b=b^a;//b=01 a=a^b;//a=10 NOT（~，也叫作“非”运算符）属于一元运算符；它只对一个自变量进行操作（其他所有运算符都是二元运算符）。按位NOT生成与输入位的相反的值——若输入0，则输出1；输入1，则输出0。\n~ 1 = 0 ~ 0 = 1 按位运算符和逻辑运算符都使用了同样的字符，只是数量不同。\n按位运算符可与等号（=）联合使用，以便合并运算及赋值\n3.1.8 移位运算符 移位运算符面向的运算对象也是二进制的“位”。可单独用它们处理整数类型（主类型的一种）。\n左移位运算符（\u0026laquo;）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。\n“有符号”右移位运算符（\u0026raquo;）则将运算符左边的运算对象向右移动运算符右侧指定的位数。“有符号”右移位运算符使用了“符号扩展”：若值为正，则在高位插入0；若值为负，则在高位插入1。\n“无符号”右移位运算符（\u0026raquo;\u0026gt;），它使用了“零扩展”：无论正负，都在高位插入0。\n若对 char，byte 或者 short 进行移位处理，那么在移位进行之前，它们会自动转换成一个int。只有右侧的5个低位才会用到。这样可防止我们在一个int数里移动不切实际的位数。若对一个long值进行处理，最后得到的结果也是long。此时只会用到右侧的6个低位，防止移动超过long值里现成的位数。但在进行“无符号”右移位时，也可能遇到一个问题。若对byte或short值进行右移位运算，得到的可能不是正确的结果（Java 1.0和Java 1.1特别突出）。它们会自动转换成int类型，并进行右移位。但“零扩展”不会发生，所以在那些情况下会得到-1的结果。\n移位可与等号（\u0026laquo;=或\u0026raquo;=或\u0026raquo;\u0026gt;=）组合使用。此时，运算符左边的值会移动由右边的值指定的位数，再将得到的结果赋回左边的值。\n3.1.9 三元 if-else 运算符 表达式采取下述形式：\n布尔表达式 ? 值0:值1 若“布尔表达式”的结果为true，就计算“值0”，而且它的结果成为最终由运算符产生的值。但若“布尔表达式”的结果为false，计算的就是“值1”，而且它的结果成为最终由运算符产生的值。\n可将条件运算符用于自己的“副作用”，或用于它生成的值。但通常都应将其用于值，因为那样做可将运算符与if-else明确区别开。\n3.1.10 逗号运算符 在Java里需要用到逗号的唯一场所就是for循环，\n3.1.11 字串运算符+ 运算符在Java里有一项特殊用途：连接不同的字串。 3.1.12 运算符常规操作规则 3.1.13 造型运算符 “造型”（Cast）的作用是“与一个模型匹配”。\nJava允许我们将任何主类型“造型”为其他任何一种主类型，但布尔值（bollean）要除外，后者根本不允许进行任何造型处理。“类”不允许进行造型。为了将一种类转换成另一种，必须采用特殊的方法。\n1、字面值\n十六进制（Base 16）——它适用于所有整数数据类型——用一个前置的0x或0X指示。并在后面跟随采用大写或小写形式的0-9以及a-f。若试图将一个变量初始化成超出自身能力的一个值（无论这个值的数值形式如何）,最大的十六进制值只会在char，byte以及short身上出现。若超出这一限制，编译器会将值自动变成一个int，并告诉我们需要对这一次赋值进行“缩小造型”。这样一来，我们就可清楚获知自己已超载了边界。 八进制（Base 8）是用数字中的一个前置0以及0-7的数位指示的。在C，C++或者Java中，对二进制数字没有相应的“字面”表示方法。 字面值后的尾随字符标志着它的类型。若为大写或小写的L，代表long；大写或小写的F，代表float；大写或小写的D，则代表double。 指数总是采用一种我们认为很不直观的记号方法：1.39e-47f。在科学与工程学领域，“e”代表自然对数的基数，约等于2.718（Java一种更精确的double值采用Math.E的形式）。它在象“1.39×e的-47次方”这样的指数表达式中使用，意味着“1.39×2.718的-47次方”。然而，自FORTRAN语言发明后，人们自然而然地觉得e代表“10多少次幂”。这种做法显得颇为古怪，因为FORTRAN最初面向的是科学与工程设计领域。理所当然，它的设计者应对这样的混淆概念持谨慎态度（注释①）。但不管怎样，这种特别的表达方法在C，C++以及现在的Java中顽固地保留下来了。所以倘若您习惯将e作为自然对数的基数使用，那么在Java中看到象“1.39e-47f”这样的表达式时，请转换您的思维，从程序设计的角度思考它；它真正的含义是“1.39×10的-47次方”。(‘E’这个字母的含义其实很简单，就是‘Exponential’的意思，即‘指数’或‘幂数’，代表计算系统的基数——一般都是10。) 2、转型\n通常，表达式中最大的数据类型是决定了表达式最终结果大小的那个类型。若将一个float值与一个double值相乘，结果就是double；如将一个int和一个long值相加，则结果为long。 3.* Expressions, Statements, and Blocks 表达式，语句和块 运算符可用于构建表达式，这些表达式可计算值。表达式是语句的核心组成部分；语句可以分为多个块。\n一个表达式是变量，运算符和方法调用，它们根据语言的语法构造由一个构建体，计算结果为单个值。\n表达式返回的值的数据类型取决于表达式中使用的元素。\n一条语句构成了完整的执行单元。通过使用分号（;）终止表达式，可以将以下类型的表达式制成语句。\n赋值表达式 任何使用++或\u0026ndash; 方法调用 对象创建表达式 这样的语句称为表达式语句。这是一些表达式语句的例子。 //赋值语句\raValue = 8933.234; //增量语句\raValue ++; //方法调用语句\rSystem.out.println（“ H​​ello World！”）; //对象创建语句\rBicycle myBike = new Bicycle（）; 除表达式语句外，还有两种其他语句：声明语句和控制流语句。一个声明语句声明一个变量。\n代码块 代码块是一组平衡括号之间的零条或多个语句，并且可以在任何地方使用单个语句是允许的。\n3.1.14 Java没有“sizeof” Java不需要sizeof()运算符来满足这方面的需要，因为所有数据类型在所有机器的大小都是相同的。\n3.2 执行控制 Java使用了C的全部控制语句，在Java里，涉及的关键字包括if-else、while、do-while、for以及一个名为switch的选择语句。\n3.2.1 真和假 所有条件语句都利用条件表达式的真或假来决定执行流程。\n3.2.2 if-else if-else语句或许是控制程序流程最基本的形式。其中的else是可选的，可按下述两种形式来使用if：\nif(布尔表达式) 语句 或者： if(布尔表达式) 语句 else 语句 布尔表达式（条件）必须产生一个布尔结果。\n1、return return关键字有两方面的用途：指定一个方法返回什么值（假设它没有void返回值），并立即返回那个值（方法在遇到return后便不再继续）。 3.2.3 反复 while，do-while和for控制着循环，有时将其划分为“反复语句”。\nwhile循环的格式如下：\nwhile(布尔表达式) 语句 在循环刚开始时，会计算一次“布尔表达式”的值。而对于后来每一次额外的循环，都会在开始前重新计算一次。\ndo-while的格式如下：\ndo 语句 while(布尔表达式) while和do-while唯一的区别就是do-while肯定会至少执行一次；也就是说，至少会将其中的语句“过一遍”——即便表达式第一次便计算为false。而在while循环结构中，若条件第一次就为false，那么其中的语句根本不会执行。在实际应用中，while比do-while更常用一些。\nfor循环的格式如下：\nfor(初始表达式; 布尔表达式; 步进) 语句 for循环在第一次反复之前要进行初始化。随后，它会进行条件测试，而且在每一次反复的时候，进行某种形式的“步进”（Stepping）。\n无论初始表达式，布尔表达式，还是步进，都可以置空。每次反复前，都要测试一下布尔表达式。若获得的结果是false，就会继续执行紧跟在for语句后面的那行代码。在每次循环的末尾，会计算一次步进。\n初始表达式：for初始化时 只执行一次 布尔表达式：每一次反复时 当 布尔表达式 结果为 false 时， 整个 for 循环结束。 语句： 步进： 注意变量c是在需要用到它的时候定义的——在for循环的控制表达式内部，而非在由起始花括号标记的代码块的最开头。c的作用域是由for控制的表达式。\n以于象C这样传统的程序化语言，要求所有变量都在一个块的开头定义。所以在编译器创建一个块的时候，它可以为那些变量分配空间。而在Java和C++中，则可在整个块的范围内分散变量声明，在真正需要的地方才加以定义。这样便可形成更自然的编码风格，也更易理解。\n可在for语句里定义多个变量，但它们必须具有同样的类型：\nfor(int i = 0, j = 1; i \u0026lt; 10 \u0026amp;\u0026amp; j != 11; i++, j++) 只有for循环才具备在控制表达式里定义变量的能力。对于其他任何条件或循环语句，都不可采用这种方法。\n1、逗号运算符 Java里唯一用到逗号运算符的地方就是for循环的控制表达式。在控制表达式的初始化和步进控制部分，我们可使用一系列由逗号分隔的语句。而且那些语句均会独立执行。 例子： public class CommaOperator { public static void main(String[] args) { for(int i = 1, j = i + 10; i \u0026lt; 5; i++, j = i * 2) { System.out.println(\u0026#34;i= \u0026#34; + i + \u0026#34; j= \u0026#34; + j); } } } 输出如下： i= 1 j= 11 i= 2 j= 4 i= 3 j= 6 i= 4 j= 8 无论在初始化还是在步进部分，语句都是顺序执行的。此外，尽管初始化部分可设置任意数量的定义，但都属于同一类型。\n3.2.6 中断和继续 在任何循环语句的主体部分，亦可用break和continue控制循环的流程。其中，break用于强行退出循环，不执行循环中剩余的语句。而continue则停止执行当前的反复，然后退回循环起始（布尔表达式）和，开始新的反复。\n编译器将 while(true) 与 for(;;)看作同一回事。\n臭名昭著的“goto” goto关键字很早就在程序设计语言中出现。事实上，goto是汇编语言的程序控制结构的始祖：“若条件A，则跳到这里；否则跳到那里”。事实上，goto是在源码的级别跳转的，所以招致了不好的声誉。若程序总是从一个地方跳到另一个地方，还有什么办法能识别代码的流程呢？真正的问题并不在于使用goto，而在于goto的滥用。而且在一些少见的情况下，goto是组织控制流程的最佳手段。\ngoto是Java的一个保留字，并未在语言中得到正式使用，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子。：标签。\n“标签”是后面跟一个冒号的标识符，就象下面这样：\nlabel1: 对Java来说，唯一用到标签的地方是在循环语句之前。进一步说，它实际需要紧靠在循环语句的前方——在标签和循环之间置入任何语句都是不明智的。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环或者一个开关。这是由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。如下所示：\nlabel1: 外部循环{ 内部循环{ //... break; //1 //... continue; //2 //... continue label1; //3 //... break label1; //4 } } 在条件1中，break中断内部循环，并在外部循环结束。 在条件2中，continue移回内部循环的起始处。 在条件3中，continue label1却同时中断内部循环以及外部循环，并移至label1处。随后，它实际是继续循环，但却从外部循环开始。 在条件4中，break label1也会中断所有循环，并回到label1处，但并不重新进入循环。也就是说，它实际是完全中止了两个循环。 (1) 简单的一个continue会退回最内层循环的开头（顶部），并继续执行。 (2) 带有标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。 (3) break会中断当前循环，并移离当前标签的末尾。 (4) 带标签的break会中断当前循环，并移离由那个标签指示的循环的末尾 大家要记住的重点是：在Java里唯一需要用到标签的地方就是拥有嵌套循环，而且想中断或继续多个嵌套级别的时候。\n标签和goto使我们难于对程序作静态分析。这是由于它们在程序的执行流程中引入了许多“怪圈”。但幸运的是，Java标签不会造成这方面的问题，因为它们的活动场所已被限死，不可通过特别的方式到处传递程序的控制权。由此也引出了一个有趣的问题：通过限制语句的能力，反而能使一项语言特性更加有用。\n3.2.7 开关 “开关”（Switch）有时也被划分为一种“选择语句”。根据一个整数表达式的值，switch语句可从一系列代码选出一段执行。\n它的格式如下： switch(整数选择因子) { case 整数值1 : 语句; break; case 整数值2 : 语句; break; case 整数值3 : 语句; break; case 整数值4 : 语句; break; case 整数值5 : 语句; break; //.. default:语句; } 其中，“整数选择因子”是一个特殊的表达式，能产生整数值。switch能将整数选择因子的结果与每个整数值比较。若发现相符的，就执行对应的语句（简单或复合语句）。若没有发现相符的，就执行default语句。\n大家会注意到每个case均以一个break结尾。这样可使执行流程跳转至switch主体的末尾。这是构建switch语句的一种传统方式，但break是可选的。若省略break，会继续执行后面的case语句的代码，直到遇到一个break为止。注意最后的default语句没有break，因为执行流程已到了break的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在default语句的末尾放置一个break，尽管它并没有任何实际的用处。\nswitch 语句是实现多路选择的一种易行方式（比如从一系列执行路径中挑选一个）。但它要求使用一个选择因子，并且必须是int或char那样的整数值。（在java中switch后的表达式的类型只能为以下几种：byte、short、char、int（在Java1.6中是这样），在java1.7后支持了对string的判断）\n将一个float或double值造型成整数值后，总是将小数部分“砍掉”，不作任何进位处理。\n3.3 总结 本章总结了大多数程序设计语言都具有的基本特性：计算、运算符优先顺序、类型转换以及选择和循环等等。现在，我们作好了相应的准备，可继续向面向对象的程序设计领域迈进。在下一章里，我们将讨论对象的初始化与清除问题，再后面则讲述隐藏的基本实现方法。\n第4章 初始化和清除 “随着计算机的进步，‘不安全’的程序设计已成为造成编程代价高昂的罪魁祸首之一。”\n“初始化”和“清除”是这些安全问题的其中两个。\nC++为我们引入了“构建器”的概念。这是一种特殊的方法，在一个对象创建之后自动调用。Java也沿用了这个概念，但新增了自己的“垃圾收集器”，能在资源不再需要的时候自动释放它们。本章将讨论初始化和清除的问题，以及Java如何提供它们的支持。\n4.1 用构建器自动初始化 对于方法的创建，可将其想象成为自己写的每个类都调用一次initialize()。这个名字提醒我们在使用对象之前，应首先进行这样的调用。但不幸的是，这也意味着用户必须记住调用方法。在Java中，由于提供了名为“构建器”的一种特殊方法，所以类的设计者可担保每个对象都会得到正确的初始化。若某个类有一个构建器，那么在创建对象时，Java会自动调用那个构建器——甚至在用户毫不知觉的情况下。所以说这是可以担保的！（也叫：构造器）\n构建器的名字与类名相同。这样一来，可保证象这样的一个方法会在初始化期间自动调用。\n一旦创建一个对象：\nnew Rock(); 就会分配相应的存储空间，并调用构建器。请注意所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 和其他任何方法一样，构建器也能使用自变量。\n利用构建器的自变量，我们可为一个对象的初始化设定相应的参数。\n构建器属于一种较特殊的方法类型，因为它没有返回值。这与 void 返回值存在着明显的区别。对于void返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。\n4.2 方法过载（overload，也翻译成重载） 我们创建一个对象时，会分配一个名字代表这个类。我们用名字引用或描述所有对象与方法。\n在日常生活中，我们用相同的词表达多种不同的含义——即词的“过载”。\n大多数程序设计语言（特别是C）要求我们为每个函数都设定一个独一无二的标识符。在Java里，允许方法名出现过载情况。\n4.2.1 区分过载方法 规则：每个过载的方法都必须采取独一无二的自变量类型列表。\n4.2.2 主类型的过载 主（数据）类型能从一个“较小”的类型自动转变成一个“较大”的类型。涉及过载问题时，这会稍微造成一些混乱。\n分两种情况： 1、若我们的数据类型“小于”方法中使用的自变量类型，就会对那种数据类型进行“转型”处理。 2、若我们的数据类型.“大于”过载方法期望的自变量类型，就必须用括号中的类型名将其“强转”处理。这是一种缩小转换”。也就是说，在造型或转型过程中可能丢失一些信息。 4.2.3 返回值过载 我们也可能调用一个方法，同时忽略返回值；\n例如： f(); void f() {} int f() {} 所以不能根据返回值类型来区分过载的方法。\n4.2.4 默认构建器 创建一个没有构建器的类，则编译程序会帮我们自动创建一个默认无参的构建器，如果已经定义了一个构建器（无论是否有自变量），编译程序都不会帮我们自动合成一个。\n4.2.5 this关键字 假定我们在一个方法的内部，并希望获得当前对象的句柄。由于那个句柄是由编译器“秘密”传递的，所以没有标识符可用。然而，针对这一目的有个专用的关键字：this。this关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。\n1、在构建器里调用构建器\n若为一个类写了多个构建器，那么经常都需要在一个构建器里调用另一个构建器，以避免写重复的代码。可用this关键字做到这一点。\n例如： public class Test { private int petalCount = 0; private String s = new String(\u0026#34;null\u0026#34;); Test(int petals) { petalCount = petals; System.out.println( \u0026#34;Constructor w/ int arg only, petalCount= \u0026#34; + petalCount); } Test(String ss) { System.out.println( \u0026#34;Constructor w/ String arg only, s=\u0026#34; + ss); s = ss; } Test(String s, int petals) { this(petals); //this(s); // Can\u0026#39;t call two! this.s = s; // Another use of \u0026#34;this\u0026#34; System.out.println(\u0026#34;String \u0026amp; int args\u0026#34;); } Test() { this(\u0026#34;hi\u0026#34;, 47); System.out.println( \u0026#34;default constructor (no args)\u0026#34;); } void print() { //! this(11); // 必须是构造函数主体中的第一个语句 System.out.println( \u0026#34;petalCount = \u0026#34; + petalCount + \u0026#34; s = \u0026#34;+ s); } public static void main(String[] args) { Test x = new Test(); x.print(); } } 注意：尽管可用 this 调用一个构建器，但不可调用两个。除此以外，对“this”代替构造器的调用必须是构造函数主体中的第一个语句，否则会收到编译程序的报错信息。\n编译器不让我们从除了一个构建器之外的其他任何方法内部调用一个构建器。\n这个例子也向大家展示了 this 的另一项用途。由于自变量s的名字以及成员数据s的名字是相同的，所以会出现混淆。为解决这个问题，可用this.s来引用成员数据。\n1、static 的含义\n在没有任何对象的前提下，我们可针对类本身发出对一个static方法的调用。事实上，那正是static方法最基本的意义。它就好象我们创建一个全局函数的等价物（在C语言中）。除了全局函数不允许在Java中使用以外，若将一个static方法置入一个类的内部，它就可以访问其他static方法以及static字段。\n4.3 清除：收尾和垃圾收集 垃圾收集器只知道释放那些由 new 分配的内存,如何释放对象的“特殊”内存。，Java提供了一个名为 finalize()的方法，可为我们的类定义它。在理想情况下，它的工作原理应该是这样的：一旦垃圾收集器准备好释放对象占用的存储空间，它首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。所以如果使用finalize()，就可以在垃圾收集期间进行一些重要的清除或清扫工作。\n不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize 的问题]\n垃圾收集并不等于“破坏”！\n我们的对象可能不会当作垃圾被收掉！\n有时可能发现一个对象的存储空间永远都不会释放，因为自己的程序永远都接近于用光空间的临界点。若程序执行结束，而且垃圾收集器一直都没有释放我们创建的任何对象的存储空间，则随着程序的退出，那些资源会返回给操作系统。这是一件好事情，因为垃圾收集本身也要消耗一些开销。如永远都不用它，那么永远也不用支出这部分开销。\n↑↑↑如上所述，JVM可能并不进行 GC，那么 finalize() 也不会被调用！！！\n4.3.1 finalize()用途何在 此时，大家可能已相信了自己应该将 finalize()作为一种常规用途的清除方法使用。它有什么好处呢？ 要记住的第三个重点是：\n垃圾收集只跟内存有关！\n也就是说，垃圾收集器存在的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾收集有关的任何活动来说，其中最值得注意的是finalize()方法，它们也必须同内存以及它的回收有关。\n但这是否意味着假如对象包含了其他对象，finalize()就应该明确释放那些对象呢？答案是否定的——垃圾收集器会负责释放所有对象占据的内存，无论这些对象是如何创建的。它将对 finalize()的需求限制到特殊的情况。在这种情况下，我们的对象可采用与创建对象时不同的方法分配一些存储空间。但大家或许会注意到，Java中的所有东西都是对象，所以这到底是怎么一回事呢？\n之所以要使用 finalize()，看起来似乎是由于有时需要采取与Java的普通方法不同的一种方法，通过分配内存来做一些具有C风格的事情。这主要可以通过“固有方法”来进行，它是从Java里调用非Java方法的一种方式（固有方法的问题在附录A讨论）。C和C++是目前唯一获得固有方法支持的语言。但由于它们能调用通过其他语言编写的子程序，所以能够有效地调用任何东西。在非Java代码内部，也许能调用C的 malloc()系列函数，用它分配存储空间。而且除非调用了free()，否则存储空间不会得到释放，从而造成内存“漏洞”的出现。当然，free()是一个C和C++函数，所以我们需要在finalize()内部的一个固有方法中调用它。\n个人总结一下：就是说在垃圾回收中需要注意的或者说影响垃圾回收行为的代码就是 finalize()，如果一个类有 finalize() ，那么它在第一次被垃圾回收器找上门的时候并不会直接被回收，而是执行 finalize() 中的代码，第二次被垃圾回收器找上门时才会被回收，另需注意的是，只有内存不足才会触发垃圾回收，才会进一步触发 finalize() 在中的代码，可能整个程序运行期间都不会进行垃圾回收，那么在 finalize() 中的代码也不会被执行。\n4.3.2 必须执行清除 为清除一个对象，那个对象的用户必须在希望进行清除的地点调用一个清除方法。这听起来似乎很容易做到，但却与C++“破坏器”的概念稍有抵触。在C++中，所有对象都会破坏（清除）。或者换句话说，所有对象都“应该”破坏。若将C++对象创建成一个本地对象，比如在堆栈中创建（在Java中是不可能的），那么清除或破坏工作就会在“结束花括号”所代表的、创建这个对象的作用域的末尾进行。若对象是用new创建的（类似于Java），那么当程序员调用C++的delete命令时（Java没有这个命令），就会调用相应的破坏器。若程序员忘记了，那么永远不会调用破坏器，我们最终得到的将是一个内存“漏洞”，另外还包括对象的其他部分永远不会得到清除。\n相反，Java不允许我们创建本地（局部）对象——无论如何都要使用new。但在Java中，没有“delete”命令来释放对象，因为垃圾收集器会帮助我们自动释放存储空间。所以如果站在比较简化的立场，我们可以说正是由于存在垃圾收集机制，所以Java没有破坏器。然而，随着以后学习的深入，就会知道垃圾收集器的存在并不能完全消除对破坏器的需要，或者说不能消除对破坏器代表的那种机制的需要（而且绝对不能直接调用finalize()，所以应尽量避免用它）。若希望执行除释放存储空间之外的其他某种形式的清除工作，仍然必须调用Java中的一个方法。它等价于C++的破坏器，只是没后者方便。\nfinalize()最有用处的地方之一是观察垃圾收集的过程。下面这个例子向大家展示了垃圾收集所经历的过程，并对前面的陈述进行了总结。\n//: Garbage.java // Demonstration of the garbage // collector and finalization class Chair { static boolean gcrun = false; static boolean f = false; static int created = 0; static int finalized = 0; int i; Chair() { i = ++created; if(created == 47) System.out.println(\u0026#34;Created 47\u0026#34;); } protected void finalize() { if(!gcrun) { gcrun = true; System.out.println( \u0026#34;Beginning to finalize after \u0026#34; + created + \u0026#34; Chairs have been created\u0026#34;); } if(i == 47) { System.out.println( \u0026#34;Finalizing Chair #47, \u0026#34; + \u0026#34;Setting flag to stop Chair creation\u0026#34;); f = true; } finalized++; if(finalized \u0026gt;= created) System.out.println( \u0026#34;All \u0026#34; + finalized + \u0026#34; finalized\u0026#34;); } } public class Garbage { public static void main(String[] args) { if(args.length == 0) { System.err.println(\u0026#34;Usage: \\n\u0026#34; + \u0026#34;java Garbage before\\n or:\\n\u0026#34; + \u0026#34;java Garbage after\u0026#34;); return; } while(!Chair.f) { new Chair(); new String(\u0026#34;To take up space\u0026#34;); } System.out.println( \u0026#34;After all Chairs have been created:\\n\u0026#34; + \u0026#34;total created = \u0026#34; + Chair.created + \u0026#34;, total finalized = \u0026#34; + Chair.finalized); if(args[0].equals(\u0026#34;before\u0026#34;)) { System.out.println(\u0026#34;gc():\u0026#34;); System.gc(); System.out.println(\u0026#34;runFinalization():\u0026#34;); System.runFinalization(); } System.out.println(\u0026#34;bye!\u0026#34;); if(args[0].equals(\u0026#34;after\u0026#34;)) System.runFinalizersOnExit(true); } } ///:~ 上面这个程序创建了许多Chair对象，而且在垃圾收集器开始运行后的某些时候，程序会停止创建Chair。由于垃圾收集器可能在任何时间运行，所以我们不能准确知道它在何时启动。因此，程序用一个名为gcrun的标记来指出垃圾收集器是否已经开始运行。利用第二个标记f，Chair可告诉main()它应停止对象的生成。这两个标记都是在finalize()内部设置的，它调用于垃圾收集期间。\n另两个 static 变量——created以及 finalized——分别用于跟踪已创建的对象数量以及垃圾收集器已进行完收尾工作的对象数量。最后，每个Chair都有它自己的（非static）int i，所以能跟踪了解它具体的编号是多少。编号为47的Chair进行完收尾工作后，标记会设为true，最终结束Chair对象的创建过程。\n所有这些都在main()的内部进行——在下面这个循环里：\nwhile(!Chair.f) { new Chair(); new String(\u0026#34;To take up space\u0026#34;); } 为强制进行收尾工作，可先调用System.gc()，再调用System.runFinalization()。这样可清除到目前为止没有使用的所有对象。若在这里首先调用runFinalization()，再调用gc()，收尾模块根本不会执行。\n有些Java虚拟机（JVM）可能已开始表现出不同的行为。为展示 GC 过程及 finalize() 作用，另寻以下示例：\n//示例代码--周志明著 Java虚拟机 public class FinalizeEscapeGC { public static FinalizeEscapeGC SAVE_HOOK = null; public String name; public FinalizeEscapeGC(String name) { this.name = name; } public void isAlive() { System.out.println(\u0026#34;yes, i am still alive\u0026#34;); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\u0026#34;finalize method executed!\u0026#34;); System.out.println(this.name); FinalizeEscapeGC.SAVE_HOOK = this; } public static void main(String[] args) throws Throwable { SAVE_HOOK = new FinalizeEscapeGC(\u0026#34;abc\u0026#34;); SAVE_HOOK =null; System.gc(); Thread.sleep(500); if(SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(\u0026#34;no, i am dead\u0026#34;); } SAVE_HOOK =null; System.gc(); Thread.sleep(500); if(SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(\u0026#34;no, i am dead\u0026#34;); } } } // 第21行，第一次垃圾回收，名为abc的FinalizeEscapeGC实例对象的finalize()方法执行，此时全局静态变量 SAVE_HOOK又重新指向了改对象，使得该对象“复活”， // 第29行，再次切断引用链，30行，第二次垃圾回收，该对象的finalize()方法不会再执行了。该对象在堆中的空间被释放。 4.4 成员初始化 一个类的所有基本类型数据成员都会保证获得一个初始值。若被定义成相对于一个方法的“局部”变量，这一保证就通过编译期的出错提示表现出来。\n4.4.1 规定初始化 想自己为变量赋予一个初始值，直接的做法是在类内部定义变量的同时也为其赋值。\n4.4.2 构建器初始化 可考虑用构建器执行初始化进程。这样便可在编程时获得更大的灵活程度。要注意这样一件事情：不可妨碍自动初始化的进行，它在构建器进入之前就会发生。例如：\nclass Counter { int i; Counter() { i = 7; } // . . . 那么i首先会初始化成零，然后变成 7。对于所有基本类型以及对象句柄，这种情况都是成立的，其中包括在定义时已进行了明确初始化的那些一些。\n初始化顺序 在一个类里，初始化的顺序是由变量在类内的定义顺序决定的。即使变量定义大量遍布于方法定义的中间，那些变量仍会在调用任何方法之前得到初始化——甚至在构建器调用之前。例如：\n//: OrderOfInitialization.java // Demonstrates initialization order. // When the constructor is called, to create a // Tag object, you\u0026#39;ll see a message: class Tag { Tag(int marker) { System.out.println(\u0026#34;Tag(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } class Card { Tag t1 = new Tag(1); // Before constructor Card() { // Indicate we\u0026#39;re in the constructor: System.out.println(\u0026#34;Card()\u0026#34;); t3 = new Tag(33); // Re-initialize t3 } Tag t2 = new Tag(2); // After constructor void f() { System.out.println(\u0026#34;f()\u0026#34;); } Tag t3 = new Tag(3); // At end } public class OrderOfInitialization { public static void main(String[] args) { Card t = new Card(); t.f(); // Shows that construction is done } } ///:~ 它的输入结果如下：\nTag(1) Tag(2) Tag(3) Card() Tag(33) f() 静态数据的初始化 若数据是静态的（static），那么同样的事情就会发生；如果它属于一个基本类型（主类型），而且未对其初始化，就会自动获得自己的标准基本类型初始值；如果它是指向一个对象的句柄，那么除非新建一个对象，并将句柄同它连接起来，否则就会得到一个空值（NULL）。\nstatic 值只有一个存储区域。如果它属于一个基本类型（主类型），而且未对其初始化，就会自动获得自己的标准基本类型初始值；如果它是指向一个对象的句柄，那么除非新建一个对象，并将句柄同它连接起来，否则就会得到一个空值（NULL）。\n//: StaticInitialization.java // Specifying initial values in a // class definition. class Bowl { Bowl(int marker) { System.out.println(\u0026#34;Bowl(\u0026#34; + marker + \u0026#34;)\u0026#34;); } void f(int marker) { System.out.println(\u0026#34;f(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } class Table { static Bowl b1 = new Bowl(1); Table() { System.out.println(\u0026#34;Table()\u0026#34;); b2.f(1); } void f2(int marker) { System.out.println(\u0026#34;f2(\u0026#34; + marker + \u0026#34;)\u0026#34;); } static Bowl b2 = new Bowl(2); } class Cupboard { Bowl b3 = new Bowl(3); static Bowl b4 = new Bowl(4); Cupboard() { System.out.println(\u0026#34;Cupboard()\u0026#34;); b4.f(2); } void f3(int marker) { System.out.println(\u0026#34;f3(\u0026#34; + marker + \u0026#34;)\u0026#34;); } static Bowl b5 = new Bowl(5); } public class StaticInitialization { public static void main(String[] args) { System.out.println( \u0026#34;Creating new Cupboard() in main\u0026#34;); new Cupboard(); System.out.println( \u0026#34;Creating new Cupboard() in main\u0026#34;); new Cupboard(); t2.f2(1); t3.f3(1); } static Table t2 = new Table(); static Cupboard t3 = new Cupboard(); } ///:~ Bowl允许我们检查一个类的创建过程，而Table和Cupboard能创建散布于类定义中的Bowl的static成员。注意在static定义之前，Cupboard先创建了一个非static的Bowl b3。它的输出结果如下：\nBowl(1) Bowl(2) Table() f(1) Bowl(4) Bowl(5) Bowl(3) Cupboard() f(2) Creating new Cupboard() in main Bowl(3) Cupboard() f(2) Creating new Cupboard() in main Bowl(3) Cupboard() f(2) f2(1) f3(1) static 初始化只有在必要的时候才会进行。如果不创建一个 Table 对象，而且永远都不引用 Table.b1或 Table.b2，那么 static Bowl b1和 b2永远都不会创建。然而，只有在创建了第一个 Table 对象之后（或者发生了第一次 static 访问），它们才会创建。在那以后，static对象不会重新初始化。 初始化的顺序是首先 static（如果它们尚未由前一次对象创建过程初始化），接着是非 static对象。大家可从输出结果中找到相应的证据。\n总结一下对象的创建过程。请考虑一个名为Dog的类：\n类型为Dog的一个对象首次创建时，或者Dog类的static方法／static字段首次访问时，Java解释器必须找到Dog.class（在事先设好的类路径里搜索）。\n找到Dog.class后（它会创建一个Class对象，这将在后面学到），它的所有static初始化模块都会运行。因此，static初始化仅发生一次——在Class对象首次载入的时候。\n创建一个new Dog()时，Dog对象的构建进程首先会在内存堆（Heap）里为一个Dog对象分配足够多的存储空间。\n这种存储空间会清为零，将Dog中的所有基本类型设为它们的默认值（零用于数字，以及boolean和char的等价设定）。\n进行字段定义时发生的所有初始化都会执行。\n执行构建器。正如第6章将要讲到的那样，这实际可能要求进行相当多的操作，特别是在涉及继承的时候。\n明确进行的静态初始化\nJava允许我们将其他static初始化工作划分到类内一个特殊的“static构建从句”（有时也叫作“静态块”）里。它看起来象下面这个样子：\nclass Spoon { static int i; static { i = 47; } } // . . . 尽管看起来象个方法，但它实际只是一个static关键字，后面跟随一个方法主体。与其他static初始化一样，这段代码仅执行一次——首次生成那个类的一个对象时，或者首次访问属于那个类的一个static成员时（即便从未生成过那个类的对象）。例如：\n//: ExplicitStatic.java // Explicit static initialization // with the \u0026#34;static\u0026#34; clause. class Cup { Cup(int marker) { System.out.println(\u0026#34;Cup(\u0026#34; + marker + \u0026#34;)\u0026#34;); } void f(int marker) { System.out.println(\u0026#34;f(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } class Cups { static Cup c1; static Cup c2; static { c1 = new Cup(1); c2 = new Cup(2); } Cups() { System.out.println(\u0026#34;Cups()\u0026#34;); } } public class ExplicitStatic { public static void main(String[] args) { System.out.println(\u0026#34;Inside main()\u0026#34;); Cups.c1.f(99); // (1) } static Cups x = new Cups(); // (2) static Cups y = new Cups(); // (2) } ///:~ 非静态实例的初始化 针对每个对象的非静态变量的初始化，Java 1.1提供了一种类似的语法格式。下面是一个例子：\n//: Mugs.java // Java 1.1 \u0026#34;Instance Initialization\u0026#34; class Mug { Mug(int marker) { System.out.println(\u0026#34;Mug(\u0026#34; + marker + \u0026#34;)\u0026#34;); } void f(int marker) { System.out.println(\u0026#34;f(\u0026#34; + marker + \u0026#34;)\u0026#34;); } } public class Mugs { Mug c1; Mug c2; { c1 = new Mug(1); c2 = new Mug(2); System.out.println(\u0026#34;c1 \u0026amp; c2 initialized\u0026#34;); } Mugs() { System.out.println(\u0026#34;Mugs()\u0026#34;); } public static void main(String[] args) { System.out.println(\u0026#34;Inside main()\u0026#34;); Mugs x = new Mugs(); } } ///:~ 它看起来与静态初始化从句极其相似，只是static关键字从里面消失了。为支持对“匿名内部类”的初始化（参见第7章），必须采用这一语法格式。\n4.5 数组初始化 数组属于引用数据类型，所以在数组使用之前一定要开辟控件（实例化），如果使用了没有开辟空间的数组，则一定会出现 NullPointerException 异常信息。既然数组属于引用数据类型，那么也一定可以发生引用传递。\n数组先开辟内存空间，而后再使用索引进行内容的设置，实际上这种做法都叫做动态初始化，而如果希望数组在定义的时候可以同时出现设置内容，那么就可以采用静态初始化完成。\n//动态初始化 int data[] = null; data = new int[3]; //开辟一个长度为3的数组 int temp[] = null; //声明对象 data[0] = 10; data[1] = 20; data[2] = 30; //静态初始化 int data[] = {1, 2, 4, 545, 11, 32, 13131, 4444}; int data2[] = new int[] {1, 2, 4, 545, 11, 32, 13131, 4444}; 所有数组都有一个本质成员（无论它们是对象数组还是基本类型数组），可对其进行查询——但不是改变，从而获知数组内包含了多少个元素。这个成员就是length。\n基本数据类型的数组元素会自动初始化成“空”值（对于数值，空值就是零；对于char，它是null；而对于boolean，它却是false）。\n4.6 总结 作为初始化的一种具体操作形式，构建器应使大家明确感受到在语言中进行初始化的重要性。与C++的程序设计一样，判断一个程序效率如何，关键是看是否由于变量的初始化不正确而造成了严重的编程错误（臭虫）。这些形式的错误很难发现，而且类似的问题也适用于不正确的清除或收尾工作。由于构建器使我们能保证正确的初始化和清除（若没有正确的构建器调用，编译器不允许对象创建），所以能获得完全的控制权和安全性。\n在C++中，与“构建”相反的“破坏”（Destruction）工作也是相当重要的，因为用new创建的对象必须明确地清除。在Java中，垃圾收集器会自动为所有对象释放内存，所以Java中等价的清除方法并不是经常都需要用到的。如果不需要类似于构建器的行为，Java的垃圾收集器可以极大简化编程工作，而且在内存的管理过程中增加更大的安全性。有些垃圾收集器甚至能清除其他资源，比如图形和文件句柄等。然而，垃圾收集器确实也增加了运行期的开销。但这种开销到底造成了多大的影响却是很难看出的，因为到目前为止，Java解释器的总体运行速度仍然是比较慢的。随着这一情况的改观，我们应该能判断出垃圾收集器的开销是否使Java不适合做一些特定的工作（其中一个问题是垃圾收集器不可预测的性质）。\n由于所有对象都肯定能获得正确的构建，所以同这儿讲述的情况相比，构建器实际做的事情还要多得多。特别地，当我们通过“创作”或“继承”生成新类的时候，对构建的保证仍然有效，而且需要一些附加的语法来提供对它的支持。大家将在以后的章节里详细了解创作、继承以及它们对构建器造成的影响。\n第 5 章 隐藏实施过程 “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。”\n这一点对于库来说是特别重要的。那个库的用户（客户程序员）必须能依赖自己使用的那一部分，并知道一旦新版本的库出台，自己不需要改写代码。而与此相反，库的创建者必须能自由地进行修改与改进，同时保证客户程序员代码不会受到那些变动的影响。\n为达到这个目的，需遵守一定的约定或规则。例如，库程序员在修改库内的一个类时，必须保证不删除已有的方法，因为那样做会造成客户程序员代码出现断点。然而，相反的情况却是令人痛苦的。对于一个数据成员，库的创建者怎样才能知道哪些数据成员已受到客户程序员的访问呢？若方法属于某个类唯一的一部分，而且并不一定由客户程序员直接使用，那么这种痛苦的情况同样是真实的。如果库的创建者想删除一种旧有的实施方案，并置入新代码，此时又该怎么办呢？对那些成员进行的任何改动都可能中断客户程序员的代码。所以库创建者处在一个尴尬的境地，似乎根本动弹不得。\n为解决这个问题，Java推出了“访问指示符”的概念，允许库创建者声明哪些东西是客户程序员可以使用的，哪些是不可使用的。这种访问控制的级别在“最大访问”和“最小访问”的范围之间，分别包括：public，“友好的”（无关键字），protected以及private。根据前一段的描述，大家或许已总结出作为一名库设计者，应将所有东西都尽可能保持为“private”（私有），并只展示出那些想让客户程序员使用的方法。这种思路是完全正确的，尽管它有点儿违背那些用其他语言（特别是C）编程的人的直觉，那些人习惯于在没有任何限制的情况下访问所有东西。到这一章结束时，大家应该可以深刻体会到Java访问控制的价值。\n然而，组件库以及控制谁能访问那个库的组件的概念现在仍不是完整的。仍存在这样一个问题：如何将组件绑定到单独一个统一的库单元里。这是通过Java的package（打包）关键字来实现的，而且访问指示符要受到类在相同的包还是在不同的包里的影响。所以在本章的开头，大家首先要学习库组件如何置入包里。这样才能理解访问指示符的完整含义。\n5.1 包：库单元 我们用import关键字导入一个完整的库时，就会获得“包”（Package）。例如：\nimport java.util.*; 它的作用是导入完整的实用工具（Utility）库，该库属于标准Java开发工具包的一部分。由于Vector位于java.util里，所以现在要么指定完整名称“java.util.Vector”（可省略import语句），要么简单地指定一个“Vector”（因为import是默认的）。\n若想导入单独一个类，可在import语句里指定那个类的名字：\nimport java.util.Vector; 之所以要进行这样的导入，是为了提供一种特殊的机制，以便管理“命名空间”（Name Space）。我们所有类成员的名字相互间都会隔离起来。位于类A内的一个方法f()不会与位于类B内的、拥有相同“签名”（自变量列表）的f()发生冲突。但类名会不会冲突呢？假设创建一个stack类，将它安装到已有一个stack类（由其他人编写）的机器上，这时会出现什么情况呢？对于因特网中的Java应用，这种情况会在用户毫不知晓的时候发生，因为类会在运行一个Java程序的时候自动下载。\n正是由于存在名字潜在的冲突，所以特别有必要对Java中的命名空间进行完整的控制，而且需要创建一个完全独一无二的名字，无论因特网存在什么样的限制\n迄今为止，本书的大多数例子都仅存在于单个文件中，而且设计成局部（本地）使用，没有同包名发生冲突（在这种情况下，类名置于“默认包”内）。这是一种有效的做法，而且考虑到问题的简化，本书剩下的部分也将尽可能地采用它。然而，若计划创建一个“对因特网友好”或者说“适合在因特网使用”的程序，必须考虑如何防止类名的重复。 为Java创建一个源码文件的时候，它通常叫作一个“编辑单元”（有时也叫作“翻译单元”）。每个编译单元都必须有一个以.java结尾的名字。而且在编译单元的内部，可以有一个公共（public）类，它必须拥有与文件相同的名字（包括大小写形式，但排除.java文件扩展名）。如果不这样做，编译器就会报告出错。每个编译单元内都只能有一个public类（同样地，否则编译器会报告出错）。那个编译单元剩下的类（如果有的话）可在那个包外面的世界面前隐藏起来，因为它们并非“公共”的（非public），而且它们由用于主public类的“支撑”类组成。\n编译一个.java文件时，我们会获得一个名字完全相同的输出文件；但对于.java文件中的每个类，它们都有一个.class扩展名。因此，我们最终从少量的.java文件里有可能获得数量众多的.class文件。如以前用一种汇编语言写过程序，那么可能已习惯编译器先分割出一种过渡形式（通常是一个.obj文件），再用一个链接器将其与其他东西封装到一起（生成一个可执行文件），或者与一个库封装到一起（生成一个库）。但那并不是Java的工作方式。一个有效的程序就是一系列.class文件，它们可以封装和压缩到一个JAR文件里（使用Java 1.1提供的jar工具）。Java解释器负责对这些文件的寻找、装载和解释（注释①）。\n①：Java并没有强制一定要使用解释器。一些固有代码的Java编译器可生成单独的可执行文件。\nclass 文件径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。\n当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的“机器语言”。\n与普通程序不同的是，Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。\n在cmd下使用javac 编译某一java文件则会产生.class文件,用java +类名运行。\n“库”也由一系列类文件构成。每个文件都有一个public类（并没强迫使用一个public类，但这种情况最很典型的），所以每个文件都有一个组件。如果想将所有这些组件（它们在各自独立的.java和.class文件里）都归纳到一起，那么package关键字就可以发挥作用）。\n若在一个文件的开头使用下述代码：\npackage mypackage; 那么 package 语句必须作为文件的第一个非注释语句出现。该语句的作用是指出这个编译单元属于名为mypackage的一个库的一部分。或者换句话说，它表明这个编译单元内的public类名位于mypackage这个名字的下面。如果其他人想使用这个名字，要么指出完整的名字，要么与mypackage联合使用import关键字（使用前面给出的选项）。注意根据Java包（封装）的约定，名字内的所有字母都应小写，甚至那些中间单词亦要如此。\n每个 .java 文件中只能有一个 public类\n现在，如果有人想使用 MyClass，或者想使用 mypackage 内的其他任何 public类，他们必须用 import关键字激活 mypackage内的名字，使它们能够使用。另一个办法则是指定完整的名称：\nmypackage.MyClass m = new mypackage.MyClass(); 或者\nimport mypackage.*; // . . . MyClass m = new MyClass(); 一定要记住 package 和 import 关键字允许我们做的事情就是分割单个全局命名空间，保证我们不会遇到名字的冲突——无论有多少人使用因特网，也无论多少人用Java编写自己的类。\n5.1.1 创建独一无二的包名 大家或许已注意到这样一个事实：由于一个包永远不会真的“封装”到单独一个文件里面，它可由多个.class文件构成，所以局面可能稍微有些混乱。为避免这个问题，最合理的一种做法就是将某个特定包使用的所有.class文件都置入单个目录里。也就是说，我们要利用操作系统的分级文件结构避免出现混乱局面。这正是Java所采取的方法。 它同时也解决了另两个问题：创建独一无二的包名以及找出那些可能深藏于目录结构某处的类。正如我们在第2章讲述的那样，为达到这个目的，需要将.class文件的位置路径编码到package的名字里。但根据约定，编译器强迫package名的第一部分是类创建者的因特网域名。由于因特网域名肯定是独一无二的（由InterNIC保证——注释②，它控制着域名的分配），所以假如按这一约定行事，package的名称就肯定不会重复，所以永远不会遇到名称冲突的问题。换句话说，除非将自己的域名转让给其他人，而且对方也按照相同的路径名编写Java代码，否则名字的冲突是永远不会出现的。当然，如果你没有自己的域名，那么必须创造一个非常生僻的包名（例如自己的英文姓名），以便尽最大可能创建一个独一无二的包名。如决定发行自己的Java代码，那么强烈推荐去申请自己的域名，它所需的费用是非常低廉的。\nJava解释器的工作程序如下：首先，它找到环境变量CLASSPATH（将Java或者具有Java解释能力的工具——如浏览器——安装到机器中时，通过操作系统进行设定）。CLASSPATH包含了一个或多个目录，它们作为一种特殊的“根”使用，从这里展开对.class文件的搜索。从那个根开始，解释器会寻找包名，并将每个点号（句点）替换成一个斜杠，从而生成从CLASSPATH根开始的一个路径名（所以package foo.bar.baz会变成foo\\bar\\baz或者foo/bar/baz；具体是正斜杠还是反斜杠由操作系统决定）。随后将它们连接到一起，成为CLASSPATH内的各个条目（入口）。以后搜索.class文件时，就可从这些地方开始查找与准备创建的类名对应的名字。此外，它也会搜索一些标准目录——这些目录与Java解释器驻留的地方有关。\n使用JAR文件时要注意一个问题：必须将JAR文件的名字置于类路径里，而不仅仅是它所在的路径。所以对一个名为grape.jar的JAR文件来说，我们的类路径需要包括：\nCLASSPATH=.;D:\\JAVA\\LIB;C:\\flavors\\grape.jar 自动编译: 为导入的类首次创建一个对象时（或者访问一个类的static成员时），编译器会在适当的目录里寻找同名的.class文件（所以如果创建类X的一个对象，就应该是X.class）。若只发现X.class，它就是必须使用的那一个类。然而，如果它在相同的目录中还发现了一个X.java，编译器就会比较两个文件的日期标记。如果X.java比X.class新，就会自动编译X.java，生成一个最新的X.class。 对于一个特定的类，或在与它同名的.java文件中没有找到它，就会对那个类采取上述的处理。\n5.1.2 自定义工具库 创建自己的工具库，以便减少或者完全消除重复的代码。\nCLASSPATH的陷阱 5.1.3 利用导入改变行为 Java已取消的一种特性是C的“条件编译”，它允许我们改变参数，获得不同的行为，同时不改变其他任何代码。Java之所以抛弃了这一特性，可能是由于该特性经常在C里用于解决跨平台问题：代码的不同部分根据具体的平台进行编译，否则不能在特定的平台上运行。由于Java的设计思想是成为一种自动跨平台的语言，所以这种特性是没有必要的。\n然而，条件编译还有另一些非常有价值的用途。一种很常见的用途就是调试代码。调试特性可在开发过程中使用，但在发行的产品中却无此功能。Alen Holub（www.holub.com）提出了利用包（package）来模仿条件编译的概念。根据这一概念，它创建了C“断定机制”一个非常有用的Java版本。之所以叫作“断定机制”，是由于我们可以说“它应该为真”或者“它应该为假”。如果语句不同意你的断定，就可以发现相关的情况。这种工具在调试过程中是特别有用的。\n通过改变导入的package，我们可将自己的代码从调试版本变成最终的发行版本。这种技术可应用于任何种类的条件代码。\n5.1.4 包的停用 大家应注意这样一个问题：每次创建一个包后，都在为包取名时间接地指定了一个目录结构。这个包必须存在（驻留）于由它的名字规定的目录内。而且这个目录必须能从CLASSPATH开始搜索并发现。最开始的时候，package关键字的运用可能会令人迷惑，因为除非坚持遵守根据目录路径指定包名的规则，否则就会在运行期获得大量莫名其妙的消息，指出找不到一个特定的类——即使那个类明明就在相同的目录中。若得到象这样的一条消息，请试着将package语句作为注释标记出去。如果这样做行得通，就可知道问题到底出在哪儿。\n5.2 Java 访问指示符 private -\u0026gt; default（Friendly） -\u0026gt; protected-\u0026gt; public 类中 -\u0026gt; 包内 -\u0026gt; 子类 -\u0026gt; 公开 修饰符 类内部 同包 子类 任何地方 private Yes default Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 5.2.1 default（Friendly） (4) Provide 提供“accessor／mutator”方法（亦称为“get／set”方法），以便读取和修改值。这是 OOP环境中最正规的一种方法，也是Java Beans的基础——具体情况会在第13章介绍。\n5.2.3 private private 有非常重要的用途，特别是在涉及多线程处理的时候（详情见第14章）。\n//: IceCream.java // Demonstrates \u0026#34;private\u0026#34; keyword class Sundae { private Sundae() {} static Sundae makeASundae() { return new Sundae(); } } public class IceCream { public static void main(String[] args) { //! Sundae x = new Sundae(); Sundae x = Sundae.makeASundae(); } } ///:~ 例子演示了使用private的方便：有时可能想控制对象的创建方式，并防止有人直接访问一个特定的构建器（或者所有构建器）。在上面的例子中，我们不可通过它的构建器创建一个Sundae对象；相反，必须调用makeASundae()方法来实现（注释③）。\n③：此时还会产生另一个影响：由于默认构建器是唯一获得定义的，而且它的属性是private，所以可防止对这个类的继承（这是第6章要重点讲述的主题）。\n5.3 接口与实现 我们通常认为访问控制是“隐藏实施细节”的一种方式。将数据和方法封装到类内后，可生成一种数据类型，它具有自己的特征与行为。但由于两方面重要的原因，访问为那个数据类型加上了自己的边界。第一个原因是规定客户程序员哪些能够使用，哪些不能。我们可在结构里构建自己的内部机制，不用担心客户程序员将其当作接口的一部分，从而自由地使用或者“滥用”。\n这个原因直接导致了第二个原因：我们需要将接口同实施细节分离开。若结构在一系列程序中使用，但用户除了将消息发给public接口之外，不能做其他任何事情，我们就可以改变不属于public的所有东西（如“友好的”、protected以及private），同时不要求用户对他们的代码作任何修改。\n我们现在是在一个面向对象的编程环境中，其中的一个类（class）实际是指“一类对象”，就象我们说“鱼类”或“鸟类”那样。从属于这个类的所有对象都共享这些特征与行为。“类”是对属于这一类的所有对象的外观及行为进行的一种描述。\n在一些早期OOP语言中，如Simula-67，关键字class的作用是描述一种新的数据类型。同样的关键字在大多数面向对象的编程语言里都得到了应用。它其实是整个语言的焦点：需要新建数据类型的场合比那些用于容纳数据和方法的“容器”多得多。\n在一些早期OOP语言中，如Simula-67，关键字class的作用是描述一种新的数据类型。同样的关键字在大多数面向对象的编程语言里都得到了应用。它其实是整个语言的焦点：需要新建数据类型的场合比那些用于容纳数据和方法的“容器”多得多。\n在Java中，类是最基本的OOP概念。它是本书未采用粗体印刷的关键字之一——由于数量太多，所以会造成页面排版的严重混乱。\n由于接口和实施细节仍然混合在一起，所以只是部分容易阅读。也就是说，仍然能够看到源码——实施的细节，因为它们需要保存在类里面。向一个类的消费者显示出接口实际是“类浏览器”的工作。这种工具能查找所有可用的类，总结出可对它们采取的全部操作（比如可以使用哪些成员等），并用一种清爽悦目的形式显示出来。到大家读到这本书的时候，所有优秀的Java开发工具都应推出了自己的浏览器。\n5.4 类访问 在Java中，亦可用访问指示符判断出一个库内的哪些类可由那个库的用户使用。\n我们注意到一些额外的限制： 每个编译单元（文件）都只能有一个public类。每个编译单元有一个公共接口的概念是由那个公共类表达出来的。根据自己的需要，它可拥有任意多个提供支撑的“友好”类。但若在一个编译单元里使用了多个public类，编译器就会向我们提示一条出错消息。 public类的名字必须与包含了编译单元的那个文件的名字完全相符，甚至包括它的大小写形式。 可能（但并常见）有一个编译单元根本没有任何公共类。此时，可按自己的意愿任意指定文件名。(内部使用，不希望有客户程序员依赖。) 若不愿其他任何人访问那个类，可将所有构建器设为private。这样一来，在类的一个static成员内部，除自己之外的其他所有人都无法创建属于那个类的一个对象（注释⑤）。 若不愿其他任何人访问那个类，可将所有构建器设为private。这样一来，在类的一个static成员内部，除自己之外的其他所有人都无法创建属于那个类的一个对象（注释⑤）。 5.5 总结 对于任何关系，最重要的一点都是规定好所有方面都必须遵守的界限或规则。\n有两方面的原因要求我们控制对成员的访问。第一个是防止用户接触那些他们不应碰的工具。对于数据类型的内部机制，那些工具是必需的。但它们并不属于用户接口的一部分，用户不必用它来解决自己的特定问题。所以将方法和字段变成“私有”（private）后，可极大方便用户。因为他们能轻易看出哪些对于自己来说是最重要的，以及哪些是自己需要忽略的。这样便简化了用户对一个类的理解。\n进行访问控制的第二个、也是最重要的一个原因是：允许库设计者改变类的内部工作机制，同时不必担心它会对客户程序员产生什么影响。\n一个类的公共接口是所有用户都能看见的，所以在进行分析与设计的时候，这是应尽量保证其准确性的最重要的一个部分。但也不必过于紧张，少许的误差仍然是允许的。若最初设计的接口存在少许问题，可考虑添加更多的方法，只要保证不删除客户程序员已在他们的代码里使用的东西。\n第 6 章 类再生 代码的重复使用\n第一个最简单：在新类里简单地创建原有类的对象。我们把这种方法叫作“合成”，因为新类由现有类的对象合并而成。我们只是简单地重复利用代码的功能，而不是采用它的形式。 第二种方法则显得稍微有些技巧。它创建一个新类，将其作为现有类的一个“类型”。我们可以原样采取现有类的形式，并在其中加入新代码，同时不会对现有的类产生影响。这种魔术般的行为叫作“继承”（Inheritance），涉及的大多数工作都是由编译器完成的。对于面向对象的程序设计，“继承”是最重要的基础概念之一。 6.1 合成的语法 为进行合成，我们只需在新类里简单地置入对象句柄即可。对于非基本类型的对象来说，只需将句柄置于新类即可；而对于基本数据类型来说，则需在自己的类中定义它们。\n每种非基本类型的对象都有一个toString()方法。若编译器本来希望一个String，但却获得某个这样的对象，就会调用这个方法（意思是说，把对象当 String 用的时候就会调用这个方法）。\n在类内作为字段使用的基本数据会初始化成零，就象第2章指出的那样。但对象句柄会初始化成null。而且假若试图为它们中的任何一个调用方法，就会产生一次“违例”。这种结果实际是相当好的（而且很有用），我们可在不丢弃一次违例的前提下，仍然把它们打印出来。\n编译器并不只是为每个句柄创建一个默认对象，因为那样会在许多情况下招致不必要的开销。如希望句柄得到初始化，可在下面这些地方进行： 在对象定义的时候。这意味着它们在构建器调用之前肯定能得到初始化。 在那个类的构建器中。 紧靠在要求实际使用那个对象之前。这样做可减少不必要的开销——假如对象并不需要创建的话。 下面向大家展示了所有这三种方法： //: Bath.java // Constructor initialization with composition class Soap { private String s; Soap() { System.out.println(\u0026#34;Soap()\u0026#34;); s = new String(\u0026#34;Constructed\u0026#34;); } public String toString() { return s; } } public class Bath { private String // Initializing at point of definition: s1 = new String(\u0026#34;Happy\u0026#34;), s2 = \u0026#34;Happy\u0026#34;, s3, s4; Soap castille; int i; float toy; Bath() { System.out.println(\u0026#34;Inside Bath()\u0026#34;); s3 = new String(\u0026#34;Joy\u0026#34;); i = 47; toy = 3.14f; castille = new Soap(); } void print() { // Delayed initialization: if(s4 == null) s4 = new String(\u0026#34;Joy\u0026#34;); System.out.println(\u0026#34;s1 = \u0026#34; + s1); System.out.println(\u0026#34;s2 = \u0026#34; + s2); System.out.println(\u0026#34;s3 = \u0026#34; + s3); System.out.println(\u0026#34;s4 = \u0026#34; + s4); System.out.println(\u0026#34;i = \u0026#34; + i); System.out.println(\u0026#34;toy = \u0026#34; + toy); System.out.println(\u0026#34;castille = \u0026#34; + castille); } public static void main(String[] args) { Bath b = new Bath(); b.print(); } } ///:~ 6.2 继承的语法 继承与Java（以及其他OOP语言）非常紧密地结合在一起。创建一个类时肯定会进行继承，因为若非如此，会从Java的标准根类Object中继承。\n需要继承的时候，需要给出类名,在类主体的起始花括号之前，放置一个关键字 extends，在后面跟随“基础类”的名字。就可自动获得基础类的所有数据成员以及方法。\n我们可为自己的每个类都创建一个main()。对于在命令行请求的public类，只有main()才会得到调用。所以在这种情况下，当我们使用“java Detergent”的时候，调用的是Degergent.main()。采用这种将main()置入每个类的做法，可方便地为每个类都进行单元测试。\n倘若省略所有访问指示符，则成员默认为“友好的”。这样一来，就只允许对包成员进行访问。在这个包内，任何人都可使用那些没有访问指示符的方法。然而，假设来自另外某个包的类准备继承Cleanser，它就只能访问那些public成员。\n可以用 super 关键字，它引用当前类已从中继承的一个“超类”（Superclass）的方法。\n6.2.1 初始化基础类 由于这儿涉及到两个类——基础类及衍生类，而不再是以前的一个，所以在想象衍生类的结果对象时，可能会产生一些迷惑。从外部看，似乎新类拥有与基础类相同的接口，而且可包含一些额外的方法和字段。但继承并非仅仅简单地复制基础类的接口了事。创建衍生类的一个对象时，它在其中包含了基础类的一个“子对象”。这个子对象就象我们根据基础类本身创建了它的一个对象。从外部看，基础类的子对象已封装到衍生类的对象里了。\n当然，基础类子对象应该正确地初始化，而且只有一种方法能保证这一点：在构建器中执行初始化，通过调用基础类构建器，后者有足够的能力和权限来执行对基础类的初始化。在衍生类的构建器中，Java会自动插入对基础类构建器的调用。下面这个例子向大家展示了对这种三级继承的应用：\n//: Cartoon.java // Constructor calls during inheritance class Art { Art() { System.out.println(\u0026#34;Art constructor\u0026#34;); } } class Drawing extends Art { Drawing() { System.out.println(\u0026#34;Drawing constructor\u0026#34;); } } public class Cartoon extends Drawing { Cartoon() { System.out.println(\u0026#34;Cartoon constructor\u0026#34;); } public static void main(String[] args) { Cartoon x = new Cartoon(); } } ///:~ 该程序的输出显示了自动调用：\nArt constructor Drawing constructor Cartoon constructor 可以看出，构建是在基础类的“外部”进行的，所以基础类会在衍生类访问它之前得到正确的初始化。 即使没有为Cartoon()创建一个构建器，编译器也会为我们自动合成一个默认构建器，并发出对基础类构建器的调用。\n在衍生类构建器中，对基础类构建器的调用是必须做的第一件事情,衍生类构建器会默认调用基础类无参构造器，若基础类无默认无参构造器，编译器会报错，如果类没有默认的无参构造器，或者想调用含有一个自变量的某个基础类构建器，必须明确地编写对基础类的调用代码。用super关键字以及适当的自变量列表实现。\n6.2 合成与继承的结合 编译器会强迫我们对基础类进行初始化，并要求我们在构建器最开头做这一工作，但它并不会监视我们是否正确初始化了成员对象。所以对此必须特别加以留意。\n6.3.1 确保正确的清除 代码置于一个finally从句中，从而防范任何可能出现的违例事件。\ntry关键字指出后面跟随的块（由花括号定界）是一个“警戒区”。也就是说，它会受到特别的待遇。其中一种待遇就是：该警戒区后面跟随的finally从句的代码肯定会得以执行——不管try块到底存不存在（通过违例控制技术，try块可有多种不寻常的应用）。在这里，finally从句的意思是“总是为x调用cleanup()，无论会发生什么事情”。\n垃圾收集的顺序 不能指望自己能确切知道何时会开始垃圾收集。垃圾收集器可能永远不会得到调用。即使得到调用，它也可能以自己愿意的任何顺序回收对象。除此以外，Java 1.0实现的垃圾收集器机制通常不会调用finalize()方法。除内存的回收以外，其他任何东西都最好不要依赖垃圾收集器进行回收。若想明确地清除什么，请制作自己的清除方法，而且不要依赖finalize()。然而正如以前指出的那样，可强迫Java1.1调用所有收尾模块（Finalizer）。\n6.4 到底选择合成还是继承 如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”关系是用继承来表达的，而“包含”关系是用合成来表达的。 6.5 protected 现在我们已理解了继承的概念，protected这个关键字最后终于有了意义。在理想情况下，private成员随时都是“私有”的，任何人不得访问。但在实际应用中，经常想把某些东西深深地藏起来，但同时允许访问衍生类的成员。protected关键字可帮助我们做到这一点。它的意思是“它本身是私有的，但可由从这个类继承的任何东西或者同一个包内的其他任何东西访问”。也就是说，Java中的protected会成为进入“友好”状态。\n我们采取的最好的做法是保持成员的private状态——无论如何都应保留对基 础的实施细节进行修改的权利。在这一前提下，可通过protected方法允许类的继承者进行受到控制的访问：\n//: Orc.java // The protected keyword import java.util.*; class Villain { private int i; protected int read() { return i; } protected void set(int ii) { i = ii; } public Villain(int ii) { i = ii; } public int value(int m) { return m*i; } } public class Orc extends Villain { private int j; public Orc(int jj) { super(jj); j = jj; } public void change(int x) { set(x); } //可以看到，change()拥有对set()的访问权限，因为它的属性是protected（受到保护的） } ///:~ 6.6 累积开发 继承的一个好处是它支持“累积开发”，允许我们引入新的代码，同时不会为现有代码造成错误。这样可将新错误隔离到新代码里。通过从一个现成的、功能性的类继承，同时增添成员新的数据成员及方法（并重新定义现有方法），我们可保持现有代码原封不动（另外有人也许仍在使用它），不会为其引入自己的编程错误。一旦出现错误，就知道它肯定是由于自己的新代码造成的。这样一来，与修改现有代码的主体相比，改正错误所需的时间和精力就可以少很多。\n类的隔离效果非常好，这是许多程序员事先没有预料到的。甚至不需要方法的源代码来实现代码的再生。最多只需要导入一个包（这对于继承和合并都是成立的）。 ``` 大家要记住这样一个重点：程序开发是一个不断递增或者累积的过程，就象人们学习知识一样。当然可根据要求进行尽可能多的分析，但在一个项目的设计之初，谁都不可能提前获知所有的答案。如果能将自己的项目看作一个有机的、能不断进步的生物，从而不断地发展和改进它，就有望获得更大的成功以及更直接的反馈。\n尽管继承是一种非常有用的技术，但在某些情况下，特别是在项目稳定下来以后，仍然需要从新的角度考察自己的类结构，将其收缩成一个更灵活的结构。请记住，继承是对一种特殊关系的表达，意味着“这个新类属于那个旧类的一种类型”。我们的程序不应纠缠于一些细树末节，而应着眼于创建和操作各种类型的对象，用它们表达出来自“问题空间”的一个模型。\n6.7 上溯造型 继承最值得注意的地方就是它没有为新类提供方法。继承是对新类和基础类之间的关系的一种表达。可这样总结该关系：“新类属于现有类的一种类型”。\n这种表达并不仅仅是对继承的一种形象化解释，继承是直接由语言提供支持的。作为一个例子，大家可考虑一个名为Instrument的基础类，它用于表示乐器；另一个衍生类叫作Wind。由于继承意味着基础类的所有方法亦可在衍生出来的类中使用，所以我们发给基础类的任何消息亦可发给衍生类。若Instrument类有一个play()方法，则Wind设备也会有这个方法。这意味着我们能肯定地认为一个Wind对象也是Instrument的一种类型。下面这个例子揭示出编译器如何提供对这一概念的支持：\n//: Wind.java // Inheritance \u0026amp; upcasting import java.util.*; class Instrument { public void play() {} static void tune(Instrument i) { // ... i.play(); } } // Wind objects are instruments // because they have the same interface: class Wind extends Instrument { public static void main(String[] args) { Wind flute = new Wind(); Instrument.tune(flute); // Upcasting } } ///:~ 这个例子中最有趣的无疑是tune()方法，它能接受一个Instrument句柄。但在Wind.main()中，tune()方法是通过为其赋予一个Wind句柄来调用的。由于Java对类型检查特别严格，所以大家可能会感到很奇怪，为什么接收一种类型的方法也能接收另一种类型呢？但是，我们一定要认识到一个Wind对象也是一个Instrument对象。而且对于不在Wind中的一个Instrument（乐器），没有方法可以由tune()调用。在tune()中，代码适用于Instrument以及从Instrument衍生出来的任何东西。在这里，我们将从一个Wind句柄转换成一个Instrument句柄的行为叫作“上溯造型”。\n总结：\n我们将从一个 衍生类 句柄转换成一个 基础类 句柄的行为叫作“上溯造型” 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。 6.7.1 何谓“上溯造型”？ 之所以叫作这个名字，除了有一定的历史原因外，也是由于在传统意义上，类继承图的画法是根位于最顶部，再逐渐向下扩展（当然，可根据自己的习惯用任何方法描绘这种图）。因素，Wind.java的继承图就象下面这个样子： 由于造型的方向是从衍生类到基础类，箭头朝上，所以通常把它叫作“上溯造型”，即Upcasting。上溯造型肯定是安全的，因为我们是从一个更特殊的类型到一个更常规的类型。换言之，衍生类是基础类的一个超集。它可以包含比基础类更多的方法，但它至少包含了基础类的方法。进行上溯造型的时候，类接口可能出现的唯一一个问题是它可能丢失方法，而不是赢得这些方法。这便是在没有任何明确的造型或者其他特殊标注的情况下，编译器为什么允许上溯造型的原因所在。\n也可以执行下溯造型，但这时会面临第11章要详细讲述的一种困境。\n再论合成与继承 在面向对象的程序设计中，创建和使用代码最可能采取的一种做法是：将数据和方法统一封装到一个类里，并且使用那个类的对象。有些时候，需通过“合成”技术用现成的类来构造新类。而继承是最少见的一种做法。因此，尽管继承在学习OOP的过程中得到了大量的强调，但并不意味着应该尽可能地到处使用它。相反，使用它时要特别慎重。只有在清楚知道继承在所有方法中最有效的前提下，才可考虑它。为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。在下一章里（多形性），会向大家介绍必须进行上溯造型的一种场合。但只要记住经常问自己“我真的需要上溯造型吗”，对于合成还是继承的选择就不应该是个太大的问题。\n6.8 final关键字 由于语境（应用环境）不同，final关键字的含义可能会稍微产生一些差异。但它最一般的意思就是声明“这个东西不能改变”。之所以要禁止改变，可能是考虑到两方面的因素：设计或效率。由于这两个原因颇有些区别，所以也许会造成final关键字的误用。\nfinal关键字的三种应用场合：数据、方法以及类。\n6.8.1 final数据 许多程序设计语言都有自己的办法告诉编译器某个数据是“常数”。常数主要应用于下述两个方面：\n(1) 编译期常数，它永远不会改变\n(2) 在运行期初始化的一个值，我们不希望它发生变化\n对于编译期的常数，编译器（程序）可将常数值“封装”到需要的计算过程里。也就是说，计算可在编译期间提前执行，从而节省运行时的一些开销。在Java中，这些形式的常数必须属于基本数据类型（Primitives），而且要用final关键字进行表达。在对这样的一个常数进行定义的时候，必须给出一个值。\n无论static还是final字段，都只能存储一个数据，而且不得改变。\nStatic强调它们只有一个；而final表明它是一个常数。（属于类，而不是属于对象）\n不能由于某样东西的属性是final，就认定它的值能在编译时期知道。\n注意对于含有固定初始化值（即编译期常数）的 fianl static基本数据类型，它们的名字根据规则要全部采用大写。\n若随同对象句柄使用final，而不是基本数据类型，它的含义就稍微让人有点儿迷糊了。对于基本数据类型，final会将值变成一个常数；但对于对象句柄，final会将句柄变成一个常数。进行声明时，必须将句柄初始化到一个具体的对象。而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。Java对此未提供任何手段，可将一个对象直接变成一个常数（但是，我们可自己编写一个类，使其中的对象具有“常数”效果）。这一限制也适用于数组，它也属于对象。\n总结：\nfinal 对象类型属性的时候必须手动初始化，（初始化可以是在属性上直接初始化，也可以是在构造方法中初始化，无论哪种，必须保证其被初始化。） final 会将句柄变成一个常数，而且永远不能将句柄变成指向另一个对象。然而，对象本身是可以修改的。 //: FinalData.java // The effect of final on fields class Value { int i = 1; } public class FinalData { // Can be compile-time constants final int i1 = 9; static final int I2 = 99; // Typical public constant: public static final int I3 = 39; // Cannot be compile-time constants: final int i4 = (int)(Math.random()*20); static final int i5 = (int)(Math.random()*20); Value v1 = new Value(); final Value v2 = new Value(); static final Value v3 = new Value(); //! final Value v4; // Pre-Java 1.1 Error: // no initializer // Arrays: final int[] a = { 1, 2, 3, 4, 5, 6 }; public void print(String id) { System.out.println( id + \u0026#34;: \u0026#34; + \u0026#34;i4 = \u0026#34; + i4 + \u0026#34;, i5 = \u0026#34; + i5); } public static void main(String[] args) { FinalData fd1 = new FinalData(); //! fd1.i1++; // Error: can\u0026#39;t change value fd1.v2.i++; // Object isn\u0026#39;t constant! fd1.v1 = new Value(); // OK -- not final for(int i = 0; i \u0026lt; fd1.a.length; i++) fd1.a[i]++; // Object isn\u0026#39;t constant! //! fd1.v2 = new Value(); // Error: Can\u0026#39;t //! fd1.v3 = new Value(); // change handle //! fd1.a = new int[3]; fd1.print(\u0026#34;fd1\u0026#34;); System.out.println(\u0026#34;Creating new FinalData\u0026#34;); FinalData fd2 = new FinalData(); fd1.print(\u0026#34;fd1\u0026#34;); fd2.print(\u0026#34;fd2\u0026#34;); } } ///:~ fd1: i4 = 15, i5 = 9 Creating new FinalData fd1: i4 = 15, i5 = 9 fd2: i4 = 10, i5 = 9 注意对于fd1和fd2来说，i4的值是唯一的(这里面的唯一大概是各自独立的意思)，但i5的值不会由于创建了另一个FinalData对象而发生改变。那是因为它的属性是static，而且在载入时初始化，而非每创建一个对象时初始化。\n从v1到v4的变量向我们揭示出final句柄的含义。正如大家在main()中看到的那样，并不能认为由于v2属于final，所以就不能再改变它的值。然而，我们确实不能再将v2绑定到一个新对象，因为它的属性是final。这便是final对于一个句柄的确切含义。我们会发现同样的含义亦适用于数组，后者只不过是另一种类型的句柄而已。将句柄变成final看起来似乎不如将基本数据类型变成final那么有用。\n空白 final Java 1.1允许我们创建“空白final”，它们属于一些特殊的字段。尽管被声明成final，但却未得到一个初始值。无论在哪种情况下，空白final都必须在实际使用前得到正确的初始化。而且编译器会主动保证这一规定得以贯彻。然而，对于final关键字的各种应用，空白final具有最大的灵活性。\n我们对final进行赋值处理——要么在定义字段时使用一个表达 式，要么在每个构建器中。这样就可以确保final字段在使用前获得正确的初始化。\nfinal 自变量 Java 1.1允许我们将自变量设成final属性，方法是在自变量列表中对它们进行适当的声明。这意味着在一个方法的内部，我们不能改变自变量句柄指向的东西。\n6.8.2 final方法 之所以要使用final方法，可能是出于对两方面理由的考虑。第一个是为方法“上锁”，防止任何继承类改变它的本来含义。设计程序时，若希望一个方法的行为在继承期间保持不变，而且不可被覆盖或改写，就可以采取这种做法。 采用final方法的第二个理由是程序执行的效率。将一个方法设成final后，编译器就可以把对那个方法的所有调用都置入“嵌入”调用里。只要编译器发现一个final方法调用，就会（根据它自己的判断）忽略为执行方法调用机制而采取的常规代码插入方法（将自变量压入堆栈；跳至方法代码并执行它；跳回来；清除堆栈自变量；最后对返回值进行处理）。相反，它会用方法主体内实际代码的一个副本来替换方法调用。这样做可避免方法调用时的系统开销。当然，若方法体积太大，那么程序也会变得雍肿，可能受到到不到嵌入代码所带来的任何性能提升。因为任何提升都被花在方法内部的时间抵消了。Java编译器能自动侦测这些情况，并颇为“明智”地决定是否嵌入一个final方法。然而，最好还是不要完全相信编译器能正确地作出所有判断。通常，只有在方法的代码量非常少，或者想明确禁止方法被覆盖的时候，才应考虑将一个方法设为final。\n类内所有 private方法都自动成为final。由于我们不能访问一个private方法，所以它绝对不会被其他方法覆盖（若强行这样做，编译器会给出错误提示）。可为一个private方法添加final指示符，但却不能为那个方法提供任何额外的含义。\n/* 1、final方法防止覆写：防止任何继承类改变它的本来含义，方法的行为在继承期间保持不变，而且不可被覆盖或改写。 2、final方法 提高执行的效率。 3、类内所有 private方法都自动成为final。 */ 6.8.3 final 类 类是final（在它的定义前冠以final关键字），就表明自己不希望从这个类继承，或者不允许其他任何人采取这种操作。\n将类定义成final后，结果只是禁止进行继承——没有更多的限制。然而，由于它禁止了继承，所以一个final类中的所有方法都默认为final。因为此时再也无法覆盖它们。所以与我们将一个方法明确声明为final一样，编译器此时有相同的效率选择。\nfinal类内的一个方法添加final指示符，但这样做没有任何意义。\n6.8.4 final 的注意事项 设计一个类时，往往需要考虑是否将一个方法设为final。可能会觉得使用自己的类时执行效率非常重要，没有人想覆盖自己的方法。这种想法在某些时候是正确的。\n但要慎重作出自己的假定。通常，我们很难预测一个类以后会以什么样的形式再生或重复利用。常规用途的类尤其如此。若将一个方法定义成final，就可能杜绝了在其他程序员的项目中对自己的类进行继承的途径，因为我们根本没有想到它会象那样使用。\n标准Java库是阐述这一观点的最好例子。其中特别常用的一个类是 Vector。如果我们考虑代码的执行效率，就会发现只有不把任何方法设为final，才能使其发挥更大的作用。我们很容易就会想到自己应继承和覆盖如此有用的一个类，但它的设计者却否定了我们的想法。但我们至少可以用两个理由来反驳他们。首先，Stack（堆栈）是从Vector继承来的，亦即Stack“是”一个Vector，这种说法是不确切的。其次，对于Vector许多重要的方法，如addElement()以及elementAt()等，它们都变成了synchronized（同步的）。正如在第14章要讲到的那样，这会造成显著的性能开销，可能会把final提供的性能改善抵销得一干二净。因此，程序员不得不猜测到底应该在哪里进行优化。在标准库里居然采用了如此笨拙的设计，真不敢想象会在程序员里引发什么样的情绪。\n另一个值得注意的是Hashtable（散列表），它是另一个重要的标准类。该类没有采用任何final方法。正如我们在本书其他地方提到的那样，显然一些类的设计人员与其他设计人员有着全然不同的素质（注意比较Hashtable极短的方法名与Vecor的方法名）。对类库的用户来说，这显然是不应该如此轻易就能看出的。一个产品的设计变得不一致后，会加大用户的工作量。这也从另一个侧面强调了代码设计与检查时需要很强的责任心。\n6.8 初始化和类装载 在许多传统语言里，程序都是作为启动过程的一部分一次性载入的。随后进行的是初始化，再是正式执行程序。在这些语言中，必须对初始化过程进行慎重的控制，保证static数据的初始化不会带来麻烦。比如在一个static数据获得初始化之前，就有另一个static数据希望它是一个有效值，那么在C++中就会造成问题。\nJava则没有这样的问题，因为它采用了不同的装载方法。由于Java中的一切东西都是对象，所以许多活动变得更加简单，这个问题便是其中的一例。正如下一章会讲到的那样，每个对象的代码都存在于独立的文件中。除非真的需要代码，否则那个文件是不会载入的。通常，我们可认为除非那个类的一个对象构造完毕，否则代码不会真的载入。由于static方法存在一些细微的歧义，所以也能认为“类代码在首次使用的时候载入”。\n首次使用的地方也是static初始化发生的地方。装载的时候，所有static对象和static代码块都会按照本来的顺序初始化（亦即它们在类定义代码里写入的顺序）。当然，static数据只会初始化一次。\n6.9.1 继承初始化 我们有必要对整个初始化过程有所认识，其中包括继承，对这个过程中发生的事情有一个整体性的概念。请观察下述代码：\n//: Beetle.java // The full process of initialization. class Insect { int i = 9; int j; Insect() { prt(\u0026#34;i = \u0026#34; + i + \u0026#34;, j = \u0026#34; + j); j = 39; } static int x1 = prt(\u0026#34;static Insect.x1 initialized\u0026#34;); static int prt(String s) { System.out.println(s); return 47; } } public class Beetle extends Insect { int k = prt(\u0026#34;Beetle.k initialized\u0026#34;); Beetle() { prt(\u0026#34;k = \u0026#34; + k); prt(\u0026#34;j = \u0026#34; + j); } static int x2 = prt(\u0026#34;static Beetle.x2 initialized\u0026#34;); static int prt(String s) { System.out.println(s); return 63; } public static void main(String[] args) { prt(\u0026#34;Beetle constructor\u0026#34;); Beetle b = new Beetle(); } } ///:~ 该程序的输出如下：\nstatic Insect.x1 initialized static Beetle.x2 initialized Beetle constructor i = 9, j = 0 Beetle.k initialized k = 63 j = 39 1、对Beetle运行Java时，发生的第一件事情是装载程序到外面找到那个类。在装载过程中，装载程序注意它有一个基础类（即extends关键字要表达的意思），所以随之将其载入。无论是否准备生成那个基础类的一个对象，这个过程都会发生（可试着将对象的创建代码当作注释标注出来，自己去证实）。\n2、若基础类含有另一个基础类，则另一个基础类随即也会载入，以此类推。接下来，会在根基础类（此时是Insect）执行static初始化，再在下一个衍生类执行，以此类推。保证这个顺序是非常关键的，因为衍生类的初始化可能要依赖于对基础类成员的正确初始化。\n3、此时，必要的类已全部装载完毕，所以能够创建对象。首先，这个对象中的所有基本数据类型都会设成它们的默认值，而将对象句柄设为null。随后会调用基础类构建器。在这种情况下，调用是自动进行的。但也完全可以用super来自行指定构建器调用（就象在Beetle()构建器中的第一个操作一样）。基础类的构建采用与衍生类构建器完全相同的处理过程。基础顺构建器完成以后，实例变量会按本来的顺序得以初始化。最后，执行构建器剩余的主体部分。\n总结：初始化和类装载\n先基础后衍生 先类加载，然后立即执行static初始化 实例属性，然后构建对象 6.10 总结 先考虑采用合成技术。只有在特别必要的时候，才应考虑采用继承技术。合成显得更加灵活。\n总结：论合成与继承\n如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”或者“类似”关系是用继承来表达的，而“包含”关系是用合成来表达的。 继承 用来表达同一个系列不同种对象的行为间的差异。 句柄在运行期间可以重新与一个不同的对象绑定或结合起来,这样一来，我们在运行期间 通过改变句柄绑定的子类类型 就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。 第7章 多形性 “对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。”\n“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。\n通过合并各种特征与行为，封装技术可创建出新的数据类型。通过对具体实施细节的隐藏，可将接口与实施细节分离，使所有细节成为“private”（私有）。这种组织方式使那些有程序化编程背景人感觉颇为舒适。但多形性却涉及对“类型”的分解。通过上一章的学习，大家已知道通过继承可将一个对象当作它自己的类型或者它自己的基础类型对待。这种能力是十分重要的，因为多个类型（从相同的基础类型中衍生出来）可被当作同一种类型对待。而且只需一段代码，即可对所有不同的类型进行同样的处理。利用具有多形性的方法调用，一种类型可将自己与另一种相似的类型区分开，只要它们都是从相同的基础类型中衍生出来的。这种区分是通过各种方法在行为上的差异实现的，可通过基础类实现对那些方法的调用。\n在这一章中，大家要由浅入深地学习有关多形性的问题（也叫作动态绑定、推迟绑定或者运行期绑定）。同时举一些简单的例子，其中所有无关的部分都已剥除，只保留与多形性有关的代码。\n7.1 上溯造型 在第 6 章，大家已知道可将一个对象作为它自己的类型使用，或者作为它的基础类型的一个对象使用。取得一个对象句柄，并将其作为基础类型句柄使用的行为就叫作“上溯造型”——因为继承树的画法是基础类位于最上方。\n7.1.1 为什么要上溯造型 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。这样就不比为每种衍生类都制作对应的方法，节省大量工作。\n这正是“多形性”大显身手的地方。\n7.2 深入理解 此处有个问题：基于上溯造型，用基础类做方法 自变量时，真正调用方法时传入的自变量类型为基础类的衍生类时。它接收 基础类 句柄。所以在这种情况下，编译器怎样才能知道 基础类 句柄指向的是一个真正的 衍生类，而不是一个其他衍生类呢？编译器无从得知。为了深入了理解这个问题，我们有必要探讨一下“绑定”这个主题。\n7.2.1 方法调用的绑定 将一个方法调用 同一个方法主体 连接到一起就称为“绑定”（Binding）。若在程序运行以前执行绑定（由编译器和链接程序，如果有的话），就叫作“早期绑定”。大家以前或许从未听说过这个术语，因为它在任何程序化语言里都是不可能的。C编译器只有一种方法调用，那就是“早期绑定”。\n上述程序最令人迷惑不解的地方全与早期绑定有关，因为在只有一个 基础类 句柄的前提下，编译器不知道具体该调用哪个方法。\n解决的方法就是“后期绑定”，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。\nJava中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。\n为什么要把一个方法声明成final呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final方法调用生成效率更高的代码。\n7.2.2 产生正确的行为 知道Java里绑定的所有方法都通过后期绑定具有多形性以后，就可以相应地编写自己的代码，令其与基础类沟通。此时，所有的衍生类都保证能用相同的代码正常地工作。或者换用另一种方法，我们可以“将一条消息发给一个对象，让对象自行判断要做什么事情。”\n在面向对象的程序设计中，有一个经典的“形状”例子。由于它很容易用可视化的形式表现出来，所以经常都用它说明问题。但很不幸的是，它可能误导初学者认为OOP只是为图形化编程设计的，这种认识当然是错误的。\n形状例子有一个基础类，名为Shape；另外还有大量衍生类型：Circle（圆形），Square（方形），Triangle（三角形）等等。大家之所以喜欢这个例子，因为很容易理解“圆属于形状的一种类型”等概念。下面这幅继承图向我们展示了它们的关系：\n上溯造型可用下面这个语句简单地表现出来：\nShape s = new Circle(); 当我们调用其中一个基础类方法时（已在衍生类里覆盖）：\ns.draw(); 此时实际调用的是Circle.draw()，因为后期绑定已经介入（多形性）。\n//: Shapes.java // Polymorphism in Java class Shape { void draw() {} void erase() {} } class Circle extends Shape { void draw() { System.out.println(\u0026#34;Circle.draw()\u0026#34;); } void erase() { System.out.println(\u0026#34;Circle.erase()\u0026#34;); } } class Square extends Shape { void draw() { System.out.println(\u0026#34;Square.draw()\u0026#34;); } void erase() { System.out.println(\u0026#34;Square.erase()\u0026#34;); } } class Triangle extends Shape { void draw() { System.out.println(\u0026#34;Triangle.draw()\u0026#34;); } void erase() { System.out.println(\u0026#34;Triangle.erase()\u0026#34;); } } public class Shapes { public static Shape randShape() { switch((int)(Math.random() * 3)) { default: // To quiet the compiler case 0: return new Circle(); case 1: return new Square(); case 2: return new Triangle(); } } public static void main(String[] args) { Shape[] s = new Shape[9]; // Fill up the array with shapes: for(int i = 0; i \u0026lt; s.length; i++) s[i] = randShape(); // Make polymorphic method calls: for(int i = 0; i \u0026lt; s.length; i++) s[i].draw(); } } ///:~ main()包含了Shape句柄的一个数组，其中的数据通过对randShape()的调用填入。在这个时候，我们知道自己拥有Shape，但不知除此之外任何具体的情况（编译器同样不知）。然而，当我们在这个数组里步进，并为每个元素调用draw()的时候，与各类型有关的正确行为会魔术般地发生，就象下面这个输出示例展示的那样：\nCircle.draw() Triangle.draw() Circle.draw() Circle.draw() Circle.draw() Square.draw() Triangle.draw() Square.draw() Square.draw() 由于几何形状是每次随机选择的，所以每次运行都可能有不同的结果。之所以要突出形状的随机选择，是为了让大家深刻体会这一点：为了在编译的时候发出正确的调用，编译器毋需获得任何特殊的情报。对draw()的所有调用都是通过动态绑定进行的。\n7.2.3 扩展性 我们认为多形性是一种至关重要的技术，它允许程序员“将发生改变的东西同没有发生改变的东西区分开”。\n7.3 覆盖与过载 “过载”是指同一样东西在不同的地方具有多种含义；而“覆盖”是指它随时随地都只有一种含义，只是原先的含义完全被后来的含义取代了。\n7.4 抽象类和方法 之所以要建立这个通用接口，唯一的原因就是它能为不同的子类型作出不同的表示。它为我们建立了一种基本形式，使我们能定义在所有衍生类里“通用”的一些东西。为阐述这个观念，另一个方法是把Instrument称为“抽象基础类”（简称“抽象类”）。若想通过该通用接口处理一系列类，就需要创建一个抽象类。对所有与基础类声明的签名相符的衍生类方法，都可以通过动态绑定机制进行调用（然而，正如上一节指出的那样，如果方法名与基础类相同，但自变量或参数不同，就会出现过载现象，那或许并非我们所愿意的）。\n抽象类的作用仅仅是表达接口，而不是表达一些具体的实施细节。所以创建一个抽象对象是没有意义的，而且我们通常都应禁止用户那样做。\n针对这个问题，Java专门提供了一种机制，名为“抽象方法”。它属于一种不完整的方法，只含有一个声明，没有方法主体。下面是抽象方法声明时采用的语法：\nabstract void X(); 包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。\n一个抽象类是不完整的，那么一旦有人试图生成那个类的一个对象，编译器又会采取什么行动呢？由于不能安全地为一个抽象类创建属于它的对象，所以会从编译器那里获得一条出错提示。通过这种方法，编译器可保证抽象类的“纯洁性”，我们不必担心会误用它。\n如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract关键字标志那个类的“抽象”本质。\n即使不包括任何abstract方法，亦可将一个类声明成“抽象类”。如果一个类没必要拥有任何抽象方法，而且我们想禁止那个类的所有实例，这种能力就会显得非常有用。\n使一个类抽象以后，并不会强迫我们将它的所有方法都同时变成抽象。\n创建抽象类和方法有时对我们非常有用，因为它们使一个类的抽象变成明显的事实，可明确告诉用户和编译器自己打算如何用它。\n7.5 接口 “interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯”抽象类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static和final。接口只提供一种形式，并不提供实施的细节。\n我们常把接口用于建立类和类之间的一个“协议”。有些面向对象的程序设计语言采用了一个名为“protocol”（协议）的关键字，它做的便是与接口相同的事情。\n为创建一个接口，请使用interface关键字，而不要用class。与类相似，我们可在interface关键字的前面增加一个public关键字（但只有接口定义于同名的一个文件内）；或者将其省略，营造一种“友好的”状态。\n为了生成与一个特定的接口（或一组接口）相符的类，要使用implements（实现）关键字。\n接口中的方法声明明确定义为“public”。但即便不明确定义，它们也会默认为public。所以在实现一个接口的时候，来自接口的方法必须定义成public。否则的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java编译器不允许我们那样做。\n为了生成与一个特定的接口（或一组接口）相符的类，要使用implements（实现）关键字。我们要表达的意思是“接口看起来就象那个样子，这儿是它具体的工作细节”。除这些之外，我们其他的工作都与继承极为相似。\n具体实现了一个接口以后，就获得了一个普通的类，可用标准方式对其进行扩展。\n接口的一个方法即使没被声明为public，但它们都会自动获得public属性。\n7.5.1 Java的“多重继承” 接口只是比抽象类“更纯”的一种形式。它的用途并不止那些。由于接口根本没有具体的实施细节——也就是说，没有与存储空间与“接口”关联在一起——所以没有任何办法可以防止多个接口合并到一起。这一点是至关重要的，因为我们经常都需要表达这样一个意思：“x从属于a，也从属于b，也从属于c”。在C++中，将多个类合并到一起的行动称作“多重继承”，而且操作较为不便，因为每个类都可能有一套自己的实施细节。在Java中，我们可采取同样的行动，但只有其中一个类拥有具体的实施细节。所以在合并多个接口的时候，C++的问题不会在Java中重演。\n在一个衍生类中，我们并不一定要拥有一个抽象或具体（没有抽象方法）的基础类。如果确实想从一个非接口继承，那么只能从一个继承。剩余的所有基本元素都必须是“接口”。我们将所有接口名置于implements关键字的后面，并用逗号分隔它们。可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型。下面这个例子展示了一个“具体”类同几个接口合并的情况，它最终生成了一个新类：\n//: Adventure.java\r// Multiple interfaces\rimport java.util.*;\rinterface CanFight {\rvoid fight();\r}\rinterface CanSwim {\rvoid swim();\r}\rinterface CanFly {\rvoid fly();\r}\rclass ActionCharacter {\rpublic void fight() {}\r}\rclass Hero extends ActionCharacter\rimplements CanFight, CanSwim, CanFly {\rpublic void swim() {}\rpublic void fly() {}\r}\rpublic class Adventure {\rstatic void t(CanFight x) { x.fight(); }\rstatic void u(CanSwim x) { x.swim(); }\rstatic void v(CanFly x) { x.fly(); }\rstatic void w(ActionCharacter x) { x.fight(); }\rpublic static void main(String[] args) {\rHero i = new Hero();\rt(i); // Treat it as a CanFight\ru(i); // Treat it as a CanSwim\rv(i); // Treat it as a CanFly\rw(i); // Treat it as an ActionCharacter\r}\r} ///:~ 从中可以看到，Hero将具体类ActionCharacter同接口CanFight，CanSwim以及CanFly合并起来。按这种形式合并一个具体类与接口的时候，具体类必须首先出现，然后才是接口（否则编译器会报错）。（先 extends 再 implements）\n接口的规则是：我们可以从它继承（稍后就会看到），但这样得到的将是另一个接口。如果想创建新类型的一个对象，它就必须是已提供所有定义的一个类。\n接口最关键的作用，也是使用接口最重要的一个原因：能上溯造型至多个基础类。使用接口的第二个原因与使用抽象基础类的原因是一样的：防止客户程序员制作这个类的一个对象，以及规定它仅仅是一个接口。这样便带来了一个问题：到底应该使用一个接口还是一个抽象类呢？若使用接口，我们可以同时获得抽象类以及接口的好处。所以假如想创建的基础类没有任何方法定义或者成员变量，那么无论如何都愿意使用接口，而不要选择抽象类。事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义或者成员变量的时候，才应考虑采用抽象类。\n7.5.2 通过继承扩展接口 利用继承技术，可方便地为一个接口添加新的方法声明，也可以将几个接口合并成一个新接口。在这两种情况下，最终得到的都是一个新接口.\n通常，我们只能对单独一个类应用extends（扩展）关键字。但由于接口可能由多个其他接口构成，所以在构建一个新接口时，extends可能引用多个基础接口。正如大家看到的那样，接口的名字只是简单地使用逗号分隔。\n7.5.3 常数分组 由于置入一个接口的所有字段都自动具有static和final属性，所以接口是对常数值进行分组的一个好工具，它具有与C或C++的enum非常相似的效果。\n注意根据Java命名规则，拥有固定标识符的static final基本数据类型（亦即编译期常数）都全部采用大写字母（用下划线分隔单个标识符里的多个单词）。\n接口中的字段会自动具备public属性，所以没必要专门指定。\n我们可以从包的外部使用常数——就象对其他任何包进行的操作那样。与将数字强行编码（硬编码）到自己的程序中相比，这种（常用的）技术无疑已经是一个巨大的进步。我们通常把“硬编码”数字的行为称为“魔术数字”，它产生的代码是非常难以维护的。 如确实不想放弃额外的类型安全性，可构建象下面这样的一个类:\npublic final class Month2 {\rprivate String name;\rprivate Month2(String nm) { name = nm; }\rpublic String toString() { return name; }\rpublic final static Month2\rJAN = new Month2(\u0026#34;January\u0026#34;),\rFEB = new Month2(\u0026#34;February\u0026#34;),\rMAR = new Month2(\u0026#34;March\u0026#34;),\rAPR = new Month2(\u0026#34;April\u0026#34;),\rMAY = new Month2(\u0026#34;May\u0026#34;),\rJUN = new Month2(\u0026#34;June\u0026#34;),\rJUL = new Month2(\u0026#34;July\u0026#34;),\rAUG = new Month2(\u0026#34;August\u0026#34;),\rSEP = new Month2(\u0026#34;September\u0026#34;),\rOCT = new Month2(\u0026#34;October\u0026#34;),\rNOV = new Month2(\u0026#34;November\u0026#34;),\rDEC = new Month2(\u0026#34;December\u0026#34;);\rpublic final static Month2[] month = {\rJAN, JAN, FEB, MAR, APR, MAY, JUN,\rJUL, AUG, SEP, OCT, NOV, DEC\r};\rpublic static void main(String[] args) {\rMonth2 m = Month2.JAN;\rSystem.out.println(m);\rm = Month2.month[12];\rSystem.out.println(m);\rSystem.out.println(m == Month2.DEC);\rSystem.out.println(m.equals(Month2.DEC));\r}\r} ///:~ 这个类叫作Month2，因为标准Java库里已经有一个Month。它是一个final类，并含有一个private构建器，所以没有人能从它继承，或制作它的一个实例。唯一的实例就是那些final static对象，它们是在类本身内部创建的，包括：JAN，FEB，MAR等等。这些对象也在month数组中使用，后者让我们能够按数字挑选月份，而不是按名字（注意数组中提供了一个多余的JAN，使偏移量增加了1，也使December确实成为12月）。在main()中，我们可注意到类型的安全性：m是一个Month2对象，所以只能将其分配给Month2。在前面的Months.java例子中，只提供了int值，所以本来想用来代表一个月份的int变量可能实际获得一个整数值，那样做可能不十分安全。 这儿介绍的方法也允许我们交换使用==或者equals()，就象main()尾部展示的那样。\n7.5.4 初始化接口中的字段 接口中定义的字段会自动具有static和final属性。它们不能是“空白final”，但可初始化成非常数表达式。例如：\npublic interface RandVals {\rint rint = (int)(Math.random() * 10);\rlong rlong = (long)(Math.random() * 10);\rfloat rfloat = (float)(Math.random() * 10);\rdouble rdouble = Math.random() * 10;\r} ///:~ 由于字段是static的，所以它们会在首次装载类之后、以及首次访问任何字段之前获得初始化。\n当然，字段并不是接口的一部分，而是保存于那个接口的static存储区域中。\n7.6 内部类 在Java 1.1中，可将一个类定义置入另一个类定义中。这就叫作“内部类”。内部类对我们非常有用，因为利用它可对那些逻辑上相互联系的类进行分组，并可控制一个类在另一个类里的“可见性”。然而，我们必须认识到内部类与以前讲述的“合成”方法存在着根本的区别。\n通常，对内部类的需要并不是特别明显的，至少不会立即感觉到自己需要使用内部类。在本章的末尾，介绍完内部类的所有语法之后，大家会发现一个特别的例子。通过它应该可以清晰地认识到内部类的好处。\n创建内部类的过程是平淡无奇的：将类定义置入一个用于封装它的类内部。\npublic class Parcel1 {\rclass Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rclass Destination {\rprivate String label;\rDestination(String whereTo) {\rlabel = whereTo;\r}\rString readLabel() { return label; }\r}\r// Using inner classes looks just like\r// using any other class, within Parcel1:\rpublic void ship(String dest) {\rContents c = new Contents();\rDestination d = new Destination(dest);\r} public static void main(String[] args) {\rParcel1 p = new Parcel1();\rp.ship(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 若在ship()内部使用，内部类的使用看起来和其他任何类都没什么分别。在这里，唯一明显的区别就是它的名字嵌套在Parcel1里面。但大家不久就会知道，这其实并非唯一的区别。\n更典型的一种情况是，一个外部类拥有一个特殊的方法，它会返回指向一个内部类的句柄。就象下面这样：\npublic class Parcel2 {\rclass Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rclass Destination {\rprivate String label;\rDestination(String whereTo) {\rlabel = whereTo;\r}\rString readLabel() { return label; }\r}\rpublic Destination to(String s) {\rreturn new Destination(s);\r}\rpublic Contents cont() {\rreturn new Contents();\r}\rpublic void ship(String dest) {\rContents c = cont();\rDestination d = to(dest);\r} public static void main(String[] args) {\rParcel2 p = new Parcel2();\rp.ship(\u0026#34;Tanzania\u0026#34;);\rParcel2 q = new Parcel2();\r// Defining handles to inner classes:\rParcel2.Contents c = q.cont();\rParcel2.Destination d = q.to(\u0026#34;Borneo\u0026#34;);\r}\r} ///:~ 若想在除外部类非static方法内部之外的任何地方生成内部类的一个对象，必须将那个对象的类型设为“外部类名.内部类名”，就象main()中展示的那样。\n7.6.1 内部类和上溯造型 迄今为止，内部类看起来仍然没什么特别的地方。毕竟，用它实现隐藏显得有些大题小做。Java已经有一个非常优秀的隐藏机制——只允许类成为“友好的”（只在一个包内可见），而不是把它创建成一个内部类。\n然而，当我们准备上溯造型到一个基础类（特别是到一个接口）的时候，内部类就开始发挥其关键作用（从用于实现的对象生成一个接口句柄具有与上溯造型至一个基础类相同的效果）。这是由于内部类随后可完全进入不可见或不可用状态——对任何人都将如此。所以我们可以非常方便地隐藏实施细节。我们得到的全部回报就是一个基础类或者接口的句柄，而且甚至有可能不知道准确的类型。就象下面这样：\nabstract class Contents {\rabstract public int value();\r}\rinterface Destination {\rString readLabel();\r}\rpublic class Parcel3 {\rprivate class PContents extends Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rprotected class PDestination\rimplements Destination {\rprivate String label;\rprivate PDestination(String whereTo) {\rlabel = whereTo;\r}\rpublic String readLabel() { return label; }\r}\rpublic Destination dest(String s) {\rreturn new PDestination(s);\r}\rpublic Contents cont() {\rreturn new PContents();\r}\r}\rclass Test {\rpublic static void main(String[] args) {\rParcel3 p = new Parcel3();\rContents c = p.cont();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;);\r// Illegal -- can\u0026#39;t access private class:\r//! Parcel3.PContents c = p.new PContents();\r}\r} ///:~ 现在，Contents和Destination代表可由客户程序员使用的接口（记住接口会将自己的所有成员都变成public属性）。为方便起见，它们置于单独一个文件里，但原始的Contents和Destination在它们自己的文件中是相互public的。\n在Parcel3中，一些新东西已经加入：内部类PContents被设为private，所以除了Parcel3之外，其他任何东西都不能访问它。PDestination被设为protected，所以除了Parcel3，Parcel3包内的类（因为protected也为包赋予了访问权；也就是说，protected也是“友好的”），以及Parcel3的继承者之外，其他任何东西都不能访问PDestination。这意味着客户程序员对这些成员的认识与访问将会受到限制。事实上，我们甚至不能下溯造型到一个private内部类（或者一个protected内部类，除非自己本身便是一个继承者），因为我们不能访问名字，就象在classTest里看到的那样。所以，利用private内部类，类设计人员可完全禁止其他人依赖类型编码，并可将具体的实施细节完全隐藏起来。除此以外，从客户程序员的角度来看，一个接口的范围没有意义的，因为他们不能访问不属于公共接口类的任何额外方法。这样一来，Java编译器也有机会生成效率更高的代码。\n普通（非内部）类不可设为private或protected——只允许public或者“友好的”。\n注意Contents不必成为一个抽象类。在这儿也可以使用一个普通类，但这种设计最典型的起点依然是一个“接口”。\n7.6.2 方法和作用域中的内部类 至此，我们已基本理解了内部类的典型用途。对那些涉及内部类的代码，通常表达的都是“单纯”的内部类，非常简单，且极易理解。然而，内部类的设计非常全面，不可避免地会遇到它们的其他大量用法——假若我们在一个方法甚至一个任意的作用域内创建内部类。有两方面的原因促使我们这样做：\n(1) 正如前面展示的那样，我们准备实现某种形式的接口，使自己能创建和返回一个句柄。 (2) 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开。 在下面这个例子里，将修改前面的代码，以便使用：\n(1) 在一个方法内定义的类 (2) 在方法的一个作用域内定义的类 (3) 一个匿名类，用于实现一个接口 (4) 一个匿名类，用于扩展拥有非默认构建器的一个类 (5) 一个匿名类，用于执行字段初始化 (6) 一个匿名类，通过实例初始化进行构建（匿名内部类不可拥有构建器） 第一个例子展示了如何在一个方法的作用域（而不是另一个类的作用域）中创建一个完整的类：\npublic class Parcel4 {\rpublic Destination dest(String s) {\rclass PDestination\rimplements Destination {\rprivate String label;\rprivate PDestination(String whereTo) {\rlabel = whereTo;\r}\rpublic String readLabel() { return label; }\r}\rreturn new PDestination(s);\r}\rpublic static void main(String[] args) {\rParcel4 p = new Parcel4();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ PDestination类属于dest()的一部分，而不是Parcel4的一部分（同时注意可为相同目录内每个类内部的一个内部类使用类标识符PDestination，这样做不会发生命名的冲突）。因此，PDestination不可从dest()的外部访问。请注意在返回语句中发生的上溯造型——除了指向基础类Destination的一个句柄之外，没有任何东西超出dest()的边界之外。当然，不能由于类PDestination的名字置于dest()内部，就认为在dest()返回之后PDestination不是一个有效的对象。\n下面这个例子展示了如何在任意作用域内嵌套一个内部类：\npublic class Parcel5 {\rprivate void internalTracking(boolean b) {\rif(b) {\rclass TrackingSlip {\rprivate String id;\rTrackingSlip(String s) {\rid = s;\r}\rString getSlip() { return id; }\r}\rTrackingSlip ts = new TrackingSlip(\u0026#34;slip\u0026#34;);\rString s = ts.getSlip();\r}\r// Can\u0026#39;t use it here! Out of scope:\r//! TrackingSlip ts = new TrackingSlip(\u0026#34;x\u0026#34;);\r}\rpublic void track() { internalTracking(true); }\rpublic static void main(String[] args) {\rParcel5 p = new Parcel5();\rp.track();\r}\r} ///:~ TrackingSlip类嵌套于一个if语句的作用域内。这并不意味着类是有条件创建的——它会随同其他所有东西得到编译。然而，在定义它的那个作用域之外，它是不可使用的。除这些以外，它看起来和一个普通类并没有什么区别。\npublic class Parcel6 {\rpublic Contents cont() {\rreturn new Contents() {\rprivate int i = 11;\rpublic int value() { return i; }\r}; // Semicolon required in this case\r}\rpublic static void main(String[] args) {\rParcel6 p = new Parcel6();\rContents c = p.cont();\r}\r} ///:~ cont()方法同时合并了返回值的创建代码，以及用于表示那个返回值的类。除此以外，这个类是匿名的——它没有名字。而且看起来似乎更让人摸不着头脑的是，我们准备创建一个Contents对象：\nreturn new Contents() 但在这之后，在遇到分号之前，我们又说：“等一等，让我先在一个类定义里再耍一下花招”：\nreturn new Contents() {\rprivate int i = 11;\rpublic int value() { return i; }\r}; 这种奇怪的语法要表达的意思是：“创建从Contents衍生出来的匿名类的一个对象”。由new表达式返回的句柄会自动上溯造型成一个Contents句柄。匿名内部类的语法其实要表达的是：\nclass MyContents extends Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rreturn new MyContents(); 在匿名内部类中，Contents是用一个默认构建器创建的。下面这段代码展示了基础类需要含有自变量的一个构建器时做的事情：\npublic class Parcel7 {\rpublic Wrapping wrap(int x) {\r// Base constructor call:\rreturn new Wrapping(x) {\rpublic int value() {\rreturn super.value() * 47;\r}\r}; // Semicolon required\r}\rpublic static void main(String[] args) {\rParcel7 p = new Parcel7();\rWrapping w = p.wrap(10);\r}\r} ///:~ 也就是说，我们将适当的自变量简单地传递给基础类构建器，在这儿表现为在“new Wrapping(x)”中传递x。匿名类不能拥有一个构建器，这和在调用super()时的常规做法不同。 在前述的两个例子中，分号并不标志着类主体的结束（和C++不同）。相反，它标志着用于包含匿名类的那个表达式的结束。因此，它完全等价于在其他任何地方使用分号。 若想对匿名内部类的一个对象进行某种形式的初始化，此时会出现什么情况呢？由于它是匿名的，没有名字赋给构建器，所以我们不能拥有一个构建器。然而，我们可在定义自己的字段时进行初始化：\npublic class Parcel8 {\r// Argument must be final to use inside\r// anonymous inner class:\rpublic Destination dest(final String dest) {\rreturn new Destination() {\rprivate String label = dest;\rpublic String readLabel() { return label; }\r};\r}\rpublic static void main(String[] args) {\rParcel8 p = new Parcel8();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 若试图定义一个匿名内部类，并想使用在匿名内部类外部定义的一个对象，则编译器要求外部对象为final属性。这正是我们将dest()的自变量设为final的原因。如果忘记这样做，就会得到一条编译期出错提示。 只要自己只是想分配一个字段，上述方法就肯定可行。但假如需要采取一些类似于构建器的行动，又应怎样操作呢？通过Java 1.1的实例初始化，我们可以有效地为一个匿名内部类创建一个构建器：\npublic class Parcel9 {\rpublic Destination\rdest(final String dest, final float price) {\rreturn new Destination() {\rprivate int cost;\r// Instance initialization for each object:\r{\rcost = Math.round(price);\rif(cost \u0026gt; 100)\rSystem.out.println(\u0026#34;Over budget!\u0026#34;);\r}\rprivate String label = dest;\rpublic String readLabel() { return label; }\r};\r}\rpublic static void main(String[] args) {\rParcel9 p = new Parcel9();\rDestination d = p.dest(\u0026#34;Tanzania\u0026#34;, 101.395F);\r}\r} ///:~ 在实例初始化模块中，我们可看到代码不能作为类初始化模块（即if语句）的一部分执行。所以实际上，一个实例初始化模块就是一个匿名内部类的构建器。当然，它的功能是有限的；我们不能对实例初始化模块进行过载处理，所以只能拥有这些构建器的其中一个。\n7.6.3 链接到外部类 迄今为止，我们见到的内部类好象仅仅是一种名字隐藏以及代码组织方案。尽管这些功能非常有用，但似乎并不特别引人注目。然而，我们还忽略了另一个重要的事实。创建自己的内部类时，那个类的对象同时拥有指向封装对象（这些对象封装或生成了内部类）的一个链接。所以它们能访问那个封装对象的成员——毋需取得任何资格。除此以外，内部类拥有对封装类所有元素的访问权限（注释②）。下面这个例子阐示了这个问题：\ninterface Selector {\rboolean end();\rObject current();\rvoid next();\r}\rpublic class Sequence {\rprivate Object[] o;\rprivate int next = 0;\rpublic Sequence(int size) {\ro = new Object[size];\r}\rpublic void add(Object x) {\rif(next \u0026lt; o.length) {\ro[next] = x;\rnext++;\r}\r}\rprivate class SSelector implements Selector {\rint i = 0;\rpublic boolean end() {\rreturn i == o.length;\r}\rpublic Object current() {\rreturn o[i];\r}\rpublic void next() {\rif(i \u0026lt; o.length) i++;\r}\r}\rpublic Selector getSelector() {\rreturn new SSelector();\r}\rpublic static void main(String[] args) {\rSequence s = new Sequence(10);\rfor(int i = 0; i \u0026lt; 10; i++)\rs.add(Integer.toString(i));\rSelector sl = s.getSelector(); while(!sl.end()) {\rSystem.out.println((String)sl.current());\rsl.next();\r}\r}\r} ///:~ ②：这与C++“嵌套类”的设计颇有不同，后者只是一种单纯的名字隐藏机制。在C++中，没有指向一个封装对象的链接，也不存在默认的访问权限。\n其中，Sequence只是一个大小固定的对象数组，有一个类将其封装在内部。我们调用add()，以便将一个新对象添加到Sequence末尾（如果还有地方的话）。为了取得Sequence中的每一个对象，要使用一个名为Selector的接口，它使我们能够知道自己是否位于最末尾（end()），能观看当前对象（current() Object），以及能够移至Sequence内的下一个对象（next() Object）。由于Selector是一个接口，所以其他许多类都能用它们自己的方式实现接口，而且许多方法都能将接口作为一个自变量使用，从而创建一般的代码。\n在这里，SSelector是一个私有类，它提供了Selector功能。在main()中，大家可看到Sequence的创建过程，在它后面是一系列字串对象的添加。随后，通过对getSelector()的一个调用生成一个Selector。并用它在Sequence中移动，同时选择每一个项目。\n从表面看，SSelector似乎只是另一个内部类。但不要被表面现象迷惑。请注意观察end()，current()以及next()，它们每个方法都引用了o。o是个不属于SSelector一部分的句柄，而是位于封装类里的一个private字段。然而，内部类可以从封装类访问方法与字段，就象已经拥有了它们一样。这一特征对我们来说是非常方便的，就象在上面的例子中看到的那样。\n因此，我们现在知道一个内部类可以访问封装类的成员。这是如何实现的呢？内部类必须拥有对封装类的特定对象的一个引用，而封装类的作用就是创建这个内部类。随后，当我们引用封装类的一个成员时，就利用那个（隐藏）的引用来选择那个成员。幸运的是，编译器会帮助我们照管所有这些细节。但我们现在也可以理解内部类的一个对象只能与封装类的一个对象联合创建。在这个创建过程中，要求对封装类对象的句柄进行初始化。若不能访问那个句柄，编译器就会报错。进行所有这些操作的时候，大多数时候都不要求程序员的任何介入。\n7.6.4 static内部类 为正确理解static在应用于内部类时的含义，必须记住内部类的对象默认持有创建它的那个封装类的一个对象的句柄。然而，假如我们说一个内部类是static的，这种说法却是不成立的。static内部类意味着：\n(1) 为创建一个static内部类的对象，我们不需要一个外部类对象。 (2) 不能从static内部类的一个对象中访问一个外部类对象。 但在存在一些限制：由于static成员只能位于一个类的外部级别，所以内部类不可拥有static数据或static内部类。\n倘若为了创建内部类的对象而不需要创建外部类的一个对象，那么可将所有东西都设为static。为了能正常工作，同时也必须将内部类设为static。如下所示：\nabstract class Contents {\rabstract public int value();\r}\rinterface Destination {\rString readLabel();\r}\rpublic class Parcel10 {\rprivate static class PContents extends Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rprotected static class PDestination implements Destination {\rprivate String label;\rprivate PDestination(String whereTo) {\rlabel = whereTo;\r}\rpublic String readLabel() { return label; }\r}\rpublic static Destination dest(String s) {\rreturn new PDestination(s);\r}\rpublic static Contents cont() {\rreturn new PContents();\r}\rpublic static void main(String[] args) {\rContents c = cont();\rDestination d = dest(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 在main()中，我们不需要Parcel10的对象；相反，我们用常规的语法来选择一个static成员，以便调用将句柄返回Contents和Destination的方法。\n通常，我们不在一个接口里设置任何代码，但static内部类可以成为接口的一部分。由于类是“静态”的，所以它不会违反接口的规则——static内部类只位于接口的命名空间内部:\ninterface IInterface {\rstatic class Inner {\rint i, j, k;\rpublic Inner() {}\rvoid f() {}\r}\r} ///:~ 在本书早些时候，我建议大家在每个类里都设置一个main()，将其作为那个类的测试床使用。这样做的一个缺点就是额外代码的数量太多。若不愿如此，可考虑用一个static内部类容纳自己的测试代码。如下所示：\nclass TestBed {\rTestBed() {}\rvoid f() { System.out.println(\u0026#34;f()\u0026#34;); }\rpublic static class Tester {\rpublic static void main(String[] args) {\rTestBed t = new TestBed();\rt.f();\r}\r}\r} ///:~ 这样便生成一个独立的、名为TestBed$Tester的类（为运行程序，请使用“java TestBed$Tester”命令）。可将这个类用于测试，但不需在自己的最终发行版本中包含它。\n7.6.5 引用外部类对象 若想生成外部类对象的句柄，就要用一个点号以及一个this来命名外部类。举个例子来说，在Sequence.SSelector类中，它的所有方法都能产生外部类Sequence的存储句柄，方法是采用Sequence.this的形式。结果获得的句柄会自动具备正确的类型（这会在编译期间检查并核实，所以不会出现运行期的开销）。\n有些时候，我们想告诉其他某些对象创建它某个内部类的一个对象。为达到这个目的，必须在new表达式中提供指向其他外部类对象的一个句柄，就象下面这样：\npublic class Parcel11 {\rclass Contents {\rprivate int i = 11;\rpublic int value() { return i; }\r}\rclass Destination {\rprivate String label;\rDestination(String whereTo) {\rlabel = whereTo;\r}\rString readLabel() { return label; }\r}\rpublic static void main(String[] args) {\rParcel11 p = new Parcel11();\r// Must use instance of outer class\r// to create an instances of the inner class:\rParcel11.Contents c = p.new Contents();\rParcel11.Destination d =\rp.new Destination(\u0026#34;Tanzania\u0026#34;);\r}\r} ///:~ 为直接创建内部类的一个对象，不能象大家或许猜想的那样——采用相同的形式，并引用外部类名Parcel11。此时，必须利用外部类的一个对象生成内部类的一个对象：\nParcel11.Contents c = p.new Contents(); 因此，除非已拥有外部类的一个对象，否则不可能创建内部类的一个对象。这是由于内部类的对象已同创建它的外部类的对象“默默”地连接到一起。然而，如果生成一个static内部类，就不需要指向外部类对象的一个句柄。\n7.6.6 从内部类继承 由于内部类构建器必须同封装类对象的一个句柄联系到一起，所以从一个内部类继承的时候，情况会稍微变得有些复杂。这儿的问题是封装类的“秘密”句柄必须获得初始化，而且在衍生类中不再有一个默认的对象可以连接。解决这个问题的办法是采用一种特殊的语法，明确建立这种关联：\nclass WithInner {\rclass Inner {}\r}\rpublic class InheritInner extends WithInner.Inner {\r//! InheritInner() {} // Won\u0026#39;t compile\rInheritInner(WithInner wi) {\rwi.super();\r}\rpublic static void main(String[] args) {\rWithInner wi = new WithInner();\rInheritInner ii = new InheritInner(wi);\r}\r} ///:~ 从中可以看到，InheritInner只对内部类进行了扩展，没有扩展外部类。但在需要创建一个构建器的时候，默认对象已经没有意义，我们不能只是传递封装对象的一个句柄。此外，必须在构建器中采用下述语法：\nenclosingClassHandle.super(); 它提供了必要的句柄，以便程序正确编译。\n7.6.7 内部类可以覆盖吗？ 若创建一个内部类，然后从封装类继承，并重新定义内部类，那么会出现什么情况呢？也就是说，我们有可能覆盖一个内部类吗？这看起来似乎是一个非常有用的概念，但“覆盖”一个内部类——好象它是外部类的另一个方法——这一概念实际不能做任何事情：\nclass Egg {\rprotected class Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;Egg.Yolk()\u0026#34;);\r}\r}\rprivate Yolk y;\rpublic Egg() {\rSystem.out.println(\u0026#34;New Egg()\u0026#34;);\ry = new Yolk();\r}\r}\rpublic class BigEgg extends Egg {\rpublic class Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;BigEgg.Yolk()\u0026#34;);\r}\r}\rpublic static void main(String[] args) {\rnew BigEgg();\r}\r} ///:~ 默认构建器是由编译器自动合成的，而且会调用基础类的默认构建器。大家或许会认为由于准备创建一个BigEgg，所以会使用Yolk的“被覆盖”版本。但实际情况并非如此。输出如下：\nNew Egg()\rEgg.Yolk() 这个例子简单地揭示出当我们从外部类继承的时候，没有任何额外的内部类继续下去。然而，仍然有可能“明确”地从内部类继承：\nclass Egg2 {\rprotected class Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;Egg2.Yolk()\u0026#34;);\r}\rpublic void f() {\rSystem.out.println(\u0026#34;Egg2.Yolk.f()\u0026#34;);\r}\r}\rprivate Yolk y = new Yolk();\rpublic Egg2() {\rSystem.out.println(\u0026#34;New Egg2()\u0026#34;);\r}\rpublic void insertYolk(Yolk yy) { y = yy; }\rpublic void g() { y.f(); }\r}\rpublic class BigEgg2 extends Egg2 {\rpublic class Yolk extends Egg2.Yolk {\rpublic Yolk() {\rSystem.out.println(\u0026#34;BigEgg2.Yolk()\u0026#34;);\r}\rpublic void f() {\rSystem.out.println(\u0026#34;BigEgg2.Yolk.f()\u0026#34;);\r}\r}\rpublic BigEgg2() { insertYolk(new Yolk()); }\rpublic static void main(String[] args) {\rEgg2 e2 = new BigEgg2();\re2.g();\r}\r} ///:~ 现在，BigEgg2.Yolk明确地扩展了Egg2.Yolk，而且覆盖了它的方法。方法insertYolk()允许BigEgg2将它自己的某个Yolk对象上溯造型至Egg2的y句柄。所以当g()调用y.f()的时候，就会使用f()被覆盖版本。输出结果如下：\nEgg2.Yolk() // private Yolk y = new Yolk();\rNew Egg2() // public Egg2(){}\rEgg2.Yolk() // insertYolk(new Yolk()) 中创建的是 BigEgg2.new Yolk()，而 BigEgg2.Yolk extends Egg2.Yolk，所以先要 Egg2.new Yolk()\rBigEgg2.Yolk() // insertYolk(new Yolk()) 中创建的是 BigEgg2.new Yolk()\rBigEgg2.Yolk.f() // 此时 e2.f 类型是 BigEgg2.Yolk 对Egg2.Yolk()的第二个调用是BigEgg2.Yolk构建器的基础类构建器调用。调用 g()的时候，可发现使用的是f()的被覆盖版本。\n7.6.8 内部类标识符 由于每个类都会生成一个.class文件，用于容纳与如何创建这个类型的对象有关的所有信息（这种信息产生了一个名为Class对象的元类），所以大家或许会猜到内部类也必须生成相应的.class文件，用来容纳与它们的Class对象有关的信息。这些文件或类的名字遵守一种严格的形式：先是封装类的名字，再跟随一个$，再跟随内部类的名字。例如，由InheritInner.java创建的.class文件包括：\nInheritInner.class\rWithInner$Inner.class\rWithInner.class 如果内部类是匿名的，那么编译器会简单地生成数字，把它们作为内部类标识符使用。若内部类嵌套于其他内部类中，则它们的名字简单地追加在一个$以及外部类标识符的后面。\n这种生成内部名称的方法除了非常简单和直观以外，也非常“健壮”，可适应大多数场合的要求（注释③）。由于它是Java的标准命名机制，所以产生的文件会自动具备“与平台无关”的能力（注意Java编译器会根据情况改变内部类，使其在不同的平台中能正常工作）。\n③：但在另一方面，由于“$”也是Unix外壳的一个元字符，所以有时会在列出.class文件时遇到麻烦。对一家以Unix为基础的公司——Sun——来说，采取这种方案显得有些奇怪。我的猜测是他们根本没有仔细考虑这方面的问题，而是认为我们会将全部注意力自然地放在源码文件上。\n7.6.9 为什么要用内部类：控制框架 到目前为止，大家已接触了对内部类的运作进行描述的大量语法与概念。但这些并不能真正说明内部类存在的原因。为什么Sun要如此麻烦地在Java 1.1里添加这样的一种基本语言特性呢？答案就在于我们在这里要学习的“控制框架”。\n一个“应用程序框架”是指一个或一系列类，它们专门设计用来解决特定类型的问题。为应用应用程序框架，我们可从一个或多个类继承，并覆盖其中的部分方法。我们在覆盖方法中编写的代码用于定制由那些应用程序框架提供的常规方案，以便解决自己的实际问题。“控制框架”属于应用程序框架的一种特殊类型，受到对事件响应的需要的支配；主要用来响应事件的一个系统叫作“由事件驱动的系统”。在应用程序设计语言中，最重要的问题之一便是“图形用户界面”（GUI），它几乎完全是由事件驱动的。正如大家会在第13章学习的那样，Java 1.1 AWT属于一种控制框架，它通过内部类完美地解决了GUI的问题。\n为理解内部类如何简化控制框架的创建与使用，可认为一个控制框架的工作就是在事件“就绪”以后执行它们。尽管“就绪”的意思很多，但在目前这种情况下，我们却是以计算机时钟为基础。随后，请认识到针对控制框架需要控制的东西，框架内并未包含任何特定的信息。首先，它是一个特殊的接口，描述了所有控制事件。它可以是一个抽象类，而非一个实际的接口。由于默认行为是根据时间控制的，所以部分实施细节可能包括：\nabstract public class Event {\rprivate long evtTime;\rpublic Event(long eventTime) {\revtTime = eventTime;\r}\rpublic boolean ready() {\rreturn System.currentTimeMillis() \u0026gt;= evtTime;\r}\rabstract public void action();\rabstract public String description();\r} ///:~ 希望Event（事件）运行的时候，构建器即简单地捕获时间。同时ready()告诉我们何时该运行它。当然，ready()也可以在一个衍生类中被覆盖，将事件建立在除时间以外的其他东西上。\naction()是事件就绪后需要调用的方法，而description()提供了与事件有关的文字信息。\n下面这个文件包含了实际的控制框架，用于管理和触发事件。第一个类实际只是一个“助手”类，它的职责是容纳Event对象。可用任何适当的集合替换它。而且通过第8章的学习，大家会知道另一些集合可简化我们的工作，不需要我们编写这些额外的代码：\nclass EventSet {\rprivate Event[] events = new Event[100];\rprivate int index = 0;\rprivate int next = 0;\rpublic void add(Event e) {\rif(index \u0026gt;= events.length)\rreturn; // (In real life, throw exception)\revents[index++] = e;\r}\rpublic Event getNext() {\rboolean looped = false;\rint start = next;\rdo {\rnext = (next + 1) % events.length;\r// See if it has looped to the beginning:\rif(start == next) looped = true;\r// If it loops past start, the list\r// is empty:\rif((next == (start + 1) % events.length)\r\u0026amp;\u0026amp; looped)\rreturn null;\r} while(events[next] == null);\rreturn events[next];\r}\rpublic void removeCurrent() {\revents[next] = null;\r}\r}\rpublic class Controller {\rprivate EventSet es = new EventSet();\rpublic void addEvent(Event c) { es.add(c); }\rpublic void run() {\rEvent e;\rwhile((e = es.getNext()) != null) {\rif(e.ready()) {\re.action();\rSystem.out.println(e.description());\res.removeCurrent();\r}\r}\r}\r} ///:~ EventSet可容纳100个事件（若在这里使用来自第8章的一个“真实”集合，就不必担心它的最大尺寸，因为它会根据情况自动改变大小）。index（索引）在这里用于跟踪下一个可用的空间，而next（下一个）帮助我们寻找列表中的下一个事件，了解自己是否已经循环到头。在对getNext()的调用中，这一点是至关重要的，因为一旦运行，Event对象就会从列表中删去（使用removeCurrent()）。所以getNext()会在列表中向前移动时遇到“空洞”。\n注意removeCurrent()并不只是指示一些标志，指出对象不再使用。相反，它将句柄设为null。这一点是非常重要的，因为假如垃圾收集器发现一个句柄仍在使用，就不会清除对象。若认为自己的句柄可能象现在这样被挂起，那么最好将其设为null，使垃圾收集器能够正常地清除它们。\nController是进行实际工作的地方。它用一个EventSet容纳自己的Event对象，而且addEvent()允许我们向这个列表加入新事件。但最重要的方法是run()。该方法会在EventSet中遍历，搜索一个准备运行的Event对象——ready()。对于它发现ready()的每一个对象，都会调用action()方法，打印出description()，然后将事件从列表中删去。\n注意在迄今为止的所有设计中，我们仍然不能准确地知道一个“事件”要做什么。这正是整个设计的关键；它怎样“将发生变化的东西同没有变化的东西区分开”？或者用我的话来讲，“改变的意图”造成了各类Event对象的不同行动。我们通过创建不同的Event子类，从而表达出不同的行动。\n这里正是内部类大显身手的地方。它们允许我们做两件事情：\n(1) 在单独一个类里表达一个控制框架应用的全部实施细节，从而完整地封装与那个实施有关的所有东西。内部类用于表达多种不同类型的action()，它们用于解决实际的问题。除此以外，后续的例子使用了private内部类，所以实施细节会完全隐藏起来，可以安全地修改。\n(2) 内部类使我们具体的实施变得更加巧妙，因为能方便地访问外部类的任何成员。若不具备这种能力，代码看起来就可能没那么使人舒服，最后不得不寻找其他方法解决。\n现在要请大家思考控制框架的一种具体实施方式，它设计用来控制温室（Greenhouse）功能（注释④）。每个行动都是完全不同的：控制灯光、供水以及温度自动调节的开与关，控制响铃，以及重新启动系统。但控制框架的设计宗旨是将不同的代码方便地隔离开。对每种类型的行动，都要继承一个新的Event内部类，并在action()内编写相应的控制代码。\n④：由于某些特殊原因，这对我来说是一个经常需要解决的、非常有趣的问题；原来的例子在《C++ Inside \u0026amp; Out》一书里也出现过，但Java提供了一种更令人舒适的解决方案。\n作为应用程序框架的一种典型行为，GreenhouseControls类是从Controller继承的：\npublic class GreenhouseControls\rextends Controller {\rprivate boolean light = false;\rprivate boolean water = false;\rprivate String thermostat = \u0026#34;Day\u0026#34;;\rprivate class LightOn extends Event {\rpublic LightOn(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here to\r// physically turn on the light.\rlight = true;\r}\rpublic String description() {\rreturn \u0026#34;Light is on\u0026#34;;\r}\r}\rprivate class LightOff extends Event {\rpublic LightOff(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here to\r// physically turn off the light.\rlight = false;\r}\rpublic String description() {\rreturn \u0026#34;Light is off\u0026#34;;\r}\r}\rprivate class WaterOn extends Event {\rpublic WaterOn(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rwater = true;\r}\rpublic String description() {\rreturn \u0026#34;Greenhouse water is on\u0026#34;;\r}\r}\rprivate class WaterOff extends Event {\rpublic WaterOff(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rwater = false;\r}\rpublic String description() {\rreturn \u0026#34;Greenhouse water is off\u0026#34;;\r}\r}\rprivate class ThermostatNight extends Event {\rpublic ThermostatNight(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rthermostat = \u0026#34;Night\u0026#34;;\r}\rpublic String description() {\rreturn \u0026#34;Thermostat on night setting\u0026#34;;\r}\r}\rprivate class ThermostatDay extends Event {\rpublic ThermostatDay(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Put hardware control code here\rthermostat = \u0026#34;Day\u0026#34;;\r}\rpublic String description() {\rreturn \u0026#34;Thermostat on day setting\u0026#34;;\r}\r}\r// An example of an action() that inserts a\r// new one of itself into the event list:\rprivate int rings;\rprivate class Bell extends Event {\rpublic Bell(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\r// Ring bell every 2 seconds, rings times:\rSystem.out.println(\u0026#34;Bing!\u0026#34;);\rif(--rings \u0026gt; 0)\raddEvent(new Bell(\rSystem.currentTimeMillis() + 2000));\r}\rpublic String description() {\rreturn \u0026#34;Ring bell\u0026#34;;\r}\r}\rprivate class Restart extends Event {\rpublic Restart(long eventTime) {\rsuper(eventTime);\r}\rpublic void action() {\rlong tm = System.currentTimeMillis();\r// Instead of hard-wiring, you could parse\r// configuration information from a text\r// file here:\rrings = 5;\raddEvent(new ThermostatNight(tm));\raddEvent(new LightOn(tm + 1000));\raddEvent(new LightOff(tm + 2000));\raddEvent(new WaterOn(tm + 3000));\raddEvent(new WaterOff(tm + 8000));\raddEvent(new Bell(tm + 9000));\raddEvent(new ThermostatDay(tm + 10000));\r// Can even add a Restart object!\raddEvent(new Restart(tm + 20000));\r}\rpublic String description() {\rreturn \u0026#34;Restarting system\u0026#34;;\r}\r}\rpublic static void main(String[] args) {\rGreenhouseControls gc =\rnew GreenhouseControls();\rlong tm = System.currentTimeMillis();\rgc.addEvent(gc.new Restart(tm));\rgc.run();\r}\r} ///:~ 注意light（灯光）、water（供水）、thermostat（调温）以及rings都隶属于外部类GreenhouseControls，所以内部类可以毫无阻碍地访问那些字段。此外，大多数action()方法也涉及到某些形式的硬件控制，这通常都要求发出对非Java代码的调用。\n大多数Event类看起来都是相似的，但Bell（铃）和Restart（重启）属于特殊情况。Bell会发出响声，若尚未响铃足够的次数，它会在事件列表里添加一个新的Bell对象，所以以后会再度响铃。请注意内部类看起来为什么总是类似于多重继承：Bell拥有Event的所有方法，而且也拥有外部类GreenhouseControls的所有方法。\nRestart负责对系统进行初始化，所以会添加所有必要的事件。当然，一种更灵活的做法是避免进行“硬编码”，而是从一个文件里读入它们（第10章的一个练习会要求大家修改这个例子，从而达到这个目标）。由于Restart()仅仅是另一个Event对象，所以也可以在Restart.action()里添加一个Restart对象，使系统能够定期重启。在main()中，我们需要做的全部事情就是创建一个GreenhouseControls对象，并添加一个Restart对象，令其工作起来。 这个例子应该使大家对内部类的价值有一个更加深刻的认识，特别是在一个控制框架里使用它们的时候。此外，在第13章的后半部分，大家还会看到如何巧妙地利用内部类描述一个图形用户界面的行为。完成那里的学习后，对内部类的认识将上升到一个前所未有的新高度。\n内部类总结 什么是内部类 大部分时候，类被定义成一个独立的程序单元。在某些情况下，也会把一个类放在另一个类的内部定义，这个定义在其他类内部的类就被称为内部类（有些地方也叫做嵌套类），包含内部类的类也被称为外部类（有些地方也叫做宿主类）\n作用？？ 更好的封装性 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量 匿名内部类适合用于创建那些仅需要一次使用的类 静态or非静态？？ 使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。称为静态内部类（也可称为类内部类），这样的内部类是类级别的，static关键字的作用是把类的成员变成类相关，而不是实例相关\n注意：\n1.非静态内部类中不允许定义静态成员 2.外部类的静态成员不可以直接使用非静态内部类 3.静态内部类，不能访问外部类的实例成员，只能访问外部类的类成员 Demo public class EmpTest {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\rpublic static final class Builder {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\rpublic Integer getId() {\rreturn id;\r}\rpublic void setId(Integer id) {\rthis.id = id;\r}\rpublic Integer getEmpLevel() {\rreturn empLevel;\r}\rpublic void setEmpLevel(Integer empLevel) {\rthis.empLevel = empLevel;\r}\rpublic String getMapingOrderLevel() {\rreturn mapingOrderLevel;\r}\rpublic void setMapingOrderLevel(String mapingOrderLevel) {\rthis.mapingOrderLevel = mapingOrderLevel;\r}\rpublic String getEmpNo() {\rreturn empNo;\r}\rpublic void setEmpNo(String empNo) {\rthis.empNo = empNo;\r}\rpublic Integer getOrderNumLimit() {\rreturn orderNumLimit;\r}\rpublic void setOrderNumLimit(Integer orderNumLimit) {\rthis.orderNumLimit = orderNumLimit;\r}\r} 添加了内部类的实体定义如下：（已经不再是严格的POJP）\npublic class EmpTest {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\r//外部类私有的构造方法\rprivate EmpTest(Builder builder) {\rsetId(builder.id);\rsetEmpLevel(builder.empLevel);\rsetMapingOrderLevel(builder.mapingOrderLevel);\rsetEmpNo(builder.empNo);\rsetOrderNumLimit(builder.orderNumLimit);\r}\r//对外提供初始化EmpTest类的唯一接口，通过这个方法，获得内部类的实例\rpublic static Builder newBuilder() {\rreturn new Builder();\r}\r//静态内部类：Builder\rpublic static final class Builder {\rprivate Integer id;\rprivate Integer empLevel;\rprivate String mapingOrderLevel;\rprivate String empNo;\rprivate Integer orderNumLimit;\rpublic Builder() {\r}\rpublic Builder id(Integer val) {\rid = val;\rreturn this;\r}\rpublic Builder empLevel(Integer val) {\rempLevel = val;\rreturn this;\r}\rpublic Builder mapingOrderLevel(String val) {\rmapingOrderLevel = val;\rreturn this;\r}\rpublic Builder empNo(String val) {\rempNo = val;\rreturn this;\r}\rpublic Builder orderNumLimit(Integer val) {\rorderNumLimit = val;\rreturn this;\r}\r//通过内部类的build方法，实例化外部类，并给其实例各个字段赋值\rpublic EmpTest build() {\rreturn new EmpTest(this);\r}\r}\rpublic Integer getId() {\rreturn id;\r}\r//...下边的get set 方法省略，和第一段一样\r} //初始化20个员工实例：\rfor(int i=0;i\u0026lt;20;i++){\rempList.add(EmpTest.newBuilder().empLevel(getRandom(5)).empNo(\u0026#34;Emp_\u0026#34;+i).id(i).mapingOrderLevel(getRandomChar()).orderNumLimit(getRandom(20)).build());\r} 7.7 构建器和多形性 同往常一样，构建器与其他种类的方法是有区别的。在涉及到多形性的问题后，这种方法依然成立。尽管构建器并不具有多形性（即便可以使用一种“虚拟构建器”——将在第11章介绍），但仍然非常有必要理解构建器如何在复杂的分级结构中以及随同多形性使用。这一理解将有助于大家避免陷入一些令人不快的纠纷。\n7.7.1 构建器的调用顺序 构建器调用的顺序已在第4章进行了简要说明，但那是在继承和多形性问题引入之前说的话。\n用于基础类的构建器肯定在一个衍生类的构建器中调用，而且逐渐向上链接，使每个基础类使用的构建器都能得到调用。之所以要这样做，是由于构建器负有一项特殊任务：检查对象是否得到了正确的构建。一个衍生类只能访问它自己的成员，不能访问基础类的成员（这些成员通常都具有private属性）。只有基础类的构建器在初始化自己的元素时才知道正确的方法以及拥有适当的权限。所以，必须令所有构建器都得到调用，否则整个对象的构建就可能不正确。那正是编译器为什么要强迫对衍生类的每个部分进行构建器调用的原因。在衍生类的构建器主体中，若我们没有明确指定对一个基础类构建器的调用，它就会“默默”地调用默认构建器。如果不存在默认构建器，编译器就会报告一个错误（若某个类没有构建器，编译器会自动组织一个默认构建器）。\n对于一个复杂的对象，构建器的调用遵照下面的顺序：\n(1) 调用基础类构建器。这个步骤会不断重复下去，首先得到构建的是分级结构的根部，然后是下一个衍生类，等等。直到抵达最深一层的衍生类。 (2) 按声明顺序调用成员初始化模块。 (3) 调用衍生构建器的主体。 构建器调用的顺序是非常重要的。进行继承时，我们知道关于基础类的一切，并且能访问基础类的任何public和protected成员。这意味着当我们在衍生类的时候，必须能假定基础类的所有成员都是有效的。采用一种标准方法，构建行动已经进行，所以对象所有部分的成员均已得到构建。但在构建器内部，必须保证使用的所有成员都已构建。为达到这个要求，唯一的办法就是首先调用基础类构建器。然后在进入衍生类构建器以后，我们在基础类能够访问的所有成员都已得到初始化。此外，所有成员对象（亦即通过合成方法置于类内的对象）在类内进行定义的时候（比如上例中的b，c和l），由于我们应尽可能地对它们进行初始化，所以也应保证构建器内部的所有成员均为有效。若坚持按这一规则行事，会有助于我们确定所有基础类成员以及当前对象的成员对象均已获得正确的初始化。但不幸的是，这种做法并不适用于所有情况，这将在下一节具体说明。\n7.7.2 继承和 finalize() 通过“合成”方法创建新类时，永远不必担心对那个类的成员对象的收尾工作。每个成员都是一个独立的对象，所以会得到正常的垃圾收集以及收尾处理——无论它是不是不自己某个类一个成员。但在进行初始化的时候，必须覆盖衍生类中的finalize()方法——如果已经设计了某个特殊的清除进程，要求它必须作为垃圾收集的一部分进行。覆盖衍生类的finalize()时，务必记住调用finalize()的基础类版本。否则，基础类的初始化根本不会发生。下面这个例子便是明证：\n//: Frog.java // Testing finalize with inheritance class DoBaseFinalization { public static boolean flag = false; } class Characteristic { String s; Characteristic(String c) { s = c; System.out.println( \u0026#34;Creating Characteristic \u0026#34; + s); } protected void finalize() { System.out.println( \u0026#34;finalizing Characteristic \u0026#34; + s); } } class LivingCreature { Characteristic p = new Characteristic(\u0026#34;is alive\u0026#34;); LivingCreature() { System.out.println(\u0026#34;LivingCreature()\u0026#34;); } protected void finalize() { System.out.println( \u0026#34;LivingCreature finalize\u0026#34;); // Call base-class version LAST! if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } } class Animal extends LivingCreature { Characteristic p = new Characteristic(\u0026#34;has heart\u0026#34;); Animal() { System.out.println(\u0026#34;Animal()\u0026#34;); } protected void finalize() { System.out.println(\u0026#34;Animal finalize\u0026#34;); if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } } class Amphibian extends Animal { Characteristic p = new Characteristic(\u0026#34;can live in water\u0026#34;); Amphibian() { System.out.println(\u0026#34;Amphibian()\u0026#34;); } protected void finalize() { System.out.println(\u0026#34;Amphibian finalize\u0026#34;); if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } } public class Frog extends Amphibian { Frog() { System.out.println(\u0026#34;Frog()\u0026#34;); } protected void finalize() { System.out.println(\u0026#34;Frog finalize\u0026#34;); if(DoBaseFinalization.flag) try { super.finalize(); } catch(Throwable t) {} } public static void main(String[] args) { if(args.length != 0 \u0026amp;\u0026amp; args[0].equals(\u0026#34;finalize\u0026#34;)) DoBaseFinalization.flag = true; else System.out.println(\u0026#34;not finalizing bases\u0026#34;); new Frog(); // Instantly becomes garbage System.out.println(\u0026#34;bye!\u0026#34;); // Must do this to guarantee that all // finalizers will be called: System.runFinalizersOnExit(true); } } ///:~ DoBasefinalization类只是简单地容纳了一个标志，向分级结构中的每个类指出是否应调用super.finalize()。这个标志的设置建立在命令行参数的基础上，所以能够在进行和不进行基础类收尾工作的前提下查看行为。 分级结构中的每个类也包含了Characteristic类的一个成员对象。大家可以看到，无论是否调用了基础类收尾模块，Characteristic成员对象都肯定会得到收尾（清除）处理。\n每个被覆盖的finalize()至少要拥有对protected成员的访问权力，因为Object类中的finalize()方法具有protected属性，而编译器不允许我们在继承过程中消除访问权限（“友好的”比“受到保护的”具有更小的访问权限）。\n在Frog.main()中，DoBaseFinalization标志会得到配置，而且会创建单独一个Frog对象。请记住垃圾收集（特别是收尾工作）可能不会针对任何特定的对象发生，所以为了强制采取这一行动，System.runFinalizersOnExit(true)添加了额外的开销，以保证收尾工作的正常进行。若没有基础类初始化 则输出结果是：\nnot finalizing bases\rCreating Characteristic is alive\rLivingCreature()\rCreating Characteristic has heart\rAnimal()\rCreating Characteristic can live in water\rAmphibian()\rFrog()\rbye!\rFrog finalize\rfinalizing Characteristic is alive\rfinalizing Characteristic has heart\rfinalizing Characteristic can live in water 从中可以看出确实没有为基础类Frog调用收尾模块。但假如在命令行加入“finalize”自变量，则会获得下述结果：\nCreating Characteristic is alive\rLivingCreature()\rCreating Characteristic has heart\rAnimal()\rCreating Characteristic can live in water\rAmphibian()\rFrog()\rbye!\rFrog finalize\rAmphibian finalize\rAnimal finalize\rLivingCreature finalize\rfinalizing Characteristic is alive\rfinalizing Characteristic has heart\rfinalizing Characteristic can live in water 尽管成员对象按照与它们创建时相同的顺序进行收尾，但从技术角度说，并没有指定对象收尾的顺序。但对于基础类，我们可对收尾的顺序进行控制。采用的最佳顺序正是在这里采用的顺序，它与初始化顺序正好相反。按照与C++中用于“破坏器”相同的形式，我们应该首先执行衍生类的收尾，再是基础类的收尾。这是由于衍生类的收尾可能调用基础类中相同的方法，要求基础类组件仍然处于活动状态。因此，必须提前将它们清除（破坏）。\n7.7.3 构建器内部的多形性方法的行为 构建器调用的分级结构（顺序）为我们带来了一个有趣的问题，或者说让我们进入了一种进退两难的局面。若当前位于一个构建器的内部，同时调用准备构建的那个对象的一个动态绑定方法，那么会出现什么情况呢？在原始的方法内部，我们完全可以想象会发生什么——动态绑定的调用会在运行期间进行解析，因为对象不知道它到底从属于方法所在的那个类，还是从属于从它衍生出来的某些类。为保持一致性，大家也许会认为这应该在构建器内部发生。 但实际情况并非完全如此。若调用构建器内部一个动态绑定的方法，会使用那个方法被覆盖的定义。然而，产生的效果可能并不如我们所愿，而且可能造成一些难于发现的程序错误。\n从概念上讲，构建器的职责是让对象实际进入存在状态。在任何构建器内部，整个对象可能只是得到部分组织——我们只知道基础类对象已得到初始化，但却不知道哪些类已经继承。然而，一个动态绑定的方法调用却会在分级结构里“向前”或者“向外”前进。它调用位于衍生类里的一个方法。如果在构建器内部做这件事情，那么对于调用的方法，它要操纵的成员可能尚未得到正确的初始化——这显然不是我们所希望的。 通过观察下面这个例子，这个问题便会昭然若揭：\nabstract class Glyph {\rabstract void draw();\rGlyph() {\rSystem.out.println(\u0026#34;Glyph() before draw()\u0026#34;);\rdraw(); System.out.println(\u0026#34;Glyph() after draw()\u0026#34;);\r}\r}\rclass RoundGlyph extends Glyph {\rint radius = 1;\rRoundGlyph(int r) {\rradius = r;\rSystem.out.println(\r\u0026#34;RoundGlyph.RoundGlyph(), radius = \u0026#34;\r+ radius);\r}\rvoid draw() { System.out.println(\r\u0026#34;RoundGlyph.draw(), radius = \u0026#34; + radius);\r}\r}\rpublic class PolyConstructors {\rpublic static void main(String[] args) {\rnew RoundGlyph(5);\r}\r} ///:~ 在Glyph中，draw()方法是“抽象的”（abstract），所以它可以被其他方法覆盖。事实上，我们在RoundGlyph中不得不对其进行覆盖。但Glyph构建器会调用这个方法，而且调用会在RoundGlyph.draw()中止，这看起来似乎是有意的。但请看看输出结果：\nGlyph() before draw()\rRoundGlyph.draw(), radius = 0\rGlyph() after draw()\rRoundGlyph.RoundGlyph(), radius = 5 当Glyph的构建器调用draw()时，radius的值甚至不是默认的初始值1，而是0。这可能是由于一个点号或者屏幕上根本什么都没有画而造成的。这样就不得不开始查找程序中的错误，试着找出程序不能工作的原因。 前一节讲述的初始化顺序并不十分完整，而那是解决问题的关键所在。初始化的实际过程是这样的：\n(1) 在采取其他任何操作之前，为对象分配的存储空间初始化成二进制零。 (2) 就象前面叙述的那样，调用基础类构建器。此时，被覆盖的draw()方法会得到调用（的确是在RoundGlyph构建器调用之前），此时会发现radius的值为0，这是由于步骤(1)造成的。 (3) 按照原先声明的顺序调用成员初始化代码。 (4) 调用衍生类构建器的主体。 采取这些操作要求有一个前提，那就是所有东西都至少要初始化成零（或者某些特殊数据类型与“零”等价的值），而不是仅仅留作垃圾。其中包括通过“合成”技术嵌入一个类内部的对象句柄。如果假若忘记初始化那个句柄，就会在运行期间出现违例事件。其他所有东西都会变成零，这在观看结果时通常是一个严重的警告信号。\n在另一方面，应对这个程序的结果提高警惕。从逻辑的角度说，我们似乎已进行了无懈可击的设计，所以它的错误行为令人非常不可思议。而且没有从编译器那里收到任何报错信息（C++在这种情况下会表现出更合理的行为）。象这样的错误会很轻易地被人忽略，而且要花很长的时间才能找出。\n因此，设计构建器时一个特别有效的规则是：用尽可能简单的方法使对象进入就绪状态；如果可能，避免调用任何方法。在构建器内唯一能够安全调用的是在基础类中具有final属性的那些方法（也适用于private方法，它们自动具有final属性）。这些方法不能被覆盖，所以不会出现上述潜在的问题。\n7.8 通过继承进行设计 学习了多形性的知识后，由于多形性是如此“聪明”的一种工具，所以看起来似乎所有东西都应该继承。但假如过度使用继承技术，也会使自己的设计变得不必要地复杂起来。事实上，当我们以一个现成类为基础建立一个新类时，如首先选择继承，会使情况变得异常复杂。\n一个更好的思路是首先选择“合成”——如果不能十分确定自己应使用哪一个。合成不会强迫我们的程序设计进入继承的分级结构中。同时，合成显得更加灵活，因为可以动态选择一种类型（以及行为），而继承要求在编译期间准确地知道一种类型。下面这个例子对此进行了阐释：\ninterface Actor { void act(); } class HappyActor implements Actor { public void act() { System.out.println(\u0026#34;HappyActor\u0026#34;); } } class SadActor implements Actor { public void act() { System.out.println(\u0026#34;SadActor\u0026#34;); } } class Stage { Actor a = new HappyActor(); void change() { a = new SadActor(); } void go() { a.act(); } } public class Transmogrify { public static void main(String[] args) { Stage s = new Stage(); s.go(); // Prints \u0026#34;HappyActor\u0026#34; s.change(); s.go(); // Prints \u0026#34;SadActor\u0026#34; } } ///:~ 在这里，一个Stage对象包含了指向一个Actor的句柄，后者被初始化成一个HappyActor对象。这意味着go()会产生特定的行为。但由于句柄在运行期间可以重新与一个不同的对象绑定或结合起来，所以SadActor对象的句柄可在a中得到替换，然后由go()产生的行为发生改变。这样一来，我们在运行期间就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。\n一条常规的设计准则是：用继承表达行为间的差异，并用成员变量表达状态的变化。在上述例子中，两者都得到了应用：继承了两个不同的类，用于表达act()方法的差异；而Stage通过合成技术允许它自己的状态发生变化。在这种情况下，那种状态的改变同时也产生了行为的变化。\n具体该如何应用“合成”、“继承”在 6.10 总结 有说明\n7.8.1 纯继承与扩展 学习继承时，为了创建继承分级结构，看来最明显的方法是采取一种“纯粹”的手段。也就是说，只有在基础类或“接口”中已建立的方法才可在衍生类中被覆盖\n可将其描述成一种纯粹的“属于”关系，因为一个类的接口已规定了它到底“是什么”或者“属于什么”。通过继承，可保证所有衍生类都只拥有基础类的接口。如果按上述示意图操作，衍生出来的类除了基础类的接口之外，也不会再拥有其他什么。\n可将其想象成一种“纯替换”，因为衍生类对象可为基础类完美地替换掉。使用它们的时候，我们根本没必要知道与子类有关的任何额外信息。\n也就是说，基础类可接收我们发给衍生类的任何消息，因为两者拥有完全一致的接口。我们要做的全部事情就是从衍生上溯造型，而且永远不需要回过头来检查对象的准确类型是什么。所有细节都已通过多形性获得了完美的控制。 若按这种思路考虑问题，那么一个纯粹的“属于”关系似乎是唯一明智的设计方法，其他任何设计方法都会导致混乱不清的思路，而且在定义上存在很大的困难。但这种想法又属于另一个极端。经过细致的研究，我们发现扩展接口对于一些特定问题来说是特别有效的方案。可将其称为“类似于”关系，因为扩展后的衍生类“类似于”基础类——它们有相同的基础接口——但它增加了一些特性，要求用额外的方法加以实现。\n尽管这是一种有用和明智的做法（由具体的环境决定），但它也有一个缺点：衍生类中对接口扩展的那一部分不可在基础类中使用。所以一旦上溯造型，就不可再调用新方法：\n若在此时不进行上溯造型，则不会出现此类问题。但在许多情况下，都需要重新核实对象的准确类型，使自己能访问那个类型的扩展方法。在后面的小节里，我们具体讲述了这是如何实现的。\n7.8.2 下溯造型与运行期类型标识 由于我们在上溯造型（在继承结构中向上移动）期间丢失了具体的类型信息，所以为了获取具体的类型信息——亦即在分级结构中向下移动——我们必须使用 “下溯造型”技术。然而，我们知道一个上溯造型肯定是安全的；基础类不可能再拥有一个比衍生类更大的接口。因此，我们通过基础类接口发送的每一条消息都肯定能够接收到。但在进行下溯造型的时候，我们（举个例子来说）并不真的知道一个几何形状实际是一个圆，它完全可能是一个三角形、方形或者其他形状。\n为解决这个问题，必须有一种办法能够保证下溯造型正确进行。只有这样，我们才不会冒然造型成一种错误的类型，然后发出一条对象不可能收到的消息。这样做是非常不安全的。\n在某些语言中（如C++），为了进行保证“类型安全”的下溯造型，必须采取特殊的操作。但在Java中，所有造型都会自动得到检查和核实！所以即使我们只是进行一次普通的括弧造型，进入运行期以后，仍然会毫无留情地对这个造型进行检查，保证它的确是我们希望的那种类型。如果不是，就会得到一个ClassCastException（类造型违例）。在运行期间对类型进行检查的行为叫作“运行期类型标识”（RTTI）。\n和在示意图中一样，MoreUseful（更有用的）对Useful（有用的）的接口进行了扩展。但由于它是继承来的，所以也能上溯造型到一个Useful。我们可看到这会在对数组x（位于main()中）进行初始化的时候发生。由于数组中的两个对象都属于Useful类，所以可将f()和g()方法同时发给它们两个。而且假如试图调用u()（它只存在于MoreUseful），就会收到一条编译期出错提示。\n若想访问一个MoreUseful对象的扩展接口，可试着进行下溯造型。如果它是正确的类型，这一行动就会成功。否则，就会得到一个ClassCastException。我们不必为这个违例编写任何特殊的代码，因为它指出的是一个可能在程序中任何地方发生的一个编程错误。\nRTTI的意义远不仅仅反映在造型处理上。例如，在试图下溯造型之前，可通过一种方法了解自己处理的是什么类型。整个第11章都在讲述Java运行期类型标识的方方面面。\n7.9 总结 “多形性”意味着“不同的形式”。在面向对象的程序设计中，我们有相同的外观（基础类的通用接口）以及使用那个外观的不同形式：动态绑定或组织的、不同版本的方法。\n通过这一章的学习，大家已知道假如不利用数据抽象以及继承技术，就不可能理解、甚至去创建多形性的一个例子。多形性是一种不可独立应用的特性（就象一个switch语句），只可与其他元素协同使用。我们应将其作为类总体关系的一部分来看待。人们经常混淆Java其他的、非面向对象的特性，比如方法过载等，这些特性有时也具有面向对象的某些特征。但不要被愚弄：如果以后没有绑定，就不成其为多形性。\n为使用多形性乃至面向对象的技术，特别是在自己的程序中，必须将自己的编程视野扩展到不仅包括单独一个类的成员和消息，也要包括类与类之间的一致性以及它们的关系。尽管这要求学习时付出更多的精力，但却是非常值得的，因为只有这样才可真正有效地加快自己的编程速度、更好地组织代码、更容易做出包容面广的程序以及更易对自己的代码进行维护与扩展。\n第8章 对象的容纳 “如果一个程序只含有数量固定的对象，而且已知它们的存在时间，那么这个程序可以说是相当简单的。”\n通常，我们的程序需要根据程序运行时才知道的一些标准创建新对象。若非程序正式运行，否则我们根本不知道自己到底需要多少数量的对象，甚至不知道它们的准确类型。为了满足常规编程的需要，我们要求能在任何时候、任何地点创建任意数量的对象。所以不可依赖一个已命名的句柄来容纳自己的每一个对象， 因为根本不知道自己实际需要多少这样的东西。\n为解决这个非常关键的问题，Java提供了容纳对象（或者对象的句柄）的多种方式。其中内建的类型是数组，我们之前已讨论过它，本章准备加深大家对它的认识。此外，Java的工具（实用程序）库提供了一些“集合类”（亦称作“容器类”，但该术语已由AWT使用，所以这里仍采用“集合”这一称呼）。利用这些集合类，我们可以容纳乃至操纵自己的对象。本章的剩余部分会就此进行详细讨论。\n8.1 数组 数组只是容纳对象的一种方式。但由于还有其他大量方法可容纳数组，所以是哪些地方使数组显得如此特别呢？ 有两方面的问题将数组与其他集合类型区分开来：效率和类型。对于Java来说，为保存和访问一系列对象（实际是对象的句柄）数组，最有效的方法莫过于数组。数组实际代表一个简单的线性序列，它使得元素的访问速度非常快，但我们却要为这种速度付出代价：创建一个数组对象时，它的大小是固定的，而且不可在那个数组对象的“存在时间”内发生改变。可创建特定大小的一个数组，然后假如用光了存储空间，就再创建一个新数组，将所有句柄从旧数组移到新数组。这属于“矢量”（Vector）类的行为，本章稍后还会详细讨论它。然而，由于为这种大小的灵活性要付出较大的代价，所以我们认为矢量的效率并没有数组高。\nC++的矢量类知道自己容纳的是什么类型的对象，但同Java的数组相比，它却有一个明显的缺点：C++矢量类的operator[]不能进行范围检查，所以很容易超出边界（然而，它可以查询vector有多大，而且at()方法确实能进行范围检查）。在Java中，无论使用的是数组还是集合，都会进行范围检查——若超过边界，就会获得一个RuntimeException（运行期违例）错误。正如大家在第9章会学到的那样，这类违例指出的是一个程序员错误，所以不需要在代码中检查它。在另一方面，由于C++的vector不进行范围检查，所以访问速度较快——在Java中，由于对数组和集合都要进行范围检查，所以对性能有一定的影响。\n本章还要学习另外几种常见的集合类：Vector（矢量）、Stack（堆栈）以及Hashtable（散列表）。这些类都涉及对对象的处理——好象它们没有特定的类型。换言之，它们将其当作Object类型处理（Object类型是Java中所有类的“根”类）。从某个角度看，这种处理方法是非常合理的：我们仅需构建一个集合，然后任何Java对象都可以进入那个集合（除基本数据类型外——可用Java的基本类型封装类将其作为常数置入集合，或者将其封装到自己的类内，作为可以变化的值使用）。这再一次反映了数组优于常规集合：创建一个数组时，可令其容纳一种特定的类型。这意味着可进行编译期类型检查，预防自己设置了错误的类型，或者错误指定了准备提取的类型。当然，在编译期或者运行期，Java会防止我们将不当的消息发给一个对象。所以我们不必考虑自己的哪种做法更加危险，只要编译器能及时地指出错误，同时在运行期间加快速度，目的也就达到了。此外，用户很少会对一次违例事件感到非常惊讶的。\n考虑到执行效率和类型检查，应尽可能地采用数组。然而，当我们试图解决一个更常规的问题时，数组的局限也可能显得非常明显。在研究过数组以后，本章剩余的部分将把重点放到Java提供的集合类身上。\n8.1.1 数组和第一类对象 无论使用的数组属于什么类型，数组标识符实际都是指向真实对象的一个句柄。那些对象本身是在内存“堆”里创建的。堆对象既可“隐式”创建（即默认产生），亦可“显式”创建（即明确指定，用一个new表达式）。堆对象的一部分（实际是我们能访问的唯一字段或方法）是只读的length（长度）成员，它告诉我们那个数组对象里最多能容纳多少元素。对于数组对象，“[]”语法是我们能采用的唯一另类访问方法。\n下面这个例子展示了对数组进行初始化的不同方式，以及如何将数组句柄分配给不同的数组对象。它也揭示出对象数组和基本数据类型数组在使用方法上几乎是完全一致的。唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体的数值（若在执行此程序时遇到困难，请参考第3章的“赋值”小节）：\nlength只告诉我们可将多少元素置入那个数组。换言之，我们只知道数组对象的大小或容量，不知其实际容纳了多少个元素。 尽管如此，由于数组对象在创建之初会自动初始化成null，所以可检查它是否为null，判断一个特定的数组“空位”是否容纳一个对象。类似地，由基本数据类型构成的数组会自动初始化成零（针对数值类型）、null（字符类型）或者false（布尔类型）。\nJava 1.1加入了一种新的数组初始化语法，可将其想象成“动态集合初始化”。\nhide(new Weeble[] {new Weeble(), new Weeble() }); 对于由基本数据类型构成的数组，它们的运作方式与对象数组极为相似，只是前者直接包容了基本类型的数据值。\n集合类只能容纳对象句柄。但对一个数组，却既可令其直接容纳基本类型的数据，亦可容纳指向对象的句柄。\n创建和访问一个基本数据类型数组，那么比起访问一个封装数据的集合，前者的效率会高出许多。\n当然，假如准备一种基本数据类型，同时又想要集合的灵活性（在需要的时候可自动扩展，腾出更多的空间），就不宜使用数组，必须使用由封装的数据构成的一个集合。大家或许认为针对每种基本数据类型，都应有一种特殊类型的Vector。但Java并未提供这一特性。某些形式的建模机制或许会在某一天帮助Java更好地解决这个问题（注释①）。\n①：这儿是C++比Java做得好的一个地方，因为C++通过template关键字提供了对“参数化类型”的支持。\n8.1.2 数组的返回 假定我们现在想写一个方法，同时不希望它仅仅返回一样东西，而是想返回一系列东西。此时，象C和C++这样的语言会使问题复杂化，因为我们不能返回一个数组，只能返回指向数组的一个指针。这样就非常麻烦，因为很难控制数组的“存在时间”，它很容易造成内存“漏洞”的出现。\nJava采用的是类似的方法，但我们能“返回一个数组”。当然，此时返回的实际仍是指向数组的指针。但在Java里，我们永远不必担心那个数组的是否可用——只要需要，它就会自动存在。而且垃圾收集器会在我们完成后自动将其清除。\n返回数组与返回其他任何对象没什么区别——最终返回的都是一个句柄。\n8.2 集合 为容纳一组对象，最适宜的选择应当是数组。而且假如容纳的是一系列基本数据类型，更是必须采用数组。\nJava提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。与拥有集合功能的其他语言相比，尽管这儿的数量显得相当少，但仍然能用它们解决数量惊人的实际问题。\n这些集合类具有形形色色的特征。例如，Stack实现了一个LIFO（先入先出）序列，而Hashtable是一种“关联数组”，允许我们将任何对象关联起来。除此以外，所有Java集合类都能自动改变自身的大小。所以，我们在编程时可使用数量众多的对象，同时不必担心会将集合弄得有多大。\n8.2.1 缺点：类型未知 使用Java集合的“缺点”是在将对象置入一个集合时丢失了类型信息。之所以会发生这种情况，是由于当初编写集合时，那个集合的程序员根本不知道用户到底想把什么类型置入集合。若指示某个集合只允许特定的类型，会妨碍它成为一个“常规用途”的工具，为用户带来麻烦。为解决这个问题，集合实际容纳的是类型为Object的一些对象的句柄。这种类型当然代表Java中的所有对象，因为它是所有类的根。当然，也要注意这并不包括基本数据类型，因为它们并不是从“任何东西”继承来的。这是一个很好的方案，只是不适用下述场合：\n(1) 将一个对象句柄置入集合时，由于类型信息会被抛弃，所以任何类型的对象都可进入我们的集合——即便特别指示它只能容纳特定类型的对象。举个例子来说，虽然指示它只能容纳猫，但事实上任何人都可以把一条狗扔进来。 (2) 由于类型信息不复存在，所以集合能肯定的唯一事情就是自己容纳的是指向一个对象的句柄。正式使用它之前，必须对其进行造型，使其具有正确的类型。 值得欣慰的是，Java不允许人们滥用置入集合的对象。假如将一条狗扔进一个猫的集合，那么仍会将集合内的所有东西都看作猫，所以在使用那条狗时会得到一个“违例”错误。在同样的意义上，假若试图将一条狗的句柄“造型”到一只猫，那么运行期间仍会得到一个“违例”错误。\n这些处理的意义都非常深远。尽管显得有些麻烦，但却获得了安全上的保证。我们从此再难偶然造成一些隐藏得深的错误。若程序的一个部分（或几个部分）将对象插入一个集合，但我们只是通过一次违例在程序的某个部分发现一个错误的对象置入了集合，就必须找出插入错误的位置。当然，可通过检查代码达到这个目的，但这或许是最笨的调试工具。另一方面，我们可从一些标准化的集合类开始自己的编程。尽管它们在功能上存在一些不足，且显得有些笨拙，但却能保证没有隐藏的错误。\n错误有时并不显露出来 在某些情况下，程序似乎正确地工作，不造型回我们原来的类型。第一种情况是相当特殊的：String类从编译器获得了额外的帮助，使其能够正常工作。只要编译器期待的是一个String对象，但它没有得到一个，就会自动调用在Object里定义、并且能够由任何Java类覆盖的toString()方法。这个方法能生成满足要求的String对象，然后在我们需要的时候使用。\n参数化类型 这类问题并不是孤立的——我们许多时候都要在其他类型的基础上创建新类型。此时，在编译期间拥有特定的类型信息是非常有帮助的。这便是“参数化类型”的概念。在C++中，它由语言通过“模板”获得了直接支持。至少，Java保留了关键字generic，期望有一天能够支持参数化类型。但我们现在无法确定这一天何时会来临。\n8.3 枚举器（迭代器） 在任何集合类中，必须通过某种方法在其中置入对象，再用另一种方法从中取得对象。毕竟，容纳各种各样的对象正是集合的首要任务。在Vector中，addElement()便是我们插入对象采用的方法，而elementAt()是提取对象的唯一方法。Vector非常灵活，我们可在任何时候选择任何东西，并可使用不同的索引选择多个元素。\n若从更高的角度看这个问题，就会发现它的一个缺陷：需要事先知道集合的准确类型，否则无法使用。乍看来，这一点似乎没什么关系。但假若最开始决定使用Vector，后来在程序中又决定（考虑执行效率的原因）改变成一个List（属于Java1.2集合库的一部分），这时又该如何做呢？ 可利用“反复器”（Iterator）的概念达到这个目的。它可以是一个对象，作用是遍历一系列对象，并选择那个序列中的每个对象，同时不让客户程序员知道或关注那个序列的基础结构。此外，我们通常认为反复器是一种“轻量级”对象；也就是说，创建它只需付出极少的代价。但也正是由于这个原因，我们常发现反复器存在一些似乎很奇怪的限制。例如，有些反复器只能朝一个方向移动。 Java的Enumeration（枚举，注释②）便是具有这些限制的一个反复器的例子。除下面这些外，不可再用它做其他任何事情：\n(1) 用一个名为elements()的方法要求集合为我们提供一个Enumeration。我们首次调用它的nextElement()时，这个Enumeration会返回序列中的第一个元素。\n(2) 用nextElement()获得下一个对象。\n(3) 用hasMoreElements()检查序列中是否还有更多的对象。\n②：“反复器”这个词在C++和OOP的其他地方是经常出现的，所以很难确定为什么Java的开发者采用了这样一个奇怪的名字。Java 1.2的集合库修正了这个问题以及其他许多问题。\n只可用Enumeration做这些事情，不能再有更多。它属于反复器一种简单的实现方式，但功能依然十分强大。为体会它的运作过程，让我们复习一下本章早些时候提到的CatsAndDogs.java程序。在原始版本中，elementAt()方法用于选择每一个元素，但在下述修订版中，可看到使用了一个“枚举”：\n使用Enumeration，我们不必关心集合中的元素数量。所有工作均由hasMoreElements()和nextElement()自动照管了。\n注意其中没有与序列类型有关的信息。我们拥有的全部东西便是Enumeration。为了解有关序列的情况，一个Enumeration便足够了：可取得下一个对象，亦可知道是否已抵达了末尾。取得一系列对象，然后在其中遍历，从而执行一个特定的操作——这是一个颇有价值的编程概念，本书许多地方都会沿用这一思路。 这个看似特殊的例子甚至可以更为通用，因为它使用了常规的toString()方法（之所以称为常规，是由于它属于Object类的一部分）。下面是调用打印的另一个方法（尽管在效率上可能会差一些）：\n它采用了封装到Java内部的“自动转换成字串”技术。一旦编译器碰到一个字串，后面跟随一个“+”，就会希望后面又跟随一个字串，并自动调用toString()。在Java 1.1中，第一个字串是不必要的；所有对象都会转换成字串。亦可对此执行一次造型，获得与调用toString()同样的效果：\n但我们想做的事情通常并不仅仅是调用Object方法，所以会再度面临类型造型的问题。对于自己感兴趣的类型，必须假定自己已获得了一个Enumeration，然后将结果对象造型成为那种类型（若操作错误，会得到运行期违例）。\n总结：\n这章就是讲迭代器的，自己去看一下集合的迭代器实现就行了。\n8.4 集合的类型 标准Java 1.0和1.1库配套提供了非常少的一系列集合类。但对于自己的大多数编程要求，它们基本上都能胜任。正如大家到本章末尾会看到的，Java 1.2提供的是一套重新设计过的大型集合库。\n这章是讲集合的先看两张图 集合框架被设计成要满足以下几个目标。\n该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 8.4.1 Vector 矢量 8.4.2 BitSet 8.4.3 Stack Stack有时也可以称为“后入先出”（LIFO）集合。换言之，我们在堆栈里最后“压入”的东西将是以后第一个“弹出”的。和其他所有Java集合一样，我们压入和弹出的都是“对象”，所以必须对自己弹出的东西进行“造型”。\n一种很少见的做法是拒绝使用Vector作为一个Stack的基本构成元素，而是从Vector里“继承”一个Stack。这样一来，它就拥有了一个Vector的所有特征及行为，另外加上一些额外的Stack行为。很难判断出设计者到底是明确想这样做，还是属于一种固有的设计。\n8.4.4 Hashtable Vector允许我们用一个数字从一系列对象中作出选择，所以它实际是将数字同对象关联起来了。但假如我们想根据其他标准选择一系列对象呢？堆栈就是这样的一个例子：它的选择标准是“最后压入堆栈的东西”。这种“从一系列对象中选择”的概念亦可叫作一个“映射”、“字典”或者“关联数组”。从概念上讲，它看起来象一个Vector，但却不是通过数字来查找对象，而是用另一个对象来查找它们！这通常都属于一个程序中的重要进程。\n在Java中，这个概念具体反映到抽象类Dictionary身上。该类的接口是非常直观的size()告诉我们其中包含了多少元素；isEmpty()判断是否包含了元素（是则为true）；put(Object key, Object value)添加一个值（我们希望的东西），并将其同一个键关联起来（想用于搜索它的东西）；get(Object key)获得与某个键对应的值；而remove(Object Key)用于从列表中删除“键－值”对。还可以使用枚举技术：keys()产生对键的一个枚举（Enumeration）；而elements()产生对所有值的一个枚举。这便是一个Dictionary（字典）的全部。\n标准Java库只包含Dictionary的一个变种，名为Hashtable（散列表，注释③）。Java的散列表具有与AssocArray相同的接口（因为两者都是从Dictionary继承来的）。但有一个方面却反映出了差别：执行效率。若仔细想想必须为一个get()做的事情，就会发现在一个Vector里搜索键的速度要慢得多。但此时用散列表却可以加快不少速度。不必用冗长的线性搜索技术来查找一个键，而是用一个特殊的值，名为“散列码”。散列码可以获取对象中的信息，然后将其转换成那个对象“相对唯一”的整数（int）。所有对象都有一个散列码，而hashCode()是根类Object的一个方法。Hashtable获取对象的hashCode()，然后用它快速查找键。这样可使性能得到大幅度提升（④）。散列表的具体工作原理已超出了本书的范围（⑤）——大家只需要知道散列表是一种快速的“字典”（Dictionary）即可，而字典是一种非常有用的工具。\n我们用第二个实例进行检索。 大家或许认为此时要做的全部事情就是正确地覆盖hashCode()。但这样做依然行不能，除非再做另一件事情：覆盖也属于Object一部分的equals()。当散列表试图判断我们的键是否等于表内的某个键时，就会用到这个方法。同样地，默认的Object.equals()只是简单地比较对象地址，所以一个Groundhog(3)并不等于另一个Groundhog(3)。 因此，为了在散列表中将自己的类作为键使用，必须同时覆盖hashCode()和equals()。\n8.4.5 再论枚举器 我们现在可以开始演示Enumeration（枚举）的真正威力：将穿越一个序列的操作与那个序列的基础结构分隔开。在下面的例子里，PrintData类用一个Enumeration在一个序列中移动，并为每个对象都调用toString()方法。此时创建了两个不同类型的集合：一个Vector和一个Hashtable。并且在它们里面分别填充Mouse和Hamster对象（本章早些时候已定义了这些类；注意必须先编译HamsterMaze.java和WorksAnyway.java，否则下面的程序不能编译）。由于Enumeration隐藏了基层集合的结构，所以PrintData不知道或者不关心Enumeration来自于什么类型的集合：\n8.5 排序 Java 1.0和1.1库都缺少的一样东西是算术运算，甚至没有最简单的排序运算方法。因此，我们最好创建一个Vector，利用经典的Quicksort（快速排序）方法对其自身进行排序。\n编写通用的排序代码时，面临的一个问题是必须根据对象的实际类型来执行比较运算，从而实现正确的排序。当然，一个办法是为每种不同的类型都写一个不同的排序方法。然而，应认识到假若这样做，以后增加新类型时便不易实现代码的重复利用。\n程序设计一个主要的目标就是“将发生变化的东西同保持不变的东西分隔开”。在这里，保持不变的代码是通用的排序算法，而每次使用时都要变化的是对象的实际比较方法。因此，我们不可将比较代码“硬编码”到多个不同的排序例程内，而是采用“回调”技术。利用回调，经常发生变化的那部分代码会封装到它自己的类内，而总是保持相同的代码则“回调”发生变化的代码。这样一来，不同的对象就可以表达不同的比较方式，同时向它们传递相同的排序代码。\n每次调用addElement()时，都可对Vector进行排序，而且将其连续保持在一个排好序的状态。但在开始读取之前，人们总是向一个Vector添加大量元素。所以与其在每个addElement()后排序，不如一直等到有人想读取Vector，再对其进行排序。后者的效率要高得多。这种除非绝对必要，否则就不采取行动的方法叫作“懒惰求值”（还有一种类似的技术叫作“懒惰初始化”——除非真的需要一个字段值，否则不进行初始化）。\nComparator\u0026lt;Users\u0026gt; comparator = new Comparator\u0026lt;Users\u0026gt;() {\r@Override\rpublic int compare(Users s1, Users s2) {\r//先排年龄\rSystem.out.println(s1.age.compareTo(s2.age));\r//return s1.age.compareTo(s2.age);//降序\rreturn s2.age.compareTo(s1.age);//升序\r}\r};\r//这里就会自动根据规则进行排序\rCollections.sort(list, comparator); 8.6 通用集合库 8.7 新集合 对我来说，集合类属于最强大的一种工具，特别适合在原创编程中使用。大家可能已感觉到我对Java 1.1提供的集合多少有点儿失望。因此，看到Java 1.2对集合重新引起了正确的注意后，确实令人非常愉快。这个版本的集合也得到了完全的重新设计（由Sun公司的Joshua Bloch）。我认为新设计的集合是Java 1.2中两项最主要的特性之一（另一项是Swing库，将在第13章叙述），因为它们极大方便了我们的编程，也使Java变成一种更成熟的编程系统。\n有些设计使得元素间的结合变得更紧密，也更容易让人理解。例如，许多名字都变得更短、更明确了，而且更易使用；类型同样如此。有些名字进行了修改，更接近于通俗：我感觉特别好的一个是用“反复器”（Inerator）代替了“枚举”（Enumeration）。\n此次重新设计也加强了集合库的功能。现在新增的行为包括链接列表、队列以及撤消组队（即“双终点队列”）。\n新的集合库考虑到了“容纳自己对象”的问题，并将其分割成两个明确的概念： (1) 集合（Collection）：一组单独的元素，通常应用了某种规则。在这里，一个List（列表）必须按特定的顺序容纳元素，而一个Set（集）不可包含任何重复的元素。相反，“包”（Bag）的概念未在新的集合库中实现，因为“列表”已提供了类似的功能。 (2) 映射（Map）：一系列“键－值”对（这已在散列表身上得到了充分的体现）。从表面看，这似乎应该成为一个“键－值”对的“集合”，但假若试图按那种方式实现它，就会发现实现过程相当笨拙。这进一步证明了应该分离成单独的概念。另一方面，可以方便地查看Map的某个部分。只需创建一个集合，然后用它表示那一部分即可。这样一来，Map就可以返回自己键的一个Set、一个包含自己值的List或者包含自己“键－值”对的一个List。和数组相似，Map可方便扩充到多个“维”，毋需涉及任何新概念。只需简单地在一个Map里包含其他Map（后者又可以包含更多的Map，以此类推）。\nCollection和Map可通过多种形式实现，具体由编程要求决定。下面列出的是一个帮助大家理解的新集合示意图：\n这张图刚开始的时候可能让人有点儿摸不着头脑，但在通读了本章以后，相信大家会真正理解它实际只有三个集合组件：Map，List和Set。而且每个组件实际只有两、三种实现方式（注释⑥），而且通常都只有一种特别好的方式。只要看出了这一点，集合就不会再令人生畏。\n⑥：写作本章时，Java 1.2尚处于β测试阶段，所以这张示意图没有包括以后会加入的TreeSet。 虚线框代表“接口”，点线框代表“抽象”类，而实线框代表普通（实际）类。点线箭头表示一个特定的类准备实现一个接口（在抽象类的情况下，则是“部分”实现一个接口）。双线箭头表示一个类可生成箭头指向的那个类的对象。例如，任何集合都可以生成一个反复器（Iterator），而一个列表可以生成一个ListIterator（以及原始的反复器，因为列表是从集合继承的）。\n在类的分级结构中，可看到大量以“Abstract”（抽象）开头的类，这刚开始可能会使人感觉迷惑。它们实际上是一些工具，用于“部分”实现一个特定的接口。举个例子来说，假如想生成自己的Set，就不是从Set接口开始，然后自行实现所有方法。相反，我们可以从AbstractSet继承，只需极少的工作即可得到自己的新类。尽管如此，新集合库仍然包含了足够的功能，可满足我们的几乎所有需求。所以考虑到我们的目的，可忽略所有以“Abstract”开头的类。\nArrayList是一个典型的Collection，它代替了Vector的位置。\n利用iterator()方法，所有集合都能生成一个“反复器”（Iterator）。反复器其实就象一个“枚举”（Enumeration），是后者的一个替代物，只是：\n(1) 它采用了一个历史上默认、而且早在OOP中得到广泛采纳的名字（反复器）。 (2) 采用了比Enumeration更短的名字：hasNext()代替了hasMoreElement()，而next()代替了nextElement()。 (3) 添加了一个名为remove()的新方法，可删除由Iterator生成的上一个元素。所以每次调用next()的时候，只需调用remove()一次。 8.7.1 使用 Collections Collections 总结了用一个集合能做的所有事情（亦可对Set和List做同样的事情，尽管List还提供了一些额外的功能）。Map 要单独对待。\n8.7.2 使用Lists List（接口） 顺序是List最重要的特性；它可保证元素按照规定的顺序排列。List为Collection添加了大量方法，以便我们在List中部插入和删除元素（只推荐对LinkedList这样做）。List也会生成一个ListIterator（列表反复器），利用它可在一个列表里朝两个方向遍历，同时插入和删除位于列表中部的元素（同样地，只建议对LinkedList这样做）\nArrayList＊ 由一个数组后推得到的List。作为一个常规用途的对象容器使用，用于替换原先的Vector。允许我们快速访问元素，但在从列表中部插入和删除元素时，速度却嫌稍慢。一般只应该用ListIterator对一个ArrayList进行向前和向后遍历，不要用它删除和插入元素；与LinkedList相比，它的效率要低许多\nLinkedList 提供优化的顺序访问性能，同时可以高效率地在列表中部进行插入和删除操作。但在进行随机访问时，速度却相当慢，此时应换用ArrayList。也提供了addFirst()，addLast()，getFirst()，getLast()，removeFirst()以及removeLast()（未在任何接口或基础类中定义），以便将其作为一个规格、队列以及一个双向队列使用。\n8.7.3 使用Sets Set拥有与Collection完全相同的接口，所以和两种不同的List不同，它没有什么额外的功能。相反，Set完全就是一个Collection，只是具有不同的行为（这是实例和多形性最理想的应用：用于表达不同的行为）。在这里，一个Set只允许每个对象存在一个实例（正如大家以后会看到的那样，一个对象的“值”的构成是相当复杂的）。\nSet（接口） 添加到Set的每个元素都必须是独一无二的；否则Set就不会添加重复的元素。添加到Set里的对象必须定义equals()，从而建立对象的唯一性。Set拥有与Collection完全相同的接口。一个Set不能保证自己可按任何特定的顺序维持自己的元素\nHashSet＊ 用于除非常小的以外的所有Set。对象也必须定义hashCode() ArraySet 由一个数组后推得到的Set。面向非常小的Set设计，特别是那些需要频繁创建和删除的。对于小Set，与HashSet相比，ArraySet创建和反复所需付出的代价都要小得多。但随着Set的增大，它的性能也会大打折扣。不需要HashCode() TreeSet 由一个“红黑树”后推得到的顺序Set（注释⑦）。这样一来，我们就可以从一个Set里提到一个顺序集合\nHashSet维持的顺序与ArraySet是不同的。这是由于它们采用了不同的方法来保存元素，以便它们以后的定位。ArraySet保持着它们的顺序状态，而HashSet使用一个散列函数，这是特别为快速检索设计的）。创建自己的类型时，一定要注意Set需要通过一种方式来维持一种存储顺序，\n8.7.4 使用Maps Map（接口） 维持“键－值”对应关系（对），以便通过一个键查找相应的值\nHashMap＊ 基于一个散列表实现（用它代替Hashtable）。针对“键－值”对的插入和检索，这种形式具有最稳定的性能。可通过构建器对这一性能进行调整，以便设置散列表的“能力”和“装载因子”\nArrayMap 由一个ArrayList后推得到的Map。对反复的顺序提供了精确的控制。面向非常小的Map设计，特别是那些需要经常创建和删除的。对于非常小的Map，创建和反复所付出的代价要比HashMap低得多。但在Map变大以后，性能也会相应地大幅度降低\nTreeMap 在一个“红－黑”树的基础上实现。查看键或者“键－值”对时，它们会按固定的顺序排列（取决于Comparable或 Comparator，稍后即会讲到）。TreeMap最大的好处就是我们得到的是已排好序的结果。TreeMap是含有subMap()方法的唯一一种Map，利用它可以返回树的一部分\nkeySet()方法会产生一个Set，它由Map中的键后推得来。在这儿，它只被当作一个Collection对待。values()也得到了类似的对待，它的作用是产生一个List，其中包含了Map中的所有值（注意键必须是独一无二的，而值可以有重复）。由于这些Collection是由Map后推得到的，所以一个Collection中的任何改变都会在相应的Map中反映出来。\n当创建自己的类，将其作为Map中的一个键使用时，必须注意到和以前的Set相同的问题。\n8.7.5 决定实施方案 从早些时候的那幅示意图可以看出，实际上只有三个集合组件：Map，List和Set。而且每个接口只有两种或三种实施方案。若需使用由一个特定的接口提供的功能，如何才能决定到底采取哪一种方案呢？\n为理解这个问题，必须认识到每种不同的实施方案都有自己的特点、优点和缺点。比如在那张示意图中，可以看到Hashtable，Vector和Stack的“特点”是它们都属于“传统”类，所以不会干扰原有的代码。但在另一方面，应尽量避免为新的（Java 1.2）代码使用它们。\n其他集合间的差异通常都可归纳为它们具体是由什么“后推”的。换言之，取决于物理意义上用于实施目标接口的数据结构是什么。例如，ArrayList，LinkedList以及Vector（大致等价于ArrayList）都实现了List接口，所以无论选用哪一个，我们的程序都会得到类似的结果。然而，ArrayList（以及Vector）是由一个数组后推得到的；而LinkedList是根据常规的双重链接列表方式实现的，因为每个单独的对象都包含了数据以及指向列表内前后元素的句柄。正是由于这个原因，假如想在一个列表中部进行大量插入和删除操作，那么LinkedList无疑是最恰当的选择（LinkedList还有一些额外的功能，建立于AbstractSequentialList中）。若非如此，就情愿选择ArrayList，它的速度可能要快一些。\n作为另一个例子，Set既可作为一个ArraySet实现，亦可作为HashSet实现。ArraySet是由一个ArrayList后推得到的，设计成只支持少量元素，特别适合要求创建和删除大量Set对象的场合使用。然而，一旦需要在自己的Set中容纳大量元素，ArraySet的性能就会大打折扣。写一个需要Set的程序时，应默认选择HashSet。而且只有在某些特殊情况下（对性能的提升有迫切的需求），才应切换到ArraySet。\n决定使用何种List 为体会各种List实施方案间的差异，最简便的方法就是进行一次性能测验。\n可以看出，在ArrayList中进行随机访问（即get()）以及循环反复是最划得来的；但对于LinkedList却是一个不小的开销。但另一方面，在列表中部进行插入和删除操作对于LinkedList来说却比ArrayList划算得多。我们最好的做法也许是先选择一个ArrayList作为自己的默认起点。以后若发现由于大量的插入和删除造成了性能的降低，再考虑换成LinkedList不迟。\n决定使用何种Set 可在ArraySet以及HashSet间作出选择，具体取决于Set的大小（如果需要从一个Set中获得一个顺序列表，请用TreeSet；注释⑧）。\n最后对ArraySet的测试只有500个元素，而不是1000个，因为它太慢了。\n进行add()以及contains()操作时，HashSet显然要比ArraySet出色得多，而且性能明显与元素的多寡关系不大。一般编写程序的时候，几乎永远用不着使用ArraySet。\n决定使用何种Map 选择不同的Map实施方案时，注意Map的大小对于性能的影响是最大的，\n由于Map的大小是最严重的问题，所以程序的计时测试按Map的大小（或容量）来分割时间，以便得到令人信服的测试结果。\n即使大小为10，ArrayMap的性能也要比HashMap差——除反复循环时以外。而在使用Map时，反复的作用通常并不重要（get()通常是我们时间花得最多的地方）。TreeMap提供了出色的put()以及反复时间，但get()的性能并不佳。但是，我们为什么仍然需要使用TreeMap呢？这样一来，我们可以不把它作为Map使用，而作为创建顺序列表的一种途径。树的本质在于它总是顺序排列的，不必特别进行排序（它的排序方式马上就要讲到）。一旦填充了一个TreeMap，就可以调用keySet()来获得键的一个Set“景象”。然后用toArray()产生包含了那些键的一个数组。随后，可用static方法Array.binarySearch()快速查找排好序的数组中的内容。当然，也许只有在HashMap的行为不可接受的时候，才需要采用这种做法。因为HashMap的设计宗旨就是进行快速的检索操作。最后，当我们使用Map时，首要的选择应该是HashMap。只有在极少数情况下才需要考虑其他方法。 此外，在上面那张表里，有另一个性能问题没有反映出来。下述程序用于测试不同类型Map的创建速度：\n8.7.7 排序和搜索 Java 1.2添加了自己的一套实用工具，可用来对数组或列表进行排列和搜索。这些工具都属于两个新类的“静态”方法。这两个类分别是用于排序和搜索数组的Arrays，以及用于排序和搜索列表的Collections。\n数组 Arrays类为所有基本数据类型的数组提供了一个过载的sort()和binarySearch()，它们亦可用于String和Object。下面这个例子显示出如何排序和搜索一个字节数组（其他所有基本数据类型都是类似的）以及一个String数组：\npackage c08.newcollections; import java.util.*; public class Array1 { static Random r = new Random(); static String ssource = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; + \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;; static char[] src = ssource.toCharArray(); // Create a random String public static String randString(int length) { char[] buf = new char[length]; int rnd; for(int i = 0; i \u0026lt; length; i++) { rnd = Math.abs(r.nextInt()) % src.length; buf[i] = src[rnd]; } return new String(buf); } // Create a random array of Strings: public static String[] randStrings(int length, int size) { String[] s = new String[size]; for(int i = 0; i \u0026lt; size; i++) s[i] = randString(length); return s; } public static void print(byte[] b) { for(int i = 0; i \u0026lt; b.length; i++) System.out.print(b[i] + \u0026#34; \u0026#34;); System.out.println(); } public static void print(String[] s) { for(int i = 0; i \u0026lt; s.length; i++) System.out.print(s[i] + \u0026#34; \u0026#34;); System.out.println(); } public static void main(String[] args) { byte[] b = new byte[15]; r.nextBytes(b); // Fill with random bytes print(b); Arrays.sort(b); print(b); int loc = Arrays.binarySearch(b, b[10]); System.out.println(\u0026#34;Location of \u0026#34; + b[10] + \u0026#34; = \u0026#34; + loc); // Test String sort \u0026amp; search: String[] s = randStrings(4, 10); print(s); Arrays.sort(s); print(s); loc = Arrays.binarySearch(s, s[4]); System.out.println(\u0026#34;Location of \u0026#34; + s[4] + \u0026#34; = \u0026#34; + loc); } } ///:~ 类的第一部分包含了用于产生随机字串对象的实用工具，可供选择的随机字母保存在一个字符数组中。randString()返回一个任意长度的字串；而readStrings()创建随机字串的一个数组，同时给定每个字串的长度以及希望的数组大小。两个print()方法简化了对示范数组的显示。在main()中，Random.nextBytes()用随机选择的字节填充数组自变量（没有对应的Random方法用于创建其他基本数据类型的数组）。获得一个数组后，便可发现为了执行sort()或者binarySearch()，只需发出一次方法调用即可。与binarySearch()有关的还有一个重要的警告：若在执行一次binarySearch()之前不调用sort()，便会发生不可预测的行为，其中甚至包括无限循环。\n对String的排序以及搜索是相似的，但在运行程序的时候，我们会注意到一个有趣的现象：排序遵守的是字典顺序，亦即大写字母在字符集中位于小写字母的前面。因此，所有大写字母都位于列表的最前面，后面再跟上小写字母——Z居然位于a的前面。似乎连电话簿也是这样排序的。\n可比较与比较器 若用自己的Comparator来进行一次sort()，那么在使用binarySearch()时必须使用那个相同的Comparator。\nArrays类提供了另一个sort()方法，它会采用单个自变量：一个Object数组，但没有Comparator。这个sort()方法也必须用同样的方式来比较两个Object。通过实现Comparable接口，它采用了赋予一个类的“自然比较方法”。这个接口含有单独一个方法——compareTo()，能分别根据它小于、等于或者大于自变量而返回负数、零或者正数，从而实现对象的比较。下面这个例子简单地阐示了这一点：\n列表 可用与数组相同的形式排序和搜索一个列表（List）。用于排序和搜索列表的静态方法包含在类Collections中，但它们拥有与Arrays中差不多的签名：sort(List)用于对一个实现了Comparable的对象列表进行排序；binarySearch(List,Object)用于查找列表中的某个对象；sort(List,Comparator)利用一个“比较器”对一个列表进行排序；\n8.7.8 实用工具 Collections类中含有其他大量有用的实用工具：\n使Collection或Map不可修改\nCollection或Map的同步\nsynchronized关键字是“多线程”机制一个非常重要的部分。我们到第14章才会对这一机制作深入的探讨。在这儿，大家只需注意到Collections类提供了对整个容器进行自动同步的一种途径。它的语法与“不可修改”的方法是类似的：\n能查出除我们的进程自己需要负责的之外的、对容器的其他任何修改。若探测到有其他方面也准备修改容器，便会立即产生一个ConcurrentModificationException（并发修改违例）。我们将这一机制称为“立即失败”——它并不用更复杂的算法在“以后”侦测问题，而是“立即”产生违例。\n8.8 总结 8.9 练习 第9章 违例差错控制 通过先进的错误纠正与恢复机制，我们可以有效地增强代码的健壮程度。对我们编写的每个程序来说，错误恢复都属于一个基本的考虑目标。它在Java中显得尤为重要，因为该语言的一个目标就是创建不同的程序组件，以便其他用户（客户程序员）使用。为构建一套健壮的系统，每个组件都必须非常健壮。 在Java里，违例控制的目的是使用尽可能精简的代码创建大型、可靠的应用程序，同时排除程序里那些不能控制的错误。 违例的概念很难掌握。但只有很好地运用它，才可使自己的项目立即获得显著的收益。Java强迫遵守违例所有方面的问题，所以无论库设计者还是客户程序员，都能够连续一致地使用它。\n9.1 基本违例 在违例条件的情况下，却无法继续下去，因为当地没有提供解决问题所需的足够多的信息。此时，我们能做的唯一事情就是跳出当地环境，将那个问题委托给一个更高级的负责人。这便是出现违例时出现的情况。\n9.1.1 违例自变量 关键字throw\n9.2 违例的捕获 为理解违例是如何捕获的，首先必须掌握“警戒区”的概念。它代表一个特殊的代码区域，有可能产生违例，并在后面跟随用于控制那些违例的代码。\n9.2.1 try块 可在那个方法内部设置一个特殊的代码块，用它捕获违例。这就叫作“try块”，因为要在这个地方“尝试”各种方法调用。try块属于一种普通的作用域，用一个try关键字开头：\ntry {\r// 可能产生违例的代码\r} 若用一种不支持违例控制的编程语言全面检查错误，必须用设置和错误检测代码将每个方法都包围起来——即便多次调用相同的方法。而在使用了违例控制技术后，可将所有东西都置入一个try块内，在同一地点捕获所有违例。这样便可极大简化我们的代码，并使其更易辨读，因为代码本身要达到的目标再也不会与繁复的错误检查混淆。\n9.2.2 违例控制器 当然，生成的违例必须在某个地方中止。这个“地方”便是违例控制器或者违例控制模块。而且针对想捕获的每种违例类型，都必须有一个相应的违例控制器。违例控制器紧接在try块后面，且用catch（捕获）关键字标记。如下所示：\ntry {\r// Code that might generate exceptions\r} catch(Type1 id1) {\r// Handle exceptions of Type1\r} catch(Type2 id2) {\r// Handle exceptions of Type2\r} catch(Type3 id3) {\r// Handle exceptions of Type3\r} 每个catch从句——即违例控制器——都类似一个小型方法，它需要采用一个（而且只有一个）特定类型的自变量。可在控制器内部使用标识符（id1，id2等等），就象一个普通的方法自变量那样。我们有时也根本不使用标识符，因为违例类型已提供了足够的信息，可有效处理违例。但即使不用，标识符也必须就位。 控制器必须“紧接”在try块后面。若“掷”出一个违例，违例控制机制就会搜寻自变量与违例类型相符的第一个控制器。随后，它会进入那个catch从句，并认为违例已得到控制（一旦catch从句结束，对控制器的搜索也会停止）。只有相符的catch从句才会得到执行；它与switch语句不同，后者在每个case后都需要一个break命令，防止误执行其他语句。 在try块内部，请注意大量不同的方法调用可能生成相同的违例，但只需要一个控制器。\n中断与恢复 在违例控制理论中，共存在两种基本方法。在“中断”方法中（Java和C++提供了对这种方法的支持），我们假定错误非常关键，没有办法返回违例发生的地方。无论谁只要“掷”出一个违例，就表明没有办法补救错误，而且也不希望再回来。 另一种方法叫作“恢复”。它意味着违例控制器有责任来纠正当前的状况，然后取得出错的方法，假定下一次会成功执行。若使用恢复，意味着在违例得到控制以后仍然想继续执行。在这种情况下，我们的违例更象一个方法调用——我们用它在Java中设置各种各样特殊的环境，产生类似于“恢复”的行为（换言之，此时不是“掷”出一个违例，而是调用一个用于解决问题的方法）。另外，也可以将自己的try块置入一个while循环里，用它不断进入try块，直到结果满意时为止。 从历史的角度看，若程序员使用的操作系统支持可恢复的违例控制，最终都会用到类似于中断的代码，并跳过恢复进程。所以尽管“恢复”表面上十分不错，但在实际应用中却显得困难重重。其中决定性的原因可能是：我们的控制模块必须随时留意是否产生了违例，以及是否包含了由产生位置专用的代码。这便使代码很难编写和维护——大型系统尤其如此，因为违例可能在多个位置产生。\n9.2.3 违例规范 在Java中，对那些要调用方法的客户程序员，我们要通知他们可能从自己的方法里“掷”出违例。这是一种有礼貌的做法，只有它才能使客户程序员准确地知道要编写什么代码来捕获所有潜在的违例。当然，若你同时提供了源码，客户程序员甚至能全盘检查代码，找出相应的throw语句。但尽管如此，通常并不随同源码提供库。为解决这个问题，Java提供了一种特殊的语法格式（并强迫我们采用），以便礼貌地告诉客户程序员该方法会“掷”出什么违例，令对方方便地加以控制。这便是我们在这里要讲述的“违例规范”，它属于方法声明的一部分，位于自变量（参数）列表的后面。\n违例规范采用了一个额外的关键字：throws；后面跟随全部潜在的违例类型。因此，我们的方法定义看起来应象下面这个样子：\nvoid f() throws tooBig, tooSmall, divZero { //... 9.2.4 捕获所有违例 具体的做法是捕获基础类违例类型Exception（也存在其他类型的基础违例，但Exception是适用于几乎所有编程活动的基础）\n打印异常堆栈信息\nvoid printStackTrace()\rvoid printStackTrace(PrintStream) 第一个版本会打印出标准错误，第二个则打印出我们的选择流程。若在Windows下工作，就不能重定向标准错误。因此，我们一般愿意使用第二个版本，并将结果送给System.out；这样一来，输出就可重定向到我们希望的任何路径。\n9.2.5 重新“掷”出违例 catch(Exception e) {\rSystem.out.println(\u0026#34;一个违例已经产生\u0026#34;);\rthrow e;\r} 若想安装新的堆栈跟踪信息，可调用fillInStackTrace()，它会返回一个特殊的违例对象。这个违例的创建过程如下：将当前堆栈的信息填充到原来的违例对象里。\n由于使用的是fillInStackTrace()，throw 成为违例的新起点。\n永远不必关心如何清除前一个违例，或者与之有关的其他任何违例。它们都属于用new创建的、以内存堆为基础的对象，所以垃圾收集器会自动将其清除。\n9.3 标准Java违例 Java包含了一个名为Throwable的类，它对可以作为违例“掷”出的所有东西进行了描述。Throwable对象有两种常规类型（亦即“从Throwable继承”）。其中，Error代表编译期和系统错误，我们一般不必特意捕获它们（除在特殊情况以外）。Exception是可以从任何标准Java库的类方法中“掷”出的基本类型。此外，它们亦可从我们自己的方法以及运行期偶发事件中“掷”出。\n9.3.1 RuntimeException的特殊情况 这个类别里含有一系列违例类型。它们全部由Java自动生成，毋需我们亲自动手把它们包含到自己的违例规范里。最方便的是，通过将它们置入单独一个名为RuntimeException的基础类下面，它们全部组合到一起。此外，我们没必要专门写一个违例规范，指出一个方法可能会“掷”出一个RuntimeException，因为已经假定可能出现那种情况。由于它们用于指出编程中的错误，所以几乎永远不必专门捕获一个“运行期违例”——RuntimeException——它在默认情况下会自动得到处理。若必须检查RuntimeException，我们的代码就会变得相当繁复。在我们自己的包里，可选择“掷”出一部分RuntimeException。\n9.4 创建自己的违例 并不一定非要使用Java违例。这一点必须掌握，因为经常都需要创建自己的违例，以便指出自己的库可能生成的一个特殊错误——但创建Java分级结构的时候，这个错误是无法预知的。 为创建自己的违例类，必须从一个现有的违例类型继承——最好在含义上与新违例近似。继承一个违例相当简单：\n违例不过是另一种形式的对象\n9.5 违例的限制 覆盖一个方法时，只能产生已在方法的基础类版本中定义的违例。这是一个重要的限制，因为它意味着与基础类协同工作的代码也会自动应用于从基础类衍生的任何对象（当然，这属于基本的OOP概念），其中包括违例。\n对违例的限制并不适用于构建器。\n一个构建器能够“掷”出它希望的任何东西，无论基础类构建器“掷”出什么。然而，由于必须坚持按某种方式调用基础类构建器（在这里，会自动调用默认构建器），所以衍生类构建器必须在自己的违例规范中声明所有基础类构建器违例。\n通过强迫衍生类方法遵守基础类方法的违例规范，对象的替换可保持连贯性。\n覆盖过的基础类方法向我们显示出一个方法的衍生类版本可以不产生任何违例——即便基础类版本要产生违例。\n编译器就会强迫我们只捕获特定于那个类的违例。但假如我们上溯造型到基础类型，编译器就会强迫我们捕获针对基础类的违例。通过所有这些限制，违例控制代码的“健壮”程度获得了大幅度改善（注释③）。\n总结：\n1、实现抽象方法 throws 异常应与抽象方法 throws 异常一致,来声明它是实现抽象方法的。（接口的实现方法不能因为 throws 异常 而与重载的方法混淆。） 9.6 用finally清除 finally从句\n无论异常是否被捕获，finally的代码一定会被执行。 finally里适合存放释放资源、后续处理的代码 try代码块并没有得到执行，所以finally中的代码块也不会得到相应的执行。只有在try代码块得到执行的情况下，finally代码块才会得到执行。 9.6.1 用finally做什么 在没有“垃圾收集”以及“自动调用破坏器”机制的一种语言中（注释⑤），finally显得特别重要，因为程序员可用它担保内存的正确释放——无论在try块内部发生了什么状况。但Java提供了垃圾收集机制，所以内存的释放几乎绝对不会成为问题。另外，它也没有构建器可供调用。既然如此，Java里何时才会用到finally呢？\n除将内存设回原始状态以外，若要设置另一些东西，finally就是必需的。例如，我们有时需要打开一个文件或者建立一个网络连接，或者在屏幕上画一些东西，甚至设置外部世界的一个开关，等等。\n9.7 构建器 没明白它说啥，但是感觉不是很重要，不建议构建器写复杂内容。\n9.8 违例匹配 “掷”出一个违例后，违例控制系统会按当初编写的顺序搜索“最接近”的控制器。一旦找到相符的控制器，就认为违例已得到控制，不再进行更多的搜索工作。\n在违例和它的控制器之间，并不需要非常精确的匹配。一个衍生类对象可与基础类的一个控制器相配\n9.8.1 违例准则 用违例做下面这些事情：\n(1) 解决问题并再次调用造成违例的方法。 (2) 平息事态的发展，并在不重新尝试方法的前提下继续。 (3) 计算另一些结果，而不是希望方法产生的结果。 (4) 在当前环境中尽可能解决问题，以及将相同的违例重新“掷”出一个更高级的环境。 (5) 在当前环境中尽可能解决问题，以及将不同的违例重新“掷”出一个更高级的环境。 (6) 中止程序执行。 (7) 简化编码。若违例方案使事情变得更加复杂，那就会令人非常烦恼，不如不用。 (8) 使自己的库和程序变得更加安全。这既是一种“短期投资”（便于调试），也是一种“长期投资”（改善应用程序的健壮性） 9.9 总结 在Java里，违例控制的目的是使用尽可能精简的代码创建大型、可靠的应用程序，同时排除程序里那些不能控制的错误。\n9.10 练习 第10章 Java IO系统 由于存在大量不同的设计方案，所以该任务的困难性是很容易证明的。其中最大的挑战似乎是如何覆盖所有可能的因素。不仅有三种不同的种类的IO需要考虑（文件、控制台、网络连接），而且需要通过大量不同的方式与它们通信（顺序、随机访问、二进制、字符、按行、按字等等）。\nJava库的设计者通过创建大量类来攻克这个难题。事实上，Java的IO系统采用了如此多的类，以致刚开始会产生不知从何处入手的感觉（具有讽刺意味的是，Java的IO设计初衷实际要求避免过多的类）。从Java 1.0升级到Java 1.1后，IO库的设计也发生了显著的变化。此时并非简单地用新库替换旧库，Sun的设计人员对原来的库进行了大手笔的扩展，添加了大量新的内容。因此，我们有时不得不混合使用新库与旧库，产生令人无奈的复杂代码。\n10.1 输入和输出 装饰者模式，处理不同来源的输入和输出。 直接总结：\n1、能读取文件、写入文件、复制文件、利用缓冲区就行。\n2、知道完成这些操作有那些步骤就行。\n可将Java库的IO类分割为输入与输出两个部分，这一点在用Web浏览器阅读联机Java类文档时便可知道。通过继承，从InputStream（输入流）衍生的所有类都拥有名为read()的基本方法，用于读取单个字节或者字节数组。类似地，从OutputStream衍生的所有类都拥有基本方法write()，用于写入单个字节或者字节数组。然而，我们通常不会用到这些方法；它们之所以存在，是因为更复杂的类可以利用它们，以便提供一个更有用的接口。因此，我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供自己期望的功能。我们之所以感到Java的流库（Stream Library）异常复杂，正是由于为了创建单独一个结果流，却需要创建多个对象的缘故。\n很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都从InputStream继承，而与输出有关的所有类都从OutputStream继承。\n10.1.1 InputStream的类型 InputStream的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream子类）：\n(1) 字节数组 (2) String对象 (3) 文件 (4) “管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。 (5) 一系列其他流，以便我们将其统一收集到单独一个流内。 (6) 其他起源地，如Internet连接等（将在本书后面的部分讲述）。 除此以外，FilterInputStream也属于InputStream的一种类型，用它可为“破坏器”类提供一个基础类，以便将属性或者有用的接口同输入流连接到一起。 具体哪种类型有何特性，自己查找API吧。\n10.1.2 OutputStream的类型 具体哪种类型有何特性，自己查找API吧。\n10.2 增添属性和有用的接口 利用层次化对象动态和透明地添加单个对象的能力的做法叫作“装饰器”（Decorator）方案——“方案”属于本书第16章的主题（注释①）。装饰器方案规定封装于初始化对象中的所有对象都拥有相同的接口，以便利用装饰器的“透明”性质——我们将相同的消息发给一个对象，无论它是否已被“装饰”。这正是在Java IO库里存在“过滤器”（Filter）类的原因：抽象的“过滤器”类是所有装饰器的基础类（装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中）。\n子类处理要求大量子类对每种可能的组合提供支持时，便经常会用到装饰器——由于组合形式太多，造成子类处理变得不切实际。Java IO库要求许多不同的特性组合方案，这正是装饰器方案显得特别有用的原因。但是，装饰器方案也有自己的一个缺点。在我们写一个程序的时候，装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于Java IO库操作不便，我们必须创建许多类——“核心”IO类型加上所有装饰器——才能得到自己希望的单个IO对象。\nFilterInputStream和FilteOutputStream分别是过滤输入流和过滤输出流,他们的作用是为基础流提供一些额外的功能\nFilterInputStream和FilterOutputStream（这两个名字不十分直观）提供了相应的装饰器接口，用于控制一个特定的输入流（InputStream）或者输出流（OutputStream）。它们分别是从InputStream和OutputStream衍生出来的。此外，它们都属于抽象类，在理论上为我们与一个流的不同通信手段都提供了一个通用的接口。事实上，FilterInputStream和FilterOutputStream只是简单地模仿了自己的基础类，它们是一个装饰器的基本要求。\n10.2.1 通过FilterInputStream从InputStream里读入数据 FilterInputStream类要完成两件全然不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，比如readByte()，readFloat()等等）。伴随对应的DataOutputStream，我们可通过数据“流”将基本类型的数据从一个地方搬到另一个地方。这些“地方”是由表10.1总结的那些类决定的。若读取块内的数据，并自己进行解析，就不需要用到DataInputStream。但在其他许多情况下，我们一般都想用它对自己读入的数据进行自动格式化。 剩下的类用于修改InputStream的内部行为方式：是否进行缓冲，是否跟踪自己读入的数据行，以及是否能够推回一个字符等等。后两种类看起来特别象提供对构建一个编译器的支持（换言之，添加它们为了支持Java编译器的构建），所以在常规编程中一般都用不着它们。\n也许几乎每次都要缓冲自己的输入，无论连接的是哪个IO设备。所以IO库最明智的做法就是将未缓冲输入作为一种特殊情况处理，同时将缓冲输入接纳为标准做法。\n10.2.2 通过FilterOutputStream向OutputStream里写入数据 与DataInputStream对应的是DataOutputStream，后者对各个基本数据类型以及String对象进行格式化，并将其置入一个数据“流”中，以便任何机器上的DataInputStream都能正常地读取它们。所有方法都以“wirte”开头，例如writeByte()，writeFloat()等等。\n若想进行一些真正的格式化输出，比如输出到控制台，请使用PrintStream。利用它可以打印出所有基本数据类型以及String对象，并可采用一种易于查看的格式。这与DataOutputStream正好相反，后者的目标是将那些数据置入一个数据流中，以便DataInputStream能够方便地重新构造它们。System.out静态对象是一个PrintStream。\nPrintStream内两个重要的方法是print()和println()。它们已进行了覆盖处理，可打印出所有数据类型。print()和println()之间的差异是后者在操作完毕后会自动添加一个新行。\nBufferedOutputStream属于一种“修改器”，用于指示数据流使用缓冲技术，使自己不必每次都向流内物理性地写入数据。通常都应将它应用于文件处理和控制器IO。 表10.4 FilterOutputStream的类型\n10.3 本身的缺陷：RandomAccessFile RandomAccessFile用于包含了已知长度记录的文件，以便我们能用seek()从一条记录移至另一条；然后读取或修改那些记录。各记录的长度并不一定相同；只要知道它们有多大以及置于文件何处即可。\n首先，我们有点难以相信RandomAccessFile不属于InputStream或者OutputStream分层结构的一部分。除了恰巧实现了DataInput以及DataOutput（这两者亦由DataInputStream和DataOutputStream实现）接口之外，它们与那些分层结构并无什么关系。它甚至没有用到现有InputStream或OutputStream类的功能——采用的是一个完全不相干的类。该类属于全新的设计，含有自己的全部（大多数为固有）方法。之所以要这样做，是因为RandomAccessFile拥有与其他IO类型完全不同的行为，因为我们可在一个文件里向前或向后移动。不管在哪种情况下，它都是独立运作的，作为Object的一个“直接继承人”使用。\n从根本上说，RandomAccessFile类似DataInputStream和DataOutputStream的联合使用。其中，getFilePointer()用于了解当前在文件的什么地方，seek()用于移至文件内的一个新地点，而length()用于判断文件的最大长度。此外，构建器要求使用另一个自变量（与C的fopen()完全一样），指出自己只是随机读（\u0026ldquo;r\u0026rdquo;），还是读写兼施（\u0026ldquo;rw\u0026rdquo;）。这里没有提供对“只写文件”的支持。也就是说，假如是从DataInputStream继承的，那么RandomAccessFile也有可能能很好地工作。\n还有更难对付的。很容易想象我们有时要在其他类型的数据流中搜索，比如一个ByteArrayInputStream，但搜索方法只有RandomAccessFile才会提供。而后者只能针对文件才能操作，不能针对数据流操作。此时，BufferedInputStream确实允许我们标记一个位置（使用mark()，它的值容纳于单个内部变量中），并用reset()重设那个位置。但这些做法都存在限制，并不是特别有用。\n10.4 File类 File类有一个欺骗性的名字——通常会认为它对付的是一个文件，但实情并非如此。它既代表一个特定文件的名字，也代表目录内一系列文件的名字。若代表一个文件集，便可用list()方法查询这个集，返回的是一个字串数组。之所以要返回一个数组，而非某个灵活的集合类，是因为元素的数量是固定的。而且若想得到一个不同的目录列表，只需创建一个不同的File对象即可。事实上，“FilePath”（文件路径）似乎是一个更好的名字。本节将向大家完整地例示如何使用这个类，其中包括相关的FilenameFilter（文件名过滤器）接口。\n10.4.1 目录列表器 现在假设我们想观看一个目录列表。可用两种方式列出File对象。若在不含自变量（参数）的情况下调用list()，会获得File对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择File对象来完成显示。\n实现”interface FilenameFilter（关于接口的问题，已在第7章进行了详述）。下面让我们看看FilenameFilter接口有多么简单\npublic interface FilenameFilter {\rboolean accept(文件目录, 字串名);\r} 它指出这种类型的所有对象都提供了一个名为accept()的方法。之所以要创建这样的一个类，背后的全部原因就是把accept()方法提供给list()方法，使list()能够“回调”accept()，从而判断应将哪些文件名包括到列表中。因此，通常将这种技术称为“回调”，有时也称为“算子”（也就是说，DirFilter是一个算子，因为它唯一的作用就是容纳一个方法）。由于list()采用一个FilenameFilter对象作为自己的自变量使用，所以我们能传递实现了FilenameFilter的任何类的一个对象，用它决定（甚至在运行期）list()方法的行为方式。回调的目的是在代码的行为上提供更大的灵活性。\n通过DirFilter，我们看出尽管一个“接口”只包含了一系列方法，但并不局限于只能写那些方法（但是，至少必须提供一个接口内所有方法的定义。在这种情况下，DirFilter构建器也会创建）。\naccept()方法必须接纳一个File对象，用它指示用于寻找一个特定文件的目录；并接纳一个String，其中包含了要寻找之文件的名字。可决定使用或忽略这两个参数之一，但有时至少要使用文件名。记住list()方法准备为目录对象中的每个文件名调用\naccept()，核实哪个应包含在内——具体由accept()返回的“布尔”结果决定。 为确定我们操作的只是文件名，其中没有包含路径信息，必须采用String对象，并在它的外部创建一个File对象。然后调用\ngetName()，它的作用是去除所有路径信息（采用与平台无关的方式）。随后，accept()用String类的indexOf()方法检查文件名内部是否存在搜索字串\u0026quot;afn\u0026quot;。若在字串内找到afn，那么返回值就是afn的起点索引；但假如没有找到，返回值就是-1。注意这只是一个简单的字串搜索例子，未使用常见的表达式“通配符”方案，比如\u0026quot;fo?.b?r*\u0026quot;；这种方案更难实现。\nlist()方法返回的是一个数组。可查询这个数组的长度，然后在其中遍历，选定数组元素。与C和C++的类似行为相比，这种于方法内外方便游历数组的行为无疑是一个显著的进步。\n注意filter()的自变量必须是final。这一点是匿名内部类要求的，使其能使用来自本身作用域以外的一个对象。\n10.4.2 检查与创建目录 File类并不仅仅是对现有目录路径、文件或者文件组的一个表示。亦可用一个File对象新建一个目录，甚至创建一个完整的目录路径——假如它尚不存在的话。亦可用它了解文件的属性（长度、上一次修改日期、读／写属性等），检查一个File对象到底代表一个文件还是一个目录，以及删除一个文件等等。\n10.5 IO流的典型应用 尽管库内存在大量IO流类，可通过多种不同的方式组合到一起，但实际上只有几种方式才会经常用到。然而，必须小心在意才能得到正确的组合。下面这个相当长的例子展示了典型IO配置的创建与使用，可在写自己的代码时将其作为一个参考使用。注意每个配置都以一个注释形式的编号起头，并提供了适当的解释信息。\n10.5.1 输入流 缓冲的输入文件 为打开一个文件以便输入，需要使用一个FileInputStream，同时将一个String或File对象作为文件名使用。为提高速度，最好先对文件进行缓冲处理，从而获得用于一个BufferedInputStream的构建器的结果句柄。为了以格式化的形式读取输入数据，我们将那个结果句柄赋给用于一个DataInputStream的构建器。DataInputStream是我们的最终（final）对象，并是我们进行读取操作的接口。\nDataInputStream in =\rnew DataInputStream(\rnew BufferedInputStream(\rnew FileInputStream(args[0])\r)\r);\rString s, s2 = new String();\rwhile((s = in.readLine())!= null)\rs2 += s + \u0026#34;\\n\u0026#34;;\rin.close(); 在这个例子中，只用到了readLine()方法，但理所当然任何DataInputStream方法都可以采用。一旦抵达文件末尾，readLine()就会返回一个null（空），以便中止并退出while循环。\n“String s2”用于聚集完整的文件内容（包括必须添加的新行，因为readLine()去除了那些行）。随后，在本程序的后面部分中使用s2。最后，我们调用close()，用它关闭文件。从技术上说，会在运行finalize()时调用close()。而且我们希望一旦程序退出，就发生这种情况（无论是否进行垃圾收集）。然而，Java 1.0有一个非常突出的错误（Bug），造成这种情况不会发生。在Java 1.1中，必须明确调用System.runFinalizersOnExit(true)，用它保证会为系统中的每个对象调用finalize()。然而，最安全的方法还是为文件明确调用close()。\nStringBufferInputStream的接口是有限的，所以通常需要将其封装到一个DataInputStream内，从而增强它的能力。然而，若选择用readByte()每次读出一个字符，那么所有值都是有效的，所以不可再用返回值来侦测何时结束输入。相反，可用available()方法判断有多少字符可用。下面这个例子展示了如何从文件中一次读出一个字符：\nDataInputStream in = new DataInputStream(\rnew BufferedInputStream(\rnew FileInputStream(\u0026#34;TestEof.java\u0026#34;)));\rwhile(in.available() != 0)\rSystem.out.print((char)in.readByte()); 注意取决于当前从什么媒体读入，avaiable()的工作方式也是有所区别的。它在字面上意味着“可以不受阻塞读取的字节数量”。对一个文件来说，它意味着整个文件。但对一个不同种类的数据流来说，它却可能有不同的含义。因此在使用时应考虑周全。\n10.5.2 输出流 两类主要的输出流是按它们写入数据的方式划分的：一种按人的习惯写入，另一种为了以后由一个DataInputStream而写入。RandomAccessFile是独立的，尽管它的数据格式兼容于DataInputStream和DataOutputStream。\n10.5.3 快捷文件处理 这段说的是工具类，熟悉可IO的API自己写就行。\n10.5.4 从标准输入中读取数据 以Unix首先倡导的“标准输入”、“标准输出”以及“标准错误输出”概念为基础，Java提供了相应的System.in，System.out以及System.err。贯这一整本书，大家都会接触到如何用System.out进行标准输出，它已预封装成一个PrintStream对象。\nSystem.err同样是一个PrintStream，但System.in是一个原始的InputStream，未进行任何封装处理。这意味着尽管能直接使用System.out和System.err，但必须事先封装System.in，否则不能从中读取数据。 典型情况下，我们希望用readLine()每次读取一行输入信息，所以需要将System.in封装到一个DataInputStream中。这是Java 1.0进行行输入时采取的“老”办法。在本章稍后，大家还会看到Java 1.1的解决方案。\npublic static void main(String[] args) {\rDataInputStream in =\rnew DataInputStream(\rnew BufferedInputStream(System.in));\rString s;\rtry {\rwhile((s = in.readLine()).length() != 0)\rSystem.out.println(s);\r// An empty line terminates the program\r} catch(IOException e) {\re.printStackTrace();\r}\r} 10.5.5 管道数据流 本章已简要介绍了PipedInputStream（管道输入流）和PipedOutputStream（管道输出流）。尽管描述不十分详细，但并不是说它们作用不大。然而，只有在掌握了多线程处理的概念后，才可真正体会它们的价值所在。原因很简单，因为管道化的数据流就是用于线程之间的通信。这方面的问题将在第14章用一个示例说明。\n10.6 StreamTokenizer 尽管StreamTokenizer并不是从InputStream或OutputStream衍生的，但它只随同InputStream工作，所以十分恰当地包括在库的IO部分中。 StreamTokenizer类用于将任何InputStream分割为一系列“记号”（Token）。这些记号实际是一些断续的文本块，中间用我们选择的任何东西分隔。例如，我们的记号可以是单词，中间用空白（空格）以及标点符号分隔。\n类java.io.StreamTokenizer可以获取输入流并将其分析为Token(标记)。StreamTokenizer的nextToken方法将读取下一个标记 默认情况下，StreamTokenizer认为下列内容是Token：字母、数字、除C和C++注释符号以外的其他符号。如符号“/”不是Token，注释后的内容也不是，而“\\”是Token。单引号和双引号以及其中的内容，只能算是一个Token。 要统计文件的字符数，不能简单地统计Token数，因为字符数不等于Token，按照Token的规定，引号中的内容就算是10页也算是一个Token。如果希望引号和引号中的内容都算作Token，应该通过StreamTokenizer的ordinaryCha()方法将单引号和双引号当做普通字符处理。 StreamTokenizer用来分隔字符串。\r可以获取输入流并将其分析为Token(标记)。StreamTokenizer的nextToken方法将读取下一个标记。\r功能 1、 将输入流分解成一组标记，允许一次读一个。分解过程由一张表和一些可以设置成各种状态的标志来控制。 2、读取的每个字节被认为是“\\u0000”-“\\u00FF”之间的字符。空格(“\\u0000”-“\\u0020”)，字母(“A”-“Z”,“a”-“z”,“\\u00A0”-“\\u00FF”)，数字，串引号(“,“)，注释字符(“/”)）。 3、做法：以一个InputStream作为源，创建一个StreamTokenizer对象，设置参数,循环调用nextToken，返回流中下一个标记的类型，并处理相关的值。 4、主要用于分析Java风格的输入；不是通用的标记分析器。 ttype域：nextToken后刚读取的标记类型。六种情况： 单字符标记：表示该字符（转换成整数） 引号串标记：引号符(String类型域sval存储了串内容) TT_WORD(-3)：单词。String类型域sval存储了该单词。 TT_NUMBER(-2)：数。double类型域nval保存该数值。只能识别十进制浮点数。( ? 3.4e79,0xffff ) TT_EOL(“\\n”)：行结束。 TT_EOF(-1)：文件结束。\r//创建分析给定字符流的标记生成器\rStreamTokenizer st = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\r//ordinaryChar方法指定字符参数在此标记生成器中是“普通”字符。\rst.ordinaryChar(\u0026#39;\\\u0026#39;\u0026#39;); //指定单引号、双引号和注释符号是普通字符\rst.ordinaryChar(\u0026#39;\\\u0026#34;\u0026#39;);\rst.ordinaryChar(\u0026#39;/\u0026#39;)\r//nextToken方法读取下一个Token.\r//TT_EOF指示已读到流末尾的常量。\rwhile (st.nextToken() != StreamTokenizer.TT_EOF) {\r//在调用 nextToken 方法之后，ttype字段将包含刚读取的标记的类型\rswitch (st.ttype) {\r//TT_EOL指示已读到行末尾的常量。\rcase StreamTokenizer.TT_EOL:\rbreak;\r//TT_NUMBER指示已读到一个数字标记的常量\rcase StreamTokenizer.TT_NUMBER:\r//如果当前标记是一个数字，nval字段将包含该数字的值\rs = String.valueOf((st.nval));\rSystem.out.println(s);\rnumberSum += s.length();\rbreak;\r//TT_WORD指示已读到一个文字标记的常量\rcase StreamTokenizer.TT_WORD:\r//如果当前标记是一个文字标记，sval字段包含一个给出该文字标记的字符的字符串\rs = st.sval;\rwordSum += s.length();\rbreak;\rdefault: 10.6.1 StringTokenizer 无论如何，只应将StringTokenizer看作StreamTokenizer一种简单而且特殊的简化形式。然而，如果有一个字串需要进行记号处理，而且StringTokenizer的功能实在有限，那么应该做的全部事情就是用StringBufferInputStream将其转换到一个数据流里，再用它创建一个功能更强大的StreamTokenizer。\n跟 StreamTokenizer 差不多，反正我没用过。。。\n10.7 Java 1.1的IO流 之所以在Java 1.1里添加了Reader和Writer层次，最重要的原因便是国际化的需求。老式IO流层次结构只支持8位字节流，不能很好地控制16位Unicode字符。由于Unicode主要面向的是国际化支持（Java内含的char是16位的Unicode），所以添加了Reader和Writer层次，以提供对所有IO操作中的Unicode的支持。除此之外，新库也对速度进行了优化，可比旧库更快地运行。 与本书其他地方一样，我会试着提供对类的一个概述，但假定你会利用联机文档搞定所有的细节，比如方法的详尽列表等。\n我还以为将NIO呢，但是NIO不是JDK 1.4 及以上版本里提供的咩。。。\n10.8 压缩 就是讲压缩API 的，自己看API写用例就行了。。。没啥细究的。。。\nJava 1.1也添加一个类，用以支持对压缩格式的数据流的读写。它们封装到现成的IO类中，以提供压缩功能。\nCheckedInputStream GetCheckSum()为任何InputStream产生校验和（不仅是解压）\rCheckedOutputStream GetCheckSum()为任何OutputStream产生校验和（不仅是解压）\rDeflaterOutputStream 用于压缩类的基础类\rZipOutputStream 一个DeflaterOutputStream，将数据压缩成Zip文件格式\rGZIPOutputStream 一个DeflaterOutputStream，将数据压缩成GZIP文件格式\rInflaterInputStream 用于解压类的基础类\rZipInputStream 一个DeflaterInputStream，解压用Zip文件格式保存的数据\rGZIPInputStream 一个DeflaterInputStream，解压用GZIP文件格式保存的数据 尽管存在许多种压缩算法，但是Zip和GZIP可能最常用的。所以能够很方便地用多种现成的工具来读写这些格式的压缩数据。\n10.8.1 用GZIP进行简单压缩 10.8.2 用Zip进行多文件保存 10.8.3 Java归档（jar）实用程序 Zip格式亦在Java 1.1的JAR（Java ARchive）文件格式中得到了采用。这种文件格式的作用是将一系列文件合并到单个压缩文件里，就象Zip那样。然而，同Java中其他任何东西一样，JAR文件是跨平台的，所以不必关心涉及具体平台的问题。除了可以包括声音和图像文件以外，也可以在其中包括类文件。\n一个JAR文件由一系列采用Zip压缩格式的文件构成，同时还有一张“详情单”，对所有这些文件进行了描述（可创建自己的详情单文件；否则，jar程序会为我们代劳）。在联机用户文档中，可以找到与JAR详情单更多的资料（详情单的英语是“Manifest”）。 jar实用程序已与Sun的JDK配套提供，可以按我们的选择自动压缩文件。请在命令行调用它：\n10.9 对象序列化 对象序列化这些年养活了很多安全工程师。。。\nJava 1.1增添了一种有趣的特性，名为“对象序列化”（Object Serialization）。它面向那些实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。这一过程亦可通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异。换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节。\n就其本身来说，对象的序列化是非常有趣的，因为利用它可以实现“有限持久化”。请记住“持久化”意味着对象的“生存时间”并不取决于程序是否正在执行——它存在或“生存”于程序的每一次调用之间。通过序列化一个对象，将其写入磁盘，以后在程序重新调用时重新恢复那个对象，就能圆满实现一种“持久”效果。之所以称其为“有限”，是因为不能用某种“persistent”（持久）关键字简单地地定义一个对象，并让系统自动照看其他所有细节问题（尽管将来可能成为现实）。相反，必须在自己的程序中明确地序列化和组装对象。\n语言里增加了对象序列化的概念后，可提供对两种主要特性的支持。Java 1.1的“远程方法调用”（RMI）使本来存在于其他机器的对象可以表现出好象就在本地机器上的行为。将消息发给远程对象时，需要通过对象序列化来传输参数和返回值。RMI将在第15章作具体讨论。\n对象的序列化也是Java Beans必需的，后者由Java 1.1引入。使用一个Bean时，它的状态信息通常在设计期间配置好。程序启动以后，这种状态信息必须保存下来，以便程序启动以后恢复；具体工作由对象序列化完成。\n学习JSP，不可避免地你会接触到JavaBeans\n对象的序列化处理非常简单，只需对象实现了Serializable接口即可（该接口仅是一个标记，没有方法）。在Java 1.1中，许多标准库类都发生了改变，以便能够序列化——其中包括用于基本数据类型的全部封装器、所有集合类以及其他许多东西。甚至Class对象也可以序列化（第11章讲述了具体实现过程）。\n为序列化一个对象，首先要创建某些OutputStream对象，然后将其封装到ObjectOutputStream对象内。此时，只需调用writeObject()即可完成对象的序列化，并将其发送给OutputStream。相反的过程是将一个InputStream封装到ObjectInputStream内，然后调用 readObject()。和往常一样，我们最后获得的是指向一个上溯造型Object的句柄，所以必须下溯造型，以便能够直接设置。\n对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内包含的所有句柄并保存那些对象；接着又能对每个对象内包含的句柄进行追踪；以此类推。我们有时将这种情况称为“对象网”，单个对象可与之建立连接。而且它还包含了对象的句柄数组以及成员对象。若必须自行操纵一套对象序列化机制，那么在代码里追踪所有这些链接时可能会显得非常麻烦。在另一方面，由于Java对象的序列化似乎找不出什么缺点，所以请尽量不要自己动手，让它用优化的算法自动维护整个对象网。下面这个例子对序列化机制进行了测试。它建立了许多链接对象的一个“Worm”（蠕虫），每个对象都与Worm中的下一段链接，同时又与属于不同类（Data）的对象句柄数组链接：\n//: Worm.java\r// Demonstrates object serialization in Java 1.1\rimport java.io.*;\rclass Data implements Serializable {\rprivate int i;\rData(int x) { i = x; }\rpublic String toString() {\rreturn Integer.toString(i);\r}\r}\rpublic class Worm implements Serializable {\r// Generate a random int value:\rprivate static int r() {\rreturn (int)(Math.random() * 10);\r}\rprivate Data[] d = {\rnew Data(r()), new Data(r()), new Data(r())\r};\rprivate Worm next;\rprivate char c;\r// Value of i == number of segments\rWorm(int i, char x) {\rSystem.out.println(\u0026#34; Worm constructor: \u0026#34; + i);\rc = x;\rif(--i \u0026gt; 0)\rnext = new Worm(i, (char)(x + 1));\r}\rWorm() {\rSystem.out.println(\u0026#34;Default constructor\u0026#34;);\r}\rpublic String toString() {\rString s = \u0026#34;:\u0026#34; + c + \u0026#34;(\u0026#34;;\rfor(int i = 0; i \u0026lt; d.length; i++)\rs += d[i].toString();\rs += \u0026#34;)\u0026#34;;\rif(next != null)\rs += next.toString();\rreturn s;\r}\rpublic static void main(String[] args) {\rWorm w = new Worm(6, \u0026#39;a\u0026#39;);\rSystem.out.println(\u0026#34;w = \u0026#34; + w);\rtry {\rObjectOutputStream out =\rnew ObjectOutputStream(\rnew FileOutputStream(\u0026#34;worm.out\u0026#34;));\rout.writeObject(\u0026#34;Worm storage\u0026#34;);\rout.writeObject(w);\rout.close(); // Also flushes output\rObjectInputStream in =\rnew ObjectInputStream(\rnew FileInputStream(\u0026#34;worm.out\u0026#34;));\rString s = (String)in.readObject();\rWorm w2 = (Worm)in.readObject();\rSystem.out.println(s + \u0026#34;, w2 = \u0026#34; + w2);\r} catch(Exception e) {\re.printStackTrace();\r}\rtry {\rByteArrayOutputStream bout =\rnew ByteArrayOutputStream();\rObjectOutputStream out =\rnew ObjectOutputStream(bout);\rout.writeObject(\u0026#34;Worm storage\u0026#34;);\rout.writeObject(w);\rout.flush();\rObjectInputStream in =\rnew ObjectInputStream(\rnew ByteArrayInputStream(\rbout.toByteArray()));\rString s = (String)in.readObject();\rWorm w3 = (Worm)in.readObject();\rSystem.out.println(s + \u0026#34;, w3 = \u0026#34; + w3);\r} catch(Exception e) {\re.printStackTrace();\r}\r}\r} ///:~ 真正的序列化过程却是非常简单的。一旦从另外某个流里创建了ObjectOutputStream，writeObject()就会序列化对象。注意也可以为一个String调用writeObject()。亦可使用与DataOutputStream相同的方法写入所有基本数据类型（它们有相同的接口）。\n有两个单独的try块看起来是类似的。第一个读写的是文件，而另一个读写的是一个ByteArray（字节数组）。可利用对任何DataInputStream或者DataOutputStream的序列化来读写特定的对象；正如在关于连网的那一章会讲到的那样，这些对象甚至包括网络。\n可以看出，装配回原状的对象确实包含了原来那个对象里包含的所有链接。\n注意在对一个Serializable（可序列化）对象进行重新装配的过程中，不会调用任何构建器（甚至默认构建器）。整个对象都是通过从InputStream中取得数据恢复的。\n作为Java 1.1特性的一种，我们注意到对象的序列化并不属于新的Reader和Writer层次结构的一部分，而是沿用老式的InputStream和OutputStream结构。所以在一些特殊的场合下，不得不混合使用两种类型的层次结构。\n10.9.1 寻找类 读者或许会奇怪为什么需要一个对象从它的序列化状态中恢复。举个例子来说，假定我们序列化一个对象，并通过网络将其作为文件传送给另一台机器。此时，位于另一台机器的程序可以只用文件目录来重新构造这个对象吗？ 回答这个问题的最好方法就是做一个实验。下面这个文件位于本章的子目录下：\n//: Alien.java\r// A serializable class\rimport java.io.*;\rpublic class Alien implements Serializable {\r} ///:~ 用于创建和序列化一个Alien对象的文件位于相同的目录下：\n//: FreezeAlien.java\r// Create a serialized output file\rimport java.io.*;\rpublic class FreezeAlien {\rpublic static void main(String[] args) throws Exception {\rObjectOutput out = new ObjectOutputStream(\rnew FileOutputStream(\u0026#34;file.x\u0026#34;));\rAlien zorcon = new Alien();\rout.writeObject(zorcon); }\r} ///:~ 该程序并不是捕获和控制违例，而是将违例简单、直接地传递到main()外部，这样便能在命令行报告它们。 程序编译并运行后，将结果产生的file.x复制到名为xfiles的子目录，代码如下：\n//: ThawAlien.java\r// Try to recover a serialized file without the // class of object that\u0026#39;s stored in that file.\rpackage c10.xfiles;\rimport java.io.*;\rpublic class ThawAlien {\rpublic static void main(String[] args) throws Exception {\rObjectInputStream in =\rnew ObjectInputStream(\rnew FileInputStream(\u0026#34;file.x\u0026#34;));\rObject mystery = in.readObject();\rSystem.out.println(\rmystery.getClass().toString());\r}\r} ///:~ 该程序能打开文件，并成功读取mystery对象中的内容。然而，一旦尝试查找与对象有关的任何资料——这要求Alien的Class对象——Java虚拟机（JVM）便找不到Alien.class（除非它正好在类路径内，而本例理应相反）。这样就会得到一个名叫ClassNotFoundException的违例（同样地，若非能够校验Alien存在的证据，否则它等于消失）。\n恢复了一个序列化的对象后，如果想对其做更多的事情，必须保证JVM能在本地类路径或者因特网的其他什么地方找到相关的.class文件。\n总结：\n这小节说啥了，是在说，通过序列化恢复产生的对象，在 JVM 中是没有.class 的，除非它正好在相同类路径内。\n10.9.2 序列化的控制 正如大家看到的那样，默认的序列化机制并不难操纵。然而，假若有特殊要求又该怎么办呢？我们可能有特殊的安全问题，不希望对象的某一部分序列化；或者某一个子对象完全不必序列化，因为对象恢复以后，那一部分需要重新创建。\n此时，通过实现Externalizable接口，用它代替Serializable接口，便可控制序列化的具体过程。这个Externalizable接口扩展了Serializable，并增添了两个方法：writeExternal()和readExternal()。在序列化和重新装配的过程中，会自动调用这两个方法，以便我们执行一些特殊操作。\n下面这个例子展示了Externalizable接口方法的简单应用。注意Blip1和Blip2几乎完全一致，除了极微小的差别（自己研究一下代码，看看是否能发现）：\n//: Blips.java // Simple use of Externalizable \u0026amp; a pitfall import java.io.*; import java.util.*; class Blip1 implements Externalizable { public Blip1() { System.out.println(\u0026#34;Blip1 Constructor\u0026#34;); } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\u0026#34;Blip1.writeExternal\u0026#34;); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;Blip1.readExternal\u0026#34;); } } class Blip2 implements Externalizable { Blip2() { System.out.println(\u0026#34;Blip2 Constructor\u0026#34;); } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\u0026#34;Blip2.writeExternal\u0026#34;); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;Blip2.readExternal\u0026#34;); } } public class Blips { public static void main(String[] args) { System.out.println(\u0026#34;Constructing objects:\u0026#34;); Blip1 b1 = new Blip1(); Blip2 b2 = new Blip2(); try { ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(\u0026#34;Blips.out\u0026#34;)); System.out.println(\u0026#34;Saving objects:\u0026#34;); o.writeObject(b1); o.writeObject(b2); o.close(); // Now get them back: ObjectInputStream in = new ObjectInputStream( new FileInputStream(\u0026#34;Blips.out\u0026#34;)); System.out.println(\u0026#34;Recovering b1:\u0026#34;); b1 = (Blip1)in.readObject(); // OOPS! Throws an exception: //! System.out.println(\u0026#34;Recovering b2:\u0026#34;); //! b2 = (Blip2)in.readObject(); } catch(Exception e) { e.printStackTrace(); } } } ///:~ 该程序输出如下：\nConstructing objects:\rBlip1 Constructor\rBlip2 Constructor\rSaving objects:\rBlip1.writeExternal\rBlip2.writeExternal\rRecovering b1:\rBlip1 Constructor\rBlip1.readExternal 未恢复Blip2对象的原因是那样做会导致一个违例。你找出了Blip1和Blip2之间的区别吗？Blip1的构建器是“公共的”（public），Blip2的构建器则不然，这样便会在恢复时造成违例。试试将Blip2的构建器属性变成“public”，然后删除//!注释标记，看看是否能得到正确的结果。\n恢复b1后，会调用Blip1默认构建器。这与恢复一个Serializable（可序列化）对象不同。在后者的情况下，对象完全以它保存下来的二进制位为基础恢复，不存在构建器调用。而对一个Externalizable对象，所有普通的默认构建行为都会发生（包括在字段定义时的初始化），而且会调用readExternal()。必须注意这一事实——特别注意所有默认的构建行为都会进行——否则很难在自己的Externalizable对象中产生正确的行为。\n下面这个例子揭示了保存和恢复一个Externalizable对象必须做的全部事情：\n//: Blip3.java // Reconstructing an externalizable object import java.io.*; import java.util.*; class Blip3 implements Externalizable { int i; String s; // No initialization public Blip3() { System.out.println(\u0026#34;Blip3 Constructor\u0026#34;); // s, i not initialized } public Blip3(String x, int a) { System.out.println(\u0026#34;Blip3(String x, int a)\u0026#34;); s = x; i = a; // s \u0026amp; i initialized only in non-default // constructor. } public String toString() { return s + i; } public void writeExternal(ObjectOutput out) throws IOException { System.out.println(\u0026#34;Blip3.writeExternal\u0026#34;); // You must do this: out.writeObject(s); out.writeInt(i); } public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { System.out.println(\u0026#34;Blip3.readExternal\u0026#34;); // You must do this: s = (String)in.readObject(); i =in.readInt(); } public static void main(String[] args) { System.out.println(\u0026#34;Constructing objects:\u0026#34;); Blip3 b3 = new Blip3(\u0026#34;A String \u0026#34;, 47); System.out.println(b3.toString()); try { ObjectOutputStream o = new ObjectOutputStream( new FileOutputStream(\u0026#34;Blip3.out\u0026#34;)); System.out.println(\u0026#34;Saving object:\u0026#34;); o.writeObject(b3); o.close(); // Now get it back: ObjectInputStream in = new ObjectInputStream( new FileInputStream(\u0026#34;Blip3.out\u0026#34;)); System.out.println(\u0026#34;Recovering b3:\u0026#34;); b3 = (Blip3)in.readObject(); System.out.println(b3.toString()); } catch(Exception e) { e.printStackTrace(); } } } ///:~ Constructing objects:\rBlip3(String x, int a)\rA String 47\rSaving object:\rBlip3.writeExternal\rRecovering b3:\rBlip3 Constructor\rBlip3.readExternal\rA String 47 其中，字段s和i只在第二个构建器中初始化，不关默认构建器的事。这意味着假如不在readExternal中初始化s和i，它们就会成为null（因为在对象创建的第一步中已将对象的存储空间清除为1）。若注释掉跟随于“You must do this”后面的两行代码，并运行程序，就会发现当对象恢复以后，s是null，而i是零。\n若从一个Externalizable对象继承，通常需要调用writeExternal()和readExternal()的基础类版本，以便正确地保存和恢复基础类组件。\n所以为了让一切正常运作起来，千万不可仅在writeExternal()方法执行期间写入对象的重要数据（没有默认的行为可用来为一个Externalizable对象写入所有成员对象）的，而是必须在readExternal()方法中也恢复那些数据。初次操作时可能会有些不习惯，因为Externalizable对象的默认构建行为使其看起来似乎正在进行某种存储与恢复操作。但实情并非如此。\n总结：\n对象继承 Externalizable 实现序列化，需要注意 writeExternal()和readExternal() 方法， 序列化时：在 writeExternal() 方法 写入对象的重要的想恢复的数据。 反序列化时： 会先调用方法的 公开无参构造方法（不公开会报错），在readExternal()方法中恢复那些序列化时的out的数据。\ntransient（临时）关键字 控制序列化过程时，可能有一个特定的子对象不愿让Java的序列化机制自动保存与恢复。一般地，若那个子对象包含了不想序列化的敏感信息（如密码），就会面临这种情况。即使那种信息在对象中具有“private”（私有）属性，但一旦经序列化处理，人们就可以通过读取一个文件，或者拦截网络传输得到它。\n为防止对象的敏感部分被序列化，一个办法是将自己的类实现为Externalizable，就象前面展示的那样。这样一来，没有任何东西可以自动序列化，只能在writeExternal()明确序列化那些需要的部分。\n然而，若操作的是一个Serializable对象，所有序列化操作都会自动进行。为解决这个问题，可以用transient（临时）逐个字段地关闭序列化，它的意思是“不要麻烦你（指自动机制）保存或恢复它了——我会自己处理的”。\n例如，假设一个Login对象包含了与一个特定的登录会话有关的信息。校验登录的合法性时，一般都想将数据保存下来，但不包括密码。为做到这一点，最简单的办法是实现Serializable，并将password字段设为transient。\n可以看到，其中的date和username字段保持原始状态（未设成transient），所以会自动序列化。然而，password被设为transient，所以不会自动保存到磁盘；另外，自动序列化机制也不会作恢复它的尝试。输出如下：\n一旦对象恢复成原来的样子，password字段就会变成null。注意必须用toString()检查password是否为null，因为若用过载的“+”运算符来装配一个String对象，而且那个运算符遇到一个null句柄，就会造成一个名为NullPointerException的违例（新版Java可能会提供避免这个问题的代码）。\n我们也发现date字段被保存到磁盘，并从磁盘恢复，没有重新生成。\n由于Externalizable对象默认时不保存它的任何字段，所以transient关键字只能伴随Serializable使用。\nExternalizable 的替代方法 若不是特别在意要实现Externalizable接口，还有另一种方法可供选用。我们可以实现Serializable接口，并添加（注意是“添加”，而非“覆盖”或者“实现”）名为writeObject()和readObject()的方法。一旦对象被序列化或者重新装配，就会分别调用那两个方法。也就是说，只要提供了这两个方法，就会优先使用它们，而不考虑默认的序列化机制。 这些方法必须含有下列准确的签名：\nprivate void writeObject(ObjectOutputStream stream)\rthrows IOException;\rprivate void readObject(ObjectInputStream stream)\rthrows IOException, ClassNotFoundException 从设计的角度出发，情况变得有些扑朔迷离。首先，大家可能认为这些方法不属于基础类或者Serializable接口的一部分，它们应该在自己的接口中得到定义。但请注意它们被定义成“private”，这意味着它们只能由这个类的其他成员调用。然而，我们实际并不从这个类的其他成员中调用它们，而是由ObjectOutputStream和ObjectInputStream的writeObject()及readObject()方法来调用我们对象的writeObject()和readObject()方法（注意我在这里用了很大的抑制力来避免使用相同的方法名——因为怕混淆）。大家可能奇怪ObjectOutputStream和ObjectInputStream如何有权访问我们的类的private方法——只能认为这是序列化机制玩的一个把戏。\n在任何情况下，接口中的定义的任何东西都会自动具有public属性，所以假若writeObject()和readObject()必须为private，那么它们不能成为接口（interface）的一部分。但由于我们准确地加上了签名，所以最终的效果实际与实现一个接口是相同的。\n看起来似乎我们调用ObjectOutputStream.writeObject()的时候，我们传递给它的Serializable对象似乎会被检查是否实现了自己的writeObject()。若答案是肯定的是，便会跳过常规的序列化过程，并调用writeObject()。readObject()也会遇到同样的情况。\n还存在另一个问题。在我们的writeObject()内部，可以调用defaultWriteObject()，从而决定采取默认的writeObject()行动。类似地，在readObject()内部，可以调用defaultReadObject()。下面这个简单的例子演示了如何对一个Serializable对象的存储与恢复进行控制：\n//: SerialCtl.java\r// Controlling serialization by adding your own\r// writeObject() and readObject() methods.\rimport java.io.*;\rpublic class SerialCtl implements Serializable {\rString a;\rtransient String b;\rpublic SerialCtl(String aa, String bb) {\ra = \u0026#34;Not Transient: \u0026#34; + aa;\rb = \u0026#34;Transient: \u0026#34; + bb;\r}\rpublic String toString() {\rreturn a + \u0026#34;\\n\u0026#34; + b;\r}\rprivate void writeObject(ObjectOutputStream stream)\rthrows IOException {\rstream.defaultWriteObject();\rstream.writeObject(b);\r}\rprivate void readObject(ObjectInputStream stream)\rthrows IOException, ClassNotFoundException {\rstream.defaultReadObject();\rb = (String)stream.readObject();\r}\rpublic static void main(String[] args) {\rSerialCtl sc = new SerialCtl(\u0026#34;Test1\u0026#34;, \u0026#34;Test2\u0026#34;);\rSystem.out.println(\u0026#34;Before:\\n\u0026#34; + sc);\rByteArrayOutputStream buf = new ByteArrayOutputStream();\rtry {\rObjectOutputStream o =\rnew ObjectOutputStream(buf);\ro.writeObject(sc);\r// Now get it back:\rObjectInputStream in =\rnew ObjectInputStream(\rnew ByteArrayInputStream(\rbuf.toByteArray()));\rSerialCtl sc2 = (SerialCtl)in.readObject();\rSystem.out.println(\u0026#34;After:\\n\u0026#34; + sc2);\r} catch(Exception e) {\re.printStackTrace();\r}\r}\r} ///:~ 在这个例子中，一个String保持原始状态，其他设为transient（临时），以便证明非临时字段会被defaultWriteObject()方法自动保存，而transient字段必须在程序中明确保存和恢复。字段是在构建器内部初始化的，而不是在定义的时候，这证明了它们不会在重新装配的时候被某些自动化机制初始化。\n若准备通过默认机制写入对象的非transient部分，那么必须调用defaultWriteObject()，令其作为writeObject()中的第一个操作；并调用defaultReadObject()，令其作为readObject()的第一个操作。这些都是不常见的调用方法。举个例子来说，当我们为一个ObjectOutputStream调用defaultWriteObject()的时候，而且没有为其传递参数，就需要采取这种操作，使其知道对象的句柄以及如何写入所有非transient的部分。这种做法非常不便。\ntransient对象的存储与恢复采用了我们更熟悉的代码。现在考虑一下会发生一些什么事情。在main()中会创建一个SerialCtl对象，随后会序列化到一个ObjectOutputStream里（注意这种情况下使用的是一个缓冲区，而非文件——与ObjectOutputStream完全一致）。正式的序列化操作是在下面这行代码里发生的：\no.writeObject(sc); 其中，writeObject()方法必须核查sc，判断它是否有自己的writeObject()方法（不是检查它的接口——它根本就没有，也不是检查类的类型，而是利用反射方法实际搜索方法）。若答案是肯定的，就使用那个方法。类似的情况也会在readObject()上发生。或许这是解决问题唯一实际的方法，但确实显得有些古怪。\n版本问题 有时候可能想改变一个可序列化的类的版本（比如原始类的对象可能保存在数据库中）。尽管这种做法得到了支持，但一般只应在非常特殊的情况下才用它。此外，它要求操作者对背后的原理有一个比较深的认识，而我们在这里还不想达到这种深度。JDK 1.1的HTML文档对这一主题进行了非常全面的论述（可从Sun公司下载，但可能也成了Java开发包联机文档的一部分）。\n10.9.3 利用“持久性” 一个比较诱人的想法是用序列化技术保存程序的一些状态信息，从而将程序方便地恢复到以前的状态。但在具体实现以前，有些问题是必须解决的。如果两个对象都有指向第三个对象的句柄，该如何对这两个对象序列化呢？如果从两个对象序列化后的状态恢复它们，第三个对象的句柄只会出现在一个对象身上吗？如果将这两个对象序列化成独立的文件，然后在代码的不同部分重新装配它们，又会得到什么结果呢？\n下面这个例子对上述问题进行了很好的说明：\n//: MyWorld.java import java.io.*; import java.util.*; class House implements Serializable {} class Animal implements Serializable { String name; House preferredHouse; Animal(String nm, House h) { name = nm; preferredHouse = h; } public String toString() { return name + \u0026#34;[\u0026#34; + super.toString() + \u0026#34;], \u0026#34; + preferredHouse + \u0026#34;\\n\u0026#34;; } } public class MyWorld { public static void main(String[] args) { House house = new House(); Vector animals = new Vector(); animals.addElement( new Animal(\u0026#34;Bosco the dog\u0026#34;, house)); animals.addElement( new Animal(\u0026#34;Ralph the hamster\u0026#34;, house)); animals.addElement( new Animal(\u0026#34;Fronk the cat\u0026#34;, house)); System.out.println(\u0026#34;animals: \u0026#34; + animals); try { ByteArrayOutputStream buf1 = new ByteArrayOutputStream(); ObjectOutputStream o1 = new ObjectOutputStream(buf1); o1.writeObject(animals); o1.writeObject(animals); // Write a 2nd set // Write to a different stream: ByteArrayOutputStream buf2 = new ByteArrayOutputStream(); ObjectOutputStream o2 = new ObjectOutputStream(buf2); o2.writeObject(animals); // Now get them back: ObjectInputStream in1 = new ObjectInputStream( new ByteArrayInputStream( buf1.toByteArray())); ObjectInputStream in2 = new ObjectInputStream( new ByteArrayInputStream( buf2.toByteArray())); Vector animals1 = (Vector)in1.readObject(); Vector animals2 = (Vector)in1.readObject(); Vector animals3 = (Vector)in2.readObject(); System.out.println(\u0026#34;animals1: \u0026#34; + animals1); System.out.println(\u0026#34;animals2: \u0026#34; + animals2); System.out.println(\u0026#34;animals3: \u0026#34; + animals3); } catch(Exception e) { e.printStackTrace(); } } } ///:~ animals: [Bosco the dog[com.openjfx.test.io.Animal@44c8afef], com.openjfx.test.io.House@5891e32e\r, Ralph the hamster[com.openjfx.test.io.Animal@cb0ed20], com.openjfx.test.io.House@5891e32e\r, Fronk the cat[com.openjfx.test.io.Animal@8e24743], com.openjfx.test.io.House@5891e32e\r]\ranimals1: [Bosco the dog[com.openjfx.test.io.Animal@48a242ce], com.openjfx.test.io.House@1e4a7dd4\r, Ralph the hamster[com.openjfx.test.io.Animal@4f51b3e0], com.openjfx.test.io.House@1e4a7dd4\r, Fronk the cat[com.openjfx.test.io.Animal@4b9e255], com.openjfx.test.io.House@1e4a7dd4\r]\ranimals2: [Bosco the dog[com.openjfx.test.io.Animal@48a242ce], com.openjfx.test.io.House@1e4a7dd4\r, Ralph the hamster[com.openjfx.test.io.Animal@4f51b3e0], com.openjfx.test.io.House@1e4a7dd4\r, Fronk the cat[com.openjfx.test.io.Animal@4b9e255], com.openjfx.test.io.House@1e4a7dd4\r]\ranimals3: [Bosco the dog[com.openjfx.test.io.Animal@5e57643e], com.openjfx.test.io.House@133e16fd\r, Ralph the hamster[com.openjfx.test.io.Animal@51b279c9], com.openjfx.test.io.House@133e16fd\r, Fronk the cat[com.openjfx.test.io.Animal@1ad282e0], com.openjfx.test.io.House@133e16fd\r] 这里一件有趣的事情是也许是能针对一个字节数组应用对象的序列化，从而实现对任何Serializable（可序列化）对象的一个“全面复制”（全面复制意味着复制的是整个对象网，而不仅是基本对象和它的句柄）。复制问题将在第12章进行全面讲述。\nAnimal对象包含了类型为House的字段。在main()中，会创建这些Animal的一个Vector，并对其序列化两次，分别送入两个不同的数据流内。这些数据重新装配并打印出来后，可看到下面这样的结果（对象在每次运行时都会处在不同的内存位置，所以每次运行的结果有区别）：\n当然，我们希望装配好的对象有与原来不同的地址。但注意在animals1和animals2中出现了相同的地址，其中包括共享的、对House对象的引用。在另一方面，当animals3恢复以后，系统没有办法知道另一个流内的对象是第一个流内对象的化身，所以会产生一个完全不同的对象网。\n只要将所有东西都序列化到单独一个数据流里，就能恢复获得与以前写入时完全一样的对象网，不会不慎造成对象的重复。当然，在写第一个和最后一个对象的时间之间，可改变对象的状态，但那必须由我们明确采取操作——序列化时，对象会采用它们当时的任何状态（包括它们与其他对象的连接关系）写入。\n也就是说一个队形在数据流里系列化两次，会恢复为一个对象，不同的流里会复制对象\n若想保存系统状态，最安全的做法是当作一种“微观”操作序列化。如果序列化了某些东西，再去做其他一些工作，再来序列化更多的东西，以此类推，那么最终将无法安全地保存系统状态。相反，应将构成系统状态的所有对象都置入单个集合内，并在一次操作里完成那个集合的写入。这样一来，同样只需一次方法调用，即可成功恢复之。\n下面这个例子是一套假想的计算机辅助设计（CAD）系统，对这一方法进行了很好的演示。此外，它还为我们引入了static字段的问题——如留意联机文档，就会发现Class是“Serializable”（可序列化）的，所以只需简单地序列化Class对象，就能实现static字段的保存。这无论如何都是一种明智的做法。\n//: CADState.java // Saving and restoring the state of a // pretend CAD system. import java.io.*; import java.util.*; abstract class Shape implements Serializable { public static final int RED = 1, BLUE = 2, GREEN = 3; private int xPos, yPos, dimension; private static Random r = new Random(); private static int counter = 0; abstract public void setColor(int newColor); abstract public int getColor(); public Shape(int xVal, int yVal, int dim) { xPos = xVal; yPos = yVal; dimension = dim; } public String toString() { return getClass().toString() + \u0026#34; color[\u0026#34; + getColor() + \u0026#34;] xPos[\u0026#34; + xPos + \u0026#34;] yPos[\u0026#34; + yPos + \u0026#34;] dim[\u0026#34; + dimension + \u0026#34;]\\n\u0026#34;; } public static Shape randomFactory() { int xVal = r.nextInt() % 100; int yVal = r.nextInt() % 100; int dim = r.nextInt() % 100; switch(counter++ % 3) { default: case 0: return new Circle(xVal, yVal, dim); case 1: return new Square(xVal, yVal, dim); case 2: return new Line(xVal, yVal, dim); } } } class Circle extends Shape { private static int color = RED; public Circle(int xVal, int yVal, int dim) { super(xVal, yVal, dim); } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } class Square extends Shape { private static int color; public Square(int xVal, int yVal, int dim) { super(xVal, yVal, dim); color = RED; } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } class Line extends Shape { private static int color = RED; public static void serializeStaticState(ObjectOutputStream os) throws IOException { os.writeInt(color); } public static void deserializeStaticState(ObjectInputStream os) throws IOException { color = os.readInt(); } public Line(int xVal, int yVal, int dim) { super(xVal, yVal, dim); } public void setColor(int newColor) { color = newColor; } public int getColor() { return color; } } public class CADState { public static void main(String[] args) throws Exception { Vector shapeTypes, shapes; if(args.length == 0) { shapeTypes = new Vector(); shapes = new Vector(); // Add handles to the class objects: shapeTypes.addElement(Circle.class); shapeTypes.addElement(Square.class); shapeTypes.addElement(Line.class); // Make some shapes: for(int i = 0; i \u0026lt; 10; i++) shapes.addElement(Shape.randomFactory()); // Set all the static colors to GREEN: for(int i = 0; i \u0026lt; 10; i++) ((Shape)shapes.elementAt(i)) .setColor(Shape.GREEN); // Save the state vector: ObjectOutputStream out = new ObjectOutputStream( new FileOutputStream(\u0026#34;CADState.out\u0026#34;)); out.writeObject(shapeTypes); Line.serializeStaticState(out); out.writeObject(shapes); } else { // There\u0026#39;s a command-line argument ObjectInputStream in = new ObjectInputStream( new FileInputStream(args[0])); // Read in the same order they were written: shapeTypes = (Vector)in.readObject(); Line.deserializeStaticState(in); shapes = (Vector)in.readObject(); } // Display the shapes: System.out.println(shapes); } } ///:~ Shape（几何形状）类“实现了可序列化”（implements Serializable），所以从Shape继承的任何东西也都会自动“可序列化”。每个Shape都包含了数据，而且每个衍生的Shape类都包含了一个特殊的static字段，用于决定所有那些类型的Shape的颜色（如将一个static字段置入基础类，结果只会产生一个字段，因为static字段未在衍生类中复制）。可对基础类中的方法进行覆盖处理，以便为不同的类型设置颜色（static方法不会动态绑定，所以这些都是普通的方法）。每次调用 randomFactory()方法时，它都会创建一个不同的Shape（Shape值采用随机值）。\nCircle（圆）和Square（矩形）属于对Shape的直接扩展；唯一的差别是Circle在定义时会初始化颜色，而Square在构建器中初始化。Line（直线）的问题将留到以后讨论。\n在main()中，一个Vector用于容纳Class对象，而另一个用于容纳形状。若不提供相应的命令行参数，就会创建shapeTypes Vector，并添加Class对象。然后创建shapes Vector，并添加Shape对象。接下来，所有static color值都会设成GREEN，而且所有东西都会序列化到文件CADState.out。\n若提供了一个命令行参数（假设CADState.out），便会打开那个文件，并用它恢复程序的状态。无论在哪种情况下，结果产生的Shape的Vector都会打印出来。下面列出它某一次运行的结果：\n\u0026gt;java CADState\r[class Circle color[3] xPos[-51] yPos[-99] dim[38]\r, class Square color[3] xPos[2] yPos[61] dim[-46]\r, class Line color[3] xPos[51] yPos[73] dim[64]\r, class Circle color[3] xPos[-70] yPos[1] dim[16]\r, class Square color[3] xPos[3] yPos[94] dim[-36]\r, class Line color[3] xPos[-84] yPos[-21] dim[-35]\r, class Circle color[3] xPos[-75] yPos[-43] dim[22]\r, class Square color[3] xPos[81] yPos[30] dim[-45]\r, class Line color[3] xPos[-29] yPos[92] dim[17]\r, class Circle color[3] xPos[17] yPos[90] dim[-76]\r]\r\u0026gt;java CADState CADState.out\r[class Circle color[1] xPos[-51] yPos[-99] dim[38]\r, class Square color[0] xPos[2] yPos[61] dim[-46]\r, class Line color[3] xPos[51] yPos[73] dim[64]\r, class Circle color[1] xPos[-70] yPos[1] dim[16]\r, class Square color[0] xPos[3] yPos[94] dim[-36]\r, class Line color[3] xPos[-84] yPos[-21] dim[-35]\r, class Circle color[1] xPos[-75] yPos[-43] dim[22]\r, class Square color[0] xPos[81] yPos[30] dim[-45]\r, class Line color[3] xPos[-29] yPos[92] dim[17]\r, class Circle color[1] xPos[17] yPos[90] dim[-76]\r] 从中可以看出，xPos，yPos以及dim的值都已成功保存和恢复出来。但在获取static信息时却出现了问题。所有“3”都已进入，但没有正常地出来。Circle有一个1值（定义为RED），而Square有一个0值（记住，它们是在构建器里初始化的）。看上去似乎static根本没有得到初始化！实情正是如此——尽管类Class是“可以序列化的”，但却不能按我们希望的工作。所以假如想序列化static值，必须亲自动手。\n这正是Line中的serializeStaticState()和deserializeStaticState()两个static方法的用途。可以看到，这两个方法都是作为存储和恢复进程的一部分明确调用的（注意写入序列化文件和从中读回的顺序不能改变）。所以为了使CADState.java正确运行起来，必须采用下述三种方法之一：\n(1) 为几何形状添加一个serializeStaticState()和deserializeStaticState()。 (2) 删除Vector shapeTypes以及与之有关的所有代码 (3) 在几何形状内添加对新序列化和撤消序列化静态方法的调用 要注意的另一个问题是安全，因为序列化处理也会将private数据保存下来。若有需要保密的字段，应将其标记成transient。但在这之后，必须设计一种安全的信息保存方法。这样一来，一旦需要恢复，就可以重设那些private变量。\n10.10 总结 Java IO流库能满足我们的许多基本要求：可以通过控制台、文件、内存块甚至因特网（参见第15章）进行读写。可以创建新的输入和输出对象类型（通过从InputStream和OutputStream继承）。向一个本来预期为收到字串的方法传递一个对象时，由于Java已限制了“自动类型转换”，所以会自动调用toString()方法。而我们可以重新定义这个toString()，扩展一个数据流能接纳的对象种类。\n在IO数据流库的联机文档和设计过程中，仍有些问题没有解决。比如当我们打开一个文件以便输出时，完全可以指定一旦有人试图覆盖该文件就“掷”出一个违例——有的编程系统允许我们自行指定想打开一个输出文件，但唯一的前提是它尚不存在。但在Java中，似乎必须用一个File对象来判断某个文件是否存在，因为假如将其作为FileOutputStream或者FileWriter打开，那么肯定会被覆盖。若同时指定文件和目录路径，File类设计上的一个缺陷就会暴露出来，因为它会说“不要试图在单个类里做太多的事情”！ IO流库易使我们混淆一些概念。它确实能做许多事情，而且也可以移植。但假如假如事先没有吃透装饰器方案的概念，那么所有的设计都多少带有一点盲目性质。所以不管学它还是教它，都要特别花一些功夫才行。而且它并不完整：没有提供对输出格式化的支持，而其他几乎所有语言的IO包都提供了这方面的支持（这一点没有在Java 1.1里得以纠正，它完全错失了改变库设计方案的机会，反而增添了更特殊的一些情况，使复杂程度进一步提高）。Java 1.1转到那些尚未替换的IO库，而不是增加新库。而且库的设计人员似乎没有很好地指出哪些特性是不赞成的，哪些是首选的，造成库设计中经常都会出现一些令人恼火的反对消息。\n然而，一旦掌握了装饰器方案，并开始在一些较为灵活的环境使用库，就会认识到这种设计的好处。到那个时候，为此多付出的代码行应该不至于使你觉得太生气。\n10.11 练习 (1) 打开一个文本文件，每次读取一行内容。将每行作为一个String读入，并将那个String对象置入一个Vector里。按相反的顺序打印出Vector中的所有行。\n(2) 修改练习1，使读取那个文件的名字作为一个命令行参数提供。\n(3) 修改练习2，又打开一个文本文件，以便将文字写入其中。将Vector中的行随同行号一起写入文件。\n(4) 修改练习2，强迫Vector中的所有行都变成大写形式，将结果发给System.out。\n(5) 修改练习2，在文件中查找指定的单词。打印出包含了欲找单词的所有文本行。\n(6) 在Blips.java中复制文件，将其重命名为BlipCheck.java。然后将类Blip2重命名为BlipCheck（在进程中将其标记为public）。删除文件中的//!记号，并执行程序。接下来，将BlipCheck的默认构建器变成注释信息。运行它，并解释为什么仍然能够工作。\n(7) 在Blip3.java中，将接在“You must do this:”字样后的两行变成注释，然后运行程序。解释得到的结果为什么会与执行了那两行代码不同。\n(8) 转换SortedWordCount.java程序，以便使用Java 1.1 IO流。\n(9) 根据本章正文的说明修改程序CADState.java。\n(10) 在第7章（中间部分）找到GreenhouseControls.java示例，它应该由三个文件构成。在GreenhouseControls.java中，Restart()内部类有一个硬编码的事件集。请修改这个程序，使其能从一个文本文件里动态读取事件以及它们的相关时间。\n第11章 运行期类型鉴定 总结:\n其实 thinking in java 虽然将 RTTI 和 反射分开讲解，其实本质上我们看Java语言提供的功能：\n利用 instanceof 来在运行期检出 对象 的类型 利用 Class.forName() 方法去获得一个未 import 对象的 Class 类 利用 java.lang.reflect.* 来获得对象的 对象信息（接口、属性、方法、修饰符） 本质上是在说明一件事：Java 提供了在运行期 完整且成系统的 创建和利用类和对象。能了解这一点并能利用使程序在运行的过程中能正确的动态的构建对象创建对象就可以了。 另需要知道的一件事是：想在运行期搞这些事情，离不开 Class 对象。因为 Java 是用 Class 对象 表示 在运行期 的 类型信息 .class 文件 ==》 JVM Class 对象 ==》 JVM new()对象 运行期类型鉴定（RTTI）的概念初看非常简单——手上只有基础类型的一个句柄时，利用它判断一个对象的正确类型。 然而，对RTTI的需要暴露出了面向对象设计许多有趣（而且经常是令人困惑的）的问题，并把程序的构造问题正式摆上了桌面。 本章将讨论如何利用Java在运行期间查找对象和类信息。这主要采取两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可在运行期独立查找类信息。首先讨论“传统”的RTTI，再讨论反射问题。\n11.1 对RTTI的需要 请考虑下面这个熟悉的类结构例子，它利用了多形性。常规类型是Shape类，而特别衍生出来的类型是Circle，Square和Triangle。\n这是一个典型的类结构示意图，基础类位于顶部，衍生类向下延展。面向对象编程的基本目标是用大量代码控制基础类型（这里是Shape）的句柄，所以假如决定添加一个新类（比如Rhomboid，从Shape衍生），从而对程序进行扩展，那么不会影响到原来的代码。在这个例子中，Shape接口中的动态绑定方法是draw()，所以客户程序员要做的是通过一个普通Shape句柄调用draw()。draw()在所有衍生类里都会被覆盖。而且由于它是一个动态绑定方法，所以即使通过一个普通的Shape句柄调用它，也有表现出正确的行为。这正是多形性的作用。\n所以，我们一般创建一个特定的对象（Circle，Square，或者Triangle），把它上溯造型到一个Shape（忽略对象的特殊类型），以后便在程序的剩余部分使用匿名Shape句柄。\n作为对多形性和上溯造型的一个简要回顾，可以象下面这样为上述例子编码（若执行这个程序时出现困难，请参考第3章3.1.2小节“赋值”）：\n//: Shapes.java package c11; import java.util.*; interface Shape { void draw(); } class Circle implements Shape { public void draw() { System.out.println(\u0026#34;Circle.draw()\u0026#34;); } } class Square implements Shape { public void draw() { System.out.println(\u0026#34;Square.draw()\u0026#34;); } } class Triangle implements Shape { public void draw() { System.out.println(\u0026#34;Triangle.draw()\u0026#34;); } } public class Shapes { public static void main(String[] args) { Vector s = new Vector(); s.addElement(new Circle()); s.addElement(new Square()); s.addElement(new Triangle()); Enumeration e = s.elements(); while(e.hasMoreElements()) ((Shape)e.nextElement()).draw(); } } ///:~ 基础类可编码成一个interface（接口）、一个abstract（抽象）类或者一个普通类。由于Shape没有真正的成员（亦即有定义的成员），而且并不在意我们创建了一个纯粹的Shape对象，所以最适合和最灵活的表达方式便是用一个接口。而且由于不必设置所有那些abstract关键字，所以整个代码也显得更为清爽。\n每个衍生类都覆盖了基础类draw方法，所以具有不同的行为。在main()中创建了特定类型的Shape，然后将其添加到一个Vector。这里正是上溯造型发生的地方，因为Vector只容纳了对象。由于Java中的所有东西（除基本数据类型外）都是对象，所以Vector也能容纳Shape对象。但在上溯造型至Object的过程中，任何特殊的信息都会丢失，其中甚至包括对象是几何形状这一事实。对Vector来说，它们只是Object。\n用nextElement()将一个元素从Vector提取出来的时候，情况变得稍微有些复杂。由于Vector只容纳Object，所以nextElement()会自然地产生一个Object句柄。但我们知道它实际是个Shape句柄，而且希望将Shape消息发给那个对象。所以需要用传统的\u0026quot;(Shape)\u0026ldquo;方式造型成一个Shape。这是RTTI最基本的形式，因为在Java中，所有造型都会在运行期间得到检查，以确保其正确性。那正是RTTI的意义所在：在运行期，对象的类型会得到鉴定。\n在目前这种情况下，RTTI造型只实现了一部分：Object造型成Shape，而不是造型成Circle，Square或者Triangle。那是由于我们目前能够肯定的唯一事实就是Vector里充斥着几何形状，而不知它们的具体类别。在编译期间，我们肯定的依据是我们自己的规则；而在编译期间，却是通过造型来肯定这一点。\n现在的局面会由多形性控制，而且会为Shape调用适当的方法，以便判断句柄到底是提供Circle，Square，还是提供给Triangle。而且在一般情况下，必须保证采用多形性方案。因为我们希望自己的代码尽可能少知道一些与对象的具体类型有关的情况，只将注意力放在某一类对象（这里是Shape）的常规信息上。只有这样，我们的代码才更易实现、理解以及修改。所以说多形性是面向对象程序设计的一个常规目标。\n然而，若碰到一个特殊的程序设计问题，只有在知道常规句柄的确切类型后，才能最容易地解决这个问题，这个时候又该怎么办呢？举个例子来说，我们有时候想让自己的用户将某一具体类型的几何形状（如三角形）全都变成紫色，以便突出显示它们，并快速找出这一类型的所有形状。此时便要用到RTTI技术，用它查询某个Shape句柄引用的准确类型是什么。\n此时便要用到RTTI技术，用它查询某个Shape句柄引用的准确类型是什么。\n11.1.1 Class对象 为理解RTTI在Java里如何工作，首先必须了解类型信息在运行期是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类有关的信息（有时也把它叫作“元类”）。事实上，我们要用Class对象创建属于某个类的全部“常规”或“普通”对象。为理解RTTI在Java里如何工作，首先必须了解类型信息在运行期是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类有关的信息（有时也把它叫作“元类”）。事实上，我们要用Class对象创建属于某个类的全部“常规”或“普通”对象。\n对于作为程序一部分的每个类，它们都有一个Class对象。换言之，每次写一个新类时，同时也会创建一个Class对象（更恰当地说，是保存在一个完全同名的.class文件中）。在运行期，一旦我们想生成那个类的一个对象，用于执行程序的Java虚拟机（JVM）首先就会检查那个类型的Class对象是否已经载入。若尚未载入，JVM就会查找同名的.class文件，并将其载入。所以Java程序启动时并不是完全载入的，这一点与许多传统语言都不同。 一旦那个类型的Class对象进入内存，就用它创建那一类型的所有对象。\n若这种说法多少让你产生了一点儿迷惑，或者并没有真正理解它，下面这个示范程序或许能提供进一步的帮助：\n//: SweetShop.java // Examination of the way the class loader works class Candy { static { System.out.println(\u0026#34;Loading Candy\u0026#34;); } } class Gum { static { System.out.println(\u0026#34;Loading Gum\u0026#34;); } } class Cookie { static { System.out.println(\u0026#34;Loading Cookie\u0026#34;); } } public class SweetShop { public static void main(String[] args) { System.out.println(\u0026#34;inside main\u0026#34;); new Candy(); System.out.println(\u0026#34;After creating Candy\u0026#34;); try { Class.forName(\u0026#34;Gum\u0026#34;); } catch(ClassNotFoundException e) { e.printStackTrace(); } System.out.println( \u0026#34;After Class.forName(\\\u0026#34;Gum\\\u0026#34;)\u0026#34;); new Cookie(); System.out.println(\u0026#34;After creating Cookie\u0026#34;); } } ///:~ 对每个类来说（Candy，Gum和Cookie），它们都有一个static从句，用于在类首次载入时执行。相应的信息会打印出来，告诉我们载入是什么时候进行的。在main()中，对象的创建代码位于打印语句之间，以便侦测载入时间。 特别有趣的一行是：\nClass.forName(\u0026#34;Gum\u0026#34;); 该方法是Class（即全部Class所从属的）的一个static成员。而Class对象和其他任何对象都是类似的，所以能够获取和控制它的一个句柄（装载模块就是干这件事的）。为获得Class的一个句柄，一个办法是使用forName()。它的作用是取得包含了目标类文本名字的一个String（注意拼写和大小写）。最后返回的是一个Class句柄。\n该程序在某个JVM中的输出如下：\ninside main\rLoading Candy\rAfter creating Candy\rLoading Gum\rAfter Class.forName(\u0026#34;Gum\u0026#34;)\rLoading Cookie\rAfter creating Cookie 可以看到，每个Class只有在它需要的时候才会载入，而static初始化工作是在类载入时执行的。 非常有趣的是，另一个JVM的输出变成了另一个样子：\nLoading Candy\rLoading Cookie\rinside main\rAfter creating Candy\rLoading Gum\rAfter Class.forName(\u0026#34;Gum\u0026#34;)\rAfter creating Cookie 看来JVM通过检查main()中的代码，已经预测到了对Candy和Cookie的需要，但却看不到Gum，因为它是通过对forName()的一个调用创建的，而不是通过更典型的new调用。尽管这个JVM也达到了我们希望的效果，因为确实会在我们需要之前载入那些类，但却不能肯定这儿展示的行为百分之百正确。\n类标记 在Java 1.1中，可以采用第二种方式来产生Class对象的句柄：使用“类标记”。对上述程序来说，看起来就象下面这样： Gum.class; 这样做不仅更加简单，而且更安全，因为它会在编译期间得到检查。由于它取消了对方法调用的需要，所以执行的效率也会更高。 类标记不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。除此以外，针对每种基本数据类型的封装器类，它还存在一个名为TYPE的标准字段。TYPE字段的作用是为相关的基本数据类型产生Class对象的一个句柄，如下所示：\nheader 1 header 2 boolean.class Boolean.TYPE char .class Character.TYPE byte .class Byte.TYPE short .class Short.TYPE int .class Integer.TYPE long .class Long.TYPE float .class Float.TYPE double .class Double.TYPE void .class Void.TYPE 11.1.2 造型前的检查 迄今为止，我们已知的RTTI形式包括：\n(1) 经典造型，如\u0026rdquo;(Shape)\u0026quot;，它用RTTI确保造型的正确性，并在遇到一个失败的造型后产生一个ClassCastException违例。 (2) 代表对象类型的Class对象。可查询Class对象，获取有用的运行期资料。 在C++中，经典的\u0026quot;(Shape)\u0026ldquo;造型并不执行RTTI。它只是简单地告诉编译器将对象当作新类型处理。而Java要执行类型检查，这通常叫作“类型安全”的下溯造型。之所以叫“下溯造型”，是由于类分层结构的历史排列方式造成的。若将一个Circle（圆）造型到一个Shape（几何形状），就叫做上溯造型，因为圆只是几何形状的一个子集。反之，若将Shape造型至Circle，就叫做下溯造型。然而，尽管我们明确知道Circle也是一个Shape，所以编译器能够自动上溯造型，但却不能保证一个Shape肯定是一个Circle。因此，编译器不允许自动下溯造型，除非明确指定一次这样的造型。\nRTTI在Java中存在三种形式。关键字instanceof告诉我们对象是不是一个特定类型的实例（Instance即“实例”）。它会返回一个布尔值，以便以问题的形式使用，就象下面这样：\nif(x instanceof Dog)\r((Dog)x).bark(); 将x造型至一个Dog前，上面的if语句会检查对象x是否从属于Dog类。进行造型前，如果没有其他信息可以告诉自己对象的类型，那么instanceof的使用是非常重要的——否则会得到一个ClassCastException违例。\n我们最一般的做法是查找一种类型（比如要变成紫色的三角形），但下面这个程序却演示了如何用instanceof标记出所有对象。\n//: PetCount.java // Using instanceof package c11.petcount; import java.util.*; class Pet {} class Dog extends Pet {} class Pug extends Dog {} class Cat extends Pet {} class Rodent extends Pet {} class Gerbil extends Rodent {} class Hamster extends Rodent {} class Counter { int i; } public class PetCount { static String[] typenames = { \u0026#34;Pet\u0026#34;, \u0026#34;Dog\u0026#34;, \u0026#34;Pug\u0026#34;, \u0026#34;Cat\u0026#34;, \u0026#34;Rodent\u0026#34;, \u0026#34;Gerbil\u0026#34;, \u0026#34;Hamster\u0026#34;, }; public static void main(String[] args) { Vector pets = new Vector(); try { Class[] petTypes = { Class.forName(\u0026#34;c11.petcount.Dog\u0026#34;), Class.forName(\u0026#34;c11.petcount.Pug\u0026#34;), Class.forName(\u0026#34;c11.petcount.Cat\u0026#34;), Class.forName(\u0026#34;c11.petcount.Rodent\u0026#34;), Class.forName(\u0026#34;c11.petcount.Gerbil\u0026#34;), Class.forName(\u0026#34;c11.petcount.Hamster\u0026#34;), }; for(int i = 0; i \u0026lt; 15; i++) pets.addElement( petTypes[ (int)(Math.random()*petTypes.length)] .newInstance()); } catch(InstantiationException e) {} catch(IllegalAccessException e) {} catch(ClassNotFoundException e) {} Hashtable h = new Hashtable(); for(int i = 0; i \u0026lt; typenames.length; i++) h.put(typenames[i], new Counter()); for(int i = 0; i \u0026lt; pets.size(); i++) { Object o = pets.elementAt(i); if(o instanceof Pet) ((Counter)h.get(\u0026#34;Pet\u0026#34;)).i++; if(o instanceof Dog) ((Counter)h.get(\u0026#34;Dog\u0026#34;)).i++; if(o instanceof Pug) ((Counter)h.get(\u0026#34;Pug\u0026#34;)).i++; if(o instanceof Cat) ((Counter)h.get(\u0026#34;Cat\u0026#34;)).i++; if(o instanceof Rodent) ((Counter)h.get(\u0026#34;Rodent\u0026#34;)).i++; if(o instanceof Gerbil) ((Counter)h.get(\u0026#34;Gerbil\u0026#34;)).i++; if(o instanceof Hamster) ((Counter)h.get(\u0026#34;Hamster\u0026#34;)).i++; } for(int i = 0; i \u0026lt; pets.size(); i++) System.out.println( pets.elementAt(i).getClass().toString()); for(int i = 0; i \u0026lt; typenames.length; i++) System.out.println( typenames[i] + \u0026#34; quantity: \u0026#34; + ((Counter)h.get(typenames[i])).i); } } ///:~ 在Java 1.0中，对instanceof有一个比较小的限制：只可将其与一个已命名的类型比较，不能同Class对象作对比。在上述例子中，大家可能觉得将所有那些instanceof表达式写出来是件很麻烦的事情。实际情况正是这样。但在Java 1.0中，没有办法让这一工作自动进行——不能创建Class的一个Vector，再将其与之比较。大家最终会意识到，如编写了数量众多的instanceof表达式，整个设计都可能出现问题。\n当然，这个例子只是一个构想——最好在每个类型里添加一个static数据成员，然后在构建器中令其增值，以便跟踪计数。编写程序时，大家可能想象自己拥有类的源码控制权，能够自由改动它。但由于实际情况并非总是这样，所以RTTI显得特别方便。\n使用类标记 PetCount.java示例可用Java 1.1的类标记重写一遍。得到的结果显得更加明确易懂：\n//: PetCount2.java // Using Java 1.1 class literals package c11.petcount2; import java.util.*; class Pet {} class Dog extends Pet {} class Pug extends Dog {} class Cat extends Pet {} class Rodent extends Pet {} class Gerbil extends Rodent {} class Hamster extends Rodent {} class Counter { int i; } public class PetCount2 { public static void main(String[] args) { Vector pets = new Vector(); Class[] petTypes = { // Class literals work in Java 1.1+ only: Pet.class, Dog.class, Pug.class, Cat.class, Rodent.class, Gerbil.class, Hamster.class, }; try { for(int i = 0; i \u0026lt; 15; i++) { // Offset by one to eliminate Pet.class: int rnd = 1 + (int)( Math.random() * (petTypes.length - 1)); pets.addElement( petTypes[rnd].newInstance()); } } catch(InstantiationException e) {} catch(IllegalAccessException e) {} Hashtable h = new Hashtable(); for(int i = 0; i \u0026lt; petTypes.length; i++) h.put(petTypes[i].toString(), new Counter()); for(int i = 0; i \u0026lt; pets.size(); i++) { Object o = pets.elementAt(i); if(o instanceof Pet) ((Counter)h.get( \u0026#34;class c11.petcount2.Pet\u0026#34;)).i++; if(o instanceof Dog) ((Counter)h.get( \u0026#34;class c11.petcount2.Dog\u0026#34;)).i++; if(o instanceof Pug) ((Counter)h.get( \u0026#34;class c11.petcount2.Pug\u0026#34;)).i++; if(o instanceof Cat) ((Counter)h.get( \u0026#34;class c11.petcount2.Cat\u0026#34;)).i++; if(o instanceof Rodent) ((Counter)h.get( \u0026#34;class c11.petcount2.Rodent\u0026#34;)).i++; if(o instanceof Gerbil) ((Counter)h.get( \u0026#34;class c11.petcount2.Gerbil\u0026#34;)).i++; if(o instanceof Hamster) ((Counter)h.get( \u0026#34;class c11.petcount2.Hamster\u0026#34;)).i++; } for(int i = 0; i \u0026lt; pets.size(); i++) System.out.println( pets.elementAt(i).getClass().toString()); Enumeration keys = h.keys(); while(keys.hasMoreElements()) { String nm = (String)keys.nextElement(); Counter cnt = (Counter)h.get(nm); System.out.println( nm.substring(nm.lastIndexOf(\u0026#39;.\u0026#39;) + 1) + \u0026#34; quantity: \u0026#34; + cnt.i); } } } ///:~ 在这里，typenames（类型名）数组已被删除，改为从Class对象里获取类型名称。注意为此而额外做的工作：例如，类名不是Getbil，而是c11.petcount2.Getbil，其中已包含了包的名字。也要注意系统是能够区分类和接口的。\n也可以看到，petTypes的创建模块不需要用一个try块包围起来，因为它会在编译期得到检查，不会象Class.forName()那样“掷”出任何违例。\nPet动态创建好以后，可以看到随机数字已得到了限制，位于1和petTypes.length之间，而且不包括零。那是由于零代表的是Pet.class，而且一个普通的Pet对象可能不会有人感兴趣。然而，由于Pet.class是petTypes的一部分，所以所有Pet（宠物）都会算入计数中。\n动态的instanceof Java 1.1为Class类添加了isInstance方法。利用它可以动态调用instanceof运算符。而在Java 1.0中，只能静态地调用它（就象前面指出的那样）。因此，所有那些烦人的instanceof语句都可以从PetCount例子中删去了。如下所示： //: PetCount3.java // Using Java 1.1 isInstance() package c11.petcount3; import java.util.*; class Pet {} class Dog extends Pet {} class Pug extends Dog {} class Cat extends Pet {} class Rodent extends Pet {} class Gerbil extends Rodent {} class Hamster extends Rodent {} class Counter { int i; } public class PetCount3 { public static void main(String[] args) { Vector pets = new Vector(); Class[] petTypes = { Pet.class, Dog.class, Pug.class, Cat.class, Rodent.class, Gerbil.class, Hamster.class, }; try { for(int i = 0; i \u0026lt; 15; i++) { // Offset by one to eliminate Pet.class: int rnd = 1 + (int)( Math.random() * (petTypes.length - 1)); pets.addElement( petTypes[rnd].newInstance()); } } catch(InstantiationException e) {} catch(IllegalAccessException e) {} Hashtable h = new Hashtable(); for(int i = 0; i \u0026lt; petTypes.length; i++) h.put(petTypes[i].toString(), new Counter()); for(int i = 0; i \u0026lt; pets.size(); i++) { Object o = pets.elementAt(i); // Using isInstance to eliminate individual // instanceof expressions: for (int j = 0; j \u0026lt; petTypes.length; ++j) if (petTypes[j].isInstance(o)) { String key = petTypes[j].toString(); ((Counter)h.get(key)).i++; } } for(int i = 0; i \u0026lt; pets.size(); i++) System.out.println( pets.elementAt(i).getClass().toString()); Enumeration keys = h.keys(); while(keys.hasMoreElements()) { String nm = (String)keys.nextElement(); Counter cnt = (Counter)h.get(nm); System.out.println( nm.substring(nm.lastIndexOf(\u0026#39;.\u0026#39;) + 1) + \u0026#34; quantity: \u0026#34; + cnt.i); } } } ///:~ 可以看到，Java 1.1的isInstance()方法已取消了对instanceof表达式的需要。此外，这也意味着一旦要求添加新类型宠物，只需简单地改变petTypes数组即可；毋需改动程序剩余的部分（但在使用instanceof时却是必需的）。\n11.2 RTTI语法 Java用Class对象实现自己的RTTI功能——即便我们要做的只是象造型那样的一些工作。Class类也提供了其他大量方式，以方便我们使用RTTI。\n首先必须获得指向适当Class对象的的一个句柄。就象前例演示的那样，一个办法是用一个字串以及Class.forName()方法。这是非常方便的，因为不需要那种类型的一个对象来获取Class句柄。然而，对于自己感兴趣的类型，如果已有了它的一个对象，那么为了取得Class句柄，可调用属于Object根类一部分的一个方法：getClass()。它的作用是返回一个特定的Class句柄，用来表示对象的实际类型。Class提供了几个有趣且较为有用的方法，从下例即可看出：\n//: ToyTest.java // Testing class Class interface HasBatteries {} interface Waterproof {} interface ShootsThings {} class Toy { // Comment out the following default // constructor to see // NoSuchMethodError from (*1*) Toy() {} Toy(int i) {} } class FancyToy extends Toy implements HasBatteries, Waterproof, ShootsThings { FancyToy() { super(1); } } public class ToyTest { public static void main(String[] args) { Class c = null; try { c = Class.forName(\u0026#34;FancyToy\u0026#34;); } catch(ClassNotFoundException e) {} printInfo(c); Class[] faces = c.getInterfaces(); for(int i = 0; i \u0026lt; faces.length; i++) printInfo(faces[i]); Class cy = c.getSuperclass(); Object o = null; try { // Requires default constructor: o = cy.newInstance(); // (*1*) } catch(InstantiationException e) {} catch(IllegalAccessException e) {} printInfo(o.getClass()); } static void printInfo(Class cc) { System.out.println( \u0026#34;Class name: \u0026#34; + cc.getName() + \u0026#34; is interface? [\u0026#34; + cc.isInterface() + \u0026#34;]\u0026#34;); } } ///:~ 从中可以看出，class FancyToy相当复杂，因为它从Toy中继承，并实现了HasBatteries，Waterproof以及ShootsThings的接口。在main()中创建了一个Class句柄，并用位于相应try块内的forName()初始化成FancyToy。\nClass.getInterfaces方法会返回Class对象的一个数组，用于表示包含在Class对象内的接口。 若有一个Class对象，也可以用getSuperclass()查询该对象的直接基础类是什么。当然，这种做会返回一个Class句柄，可用它作进一步的查询。这意味着在运行期的时候，完全有机会调查到对象的完整层次结构。\n若从表面看，Class的newInstance()方法似乎是克隆（clone()）一个对象的另一种手段。但两者是有区别的。利用newInstance()，我们可在没有现成对象供“克隆”的情况下新建一个对象。就象上面的程序演示的那样，当时没有Toy对象，只有cy——即y的Class对象的一个句柄。利用它可以实现“虚拟构建器”。换言之，我们表达：“尽管我不知道你的准确类型是什么，但请你无论如何都正确地创建自己。”在上述例子中，cy只是一个Class句柄，编译期间并不知道进一步的类型信息。一旦新建了一个实例后，可以得到Object句柄。但那个句柄指向一个Toy对象。当然，如果要将除Object能够接收的其他任何消息发出去，首先必须进行一些调查研究，再进行造型。除此以外，用newInstance()创建的类必须有一个默认构建器。没有办法用newInstance()创建拥有非默认构建器的对象，所以在Java 1.0中可能存在一些限制。然而，Java 1.1的“反射”API（下一节讨论）却允许我们动态地使用类里的任何构建器。\n程序中的最后一个方法是printInfo()，它取得一个Class句柄，通过getName()获得它的名字，并用interface()调查它是不是一个接口。\n该程序的输出如下：\nClass name: FancyToy is interface? [false]\rClass name: HasBatteries is interface? [true]\rClass name: Waterproof is interface? [true]\rClass name: ShootsThings is interface? [true]\rClass name: Toy is interface? [false] 所以利用Class对象，我们几乎能将一个对象的祖宗十八代都调查出来。\n总结：\n理解RTTI在Java里如何工作，首先必须了解类型信息在运行期是如何表示的。这时要用到一个名为“Class对象”的特殊形式的对象，其中包含了与类有关的信息（有时也把它叫作“元类”）。事实上，我们要用Class对象创建属于某个类的全部“常规”或“普通”对象。\n11.3 反射：运行期类信息 如果不知道一个对象的准确类型，RTTI会帮助我们调查。但却有一个限制：类型必须是在编译期间已知的，否则就不能用RTTI调查它，进而无法展开下一步的工作。换言之，编译器必须明确知道RTTI要处理的所有类。\n从表面看，这似乎并不是一个很大的限制，但假若得到的是一个不在自己程序空间内的对象的句柄，这时又会怎样呢？事实上，对象的类即使在编译期间也不可由我们的程序使用。例如，假设我们从磁盘或者网络获得一系列字节，而且被告知那些字节代表一个类。由于编译器在编译代码时并不知道那个类的情况，所以怎样才能顺利地使用这个类呢？\n在传统的程序设计环境中，出现这种情况的概率或许很小。但当我们转移到一个规模更大的编程世界中，却必须对这个问题加以高度重视。第一个要注意的是基于组件的程序设计。在这种环境下，我们用“快速应用开发”（RAD）模型来构建程序项目。RAD一般是在应用程序构建工具中内建的。这是编制程序的一种可视途径（在屏幕上以窗体的形式出现）。可将代表不同组件的图标拖曳到窗体中。随后，通过设定这些组件的属性或者值，进行正确的配置。设计期间的配置要求任何组件都是可以“例示”的（即可以自由获得它们的实例）。这些组件也要揭示出自己的一部分内容，允许程序员读取和设置各种值。此外，用于控制GUI事件的组件必须揭示出与相应的方法有关的信息，以便RAD环境帮助程序员用自己的代码覆盖这些由事件驱动的方法。“反射”提供了一种特殊的机制，可以侦测可用的方法，并产生方法名。通过Java Beans（第13章将详细介绍），Java 1.1为这种基于组件的程序设计提供了一个基础结构。\n在运行期查询类信息的另一个原动力是通过网络创建与执行位于远程系统上的对象。这就叫作“远程方法调用”（RMI），它允许Java程序（版本1.1以上）使用由多台机器发布或分布的对象。这种对象的分布可能是由多方面的原因引起的：可能要做一件计算密集型的工作，想对它进行分割，让处于空闲状态的其他机器分担部分工作，从而加快处理进度。某些情况下，可能需要将用于控制特定类型任务（比如多层客户／服务器架构中的“运作规则”）的代码放置在一台特殊的机器上，使这台机器成为对那些行动进行描述的一个通用储藏所。而且可以方便地修改这个场所，使其对系统内的所有方面产生影响（这是一种特别有用的设计思路，因为机器是独立存在的，所以能轻易修改软件！）。分布式计算也能更充分地发挥某些专用硬件的作用，它们特别擅长执行一些特定的任务——例如矩阵逆转——但对常规编程来说却显得太夸张或者太昂贵了。\n在Java 1.1中，Class类（本章前面已有详细论述）得到了扩展，可以支持“反射”的概念。针对Field，Method以及Constructor类（每个都实现了Memberinterface——成员接口），它们都新增了一个库：java.lang.reflect。这些类型的对象都是JVM在运行期创建的，用于代表未知类里对应的成员。这样便可用构建器创建新对象，用get()和set()方法读取和修改与Field对象关联的字段，以及用invoke()方法调用与Method对象关联的方法。此外，我们可调用方法getFields()，getMethods()，getConstructors()，分别返回用于表示字段、方法以及构建器的对象数组（在联机文档中，还可找到与Class类有关的更多的资料）。因此，匿名对象的类信息可在运行期被完整的揭露出来，而在编译期间不需要知道任何东西。 大家要认识的很重要的一点是“反射”并没有什么神奇的地方。通过“反射”同一个未知类型的对象打交道时，JVM只是简单地检查那个对象，并调查它从属于哪个特定的类（就象以前的RTTI那样）。但在这之后，在我们做其他任何事情之前，Class对象必须载入。因此，用于那种特定类型的.class文件必须能由JVM调用（要么在本地机器内，要么可以通过网络取得）。\n所以RTTI和“反射”之间唯一的区别就是对RTTI来说，编译器会在编译期打开和检查.class文件。换句话说，我们可以用“普通”方式调用一个对象的所有方法；但对“反射”来说，.class文件在编译期间是不可使用的，而是由运行期环境打开和检查。\n11.3.1 一个类方法提取器 很少需要直接使用反射工具；之所以在语言中提供它们，仅仅是为了支持其他Java特性，比如对象序列化（第10章介绍）、Java Beans以及RMI（本章后面介绍）。但是，我们许多时候仍然需要动态提取与一个类有关的资料。其中特别有用的工具便是一个类方法提取器。正如前面指出的那样，若检视类定义源码或者联机文档，只能看到在那个类定义中被定义或覆盖的方法，基础类那里还有大量资料拿不到。幸运的是，“反射”做到了这一点，可用它写一个简单的工具，令其自动展示整个接口。下面便是具体的程序：\n//: ShowMethods.java // Using Java 1.1 reflection to show all the // methods of a class, even if the methods are // defined in the base class. import java.lang.reflect.*; public class ShowMethods { static final String usage = \u0026#34;usage: \\n\u0026#34; + \u0026#34;ShowMethods qualified.class.name\\n\u0026#34; + \u0026#34;To show all methods in class or: \\n\u0026#34; + \u0026#34;ShowMethods qualified.class.name word\\n\u0026#34; + \u0026#34;To search for methods involving \u0026#39;word\u0026#39;\u0026#34;; public static void main(String[] args) { if(args.length \u0026lt; 1) { System.out.println(usage); System.exit(0); } try { Class c = Class.forName(args[0]); Method[] m = c.getMethods(); Constructor[] ctor = c.getConstructors(); if(args.length == 1) { for (int i = 0; i \u0026lt; m.length; i++) System.out.println(m[i].toString()); for (int i = 0; i \u0026lt; ctor.length; i++) System.out.println(ctor[i].toString()); } else { for (int i = 0; i \u0026lt; m.length; i++) if(m[i].toString() .indexOf(args[1])!= -1) System.out.println(m[i].toString()); for (int i = 0; i \u0026lt; ctor.length; i++) if(ctor[i].toString() .indexOf(args[1])!= -1) System.out.println(ctor[i].toString()); } } catch (ClassNotFoundException e) { System.out.println(\u0026#34;No such class: \u0026#34; + e); } } } ///:~ Class方法getMethods()和getConstructors()可以分别返回Method和Constructor的一个数组。每个类都提供了进一步的方法，可解析出它们所代表的方法的名字、参数以及返回值。但也可以象这样一样只使用toString()，生成一个含有完整方法签名的字串。代码剩余的部分只是用于提取命令行信息，判断特定的签名是否与我们的目标字串相符（使用indexOf()），并打印出结果。\n这里便用到了“反射”技术，因为由Class.forName()产生的结果不能在编译期间获知，所以所有方法签名信息都会在运行期间提取。若研究一下联机文档中关于“反射”（Reflection）的那部分文字，就会发现它已提供了足够多的支持，可对一个编译期完全未知的对象进行实际的设置以及发出方法调用。同样地，这也属于几乎完全不用我们操心的一个步骤——Java自己会利用这种支持，所以程序设计环境能够控制Java Beans——但它无论如何都是非常有趣的。\n一个有趣的试验是运行java ShowMehods ShowMethods。这样做可得到一个列表，其中包括一个public默认构建器，尽管我们在代码中看见并没有定义一个构建器。我们看到的是由编译器自动合成的那一个构建器。如果随之将ShowMethods设为一个非public类（即换成“友好”类），合成的默认构建器便不会在输出结果中出现。合成的默认构建器会自动获得与类一样的访问权限。 ShowMethods的输出仍然有些“不爽”。例如，下面是通过调用java ShowMethods java.lang.String得到的输出结果的一部分：\npublic boolean java.lang.String.startsWith(java.lang.String,int)\rpublic boolean java.lang.String.startsWith(java.lang.String)\rpublic boolean\rjava.lang.String.endsWith(java.lang.String) 若能去掉象java.lang这样的限定词，结果显然会更令人满意。有鉴于此，可引入上一章介绍的StreamTokenizer类，解决这个问题：\n//: ShowMethodsClean.java // ShowMethods with the qualifiers stripped // to make the results easier to read import java.lang.reflect.*; import java.io.*; public class ShowMethodsClean { static final String usage = \u0026#34;usage: \\n\u0026#34; + \u0026#34;ShowMethodsClean qualified.class.name\\n\u0026#34; + \u0026#34;To show all methods in class or: \\n\u0026#34; + \u0026#34;ShowMethodsClean qualif.class.name word\\n\u0026#34; + \u0026#34;To search for methods involving \u0026#39;word\u0026#39;\u0026#34;; public static void main(String[] args) { if(args.length \u0026lt; 1) { System.out.println(usage); System.exit(0); } try { Class c = Class.forName(args[0]); Method[] m = c.getMethods(); Constructor[] ctor = c.getConstructors(); // Convert to an array of cleaned Strings: String[] n = new String[m.length + ctor.length]; for(int i = 0; i \u0026lt; m.length; i++) { String s = m[i].toString(); n[i] = StripQualifiers.strip(s); } for(int i = 0; i \u0026lt; ctor.length; i++) { String s = ctor[i].toString(); n[i + m.length] = StripQualifiers.strip(s); } if(args.length == 1) for (int i = 0; i \u0026lt; n.length; i++) System.out.println(n[i]); else for (int i = 0; i \u0026lt; n.length; i++) if(n[i].indexOf(args[1])!= -1) System.out.println(n[i]); } catch (ClassNotFoundException e) { System.out.println(\u0026#34;No such class: \u0026#34; + e); } } } class StripQualifiers { private StreamTokenizer st; public StripQualifiers(String qualified) { st = new StreamTokenizer( new StringReader(qualified)); st.ordinaryChar(\u0026#39; \u0026#39;); // Keep the spaces } public String getNext() { String s = null; try { if(st.nextToken() != StreamTokenizer.TT_EOF) { switch(st.ttype) { case StreamTokenizer.TT_EOL: s = null; break; case StreamTokenizer.TT_NUMBER: s = Double.toString(st.nval); break; case StreamTokenizer.TT_WORD: s = new String(st.sval); break; default: // single character in ttype s = String.valueOf((char)st.ttype); } } } catch(IOException e) { System.out.println(e); } return s; } public static String strip(String qualified) { StripQualifiers sq = new StripQualifiers(qualified); String s = \u0026#34;\u0026#34;, si; while((si = sq.getNext()) != null) { int lastDot = si.lastIndexOf(\u0026#39;.\u0026#39;); if(lastDot != -1) si = si.substring(lastDot + 1); s += si; } return s; } } ///:~ ShowMethodsClean方法非常接近前一个ShowMethods，只是它取得了Method和Constructor数组，并将它们转换成单个String数组。随后，每个这样的String对象都在StripQualifiers.Strip()里“过”一遍，删除所有方法限定词。正如大家看到的那样，此时用到了StreamTokenizer和String来完成这个工作。\n假如记不得一个类是否有一个特定的方法，而且不想在联机文档里逐步检查类结构，或者不知道那个类是否能对某个对象（如Color对象）做某件事情，该工具便可节省大量编程时间。\n第17章提供了这个程序的一个GUI版本，可在自己写代码的时候运行它，以便快速查找需要的东西。\n11.4 总结 利用RTTI可根据一个匿名的基础类句柄调查出类型信息。但正是由于这个原因，新手们极易误用它，因为有些时候多形性方法便足够了。对那些以前习惯程序化编程的人来说，极易将他们的程序组织成一系列switch语句。他们可能用RTTI做到这一点，从而在代码开发和维护中损失多形性技术的重要价值。Java的要求是让我们尽可能地采用多形性，只有在极特别的情况下才使用RTTI。 但为了利用多形性，要求我们拥有对基础类定义的控制权，因为有些时候在程序范围之内，可能发现基础类并未包括我们想要的方法。若基础类来自一个库，或者由别的什么东西控制着，RTTI便是一种很好的解决方案：可继承一个新类型，然后添加自己的额外方法。在代码的其他地方，可以侦测自己的特定类型，并调用那个特殊的方法。这样做不会破坏多形性以及程序的扩展能力，因为新类型的添加不要求查找程序中的switch语句。但在需要新特性的主体中添加新代码时，就必须用RTTI侦测自己特定的类型。\n从某个特定类的利益的角度出发，在基础类里加入一个特性后，可能意味着从那个基础类衍生的其他所有类都必须获得一些无意义的“鸡肋”。这使得接口变得含义模糊。若有人从那个基础类继承，且必须覆盖抽象方法，这一现象便会使他们陷入困扰。比如现在用一个类结构来表示乐器（Instrument）。假定我们想清洁管弦乐队中所有适当乐器的通气音栓（Spit Valve），此时的一个办法是在基础类Instrument中置入一个ClearSpitValve()方法。但这样做会造成一个误区，因为它暗示着打击乐器和电子乐器中也有音栓。针对这种情况，RTTI提供了一个更合理的解决方案，可将方法置入特定的类中（此时是Wind，即“通气口”）——这样做是可行的。但事实上一种更合理的方案是将prepareInstrument()置入基础类中。初学者刚开始时往往看不到这一点，一般会认定自己必须使用RTTI。\n最后，RTTI有时能解决效率问题。若代码大量运用了多形性，但其中的一个对象在执行效率上很有问题，便可用RTTI找出那个类型，然后写一段适当的代码，改进其效率。\n11.5 练习 第12章 传递和返回对象 到目前为止，读者应对对象的“传递”有了一个较为深刻的认识，记住实际传递的只是一个句柄。\n在许多程序设计语言中，我们可用语言的“普通”方式到处传递对象，而且大多数时候都不会遇到问题。但有些时候却不得不采取一些非常做法，使得情况突然变得稍微复杂起来（在C++中则是变得非常复杂）。Java亦不例外，我们十分有必要准确认识在对象传递和赋值时所发生的一切。这正是本章的宗旨。\n若读者是从某些特殊的程序设计环境中转移过来的，那么一般都会问到：“Java有指针吗？”有些人认为指针的操作很困难，而且十分危险，所以一厢情愿地认为它没有好处。同时由于Java有如此好的口碑，所以应该很轻易地免除自己以前编程中的麻烦，其中不可能夹带有指针这样的“危险品”。然而准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有“戒心”，运行期系统也不例外。或者换从另一个角度说，Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做“句柄”，但你可以把它想像成“安全指针”。和预备学校为学生提供的安全剪刀类似——除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。\n12.1 传递句柄 将句柄传递进入一个方法时，指向的仍然是相同的对象。\n可以在调用方法前和在方法中打印对象，可以看出是一个对象。\n12.1.1 别名问题 “别名”意味着多个句柄都试图指向同一个对象，就象前面的例子展示的那样。若有人向那个对象里写入一点什么东西，就会产生别名问题。若其他句柄的所有者不希望那个对象改变，恐怕就要失望了。\n此时最直接的一个解决办法就是干脆不这样做：不要有意将多个句柄指向同一个作用域内的同一个对象。这样做可使代码更易理解和调试。然而，一旦准备将句柄作为一个自变量或参数传递——这是Java设想的正常方法——别名问题就会自动出现，因为创建的本地句柄可能修改“外部对象”（在方法作用域之外创建的对象）。\n方法改变了自己的参数——外部对象。一旦遇到这种情况，必须判断它是否合理，用户是否愿意这样，以及是不是会造成问题。 通常，我们调用一个方法是为了产生返回值，或者用它改变为其调用方法的那个对象的状态（方法其实就是我们向那个对象“发一条消息”的方式）。很少需要调用一个方法来处理它的参数；这叫作利用方法的“副作用”（Side Effect）。所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。 若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。\n12.2 制作本地副本 Java中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，实际传递的只是指向位于方法外部的那个对象的“一个句柄”。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：\n■参数传递过程中会自动产生别名问题 ■不存在本地对象，只有本地句柄 ■句柄有自己的作用域，而对象没有 ■对象的“存在时间”在Java里不是个问题 ■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用） 若只是从对象中读取信息，而不修改它，传递句柄便是自变量传递中最有效的一种形式。 这种做非常恰当；默认的方法一般也是最有效的方法。然而，有时仍需将对象当作“本地的”对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响。许多程序设计语言都支持在方法内自动生成外部对象的一个本地副本（注释①）。尽管Java不具备这种能力，但允许我们达到同样的效果。\n①：在C语言中，通常控制的是少量数据位，默认操作是按值传递。C++也必须遵照这一形式，但按值传递对象并非肯定是一种有效的方式。此外，在C++中用于支持按值传递的代码也较难编写，是件让人头痛的事情。\n12.2.1 按值传递 首先要解决术语的问题，最适合“按值传递”的看起来是自变量。“按值传递”以及它的含义取决于如何理解程序的运行方式。最常见的意思是获得要传递的任何东西的一个本地副本，但这里真正的问题是如何看待自己准备传递的东西。对于“按值传递”的含义，目前存在两种存在明显区别的见解：\n(1) Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。但若将一个句柄传递进入方法，得到的是句柄的副本。所以人们认为“一切”都按值传递。当然，这种说法也有一个前提：句柄肯定也会被传递。但Java的设计方案似乎有些超前，允许我们忽略（大多数时候）自己处理的是一个句柄。也就是说，它允许我们将句柄假想成“对象”，因为在发出方法调用时，系统会自动照管两者间的差异。 (2) Java主要按值传递（无自变量），但对象却是按引用传递的。得到这个结论的前提是句柄只是对象的一个“别名”，所以不考虑传递句柄的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它“保留但未实现”的关键字之一便是byvalue（按值）。但没人知道那个关键字什么时候可以发挥作用。 尽管存在两种不同的见解，但其间的分歧归根到底是由于对“句柄”的不同解释造成的。我打算在本书剩下的部分里回避这个问题。大家不久就会知道，这个问题争论下去其实是没有意义的——最重要的是理解一个句柄的传递会使调用者的对象发生意外的改变。 12.2.2 克隆对象 若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用clone()方法即可。Clone是“克隆”的意思，即制作完全一模一样的副本。这个方法在基础类Object中定义成“protected”（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为“public”模式。例如，标准库类Vector覆盖了clone()，所以能为Vector调用clone()，\nclone()方法产生了一个Object，后者必须立即重新造型为正确类型。这个例子指出Vector的clone()方法不能自动尝试克隆Vector内包含的每个对象——由于别名问题，老的Vector和克隆的Vector都包含了相同的对象。我们通常把这种情况叫作“简单复制”或者“浅层复制”，因为它只复制了一个对象的“表面”部分。实际对象除包含这个“表面”以外，还包括句柄指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是“对象网”或“对象关系网”的由来。若能复制下所有这张网，便叫作“全面复制”或者“深层复制”。\n一般来说，由于不敢保证Vector里包含的对象是“可以克隆”（注释②）的，所以最好不要试图克隆那些对象。\n②：“可以克隆”用英语讲是cloneable，请留意Java库中专门保留了这样的一个关键字。\n12.2.3 使类具有克隆能力 尽管克隆方法是在所有类最基本的Object中定义的，但克隆仍然不会在每个类里自动进行。这似乎有些不可思议，因为基础类方法在衍生类里是肯定能用的。但Java确实有点儿反其道而行之；如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行。\n使用protected时的技巧 为避免我们创建的每个类都默认具有克隆能力，clone()方法在基础类Object里得到了“保留”（设为protected）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用clone()（尽管那样做在某些情况下特别有用，比如用多形性的方式克隆一系列对象）。在编译期的时候，这实际是通知我们对象不可克隆的一种方式——而且最奇怪的是，Java库中的大多数类都不能克隆。因此，假如我们执行下述代码： Integer x = new Integer(l); x = x.clone(); 那么在编译期，就有一条讨厌的错误消息弹出，告诉我们不可访问clone()——因为Integer并没有覆盖它，而且它对protected版本来说是默认的）。 但是，假若我们是在一个从Object衍生出来的类中（所有类都是从Object衍生的），就有权调用Object.clone()，因为它是“protected”，而且我们在一个继承器中。基础类clone()提供了一个有用的功能——它进行的是对衍生类对象的真正“按位”复制，所以相当于标准的克隆行动。然而，我们随后需要将自己的克隆操作设为public，否则无法访问。总之，克隆时要注意的两个关键问题是：几乎肯定要调用super.clone()，以及注意将克隆设为public。 有时还想在更深层的衍生类中覆盖clone()，否则就直接使用我们的clone()（现在已成为public），而那并不一定是我们所希望的（然而，由于Object.clone()已制作了实际对象的一个副本，所以也有可能允许这种情况）。protected的技巧在这里只能用一次：首次从一个不具备克隆能力的类继承，而且想使一个类变成“能够克隆”。而在从我们的类继承的任何场合，clone()方法都是可以使用的，因为Java不可能在衍生之后反而缩小方法的访问范围。换言之，一旦对象变得可以克隆，从它衍生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其“关闭”克隆能力。\n实现Cloneable接口 为使一个对象的克隆能力功成圆满，还需要做另一件事情：实现Cloneable接口。这个接口使人稍觉奇怪，因为它是空的！ interface Cloneable {} 之所以要实现这个空接口，显然不是因为我们准备上溯造型成一个Cloneable，以及调用它的某个方法。有些人认为在这里使用接口属于一种“欺骗”行为，因为它使用的特性打的是别的主意，而非原来的意思。Cloneable interface的实现扮演了一个标记的角色，封装到类的类型中。 两方面的原因促成了Cloneable interface的存在。首先，可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用instanceof关键字（第11章有介绍）调查句柄是否确实同一个能克隆的对象连接： if(myHandle instanceof Cloneable) // \u0026hellip; 第二个原因是考虑到我们可能不愿所有对象类型都能克隆。所以Object.clone()会验证一个类是否真的是实现了Cloneable接口。若答案是否定的，则“掷”出一个CloneNotSupportedException违例。所以在一般情况下，我们必须将“implement Cloneable”作为对克隆能力提供支持的一部分。\n12.2.4 成功的克隆 理解了实现clone()方法背后的所有细节后，便可创建出能方便复制的类，以便提供了一个本地副本:\n//: LocalCopy.java // Creating local copies with clone() import java.util.*; class MyObject implements Cloneable { int i; MyObject(int ii) { i = ii; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { System.out.println(\u0026#34;MyObject can\u0026#39;t clone\u0026#34;); } return o; } public String toString() { return Integer.toString(i); } } public class LocalCopy { static MyObject g(MyObject v) { // Passing a handle, modifies outside object: v.i++; return v; } static MyObject f(MyObject v) { v = (MyObject)v.clone(); // Local copy v.i++; return v; } public static void main(String[] args) { MyObject a = new MyObject(11); MyObject b = g(a); // Testing handle equivalence, // not object equivalence: if(a == b) System.out.println(\u0026#34;a == b\u0026#34;); else System.out.println(\u0026#34;a != b\u0026#34;); System.out.println(\u0026#34;a = \u0026#34; + a); System.out.println(\u0026#34;b = \u0026#34; + b); MyObject c = new MyObject(47); MyObject d = f(c); if(c == d) System.out.println(\u0026#34;c == d\u0026#34;); else System.out.println(\u0026#34;c != d\u0026#34;); System.out.println(\u0026#34;c = \u0026#34; + c); System.out.println(\u0026#34;d = \u0026#34; + d); } } ///:~ 不管怎样，clone()必须能够访问，所以必须将其设为public（公共的）。其次，作为clone()的初期行动，应调用clone()的基础类版本。这里调用的clone()是Object内部预先定义好的。之所以能调用它，是由于它具有protected（受到保护的）属性，所以能在衍生的类里访问。 Object.clone()会检查原先的对象有多大，再为新对象腾出足够多的内存，将所有二进制位从原来的对象复制到新对象。这叫作“按位复制”，而且按一般的想法，这个工作应该是由clone()方法来做的。但在Object.clone()正式开始操作前，首先会检查一个类是否Cloneable，即是否具有克隆能力——换言之，它是否实现了Cloneable接口。若未实现，Object.clone()就掷出一个CloneNotSupportedException违例，指出我们不能克隆它。因此，我们最好用一个try-catch块将对super.clone()的调用代码包围（或封装）起来，试图捕获一个应当永不出现的违例（因为这里确实已实现了Cloneable接口）。 在LocalCopy中，两个方法g()和f()揭示出两种参数传递方法间的差异。其中，g()演示的是按引用传递，它会修改外部对象，并返回对那个外部对象的一个引用。而f()是对自变量进行克隆，所以将其分离出来，并让原来的对象保持独立。随后，它继续做它希望的事情。甚至能返回指向这个新对象的一个句柄，而且不会对原来的对象产生任何副作用。注意下面这个多少有些古怪的语句： v = (MyObject)v.clone(); 它的作用正是创建一个本地副本。为避免被这样的一个语句搞混淆，记住这种相当奇怪的编码形式在Java中是完全允许的，因为有一个名字的所有东西实际都是一个句柄。所以句柄v用于克隆一个它所指向的副本，而且最终返回指向基础类型Object的一个句柄（因为它在Object.clone()中是那样被定义的），随后必须将其造型为正确的类型。 在main()中，两种不同参数传递方式的区别在于它们分别测试了一个不同的方法。输出结果如下：\na == b a = 12 b = 12 c != d c = 47 d = 48 大家要记住这样一个事实：Java对“是否等价”的测试并不对所比较对象的内部进行检查，从而核实它们的值是否相同。==和!=运算符只是简单地对比句柄的内容。若句柄内的地址相同，就认为句柄指向同样的对象，所以认为它们是“等价”的。所以运算符真正检测的是“由于别名问题，句柄是否指向同一个对象？”\n12.2.5 Object.clone()的效果 调用Object.clone()时，实际发生的是什么事情呢？当我们在自己的类里覆盖clone()时，什么东西对于super.clone()来说是最关键的呢？根类中的clone()方法负责建立正确的存储容量，并通过“按位复制”将二进制位从原始对象中复制到新对象的存储空间。也就是说，它并不只是预留存储空间以及复制一个对象——实际需要调查出欲复制之对象的准确大小，然后复制那个对象。由于所有这些工作都是在由根类定义之clone()方法的内部代码中进行的（根类并不知道要从自己这里继承出去什么），所以大家或许已经猜到，这个过程需要用RTTI判断欲克隆的对象的实际大小。采取这种方式，clone()方法便可建立起正确数量的存储空间，并对那个类型进行正确的按位复制。 不管我们要做什么，克隆过程的第一个部分通常都应该是调用super.clone()。通过进行一次准确的复制，这样做可为后续的克隆进程建立起一个良好的基础。随后，可采取另一些必要的操作，以完成最终的克隆。 为确切了解其他操作是什么，首先要正确理解Object.clone()为我们带来了什么。特别地，它会自动克隆所有句柄指向的目标吗？下面这个例子可完成这种形式的检测：\n//: Snake.java // Tests cloning to see if destination of // handles are also cloned. public class Snake implements Cloneable { private Snake next; private char c; // Value of i == number of segments Snake(int i, char x) { c = x; if(--i \u0026gt; 0) next = new Snake(i, (char)(x + 1)); } void increment() { c++; if(next != null) next.increment(); } public String toString() { String s = \u0026#34;:\u0026#34; + c; if(next != null) s += next.toString(); return s; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { } return o; } public static void main(String[] args) { Snake s = new Snake(5, \u0026#39;a\u0026#39;); System.out.println(\u0026#34;s = \u0026#34; + s); Snake s2 = (Snake)s.clone(); System.out.println(\u0026#34;s2 = \u0026#34; + s2); s.increment(); System.out.println( \u0026#34;after s.increment, s2 = \u0026#34; + s2); } } ///:~ 一条Snake（蛇）由数段构成，每一段的类型都是Snake。所以，这是一个一段段链接起来的列表。所有段都是以循环方式创建的，每做好一段，都会使第一个构建器参数的值递减，直至最终为零。而为给每段赋予一个独一无二的标记，第二个参数（一个Char）的值在每次循环构建器调用时都会递增。 increment()方法的作用是循环递增每个标记，使我们能看到发生的变化；而toString则循环打印出每个标记。输出如下：\ns = :a:b:c:d:e s2 = :a:b:c:d:e after s.increment, s2 = :a:c:d:e:f 这意味着只有第一段才是由Object.clone()复制的，所以此时进行的是一种“浅层复制”。若希望复制整条蛇——即进行“深层复制”——必须在被覆盖的clone()里采取附加的操作。 通常可在从一个能克隆的类里调用super.clone()，以确保所有基础类行动（包括Object.clone()）能够进行。随着是为对象内每个句柄都明确调用一个clone()；否则那些句柄会别名变成原始对象的句柄。构建器的调用也大致相同——首先构造基础类，然后是下一个衍生的构建器……以此类推，直到位于最深层的衍生构建器。区别在于clone()并不是个构建器，所以没有办法实现自动克隆。为了克隆，必须由自己明确进行。\n12.2.6 克隆合成对象 试图深层复制合成对象时会遇到一个问题。必须假定成员对象中的clone()方法也能依次对自己的句柄进行深层复制，以此类推。这使我们的操作变得复杂。为了能正常实现深层复制，必须对所有类中的代码进行控制，或者至少全面掌握深层复制中需要涉及的类，确保它们自己的深层复制能正确进行。 下面这个例子总结了面对一个合成对象进行深层复制时需要做哪些事情：\n//: DeepCopy.java // Cloning a composed object class DepthReading implements Cloneable { private double depth; public DepthReading(double depth) { this.depth = depth; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } class TemperatureReading implements Cloneable { private long time; private double temperature; public TemperatureReading(double temperature) { time = System.currentTimeMillis(); this.temperature = temperature; } public Object clone() { Object o = null; try { o = super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return o; } } class OceanReading implements Cloneable { private DepthReading depth; private TemperatureReading temperature; public OceanReading(double tdata, double ddata){ temperature = new TemperatureReading(tdata); depth = new DepthReading(ddata); } public Object clone() { OceanReading o = null; try { o = (OceanReading)super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } // Must clone handles: o.depth = (DepthReading)o.depth.clone(); o.temperature = (TemperatureReading)o.temperature.clone(); return o; // Upcasts back to Object } } public class DeepCopy { public static void main(String[] args) { OceanReading reading = new OceanReading(33.9, 100.5); // Now clone it: OceanReading r = (OceanReading)reading.clone(); } } ///:~ DepthReading和TemperatureReading非常相似；它们都只包含了基本数据类型。所以clone()方法能够非常简单：调用super.clone()并返回结果即可。注意两个类使用的clone()代码是完全一致的。 OceanReading是由DepthReading和TemperatureReading对象合并而成的。为了对其进行深层复制，clone()必须同时克隆OceanReading内的句柄。为达到这个目标，super.clone()的结果必须造型成一个OceanReading对象（以便访问depth和temperature句柄）。\n12.2.7 用Vector进行深层复制 Int3自Int2继承而来，并添加了一个新的基本类型成员int j。大家也许认为自己需要再次覆盖clone()，以确保j得到复制，但实情并非如此。将Int2的clone()当作Int3的clone()调用时，它会调用Object.clone()，判断出当前操作的是Int3，并复制Int3内的所有二进制位。只要没有新增需要克隆的句柄，对Object.clone()的一个调用就能完成所有必要的复制——无论clone()是在层次结构多深的一级定义的。 至此，大家可以总结出对Vector进行深层复制的先决条件：在克隆了Vector后，必须在其中遍历，并克隆由Vector指向的每个对象。为了对Hashtable（散列表）进行深层复制，也必须采取类似的处理。 这个例子剩余的部分显示出克隆已实际进行——证据就是在克隆了对象以后，可以自由改变它，而原来那个对象不受任何影响。\n12.2.8 通过序列化进行深层复制 若研究一下第10章介绍的那个Java 1.1对象序列化示例，可能发现若在一个对象序列化以后再撤消对它的序列化，或者说进行装配，那么实际经历的正是一个“克隆”的过程。 那么为什么不用序列化进行深层复制呢？ 其中，Thing2和Thing4包含了成员对象，所以需要进行一些深层复制。一个有趣的地方是尽管Serializable类很容易设置，但在复制它们时却要做多得多的工作。克隆涉及到大量的类设置工作，但实际的对象复制是相当简单的。结果很好地说明了一切。下面是几次运行分别得到的结果： Duplication via serialization: 3400 Milliseconds Duplication via cloning: 110 Milliseconds Duplication via serialization: 3410 Milliseconds Duplication via cloning: 110 Milliseconds Duplication via serialization: 3520 Milliseconds Duplication via cloning: 110 Milliseconds 除了序列化和克隆之间巨大的时间差异以外，我们也注意到序列化技术的运行结果并不稳定，而克隆每一次花费的时间都是相同的。\n12.2.9 使克隆具有更大的深度 若新建一个类，它的基础类会默认为Object，并默认为不具备克隆能力（就象在下一节会看到的那样）。只要不明确地添加克隆能力，这种能力便不会自动产生。但我们可以在任何层添加它，然后便可从那个层开始向下具有克隆能力。\n添加克隆能力之前，编译器会阻止我们的克隆尝试。一旦在Scientist里添加了克隆能力，那么Scientist以及它的所有“后裔”都可以克隆。\n12.2.10 为什么有这个奇怪的设计 之所以感觉这个方案的奇特，因为它事实上的确如此。也许大家会奇怪它为什么要象这样运行，而该方案背后的真正含义是什么呢？后面讲述的是一个未获证实的故事——大概是由于围绕Java的许多买卖使其成为一种设计优良的语言——但确实要花许多口舌才能讲清楚这背后发生的所有事情。 最初，Java只是作为一种用于控制硬件的语言而设计，与因特网并没有丝毫联系。象这样一类面向大众的语言一样，其意义在于程序员可以对任意一个对象进行克隆。这样一来，clone()就放置在根类Object里面，但因为它是一种公用方式，因而我们通常能够对任意一个对象进行克隆。看来这是最灵活的方式了，毕竟它不会带来任何害处。 正当Java看起来象一种终级因特网程序设计语言的时候，情况却发生了变化。突然地，人们提出了安全问题，而且理所当然，这些问题与使用对象有关，我们不愿望任何人克隆自己的保密对象。所以我们最后看到的是为原来那个简单、直观的方案添加的大量补丁：clone()在Object里被设置成“protected”。必须将其覆盖，并使用“implement Cloneable”，同时解决违例的问题。 只有在准备调用Object的clone()方法时，才没有必要使用Cloneable接口，因为那个方法会在运行期间得到检查，以确保我们的类实现了Cloneable。但为了保持连贯性（而且由于Cloneable无论如何都是空的），最好还是由自己实现Cloneable。\n12.3 克隆的控制 为消除克隆能力，大家也许认为只需将clone()方法简单地设为private（私有）即可，但这样是行不通的，因为不能采用一个基础类方法，并使其在衍生类中更“私有”。所以事情并没有这么简单。此外，我们有必要控制一个对象是否能够克隆。对于我们设计的一个类，实际有许多种方案都是可以采取的：\n(1) 保持中立，不为克隆做任何事情。也就是说，尽管不可对我们的类克隆，但从它继承的一个类却可根据实际情况决定克隆。只有Object.clone()要对类中的字段进行某些合理的操作时，才可以作这方面的决定。 (2) 支持clone()，采用实现Cloneable（可克隆）能力的标准操作，并覆盖clone()。在被覆盖的clone()中，可调用super.clone()，并捕获所有违例（这样可使clone()不“掷”出任何违例）。 (3) 有条件地支持克隆。若类容纳了其他对象的句柄，而那些对象也许能够克隆（集合类便是这样的一个例子），就可试着克隆拥有对方句柄的所有对象；如果它们“掷”出了违例，只需让这些违例通过即可。举个例子来说，假设有一个特殊的Vector，它试图克隆自己容纳的所有对象。编写这样的一个Vector时，并不知道客户程序员会把什么形式的对象置入这个Vector中，所以并不知道它们是否真的能够克隆。 (4) 不实现Cloneable()，但是将clone()覆盖成protected，使任何字段都具有正确的复制行为。这样一来，从这个类继承的所有东西都能覆盖clone()，并调用super.clone()来产生正确的复制行为。注意在我们实现方案里，可以而且应该调用super.clone()——即使那个方法本来预期的是一个Cloneable对象（否则会掷出一个违例），因为没有人会在我们这种类型的对象上直接调用它。它只有通过一个衍生类调用；对那个衍生类来说，如果要保证它正常工作，需实现Cloneable。 (5) 不实现Cloneable来试着防止克隆，并覆盖clone()，以产生一个违例。为使这一设想顺利实现，只有令从它衍生出来的任何类都调用重新定义后的clone()里的suepr.clone()。 (6) 将类设为final，从而防止克隆。若clone()尚未被我们的任何一个上级类覆盖，这一设想便不会成功。若已被覆盖，那么再一次覆盖它，并“掷”出一个CloneNotSupportedException（克隆不支持）违例。为担保克隆被禁止，将类设为final是唯一的办法。除此以外，一旦涉及保密对象或者遇到想对创建的对象数量进行控制的其他情况，应该将所有构建器都设为private，并提供一个或更多的特殊方法来创建对象。采用这种方式，这些方法就可以限制创建的对象数量以及它们的创建条件——一种特殊情况是第16章要介绍的singleton（独子）方案。 唯一安全的方法在ReallyNoMore中得到了演示，它设为final，所以不可继承。这意味着假如clone()在final类中掷出了一个违例，便不能通过继承来进行修改，并可有效地禁止克隆（不能从一个拥有任意继承级数的类中明确调用Object.clone()；只能调用super.clone()，它只可访问直接基础类）。因此，只要制作一些涉及安全问题的对象，就最好把那些类设为final。\n总之，如果希望一个类能够克隆，那么：\n(1) 实现Cloneable接口 (2) 覆盖clone() (3) 在自己的clone()中调用super.clone() (4) 在自己的clone()中捕获违例 这一系列步骤能达到最理想的效果。 12.3.1 副本构建器 非常不幸，假如想制作对象的一个本地副本，Java中的副本构建器便不是特别适合我们。\n12.4 只读类 尽管在一些特定的场合，由clone()产生的本地副本能够获得我们希望的结果，但程序员（方法的作者）不得不亲自禁止别名处理的副作用。假如想制作一个库，令其具有常规用途，但却不能担保它肯定能在正确的类中得以克隆，这时又该怎么办呢？更有可能的一种情况是，假如我们想让别名发挥积极的作用——禁止不必要的对象复制——但却不希望看到由此造成的副作用，那么又该如何处理呢？ 一个办法是创建“不变对象”，令其从属于只读类。可定义一个特殊的类，使其中没有任何方法能造成对象内部状态的改变。在这样的一个类中，别名处理是没有问题的。因为我们只能读取内部状态，所以当多处代码都读取相同的对象时，不会出现任何副作用。 作为“不变对象”一个简单例子，Java的标准库包含了“封装器”（wrapper）类，可用于所有基本数据类型。大家可能已发现了这一点，如果想在一个象Vector（只采用Object句柄）这样的集合里保存一个int数值，可以将这个int封装到标准库的Integer类内部。\nInteger类（以及基本的“封装器”类）用简单的形式实现了“不变性”：它们没有提供可以修改对象的方法。 若确实需要一个容纳了基本数据类型的对象，并想对基本数据类型进行修改，就必须亲自创建它们。幸运的是，操作非常简单\n12.4.1 创建只读类 所有数据都设为private，没有任何public方法对数据作出修改。它能保证对象不被改动。\n12.4.2 “一成不变”的弊端 从表面看，不变类的建立似乎是一个好方案。但是，一旦真的需要那种新类型的一个修改的对象，就必须辛苦地进行新对象的创建工作，同时还有可能涉及更频繁的垃圾收集。对有些类来说，这个问题并不是很大。但对其他类来说（比如String类），这一方案的代价显得太高了。 为解决这个问题，我们可以创建一个“同志”类，并使其能够修改。以后只要涉及大量的修改工作，就可换为使用能修改的同志类。完事以后，再切换回不可变的类。\n我们只创建了两个新对象（Mutable和Immutable2的结果），而不是四个。 这一方法特别适合在下述场合应用： (1) 需要不可变的对象，而且 (2) 经常需要进行大量修改，或者 (3) 创建新的不变对象代价太高\nString 和 StringBuffer 类\n12.4.3 不变字串 隐式常数 若使用下述语句： String s = \u0026ldquo;asdf\u0026rdquo;; String x = Stringer.upcase(s); 那么真的希望upcase()方法改变自变量或者参数吗？我们通常是不愿意的，因为作为提供给方法的一种信息，自变量一般是拿给代码的读者看的，而不是让他们修改。这是一个相当重要的保证，因为它使代码更易编写和理解。 为了在C++中实现这一保证，需要一个特殊关键字的帮助：const。利用这个关键字，程序员可以保证一个句柄（C++叫“指针”或者“引用”）不会被用来修改原始的对象。但这样一来，C++程序员需要用心记住在所有地方都使用const。这显然易使人混淆，也不容易记住。 覆盖\u0026rdquo;+\u0026ldquo;和StringBuffer 利用前面提到的技术，String类的对象被设计成“不可变”。若查阅联机文档中关于String类的内容（本章稍后还要总结它），就会发现类中能够修改String的每个方法实际都创建和返回了一个崭新的String对象，新对象里包含了修改过的信息——原来的String是原封未动的。因此，Java里没有与C++的const对应的特性可用来让编译器支持对象的不可变能力。若想获得这一能力，可以自行设置，就象String那样。 由于String对象是不可变的，所以能够根据情况对一个特定的String进行多次别名处理。因为它是只读的，所以一个句柄不可能会改变一些会影响其他句柄的东西。因此，只读对象可以很好地解决别名问题。 通过修改产生对象的一个崭新版本，似乎可以解决修改对象时的所有问题，就象String那样。但对某些操作来讲，这种方法的效率并不高。一个典型的例子便是为String对象覆盖的运算符“+”。“覆盖”意味着在与一个特定的类使用时，它的含义已发生了变化（用于String的“+”和“+=”是Java中能被覆盖的唯一运算符，Java不允许程序员覆盖其他任何运算符——注释④）。 ④：C++允许程序员随意覆盖运算符。由于这通常是一个复杂的过程（参见《Thinking in C++》，Prentice-Hall于1995年出版），所以Java的设计者认定它是一种“糟糕”的特性，决定不在Java中采用。但具有讽剌意味的是，运算符的覆盖在Java中要比在C++中容易得多。\n针对String对象使用时，“+”允许我们将不同的字串连接起来： String s = \u0026ldquo;abc\u0026rdquo; + foo + \u0026ldquo;def\u0026rdquo; + Integer.toString(47);\n可以想象出它“可能”是如何工作的：字串\u0026quot;abc\u0026quot;可以有一个方法append()，它新建了一个字串，其中包含\u0026quot;abc\u0026quot;以及foo的内容；这个新字串然后再创建另一个新字串，在其中添加\u0026quot;def\u0026rdquo;；以此类推。 这一设想是行得通的，但它要求创建大量字串对象。尽管最终的目的只是获得包含了所有内容的一个新字串，但中间却要用到大量字串对象，而且要不断地进行垃圾收集。我怀疑Java的设计者是否先试过种方法（这是软件开发的一个教训——除非自己试试代码，并让某些东西运行起来，否则不可能真正了解系统）。我还怀疑他们是否早就发现这样做获得的性能是不能接受的。 解决的方法是象前面介绍的那样制作一个可变的同志类。对字串来说，这个同志类叫作StringBuffer，编译器可以自动创建一个StringBuffer，以便计算特定的表达式，特别是面向String对象应用覆盖过的运算符+和+=时。\n创建字串s时，编译器做的工作大致等价于后面使用sb的代码——创建一个StringBuffer，并用append()将新字符直接加入StringBuffer对象（而不是每次都产生新对象）。尽管这样做更有效，但不值得每次都创建象\u0026quot;abc\u0026quot;和\u0026quot;def\u0026quot;这样的引号字串，编译器会把它们都转换成String对象。所以尽管StringBuffer提供了更高的效率，但会产生比我们希望的多得多的对象。\n12.4.4 String和StringBuffer类 这里总结一下同时适用于String和StringBuffer的方法，以便对它们相互间的沟通方式有一个印象。这些表格并未把每个单独的方法都包括进去，而是包含了与本次讨论有重要关系的方法。那些已被覆盖的方法用单独一行总结。 首先总结String类的各种方法：\n最常用的一个方法是append()。在计算包含了+和+=运算符的String表达式时，编译器便会用到这个方法。insert()方法采用类似的形式。这两个方法都能对缓冲区进行重要的操作，不需要另建新对象。\n12.4.5 字串的特殊性 现在，大家已知道String类并非仅仅是Java提供的另一个类。String里含有大量特殊的类。通过编译器和特殊的覆盖或过载运算符+和+=，可将引号字符串转换成一个String。在本章中，大家已见识了剩下的一种特殊情况：用同志StringBuffer精心构造的“不可变”能力，以及编译器中出现的一些有趣现象。\n12.5 总结 由于Java中的所有东西都是句柄，而且由于每个对象都是在内存堆中创建的——只有不再需要的时候，才会当作垃圾收集掉，所以对象的操作方式发生了变化，特别是在传递和返回对象的时候。举个例子来说，在C和C++中，如果想在一个方法里初始化一些存储空间，可能需要请求用户将那片存储区域的地址传递进入方法。否则就必须考虑由谁负责清除那片区域。因此，这些方法的接口和对它们的理解就显得要复杂一些。但在Java中，根本不必关心由谁负责清除，也不必关心在需要一个对象的时候它是否仍然存在。因为系统会为我们照料一切。我们的程序可在需要的时候创建一个对象。而且更进一步地，根本不必担心那个对象的传输机制的细节：只需简单地传递句柄即可。有些时候，这种简化非常有价值，但另一些时候却显得有些多余。 可从两个方面认识这一机制的缺点：\n(1) 肯定要为额外的内存管理付出效率上的损失（尽管损失不大），而且对于运行所需的时间，总是存在一丝不确定的因素（因为在内存不够时，垃圾收集器可能会被强制采取行动）。对大多数应用来说，优点显得比缺点重要，而且部分对时间要求非常苛刻的段落可以用native方法写成（参见附录A）。 (2) 别名处理：有时会不慎获得指向同一个对象的两个句柄。只有在这两个句柄都假定指向一个“明确”的对象时，才有可能产生问题。对这个问题，必须加以足够的重视。而且应该尽可能地“克隆”一个对象，以防止另一个句柄被不希望的改动影响。除此以外，可考虑创建“不可变”对象，使它的操作能返回同种类型或不同种类型的一个新对象，从而提高程序的执行效率。但千万不要改变原始对象，使对那个对象别名的其他任何方面都感觉不出变化。 有些人认为Java的克隆是一个笨拙的家伙，所以他们实现了自己的克隆方案（注释⑤），永远杜绝调用Object.clone()方法，从而消除了实现Cloneable和捕获CloneNotSupportException违例的需要。这一做法是合理的，而且由于clone()在Java标准库中很少得以支持，所以这显然也是一种“安全”的方法。只要不调用Object.clone()，就不必实现Cloneable或者捕获违例，所以那看起来也是能够接受的。\n⑤：Doug Lea特别重视这个问题，并把这个方法推荐给了我，他说只需为每个类都创建一个名为duplicate()的函数即可。\nJava中一个有趣的关键字是byvalue（按值），它属于那些“保留但未实现”的关键字之一。在理解了别名和克隆问题以后，大家可以想象byvalue最终有一天会在Java中用于实现一种自动化的本地副本。这样做可以解决更多复杂的克隆问题，并使这种情况下的编写的代码变得更加简单和健壮。\n12.6 练习 第13章 创建窗口和程序片 第14章 多线程 利用对象，可将一个程序分割成相互独立的区域。我们通常也需要将一个程序转换成多个独立运行的子任务。\n象这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。\n这时理解一些定义对以后的学习狠有帮助。“进程”是指一种“自包容”的运行程序，有自己的地址空间。“多任务”操作系统能同时运行多个进程（程序）——但实际是由于CPU分时机制的作用，使每个进程都能循环获得自己的CPU时间片。但由于轮换速度非常快，使得所有程序好象是在“同时”运行一样。“线程”是进程内部单一的一个顺序控制流。因此，一个进程可能容纳了多个同时执行的线程。\n多线程的应用范围很广。但在一般情况下，程序的一些部分同特定的事件或资源联系在一起，同时又不想为它而暂停程序其他部分的执行。这样一来，就可考虑创建一个线程，令其与那个事件或资源关联到一起，并让它独立于主程序运行。一个很好的例子便是“Quit”或“退出”按钮——我们并不希望在程序的每一部分代码中都轮询这个按钮，同时又希望该按钮能及时地作出响应（使程序看起来似乎经常都在轮询它）。事实上，多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。\n14.1 反应灵敏的用户界面 作为我们的起点，请思考一个需要执行某些CPU密集型计算的程序。由于CPU“全心全意”为那些计算服务，所以对用户的输入十分迟钝，几乎没有什么反应。在这里，我们用一个合成的applet/application（程序片／应用程序）来简单显示出一个计数器的结果：\n//: Counter1.java // A non-responsive user interface package c14; import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter1 extends Applet { private int count = 0; private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); private TextField t = new TextField(10); private boolean runFlag = true; public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } public void go() { while (true) { try { Thread.currentThread().sleep(100); } catch (InterruptedException e){} if(runFlag) t.setText(Integer.toString(count++)); } } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { go(); } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } public static void main(String[] args) { Counter1 applet = new Counter1(); Frame aFrame = new Frame(\u0026#34;Counter1\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 在这个程序中，AWT和程序片代码都应是大家熟悉的，第13章对此已有很详细的交待。go()方法正是程序全心全意服务的对待：将当前的count（计数）值置入TextField（文本字段）t，然后使count增值。\ngo()内的部分无限循环是调用sleep()。sleep()必须同一个Thread（线程）对象关联到一起，而且似乎每个应用程序都有部分线程同它关联（事实上，Java本身就是建立在线程基础上的，肯定有一些线程会伴随我们写的应用一起运行）。所以无论我们是否明确使用了线程，都可利用Thread.currentThread()产生由程序使用的当前线程，然后为那个线程调用sleep()。注意，Thread.currentThread()是Thread类的一个静态方法。\n注意sleep()可能“掷”出一个InterruptException（中断违例）——尽管产生这样的违例被认为是中止线程的一种“恶意”手段，而且应该尽可能地杜绝这一做法。再次提醒大家，违例是为异常情况而产生的，而不是为了正常的控制流。在这里包含了对一个“睡眠”线程的中断，以支持未来的一种语言特性。\n一旦按下start按钮，就会调用go()。研究一下go()，你可能会很自然地（就象我一样）认为它该支持多线程，因为它会进入“睡眠”状态。也就是说，尽管方法本身“睡着”了，CPU仍然应该忙于监视其他按钮“按下”事件。但有一个问题，那就是go()是永远不会返回的，因为它被设计成一个无限循环。这意味着actionPerformed()根本不会返回。由于在第一个按键以后便陷入actionPerformed()中，所以程序不能再对其他任何事件进行控制（如果想出来，必须以某种方式“杀死”进程——最简便的方式就是在控制台窗口按Ctrl＋C键）。\n这里最基本的问题是go()需要继续执行自己的操作，而与此同时，它也需要返回，以便actionPerformed()能够完成，而且用户界面也能继续响应用户的操作。但对象go()这样的传统方法来说，它却不能在继续的同时将控制权返回给程序的其他部分。这听起来似乎是一件不可能做到的事情，就象CPU必须同时位于两个地方一样，但线程可以解决一切。“线程模型”（以及Java中的编程支持）是一种程序编写规范，可在单独一个程序里实现几个操作的同时进行。根据这一机制，CPU可为每个线程都分配自己的一部分时间。每个线程都“感觉”自己好象拥有整个CPU，但CPU的计算时间实际却是在所有线程间分摊的。 线程机制多少降低了一些计算效率，但无论程序的设计，资源的均衡，还是用户操作的方便性，都从中获得了巨大的利益。综合考虑，这一机制是非常有价值的。当然，如果本来就安装了多块CPU，那么操作系统能够自行决定为不同的CPU分配哪些线程，程序的总体运行速度也会变得更快（所有这些都要求操作系统以及应用程序的支持）。多线程和多任务是充分发挥多处理机系统能力的一种最有效的方式。\n14.1.1 从线程继承 为创建一个线程，最简单的方法就是从Thread类继承。这个类包含了创建和运行线程所需的一切东西。Thread最重要的方法是run()。但为了使用run()，必须对其进行过载或者覆盖，使其能充分按自己的吩咐行事。因此，run()属于那些会与程序中的其他线程“并发”或“同时”执行的代码。\n下面这个例子可创建任意数量的线程，并通过为每个线程分配一个独一无二的编号（由一个静态变量产生），从而对不同的线程进行跟踪。Thread的run()方法在这里得到了覆盖，每通过一次循环，计数就减1——计数为0时则完成循环（此时一旦返回run()，线程就中止运行）。\n//: SimpleThread.java // Very simple Threading example public class SimpleThread extends Thread { private int countDown = 5; private int threadNumber; private static int threadCount = 0; public SimpleThread() { threadNumber = ++threadCount; System.out.println(\u0026#34;Making \u0026#34; + threadNumber); } public void run() { while(true) { System.out.println(\u0026#34;Thread \u0026#34; + threadNumber + \u0026#34;(\u0026#34; + countDown + \u0026#34;)\u0026#34;); if(--countDown == 0) return; } } public static void main(String[] args) { for(int i = 0; i \u0026lt; 5; i++) new SimpleThread().start(); System.out.println(\u0026#34;All Threads Started\u0026#34;); } } ///:~ run()方法几乎肯定含有某种形式的循环——它们会一直持续到线程不再需要为止。因此，我们必须规定特定的条件，以便中断并退出这个循环（或者在上述的例子中，简单地从run()返回即可）。run()通常采用一种无限循环的形式。也就是说，通过阻止外部发出对线程的stop()或者destroy()调用，它会永远运行下去（直到程序完成）。\n在main()中，可看到创建并运行了大量线程。Thread包含了一个特殊的方法，叫作start()，它的作用是对线程进行特殊的初始化，然后调用run()。所以整个步骤包括：调用构建器来构建对象，然后用start()配置线程，再调用run()。如果不调用start()——如果适当的话，可在构建器那样做——线程便永远不会启动。\n下面是该程序某一次运行的输出（注意每次运行都会不同）：\n可注意到这个例子中到处都调用了sleep()，然而输出结果指出每个线程都获得了属于自己的那一部分CPU执行时间。从中可以看出，尽管sleep()依赖一个线程的存在来执行，但却与允许或禁止线程无关。它只不过是另一个不同的方法而已。\n亦可看出线程并不是按它们创建时的顺序运行的。事实上，CPU处理一个现有线程集的顺序是不确定的——除非我们亲自介入，并用Thread的setPriority()方法调整它们的优先级。\nmain()创建Thread对象时，它并未捕获任何一个对象的句柄。普通对象对于垃圾收集来说是一种“公平竞赛”，但线程却并非如此。每个线程都会“注册”自己，所以某处实际存在着对它的一个引用。这样一来，垃圾收集器便只好对它“瞠目以对”了。\n14.1.2 针对用户界面的多线程 现在，我们也许能用一个线程解决在Counter1.java中出现的问题。采用的一个技巧便是在一个线程的run()方法中放置“子任务”——亦即位于go()内的循环。一旦用户按下Start按钮，线程就会启动，但马上结束线程的创建。这样一来，尽管线程仍在运行，但程序的主要工作却能得以继续（等候并响应用户界面的事件）。下面是具体的代码：\n//: Counter2.java // A responsive user interface with threads import java.awt.*; import java.awt.event.*; import java.applet.*; class SeparateSubTask extends Thread { private int count = 0; private Counter2 c2; private boolean runFlag = true; public SeparateSubTask(Counter2 c2) { this.c2 = c2; start(); } public void invertFlag() { runFlag = !runFlag;} public void run() { while (true) { try { sleep(100); } catch (InterruptedException e){} if(runFlag) c2.t.setText(Integer.toString(count++)); } } } public class Counter2 extends Applet { TextField t = new TextField(10); private SeparateSubTask sp = null; private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp == null) sp = new SeparateSubTask(Counter2.this); } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp != null) sp.invertFlag(); } } public static void main(String[] args) { Counter2 applet = new Counter2(); Frame aFrame = new Frame(\u0026#34;Counter2\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 现在，Counter2变成了一个相当直接的程序，它的唯一任务就是设置并管理用户界面。但假若用户现在按下Start按钮，却不会真正调用一个方法。此时不是创建类的一个线程，而是创建SeparateSubTask，然后继续Counter2事件循环。注意此时会保存SeparateSubTask的句柄，以便我们按下onOff按钮的时候，能正常地切换位于SeparateSubTask内部的runFlag（运行标志）。随后那个线程便可启动（当它看到标志的时候），然后将自己中止（亦可将SeparateSubTask设为一个内部类来达到这一目的）。\nSeparateSubTask类是对Thread的一个简单扩展，它带有一个构建器（其中保存了Counter2句柄，然后通过调用start()来运行线程）以及一个run()——本质上包含了Counter1.java的go()内的代码。由于SeparateSubTask知道自己容纳了指向一个Counter2的句柄，所以能够在需要的时候介入，并访问Counter2的TestField（文本字段）。 按下onOff按钮，几乎立即能得到正确的响应。当然，这个响应其实并不是“立即”发生的，它毕竟和那种由“中断”驱动的系统不同。只有线程拥有CPU的执行时间，并注意到标记已发生改变，计数器才会停止。\n用内部类改善代码 下面说说题外话，请大家注意一下SeparateSubTask和Counter2类之间发生的结合行为。SeparateSubTask同Counter2“亲密”地结合到了一起——它必须持有指向自己“父”Counter2对象的一个句柄，以便自己能回调和操纵它。但两个类并不是真的合并为单独一个类（尽管在下一节中，我们会讲到Java确实提供了合并它们的方法），因为它们各自做的是不同的事情，而且是在不同的时间创建的。但不管怎样，它们依然紧密地结合到一起（更准确地说，应该叫“联合”），所以使程序代码多少显得有些笨拙。在这种情况下，一个内部类可以显著改善代码的“可读性”和执行效率：\n//: Counter2i.java // Counter2 using an inner class for the thread import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter2i extends Applet { private class SeparateSubTask extends Thread { int count = 0; boolean runFlag = true; SeparateSubTask() { start(); } public void run() { while (true) { try { sleep(100); } catch (InterruptedException e){} if(runFlag) t.setText(Integer.toString(count++)); } } } private SeparateSubTask sp = null; private TextField t = new TextField(10); private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp == null) sp = new SeparateSubTask(); } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { if(sp != null) sp.runFlag = !sp.runFlag; // invertFlag(); } } public static void main(String[] args) { Counter2i applet = new Counter2i(); Frame aFrame = new Frame(\u0026#34;Counter2i\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 这个SeparateSubTask名字不会与前例中的SeparateSubTask冲突——即使它们都在相同的目录里——因为它已作为一个内部类隐藏起来。大家亦可看到内部类被设为private（私有）属性，这意味着它的字段和方法都可获得默认的访问权限（run()除外，它必须设为public，因为它在基础类中是公开的）。除Counter2i之外，其他任何方面都不可访问private内部类。而且由于两个类紧密结合在一起，所以很容易放宽它们之间的访问限制。在SeparateSubTask中，我们可看到invertFlag()方法已被删去，因为Counter2i现在可以直接访问runFlag。\n此外，注意SeparateSubTask的构建器已得到了简化——它现在唯一的用外就是启动线程。Counter2i对象的句柄仍象以前那样得以捕获，但不再是通过人工传递和引用外部对象来达到这一目的，此时的内部类机制可以自动照料它。在run()中，可看到对t的访问是直接进行的，似乎它是SeparateSubTask的一个字段。父类中的t字段现在可以变成private，因为SeparateSubTask能在未获任何特殊许可的前提下自由地访问它——而且无论如何都该尽可能地把字段变成“私有”属性，以防来自类外的某种力量不慎地改变它们。\n无论在什么时候，只要注意到类相互之间结合得比较紧密，就可考虑利用内部类来改善代码的编写与维护。\n内部类这玩意与对应类有点像线粒体与细胞的关系，处于类内部单不仅仅是方法能代替的。以对象分类，对象与对象关系结合紧密，就可考虑利用内部类来改善代码的编写与维护。\n14.1.3 用主类合并线程 在上面的例子中，我们看到线程类（Thread）与程序的主类（Main）是分隔开的。这样做非常合理，而且易于理解。然而，还有另一种方式也是经常要用到的。尽管它不十分明确，但一般都要更简洁一些（这也解释了它为什么十分流行）。通过将主程序类变成一个线程，这种形式可将主程序类与线程类合并到一起。由于对一个GUI程序来说，主程序类必须从Frame或Applet继承，所以必须用一个接口加入额外的功能。这个接口叫作Runnable，其中包含了与Thread一致的基本方法。事实上，Thread也实现了Runnable，它只指出有一个run()方法。\n对合并后的程序／线程来说，它的用法不是十分明确。当我们启动程序时，会创建一个Runnable（可运行的）对象，但不会自行启动线程。线程的启动必须明确进行。下面这个程序向我们演示了这一点，它再现了Counter2的功能：\n//: Counter3.java // Using the Runnable interface to turn the // main class into a thread. import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter3 extends Applet implements Runnable { private int count = 0; private boolean runFlag = true; private Thread selfThread = null; private Button onOff = new Button(\u0026#34;Toggle\u0026#34;), start = new Button(\u0026#34;Start\u0026#34;); private TextField t = new TextField(10); public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } public void run() { while (true) { try { selfThread.sleep(100); } catch (InterruptedException e){} if(runFlag) t.setText(Integer.toString(count++)); } } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(selfThread == null) { selfThread = new Thread(Counter3.this); selfThread.start(); } } } class OnOffL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } public static void main(String[] args) { Counter3 applet = new Counter3(); Frame aFrame = new Frame(\u0026#34;Counter3\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,200); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD\n14.2 共享有限的资源 14.3 堵塞 14.4 优先级 14.5 回顾runnable 14.6 总结 14.7 练习 第15章 网络编程 15.1 机器的标识 ======= 现在run()位于类内，但它在init()结束以后仍处在“睡眠”状态。若按下启动按钮，线程便会用多少有些暧昧的表达方式创建（若线程尚不存在）：\nnew Thread(Counter3.this); 若某样东西有一个Runnable接口，实际只是意味着它有一个run()方法，但不存在与之相关的任何特殊东西——它不具有任何天生的线程处理能力，这与那些从Thread继承的类是不同的。所以为了从一个Runnable对象产生线程，必须单独创建一个线程，并为其传递Runnable对象；可为其使用一个特殊的构建器，并令其采用一个Runnable作为自己的参数使用。随后便可为那个线程调用start()，如下所示：\nselfThread.start(); 它的作用是执行常规初始化操作，然后调用run()。\nRunnable接口最大的一个优点是所有东西都从属于相同的类。若需访问什么东西，只需简单地访问它即可，不需要涉及一个独立的对象。但为这种便利也是要付出代价的——只可为那个特定的对象运行单独一个线程（尽管可创建那种类型的多个对象，或者在不同的类里创建其他对象）。\n注意Runnable接口本身并不是造成这一限制的罪魁祸首。它是由于Runnable与我们的主类合并造成的，因为每个应用只能主类的一个对象。\n这说的什么玩应。。。\n14.1.4 制作多个线程 现在考虑一下创建多个不同的线程的问题。我们不可用前面的例子来做到这一点，所以必须倒退回去，利用从Thread继承的多个独立类来封装run()。但这是一种更常规的方案，而且更易理解，所以尽管前例揭示了我们经常都能看到的编码样式，但并不推荐在大多数情况下都那样做，因为它只是稍微复杂一些，而且灵活性稍低一些。\n下面这个例子用计数器和切换按钮再现了前面的编码样式。但这一次，一个特定计数器的所有信息（按钮和文本字段）都位于它自己的、从Thread继承的对象内。Ticker 中的所有字段都具有private（私有）属性，这意味着Ticker的具体实现方案可根据实际情况任意修改，其中包括修改用于获取和显示信息的数据组件的数量及类型。创建好一个 Ticker 对象以后，构建器便请求一个AWT容器（Container）的句柄—— Ticker 用自己的可视组件填充那个容器。采用这种方式，以后一旦改变了可视组件，使用 Ticker 的代码便不需要另行修改一道。\n//: Counter4.java // If you separate your thread from the main // class, you can have as many threads as you // want. import java.awt.*; import java.awt.event.*; import java.applet.*; class Ticker extends Thread { private Button b = new Button(\u0026#34;Toggle\u0026#34;); private TextField t = new TextField(10); private int count = 0; private boolean runFlag = true; public Ticker(Container c) { b.addActionListener(new ToggleL()); Panel p = new Panel(); p.add(t); p.add(b); c.add(p); } class ToggleL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } public void run() { while (true) { if(runFlag) t.setText(Integer.toString(count++)); try { sleep(100); } catch (InterruptedException e){} } } } public class Counter4 extends Applet { private Button start = new Button(\u0026#34;Start\u0026#34;); private boolean started = false; private Ticker[] s; private boolean isApplet = true; private int size; public void init() { // Get parameter \u0026#34;size\u0026#34; from Web page: if(isApplet) size = Integer.parseInt(getParameter(\u0026#34;size\u0026#34;)); s = new Ticker[size]; for(int i = 0; i \u0026lt; s.length; i++) s[i] = new Ticker(this); start.addActionListener(new StartL()); add(start); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(!started) { started = true; for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } } public static void main(String[] args) { Counter4 applet = new Counter4(); // This isn\u0026#39;t an applet, so set the flag and // produce the parameter values from args: applet.isApplet = false; applet.size = (args.length == 0 ? 5 : Integer.parseInt(args[0])); Frame aFrame = new Frame(\u0026#34;Counter4\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(200, applet.size * 50); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Ticker不仅包括了自己的线程处理机制，也提供了控制与显示线程的工具。可按自己的意愿创建任意数量的线程，毋需明确地创建窗口化组件。\n在Counter4中，有一个名为s的Ticker对象的数组。为获得最大的灵活性，这个数组的长度是用程序片参数接触Web页而初始化的。下面是网页中长度参数大致的样子，它们嵌于对程序片（applet）的描述内容中：\n\u0026lt;applet code=Counter4 width=600 height=600\u0026gt;\r\u0026lt;param name=size value=\u0026#34;20\u0026#34;\u0026gt;\r\u0026lt;/applet\u0026gt; 其中，param，name和value是所有Web页都适用的关键字。name是指程序中对参数的一种引用称谓，value可以是任何字串（并不仅仅是解析成一个数字的东西）。\n我们注意到对数组s长度的判断是在init()内部完成的，它没有作为s的内嵌定义的一部分提供。换言之，不可将下述代码作为类定义的一部分使用（应该位于任何方法的外部）：\ninst size = Integer.parseInt(getParameter(\u0026#34;Size\u0026#34;));\rTicker[] s = new Ticker[size] 可把它编译出来，但会在运行期得到一个空指针违例。但若将getParameter()初始化移入init()，则可正常工作。程序片框架会进行必要的启动工作，以便在进入init()前收集好一些参数。\n此外，上述代码被同时设置成一个程序片和一个应用（程序）。在它是应用程序的情况下，size参数可从命令行里提取出来（否则就提供一个默认的值）。\n数组的长度建好以后，就可以创建新的Ticker对象；作为Ticker构建器的一部分，用于每个Ticker的按钮和文本字段就会加入程序片。\n按下Start按钮后，会在整个Ticker数组里遍历，并为每个Ticker调用start()。记住，start()会进行必要的线程初始化工作，然后为那个线程调用run()。\nToggleL监视器只是简单地切换Ticker中的标记，一旦对应线程以后需要修改这个标记，它会作出相应的反应。\n这个例子的一个好处是它使我们能够方便地创建由单独子任务构成的大型集合，并以监视它们的行为。在这种情况下，我们会发现随着子任务数量的增多，机器显示出来的数字可能会出现更大的分歧，这是由于为线程提供服务的方式造成的。\n亦可试着体验一下sleep(100)在Ticker.run()中的重要作用。若删除sleep()，那么在按下一个切换按钮前，情况仍然会进展良好。按下按钮以后，那个特定的线程就会出现一个失败的runFlag，而且run()会深深地陷入一个无限循环——很难在多任务处理期间中止退出。因此，程序对用户操作的反应灵敏度会大幅度降低。\n14.1.5 Daemon线程(守护线程) “Daemon”线程的作用是在程序的运行期间于后台提供一种“常规”服务，但它并不属于程序的一个基本部分。因此，一旦所有非 Daemon 线程完成，程序也会中止运行。相反，假若有任何非Daemon线程仍在运行（比如还有一个正在运行main()的线程），则程序的运行不会中止。\n通过调用isDaemon()，可调查一个线程是不是一个Daemon，而且能用setDaemon()打开或者关闭一个线程的Daemon状态。如果是一个Daemon线程，那么它创建的任何线程也会自动具备Daemon属性。 下面这个例子演示了Daemon线程的用法：\nJava线程中的Thread.yield( )方法，\n译为线程让步。\n顾名思义，就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行，注意是让自己或者其他线程运行，并不是单纯的让给其他线程。yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！\n//: Daemons.java // Daemonic behavior import java.io.*; class Daemon extends Thread { private static final int SIZE = 10; private Thread[] t = new Thread[SIZE]; public Daemon() { setDaemon(true); start(); } public void run() { for(int i = 0; i \u0026lt; SIZE; i++) t[i] = new DaemonSpawn(i); for(int i = 0; i \u0026lt; SIZE; i++) System.out.println( \u0026#34;t[\u0026#34; + i + \u0026#34;].isDaemon() = \u0026#34; + t[i].isDaemon()); while(true) yield(); } } class DaemonSpawn extends Thread { public DaemonSpawn(int i) { System.out.println( \u0026#34;DaemonSpawn \u0026#34; + i + \u0026#34; started\u0026#34;); start(); } public void run() { while(true) yield(); } } public class Daemons { public static void main(String[] args) { Thread d = new Daemon(); System.out.println( \u0026#34;d.isDaemon() = \u0026#34; + d.isDaemon()); // Allow the daemon threads to finish // their startup processes: BufferedReader stdin = new BufferedReader( new InputStreamReader(System.in)); System.out.println(\u0026#34;Waiting for CR\u0026#34;); try { stdin.readLine(); } catch(IOException e) {} } } ///:~ Daemon线程可将自己的Daemon标记设置成“真”，然后产生一系列其他线程，而且认为它们也具有Daemon属性。随后，它进入一个无限循环，在其中调用yield()，放弃对其他进程的控制。在这个程序早期的一个版本中，无限循环会使int计数器增值，但会使整个程序都好象陷入停顿状态。换用yield()后，却可使程序充满“活力”，不会使人产生停滞或反应迟钝的感觉。\n一旦main()完成自己的工作，便没有什么能阻止程序中断运行，因为这里运行的只有Daemon线程。所以能看到启动所有Daemon线程后显示出来的结果，System.in也进行了相应的设置，使程序中断前能等待一个回车。如果不进行这样的设置，就只能看到创建Daemon线程的一部分结果（试试将readLine()代码换成不同长度的sleep()调用，看看会有什么表现）。\n14.2 共享有限的资源 可将单线程程序想象成一种孤立的实体，它能遍历我们的问题空间，而且一次只能做一件事情。由于只有一个实体，所以永远不必担心会有两个实体同时试图使用相同的资源，就象两个人同时都想停到一个车位，同时都想通过一扇门，甚至同时发话。\n进入多线程环境后，它们则再也不是孤立的。可能会有两个甚至更多的线程试图同时同一个有限的资源。必须对这种潜在资源冲突进行预防，否则就可能发生两个线程同时访问一个银行帐号，打印到同一台计算机，以及对同一个值进行调整等等。\n14.2.1 资源访问的错误方法 现在考虑换成另一种方式来使用本章频繁见到的计数器。在下面的例子中，每个线程都包含了两个计数器，它们在run()里增值以及显示。除此以外，我们使用了Watcher类的另一个线程。它的作用是监视计数器，检查它们是否保持相等。这表面是一项无意义的行动，因为如果查看代码，就会发现计数器肯定是相同的。但实际情况却不一定如此。下面是程序的第一个版本：\n//: Sharing1.java // Problems with resource sharing while threading import java.awt.*; import java.awt.event.*; import java.applet.*; class TwoCounter extends Thread { private boolean started = false; private TextField t1 = new TextField(5), t2 = new TextField(5); private Label l = new Label(\u0026#34;count1 == count2\u0026#34;); private int count1 = 0, count2 = 0; // Add the display components as a panel // to the given container: public TwoCounter(Container c) { Panel p = new Panel(); p.add(t1); p.add(t2); p.add(l); c.add(p); } public void start() { if(!started) { started = true; super.start(); } } public void run() { while (true) { t1.setText(Integer.toString(count1++)); t2.setText(Integer.toString(count2++)); try { sleep(500); } catch (InterruptedException e){} } } public void synchTest() { Sharing1.incrementAccess(); if(count1 != count2) l.setText(\u0026#34;Unsynched\u0026#34;); } } class Watcher extends Thread { private Sharing1 p; public Watcher(Sharing1 p) { this.p = p; start(); } public void run() { while(true) { for(int i = 0; i \u0026lt; p.s.length; i++) p.s[i].synchTest(); try { sleep(500); } catch (InterruptedException e){} } } } public class Sharing1 extends Applet { TwoCounter[] s; private static int accessCount = 0; private static TextField aCount = new TextField(\u0026#34;0\u0026#34;, 10); public static void incrementAccess() { accessCount++; aCount.setText(Integer.toString(accessCount)); } private Button start = new Button(\u0026#34;Start\u0026#34;), observer = new Button(\u0026#34;Observe\u0026#34;); private boolean isApplet = true; private int numCounters = 0; private int numObservers = 0; public void init() { if(isApplet) { numCounters = Integer.parseInt(getParameter(\u0026#34;size\u0026#34;)); numObservers = Integer.parseInt( getParameter(\u0026#34;observers\u0026#34;)); } s = new TwoCounter[numCounters]; for(int i = 0; i \u0026lt; s.length; i++) s[i] = new TwoCounter(this); Panel p = new Panel(); start.addActionListener(new StartL()); p.add(start); observer.addActionListener(new ObserverL()); p.add(observer); p.add(new Label(\u0026#34;Access Count\u0026#34;)); p.add(aCount); add(p); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } class ObserverL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; numObservers; i++) new Watcher(Sharing1.this); } } public static void main(String[] args) { Sharing1 applet = new Sharing1(); // This isn\u0026#39;t an applet, so set the flag and // produce the parameter values from args: applet.isApplet = false; applet.numCounters = (args.length == 0 ? 5 : Integer.parseInt(args[0])); applet.numObservers = (args.length \u0026lt; 2 ? 5 : Integer.parseInt(args[1])); Frame aFrame = new Frame(\u0026#34;Sharing1\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(350, applet.numCounters *100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 和往常一样，每个计数器都包含了自己的显示组件：两个文本字段以及一个标签。根据它们的初始值，可知道计数是相同的。这些组件在TwoCounter构建器加入Container。由于这个线程是通过用户的一个“按下按钮”操作启动的，所以start()可能被多次调用。但对一个线程来说，对Thread.start()的多次调用是非法的（会产生违例）。在started标记和过载的start()方法中，大家可看到针对这一情况采取的防范措施。\n在run()中，count1和count2的增值与显示方式表面上似乎能保持它们完全一致。随后会调用sleep()；若没有这个调用，程序便会出错，因为那会造成CPU难于交换任务。\nsynchTest()方法采取的似乎是没有意义的行动，它检查count1是否等于count2；如果不等，就把标签设为“Unsynched”（不同步）。但是首先，它调用的是类Sharing1的一个静态成员，以便增值和显示一个访问计数器，指出这种检查已成功进行了多少次（这样做的理由会在本例的其他版本中变得非常明显）。\nWatcher类是一个线程，它的作用是为处于活动状态的所有TwoCounter对象都调用synchTest()。其间，它会对Sharing1对象中容纳的数组进行遍历。可将Watcher想象成它掠过TwoCounter对象的肩膀不断地“偷看”。\nSharing1包含了TwoCounter对象的一个数组，它通过init()进行初始化，并在我们按下“start”按钮后作为线程启动。以后若按下“Observe”（观察）按钮，就会创建一个或者多个观察器，并对毫不设防的TwoCounter进行调查。 注意为了让它作为一个程序片在浏览器中运行，Web页需要包含下面这几行：\n\u0026lt;applet code=Sharing1 width=650 height=500\u0026gt;\r\u0026lt;param name=size value=\u0026#34;20\u0026#34;\u0026gt;\r\u0026lt;param name=observers value=\u0026#34;1\u0026#34;\u0026gt;\r\u0026lt;/applet\u0026gt; 可自行改变宽度、高度以及参数，根据自己的意愿进行试验。若改变了size和observers，程序的行为也会发生变化。我们也注意到，通过从命令行接受参数（或者使用默认值），它被设计成作为一个独立的应用程序运行。\n下面才是最让人“不可思议”的。在TwoCounter.run()中，无限循环只是不断地重复相邻的行:\nt1.setText(Integer.toString(count1++));\rt2.setText(Integer.toString(count2++)); （和“睡眠”一样，不过在这里并不重要）。但在程序运行的时候，你会发现count1和count2被“观察”（用Watcher观察）的次数是不相等的！这是由线程的本质造成的——它们可在任何时候挂起（暂停）。所以在上述两行的执行时刻之间，有时会出现执行暂停现象。同时，Watcher线程也正好跟随着进来，并正好在这个时候进行比较，造成计数器出现不相等的情况。\n本例揭示了使用线程时一个非常基本的问题。我们跟无从知道一个线程什么时候运行。想象自己坐在一张桌子前面，桌上放有一把叉子，准备叉起自己的最后一块食物。当叉子要碰到食物时，食物却突然消失了（因为这个线程已被挂起，同时另一个线程进来“偷”走了食物）。这便是我们要解决的问题。\n有的时候，我们并不介意一个资源在尝试使用它的时候是否正被访问（食物在另一些盘子里）。但为了让多线程机制能够正常运转，需要采取一些措施来防止两个线程访问相同的资源——至少在关键的时期。\n为防止出现这样的冲突，只需在线程使用一个资源时为其加锁即可。访问资源的第一个线程会其加上锁以后，其他线程便不能再使用那个资源，除非被解锁。如果车子的前座是有限的资源，高喊“这是我的！”的孩子会主张把它锁起来。\n14.2.2 Java如何共享资源 对一种特殊的资源——对象中的内存——Java提供了内建的机制来防止它们的冲突。由于我们通常将数据元素设为从属于private（私有）类，然后只通过方法访问那些内存，所以只需将一个特定的方法设为synchronized（同步的），便可有效地防止冲突。在任何时刻，只可有一个线程调用特定对象的一个synchronized方法（尽管那个线程可以调用多个对象的同步方法）。下面列出简单的synchronized方法\nsynchronized void f() { /* ... */ }\rsynchronized void g() { /* ... */ } 每个对象都包含了一把锁（也叫作“监视器”），它自动成为对象的一部分（不必为此写任何特殊的代码）。调用任何synchronized方法时，对象就会被锁定，不可再调用那个对象的其他任何synchronized方法，除非第一个方法完成了自己的工作，并解除锁定。在上面的例子中，如果为一个对象调用f()，便不能再为同样的对象调用g()，除非f()完成并解除锁定。因此，一个特定对象的所有synchronized方法都共享着一把锁，而且这把锁能防止多个方法对通用内存同时进行写操作（比如同时有多个线程）。\n一个特定对象的所有synchronized方法都共享着一把锁\n每个类也有自己的一把锁（作为类的Class对象的一部分），所以synchronized static方法可在一个类的范围内被相互间锁定起来，防止与static数据的接触。\n一个类所有synchronized static 方法都共享着一把锁\n注意如果想保护其他某些资源不被多个线程同时访问，可以强制通过 synchronized 方访问那些资源。\n计数器的同步 装备了这个新关键字后，我们能够采取的方案就更灵活了：可以只为TwoCounter中的方法简单地使用synchronized关键字。下面这个例子是对前例的改版，其中加入了新的关键字：\n//: Sharing2.java // Using the synchronized keyword to prevent // multiple access to a particular resource. import java.awt.*; import java.awt.event.*; import java.applet.*; class TwoCounter2 extends Thread { private boolean started = false; private TextField t1 = new TextField(5), t2 = new TextField(5); private Label l = new Label(\u0026#34;count1 == count2\u0026#34;); private int count1 = 0, count2 = 0; public TwoCounter2(Container c) { Panel p = new Panel(); p.add(t1); p.add(t2); p.add(l); c.add(p); } public void start() { if(!started) { started = true; super.start(); } } public synchronized void run() { while (true) { t1.setText(Integer.toString(count1++)); t2.setText(Integer.toString(count2++)); try { sleep(500); } catch (InterruptedException e){} } } public synchronized void synchTest() { Sharing2.incrementAccess(); if(count1 != count2) l.setText(\u0026#34;Unsynched\u0026#34;); } } class Watcher2 extends Thread { private Sharing2 p; public Watcher2(Sharing2 p) { this.p = p; start(); } public void run() { while(true) { for(int i = 0; i \u0026lt; p.s.length; i++) p.s[i].synchTest(); try { sleep(500); } catch (InterruptedException e){} } } } public class Sharing2 extends Applet { TwoCounter2[] s; private static int accessCount = 0; private static TextField aCount = new TextField(\u0026#34;0\u0026#34;, 10); public static void incrementAccess() { accessCount++; aCount.setText(Integer.toString(accessCount)); } private Button start = new Button(\u0026#34;Start\u0026#34;), observer = new Button(\u0026#34;Observe\u0026#34;); private boolean isApplet = true; private int numCounters = 0; private int numObservers = 0; public void init() { if(isApplet) { numCounters = Integer.parseInt(getParameter(\u0026#34;size\u0026#34;)); numObservers = Integer.parseInt( getParameter(\u0026#34;observers\u0026#34;)); } s = new TwoCounter2[numCounters]; for(int i = 0; i \u0026lt; s.length; i++) s[i] = new TwoCounter2(this); Panel p = new Panel(); start.addActionListener(new StartL()); p.add(start); observer.addActionListener(new ObserverL()); p.add(observer); p.add(new Label(\u0026#34;Access Count\u0026#34;)); p.add(aCount); add(p); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } class ObserverL implements ActionListener { public void actionPerformed(ActionEvent e) { for(int i = 0; i \u0026lt; numObservers; i++) new Watcher2(Sharing2.this); } } public static void main(String[] args) { Sharing2 applet = new Sharing2(); // This isn\u0026#39;t an applet, so set the flag and // produce the parameter values from args: applet.isApplet = false; applet.numCounters = (args.length == 0 ? 5 : Integer.parseInt(args[0])); applet.numObservers = (args.length \u0026lt; 2 ? 5 : Integer.parseInt(args[1])); Frame aFrame = new Frame(\u0026#34;Sharing2\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(350, applet.numCounters *100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 我们注意到无论run()还是synchTest()都是“同步的”。如果只同步其中的一个方法，那么另一个就可以自由忽视对象的锁定，并可无碍地调用。所以必须记住一个重要的规则：对于访问某个关键共享资源的所有方法，都必须把它们设为synchronized，否则就不能正常地工作。\n现在又遇到了一个新问题。Watcher2永远都不能看到正在进行的事情，因为整个run()方法已设为“同步”。而且由于肯定要为每个对象运行run()，所以锁永远不能打开，而synchTest()永远不会得到调用。之所以能看到这一结果，是因为accessCount根本没有变化。\n为解决这个问题，我们能采取的一个办法是只将run()中的一部分代码隔离出来。想用这个办法隔离出来的那部分代码叫作“关键区域”，而且要用不同的方式来使用synchronized关键字，以设置一个关键区域。Java通过“同步块”提供对关键区域的支持；这一次，我们用synchronized关键字指出对象的锁用于对其中封闭的代码进行同步。\n在能进入同步块之前，必须在synchObject上取得锁。如果已有其他线程取得了这把锁，块便不能进入，必须等候那把锁被释放。 可从整个run()中删除synchronized关键字，换成用一个同步块包围两个关键行，从而完成对Sharing2例子的修改。但什么对象应作为锁来使用呢？那个对象已由synchTest()标记出来了——也就是当前对象（this）！所以修改过的run()方法象下面这个样子：\npublic void run() {\rwhile (true) {\rsynchronized(this) {\rt1.setText(Integer.toString(count1++));\rt2.setText(Integer.toString(count2++));\r}\rtry {\rsleep(500);\r} catch (InterruptedException e){}\r}\r} 这是必须对Sharing2.java作出的唯一修改，我们会看到尽管两个计数器永远不会脱离同步（取决于允许Watcher什么时候检查它们），但在run()执行期间，仍然向Watcher提供了足够的访问权限。\n当然，所有同步都取决于程序员是否勤奋：要访问共享资源的每一部分代码都必须封装到一个适当的同步块里。\n同步的效率 由于要为同样的数据编写两个方法，所以无论如何都不会给人留下效率很高的印象。看来似乎更好的一种做法是将所有方法都设为自动同步，并完全消除synchronized关键字（当然，含有synchronized run()的例子显示出这样做是很不通的）。但它也揭示出获取一把锁并非一种“廉价”方案——为一次方法调用付出的代价（进入和退出方法，不执行方法主体）至少要累加到四倍，而且根据我们的具体现方案，这一代价还有可能变得更高。所以假如已知一个方法不会造成冲突，最明智的做法便是撤消其中的synchronized关键字。\n14.2.3 回顾 Java Beans 我们现在已理解了同步，接着可换从另一个角度来考察Java Beans。无论什么时候创建了一个Bean，就必须假定它要在一个多线程的环境中运行。这意味着：\n(1) 只要可行，Bean的所有公共方法都应同步。当然，这也带来了“同步”在运行期间的开销。若特别在意这个问题，在关键区域中不会造成问题的方法就可保留为“不同步”，但注意这通常都不是十分容易判断。有资格的方法倾向于规模很小（如下例的getCircleSize()）以及／或者“微小”。也就是说，这个方法调用在如此少的代码片里执行，以至于在执行期间对象不能改变。如果将这种方法设为“不同步”，可能对程序的执行速度不会有明显的影响。可能也将一个Bean的所有public方法都设为synchronized，并只有在保证特别必要、而且会造成一个差异的情况下，才将synchronized关键字删去。\n并只有在保证特别必要、而且会造成一个差异的情况下，才将synchronized关键字删去。\n(2) 如果将一个多造型事件送给一系列对那个事件感兴趣的“听众”，必须假在列表中移动的时候可以添加或者删除。\n第一点很容易处理，但第二点需要考虑更多的东西。让我们以前一章提供的BangBean.java为例。在那个例子中，我们忽略了synchronized关键字（那时还没有引入呢），并将造型设为单造型，从而回避了多线程的问题。在下面这个修改过的版本中，我们使其能在多线程环境中工作，并为事件采用了多造型技术：\n//: BangBean2.java // You should write your Beans this way so they // can run in a multithreaded environment. import java.awt.*; import java.awt.event.*; import java.util.*; import java.io.*; public class BangBean2 extends Canvas implements Serializable { private int xm, ym; private int cSize = 20; // Circle size private String text = \u0026#34;Bang!\u0026#34;; private int fontSize = 48; private Color tColor = Color.red; private Vector actionListeners = new Vector(); public BangBean2() { addMouseListener(new ML()); addMouseMotionListener(new MM()); } public synchronized int getCircleSize() { return cSize; } public synchronized void setCircleSize(int newSize) { cSize = newSize; } public synchronized String getBangText() { return text; } public synchronized void setBangText(String newText) { text = newText; } public synchronized int getFontSize() { return fontSize; } public synchronized void setFontSize(int newSize) { fontSize = newSize; } public synchronized Color getTextColor() { return tColor; } public synchronized void setTextColor(Color newColor) { tColor = newColor; } public void paint(Graphics g) { g.setColor(Color.black); g.drawOval(xm - cSize/2, ym - cSize/2, cSize, cSize); } // This is a multicast listener, which is // more typically used than the unicast // approach taken in BangBean.java: public synchronized void addActionListener ( ActionListener l) { actionListeners.addElement(l); } public synchronized void removeActionListener( ActionListener l) { actionListeners.removeElement(l); } // Notice this isn\u0026#39;t synchronized: public void notifyListeners() { ActionEvent a = new ActionEvent(BangBean2.this, ActionEvent.ACTION_PERFORMED, null); Vector lv = null; // Make a copy of the vector in case someone // adds a listener while we\u0026#39;re // calling listeners: synchronized(this) { lv = (Vector)actionListeners.clone(); } // Call all the listener methods: for(int i = 0; i \u0026lt; lv.size(); i++) { ActionListener al = (ActionListener)lv.elementAt(i); al.actionPerformed(a); } } class ML extends MouseAdapter { public void mousePressed(MouseEvent e) { Graphics g = getGraphics(); g.setColor(tColor); g.setFont( new Font( \u0026#34;TimesRoman\u0026#34;, Font.BOLD, fontSize)); int width = g.getFontMetrics().stringWidth(text); g.drawString(text, (getSize().width - width) /2, getSize().height/2); g.dispose(); notifyListeners(); } } class MM extends MouseMotionAdapter { public void mouseMoved(MouseEvent e) { xm = e.getX(); ym = e.getY(); repaint(); } } // Testing the BangBean2: public static void main(String[] args) { BangBean2 bb = new BangBean2(); bb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e){ System.out.println(\u0026#34;ActionEvent\u0026#34; + e); } }); bb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e){ System.out.println(\u0026#34;BangBean2 action\u0026#34;); } }); bb.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e){ System.out.println(\u0026#34;More action\u0026#34;); } }); Frame aFrame = new Frame(\u0026#34;BangBean2 Test\u0026#34;); aFrame.addWindowListener(new WindowAdapter(){ public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(bb, BorderLayout.CENTER); aFrame.setSize(300,300); aFrame.setVisible(true); } } ///:~ 很容易就可以为方法添加synchronized。但注意在addActionListener()和removeActionListener()中，现在添加了ActionListener，并从一个Vector中移去，所以能够根据自己愿望使用任意多个。\n我们注意到，notifyListeners()方法并未设为“同步”。可从多个线程中发出对这个方法的调用。另外，在对notifyListeners()调用的中途，也可能发出对addActionListener()和removeActionListener()的调用。这显然会造成问题，因为它否定了Vector actionListeners。为缓解这个问题，我们在一个synchronized从句中“克隆”了Vector，并对克隆进行了否定。这样便可在不影响notifyListeners()的前提下，对Vector进行操纵。\npaint()方法也没有设为“同步”。与单纯地添加自己的方法相比，决定是否对过载的方法进行同步要困难得多。在这个例子中，无论paint()是否“同步”，它似乎都能正常地工作。但必须考虑的问题包括：\n(1) 方法会在对象内部修改“关键”变量的状态吗？为判断一个变量是否“关键”，必须知道它是否会被程序中的其他线程读取或设置（就目前的情况看，读取或设置几乎肯定是通过“同步”方法进行的，所以可以只对它们进行检查）。对paint()的情况来说，不会发生任何修改。\n(2) 方法要以这些“关键”变量的状态为基础吗？如果一个“同步”方法修改了一个变量，而我们的方法要用到这个变量，那么一般都愿意把自己的方法也设为“同步”。基于这一前提，大家可观察到cSize由“同步”方法进行了修改，所以paint()应当是“同步”的。但在这里，我们可以问：“假如cSize在paint()执行期间发生了变化，会发生的最糟糕的事情是什么呢？”如果发现情况不算太坏，而且仅仅是暂时的效果，那么最好保持paint()的“不同步”状态，以避免同步方法调用带来的额外开销。\n(3) 要留意的第三条线索是paint()基础类版本是否“同步”，在这里它不是同步的。这并不是一个非常严格的参数，仅仅是一条“线索”。比如在目前的情况下，通过同步方法（好cSize）改变的一个字段已合成到paint()公式里，而且可能已改变了情况。但请注意，synchronized不能继承——也就是说，假如一个方法在基础类中是“同步”的，那么在衍生类过载版本中，它不会自动进入“同步”状态。\nsynchronized不能继承——也就是说，假如一个方法在基础类中是“同步”的，那么在衍生类过载版本中，它不会自动进入“同步”状态。\nTestBangBean2中的测试代码已在前一章的基础上进行了修改，已在其中加入了额外的“听众”，从而演示了BangBean2的多造型能力。\n14.3 堵塞 (1) 新（New）：线程对象已经创建，但尚未启动，所以不可运行。\n(2) 可运行（Runnable）：意味着一旦时间分片机制有空闲的CPU周期提供给一个线程，那个线程便可立即开始运行。因此，线程可能在、也可能不在运行当中，但一旦条件许可，没有什么能阻止它的运行——它既没有“死”掉，也未被“堵塞”。\n(3) 死（Dead）：从自己的run()方法中返回后，一个线程便已“死”掉。亦可调用stop()令其死掉，但会产生一个违例——属于 Error的一个子类（也就是说，我们通常不捕获它）。记住一个违例的“掷”出应当是一个特殊事件，而不是正常程序运行的一部分。所以不建议你使用stop()（在Java 1.2则是坚决反对）。另外还有一个destroy()方法（它永远不会实现），应该尽可能地避免调用它，因为它非常武断，根本不会解除对象的锁定。\n(4) 堵塞（Blocked）：线程可以运行，但有某种东西阻碍了它。若线程处于堵塞状态，调度机制可以简单地跳过它，不给它分配任何CPU时间。除非线程再次进入“可运行”状态，否则不会采取任何操作。\n14.3.1 为何会堵塞 堵塞状态是前述四种状态中最有趣的，值得我们作进一步的探讨。线程被堵塞可能是由下述五方面的原因造成的：\n(1) 调用sleep(毫秒数)，使线程进入“睡眠”状态。在规定的时间内，这个线程是不会运行的。\n(2) 用suspend()暂停了线程的执行。除非线程收到resume()消息，否则不会返回“可运行”状态。\n(3) 用wait()暂停了线程的执行。除非线程收到nofify()或者notifyAll()消息，否则不会变成“可运行”（是的，这看起来同原因2非常相象，但有一个明显的区别是我们马上要揭示的）。\n(4) 线程正在等候一些IO（输入输出）操作完成。\n(5) 线程试图调用另一个对象的“同步”方法，但那个对象处于锁定状态，暂时无法使用。\n亦可调用yield()（Thread类的一个方法）自动放弃CPU，以便其他线程能够运行。然而，假如调度机制觉得我们的线程已拥有足够的时间，并跳转到另一个线程，就会发生同样的事情。也就是说，没有什么能防止调度机制重新启动我们的线程。线程被堵塞后，便有一些原因造成它不能继续运行。\n下面这个例子展示了进入堵塞状态的全部五种途径。它们全都存在于名为Blocking.java的一个文件中，但在这儿采用散落的片断进行解释（大家可注意到片断前后的“Continued”以及“Continuing”标志。利用第17章介绍的工具，可将这些片断连结到一起）。首先让我们看看基本的框架：\n//: Blocking.java // Demonstrates the various ways a thread // can be blocked. import java.awt.*; import java.awt.event.*; import java.applet.*; import java.io.*; //////////// The basic framework /////////// class Blockable extends Thread { private Peeker peeker; protected TextField state = new TextField(40); protected int i; public Blockable(Container c) { c.add(state); peeker = new Peeker(this, c); } public synchronized int read() { return i; } protected synchronized void update() { state.setText(getClass().getName() + \u0026#34; state: i = \u0026#34; + i); } public void stopPeeker() { // peeker.stop(); Deprecated in Java 1.2 peeker.terminate(); // The preferred approach } } class Peeker extends Thread { private Blockable b; private int session; private TextField status = new TextField(40); private boolean stop = false; public Peeker(Blockable b, Container c) { c.add(status); this.b = b; start(); } public void terminate() { stop = true; } public void run() { while (!stop) { status.setText(b.getClass().getName() + \u0026#34; Peeker \u0026#34; + (++session) + \u0026#34;; value = \u0026#34; + b.read()); try { sleep(100); } catch (InterruptedException e){} } } } ///:Continued Blockable类打算成为本例所有类的一个基础类。一个Blockable对象包含了一个名为state的TextField（文本字段），用于显示出对象有关的信息。用于显示这些信息的方法叫作update()。我们发现它用getClass.getName()来产生类名，而不是仅仅把它打印出来；这是由于update(0不知道自己为其调用的那个类的准确名字，因为那个类是从Blockable衍生出来的。 在Blockable中，变动指示符是一个int i；衍生类的run()方法会为其增值。\n针对每个Bloackable对象，都会启动Peeker类的一个线程。Peeker的任务是调用read()方法，检查与自己关联的Blockable对象，看看i是否发生了变化，最后用它的status文本字段报告检查结果。注意read()和update()都是同步的，要求对象的锁定能自由解除，这一点非常重要。\n睡眠 这个程序的第一项测试是用sleep()作出的：\n///:Continuing ///////////// Blocking via sleep() /////////// class Sleeper1 extends Blockable { public Sleeper1(Container c) { super(c); } public synchronized void run() { while(true) { i++; update(); try { sleep(1000); } catch (InterruptedException e){} } } } class Sleeper2 extends Blockable { public Sleeper2(Container c) { super(c); } public void run() { while(true) { change(); try { sleep(1000); } catch (InterruptedException e){} } } public synchronized void change() { i++; update(); } } ///:Continued 在Sleeper1中，整个run()方法都是同步的。我们可看到与这个对象关联在一起的Peeker可以正常运行，直到我们启动线程为止，随后Peeker便会完全停止。这正是“堵塞”的一种形式：因为Sleeper1.run()是同步的，而且一旦线程启动，它就肯定在run()内部，方法永远不会放弃对象锁定，造成Peeker线程的堵塞。\nSleeper2通过设置不同步的运行，提供了一种解决方案。只有change()方法才是同步的，所以尽管run()位于sleep()内部，Peeker仍然能访问自己需要的同步方法——read()。在这里，我们可看到在启动了Sleeper2线程以后，Peeker会持续运行下去。\n暂停和恢复 这个例子接下来的一部分引入了“挂起”或者“暂停”（Suspend）的概述。Thread类提供了一个名为suspend()的方法，可临时中止线程；以及一个名为resume()的方法，用于从暂停处开始恢复线程的执行。显然，我们可以推断出resume()是由暂停线程外部的某个线程调用的。在这种情况下，需要用到一个名为Resumer（恢复器）的独立类。演示暂停／恢复过程的每个类都有一个相关的恢复器。如下所示：\n///:Continuing /////////// Blocking via suspend() /////////// class SuspendResume extends Blockable { public SuspendResume(Container c) { super(c); new Resumer(this); } } class SuspendResume1 extends SuspendResume { public SuspendResume1(Container c) { super(c);} public synchronized void run() { while(true) { i++; update(); suspend(); // Deprecated in Java 1.2 } } } class SuspendResume2 extends SuspendResume { public SuspendResume2(Container c) { super(c);} public void run() { while(true) { change(); suspend(); // Deprecated in Java 1.2 } } public synchronized void change() { i++; update(); } } class Resumer extends Thread { private SuspendResume sr; public Resumer(SuspendResume sr) { this.sr = sr; start(); } public void run() { while(true) { try { sleep(1000); } catch (InterruptedException e){} sr.resume(); // Deprecated in Java 1.2 } } } ///:Continued SuspendResume1也提供了一个同步的run()方法。同样地，当我们启动这个线程以后，就会发现与它关联的Peeker进入“堵塞”状态，等候对象锁被释放，但那永远不会发生。和往常一样，这个问题在SuspendResume2里得到了解决，它并不同步整个run()方法，而是采用了一个单独的同步change()方法。\n对于Java 1.2，大家应注意suspend()和resume()已获得强烈反对，因为suspend()包含了对象锁，所以极易出现“死锁”现象。换言之，很容易就会看到许多被锁住的对象在傻乎乎地等待对方。这会造成整个应用程序的“凝固”。尽管在一些老程序中还能看到它们的踪迹，但在你写自己的程序时，无论如何都应避免。本章稍后就会讲述正确的方案是什么。\n等待和通知 通过前两个例子的实践，我们知道无论sleep()还是suspend()都不会在自己被调用的时候解除锁定。需要用到对象锁时，请务必注意这个问题。在另一方面，wait()方法在被调用时却会解除锁定，这意味着可在执行wait()期间调用线程对象中的其他同步方法。但在接着的两个类中，我们看到run()方法都是“同步”的。在wait()期间，Peeker仍然拥有对同步方法的完全访问权限。这是由于wait()在挂起内部调用的方法时，会解除对象的锁定。\n我们也可以看到wait()的两种形式。第一种形式采用一个以毫秒为单位的参数，它具有与sleep()中相同的含义：暂停这一段规定时间。区别在于在wait()中，对象锁已被解除，而且能够自由地退出wait()，因为一个notify()可强行使时间流逝。\n第二种形式不采用任何参数，这意味着wait()会持续执行，直到notify()介入为止。而且在一段时间以后，不会自行中止。 wait()和notify()比较特别的一个地方是这两个方法都属于基础类Object的一部分，不象sleep()，suspend()以及resume()那样属于Thread的一部分。尽管这表面看有点儿奇怪——居然让专门进行线程处理的东西成为通用基础类的一部分——但仔细想想又会释然，因为它们操纵的对象锁也属于每个对象的一部分。因此，我们可将一个wait()置入任何同步方法内部，无论在那个类里是否准备进行涉及线程的处理。事实上，我们能调用wait()的唯一地方是在一个同步的方法或代码块内部。若在一个不同步的方法内调用wait()或者notify()，尽管程序仍然会编译，但在运行它的时候，就会得到一个IllegalMonitorStateException（非法监视器状态违例），而且会出现多少有点莫名其妙的一条消息：“current thread not owner”（当前线程不是所有人”。注意sleep()，suspend()以及resume()都能在不同步的方法内调用，因为它们不需要对锁定进行操作。\n只能为自己的锁定调用wait()和notify()。同样地，仍然可以编译那些试图使用错误锁定的代码，但和往常一样会产生同样的IllegalMonitorStateException违例。我们没办法用其他人的对象锁来愚弄系统，但可要求另一个对象执行相应的操作，对它自己的锁进行操作。所以一种做法是创建一个同步方法，令其为自己的对象调用notify()。但在Notifier中，我们会看到一个同步方法内部的notify()：\nsynchronized(wn2) {\rwn2.notify();\r} 其中，wn2是类型为WaitNotify2的对象。尽管并不属于WaitNotify2的一部分，这个方法仍然获得了wn2对象的锁定。在这个时候，它为wn2调用notify()是合法的，不会得到IllegalMonitorStateException违例。\n///:Continuing /////////// Blocking via wait() /////////// class WaitNotify1 extends Blockable { public WaitNotify1(Container c) { super(c); } public synchronized void run() { while(true) { i++; update(); try { wait(1000); } catch (InterruptedException e){} } } } class WaitNotify2 extends Blockable { public WaitNotify2(Container c) { super(c); new Notifier(this); } public synchronized void run() { while(true) { i++; update(); try { wait(); } catch (InterruptedException e){} } } } class Notifier extends Thread { private WaitNotify2 wn2; public Notifier(WaitNotify2 wn2) { this.wn2 = wn2; start(); } public void run() { while(true) { try { sleep(2000); } catch (InterruptedException e){} synchronized(wn2) { wn2.notify(); } } } } ///:Continued 若必须等候其他某些条件（从线程外部加以控制）发生变化，同时又不想在线程内一直傻乎乎地等下去，一般就需要用到wait()。wait()允许我们将线程置入“睡眠”状态，同时又“积极”地等待条件发生改变。而且只有在一个notify()或notifyAll()发生变化的时候，线程才会被唤醒，并检查条件是否有变。因此，我们认为它提供了在线程间进行同步的一种手段。\nIO堵塞 若一个数据流必须等候一些IO活动，便会自动进入“堵塞”状态。在本例下面列出的部分中，有两个类协同通用的Reader以及Writer对象工作（使用Java 1.1的流）。但在测试模型中，会设置一个管道化的数据流，使两个线程相互间能安全地传递数据（这正是使用管道流的目的）。\nSender将数据置入Writer，并“睡眠”随机长短的时间。然而，Receiver本身并没有包括sleep()，suspend()或者wait()方法。但在执行read()的时候，如果没有数据存在，它会自动进入“堵塞”状态。如下所示：\n///:Continuing class Sender extends Blockable { // send private Writer out; public Sender(Container c, Writer out) { super(c); this.out = out; } public void run() { while(true) { for(char c = \u0026#39;A\u0026#39;; c \u0026lt;= \u0026#39;z\u0026#39;; c++) { try { i++; out.write(c); state.setText(\u0026#34;Sender sent: \u0026#34; + (char)c); sleep((int)(3000 * Math.random())); } catch (InterruptedException e){} catch (IOException e) {} } } } } class Receiver extends Blockable { private Reader in; public Receiver(Container c, Reader in) { super(c); this.in = in; } public void run() { try { while(true) { i++; // Show peeker it\u0026#39;s alive // Blocks until characters are there: state.setText(\u0026#34;Receiver read: \u0026#34; + (char)in.read()); } } catch(IOException e) { e.printStackTrace();} } } ///:Continued 这两个类也将信息送入自己的state字段，并修改i值，使Peeker知道线程仍在运行。\n测试 令人惊讶的是，主要的程序片（Applet）类非常简单，这是大多数工作都已置入Blockable框架的缘故。大概地说，我们创建了一个由Blockable对象构成的数组。而且由于每个对象都是一个线程，所以在按下“start”按钮后，它们会采取自己的行动。还有另一个按钮和actionPerformed()从句，用于中止所有Peeker对象。由于Java 1.2“反对”使用Thread的stop()方法，所以可考虑采用这种折衷形式的中止方式。\n为了在Sender和Receiver之间建立一个连接，我们创建了一个PipedWriter和一个PipedReader。注意PipedReader in必须通过一个构建器参数同PipedWriterout连接起来。在那以后，我们在out内放进去的所有东西都可从in中提取出来——似乎那些东西是通过一个“管道”传输过去的。随后将in和out对象分别传递给Receiver和Sender构建器；后者将它们当作任意类型的Reader和Writer看待（也就是说，它们被“上溯”造型了）。 Blockable句柄b的数组在定义之初并未得到初始化，因为管道化的数据流是不可在定义前设置好的（对try块的需要将成为障碍）：\n///:Continuing /////////// Testing Everything /////////// public class Blocking extends Applet { private Button start = new Button(\u0026#34;Start\u0026#34;), stopPeekers = new Button(\u0026#34;Stop Peekers\u0026#34;); private boolean started = false; private Blockable[] b; private PipedWriter out; private PipedReader in; public void init() { out = new PipedWriter(); try { in = new PipedReader(out); } catch(IOException e) {} b = new Blockable[] { new Sleeper1(this), new Sleeper2(this), new SuspendResume1(this), new SuspendResume2(this), new WaitNotify1(this), new WaitNotify2(this), new Sender(this, out), new Receiver(this, in) }; start.addActionListener(new StartL()); add(start); stopPeekers.addActionListener( new StopPeekersL()); add(stopPeekers); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(!started) { started = true; for(int i = 0; i \u0026lt; b.length; i++) b[i].start(); } } } class StopPeekersL implements ActionListener { public void actionPerformed(ActionEvent e) { // Demonstration of the preferred // alternative to Thread.stop(): for(int i = 0; i \u0026lt; b.length; i++) b[i].stopPeeker(); } } public static void main(String[] args) { Blocking applet = new Blocking(); Frame aFrame = new Frame(\u0026#34;Blocking\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(350,550); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ 在init()中，注意循环会遍历整个数组，并为页添加state和peeker.status文本字段。\n首次创建好Blockable线程以后，每个这样的线程都会自动创建并启动自己的Peeker。所以我们会看到各个Peeker都在Blockable线程启动之前运行起来。这一点非常重要，因为在Blockable线程启动的时候，部分Peeker会被堵塞，并停止运行。弄懂这一点，将有助于我们加深对“堵塞”这一概念的认识。\n14.3.2 死锁 由于线程可能进入堵塞状态，而且由于对象可能拥有“同步”方法——除非同步锁定被解除，否则线程不能访问那个对象——所以一个线程完全可能等候另一个对象，而另一个对象又在等候下一个对象，以此类推。这个“等候”链最可怕的情形就是进入封闭状态——最后那个对象等候的是第一个对象！此时，所有线程都会陷入无休止的相互等待状态，大家都动弹不得。我们将这种情况称为“死锁”。尽管这种情况并非经常出现，但一旦碰到，程序的调试将变得异常艰难。 就语言本身来说，尚未直接提供防止死锁的帮助措施，需要我们通过谨慎的设计来避免。如果有谁需要调试一个死锁的程序，他是没有任何窍门可用的。\nJava 1.2对stop()，suspend()，resume()以及destroy()的反对 为减少出现死锁的可能，Java 1.2作出的一项贡献是“反对”使用Thread的stop()，suspend()，resume()以及destroy()方法。\n之所以反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态（“被破坏”），那么其他线程能在那种状态下检查和修改它们。结果便造成了一种微妙的局面，我们很难检查出真正的问题所在。所以应尽量避免使用stop()，应该采用Blocking.java那样的方法，用一个标志告诉线程什么时候通过退出自己的run()方法来中止自己的执行。\n如果一个线程被堵塞，比如在它等候输入的时候，那么一般都不能象在Blocking.java中那样轮询一个标志。但在这些情况下，我们仍然不该使用stop()，而应换用由Thread提供的interrupt()方法，以便中止并退出堵塞的代码。\n//: Interrupt.java // The alternative approach to using stop() // when a thread is blocked import java.awt.*; import java.awt.event.*; import java.applet.*; class Blocked extends Thread { public synchronized void run() { try { wait(); // Blocks } catch(InterruptedException e) { System.out.println(\u0026#34;InterruptedException\u0026#34;); } System.out.println(\u0026#34;Exiting run()\u0026#34;); } } public class Interrupt extends Applet { private Button interrupt = new Button(\u0026#34;Interrupt\u0026#34;); private Blocked blocked = new Blocked(); public void init() { add(interrupt); interrupt.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println(\u0026#34;Button pressed\u0026#34;); if(blocked == null) return; Thread remove = blocked; blocked = null; // to release it remove.interrupt(); } }); blocked.start(); } public static void main(String[] args) { Interrupt applet = new Interrupt(); Frame aFrame = new Frame(\u0026#34;Interrupt\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(200,100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Blocked.run()内部的wait()会产生堵塞的线程。当我们按下按钮以后，blocked（堵塞）的句柄就会设为null，使垃圾收集器能够将其清除，然后调用对象的interrupt()方法。如果是首次按下按钮，我们会看到线程正常退出。但在没有可供“杀死”的线程以后，看到的便只是按钮被按下而已。\nsuspend()和resume()方法天生容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成令人难堪的死锁。所以我们不应该使用suspend()和resume()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。我们可以修改前面的Counter2.java来实际体验一番。尽管两个版本的效果是差不多的，但大家会注意到代码的组织结构发生了很大的变化——为所有“听众”都使用了匿名的内部类，而且Thread是一个内部类。这使得程序的编写稍微方便一些，因为它取消了Counter2.java中一些额外的记录工作。\n//: Suspend.java // The alternative approach to using suspend() // and resume(), which have been deprecated // in Java 1.2. import java.awt.*; import java.awt.event.*; import java.applet.*; public class Suspend extends Applet { private TextField t = new TextField(10); private Button suspend = new Button(\u0026#34;Suspend\u0026#34;), resume = new Button(\u0026#34;Resume\u0026#34;); class Suspendable extends Thread { private int count = 0; private boolean suspended = false; public Suspendable() { start(); } public void fauxSuspend() { suspended = true; } public synchronized void fauxResume() { suspended = false; notify(); } public void run() { while (true) { try { sleep(100); synchronized(this) { while(suspended) wait(); } } catch (InterruptedException e){} t.setText(Integer.toString(count++)); } } } private Suspendable ss = new Suspendable(); public void init() { add(t); suspend.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent e) { ss.fauxSuspend(); } }); add(suspend); resume.addActionListener( new ActionListener() { public void actionPerformed(ActionEvent e) { ss.fauxResume(); } }); add(resume); } public static void main(String[] args) { Suspend applet = new Suspend(); Frame aFrame = new Frame(\u0026#34;Suspend\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e){ System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300,100); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Suspendable中的suspended（已挂起）标志用于开关“挂起”或者“暂停”状态。为挂起一个线程，只需调用fauxSuspend()将标志设为true（真）即可。对标志状态的侦测是在run()内进行的。就象本章早些时候提到的那样，wait()必须设为“同步”（synchronized），使其能够使用对象锁。在fauxResume()中，suspended标志被设为false（假），并调用notify()——由于这会在一个“同步”从句中唤醒wait()，所以fauxResume()方法也必须同步，使其能在调用notify()之前取得对象锁（这样一来，对象锁可由要唤醍的那个wait()使用）。如果遵照本程序展示的样式，可以避免使用wait()和notify()。 Thread的destroy()方法根本没有实现；它类似一个根本不能恢复的suspend()，所以会发生与suspend()一样的死锁问题。然而，这一方法没有得到明确的“反对”，也许会在Java以后的版本（1.2版以后）实现，用于一些可以承受死锁危险的特殊场合。 大家可能会奇怪当初为什么要实现这些现在又被“反对”的方法。之所以会出现这种情况，大概是由于Sun公司主要让技术人员来决定对语言的改动，而不是那些市场销售人员。通常，技术人员比搞销售的更能理解语言的实质。当初犯下了错误以后，也能较为理智地正视它们。这意味着Java能够继续进步，即便这使Java程序员多少感到有些不便。就我自己来说，宁愿面对这些不便之处，也不愿看到语言停滞不前。\n14.4 优先级 线程的优先级（Priority）告诉调试程序该线程的重要程度有多大。如果有大量线程都被堵塞，都在等候运行，调试程序会首先运行具有最高优先级的那个线程。然而，这并不表示优先级较低的线程不会运行（换言之，不会因为存在优先级而导致死锁）。若线程的优先级较低，只不过表示它被准许运行的机会小一些而已。\n可用getPriority()方法读取一个线程的优先级，并用setPriority()改变它。在下面这个程序片中，大家会发现计数器的计数速度慢了下来，因为它们关联的线程分配了较低的优先级：\n//: Counter5.java // Adjusting the priorities of threads import java.awt.*; import java.awt.event.*; import java.applet.*; class Ticker2 extends Thread { private Button b = new Button(\u0026#34;Toggle\u0026#34;), incPriority = new Button(\u0026#34;up\u0026#34;), decPriority = new Button(\u0026#34;down\u0026#34;); private TextField t = new TextField(10), pr = new TextField(3); // Display priority private int count = 0; private boolean runFlag = true; public Ticker2(Container c) { b.addActionListener(new ToggleL()); incPriority.addActionListener(new UpL()); decPriority.addActionListener(new DownL()); Panel p = new Panel(); p.add(t); p.add(pr); p.add(b); p.add(incPriority); p.add(decPriority); c.add(p); } class ToggleL implements ActionListener { public void actionPerformed(ActionEvent e) { runFlag = !runFlag; } } class UpL implements ActionListener { public void actionPerformed(ActionEvent e) { int newPriority = getPriority() + 1; if(newPriority \u0026gt; Thread.MAX_PRIORITY) newPriority = Thread.MAX_PRIORITY; setPriority(newPriority); } } class DownL implements ActionListener { public void actionPerformed(ActionEvent e) { int newPriority = getPriority() - 1; if(newPriority \u0026lt; Thread.MIN_PRIORITY) newPriority = Thread.MIN_PRIORITY; setPriority(newPriority); } } public void run() { while (true) { if(runFlag) { t.setText(Integer.toString(count++)); pr.setText( Integer.toString(getPriority())); } yield(); } } } public class Counter5 extends Applet { private Button start = new Button(\u0026#34;Start\u0026#34;), upMax = new Button(\u0026#34;Inc Max Priority\u0026#34;), downMax = new Button(\u0026#34;Dec Max Priority\u0026#34;); private boolean started = false; private static final int SIZE = 10; private Ticker2[] s = new Ticker2[SIZE]; private TextField mp = new TextField(3); public void init() { for(int i = 0; i \u0026lt; s.length; i++) s[i] = new Ticker2(this); add(new Label(\u0026#34;MAX_PRIORITY = \u0026#34; + Thread.MAX_PRIORITY)); add(new Label(\u0026#34;MIN_PRIORITY = \u0026#34; + Thread.MIN_PRIORITY)); add(new Label(\u0026#34;Group Max Priority = \u0026#34;)); add(mp); add(start); add(upMax); add(downMax); start.addActionListener(new StartL()); upMax.addActionListener(new UpMaxL()); downMax.addActionListener(new DownMaxL()); showMaxPriority(); // Recursively display parent thread groups: ThreadGroup parent = s[0].getThreadGroup().getParent(); while(parent != null) { add(new Label( \u0026#34;Parent threadgroup max priority = \u0026#34; + parent.getMaxPriority())); parent = parent.getParent(); } } public void showMaxPriority() { mp.setText(Integer.toString( s[0].getThreadGroup().getMaxPriority())); } class StartL implements ActionListener { public void actionPerformed(ActionEvent e) { if(!started) { started = true; for(int i = 0; i \u0026lt; s.length; i++) s[i].start(); } } } class UpMaxL implements ActionListener { public void actionPerformed(ActionEvent e) { int maxp = s[0].getThreadGroup().getMaxPriority(); if(++maxp \u0026gt; Thread.MAX_PRIORITY) maxp = Thread.MAX_PRIORITY; s[0].getThreadGroup().setMaxPriority(maxp); showMaxPriority(); } } class DownMaxL implements ActionListener { public void actionPerformed(ActionEvent e) { int maxp = s[0].getThreadGroup().getMaxPriority(); if(--maxp \u0026lt; Thread.MIN_PRIORITY) maxp = Thread.MIN_PRIORITY; s[0].getThreadGroup().setMaxPriority(maxp); showMaxPriority(); } } public static void main(String[] args) { Counter5 applet = new Counter5(); Frame aFrame = new Frame(\u0026#34;Counter5\u0026#34;); aFrame.addWindowListener( new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); aFrame.add(applet, BorderLayout.CENTER); aFrame.setSize(300, 600); applet.init(); applet.start(); aFrame.setVisible(true); } } ///:~ Ticker采用本章前面构造好的形式，但有一个额外的TextField（文本字段），用于显示线程的优先级；以及两个额外的按钮，用于人为提高及降低优先级。\n也要注意yield()的用法，它将控制权自动返回给调试程序（机制）。若不进行这样的处理，多线程机制仍会工作，但我们会发现它的运行速度慢了下来（试试删去对yield()的调用）。亦可调用sleep()，但假若那样做，计数频率就会改由sleep()的持续时间控制，而不是优先级。\nCounter5中的init()创建了由10个Ticker2构成的一个数组；它们的按钮以及输入字段（文本字段）由Ticker2构建器置入窗体。Counter5增加了新的按钮，用于启动一切，以及用于提高和降低线程组的最大优先级。除此以外，还有一些标签用于显示一个线程可以采用的最大及最小优先级；以及一个特殊的文本字段，用于显示线程组的最大优先级（在下一节里，我们将全面讨论线程组的问题）。最后，父线程组的优先级也作为标签显示出来。\n按下“up”（上）或“down”（下）按钮的时候，会先取得Ticker2当前的优先级，然后相应地提高或者降低。 运行该程序时，我们可注意到几件事情。首先，线程组的默认优先级是5。即使在启动线程之前（或者在创建线程之前，这要求对代码进行适当的修改）将最大优先级降到5以下，每个线程都会有一个5的默认优先级。\n最简单的测试是获取一个计数器，将它的优先级降低至1，此时应观察到它的计数频率显著放慢。现在试着再次提高优先级，可以升高回线程组的优先级，但不能再高了。现在将线程组的优先级降低两次。线程的优先级不会改变，但假若试图提高或者降低它，就会发现这个优先级自动变成线程组的优先级。此外，新线程仍然具有一个默认优先级，即使它比组的优先级还要高（换句话说，不要指望利用组优先级来防止新线程拥有比现有的更高的优先级）。\n最后，试着提高组的最大优先级。可以发现，这样做是没有效果的。我们只能减少线程组的最大优先级，而不能增大它。\n14.4.1 线程组 所有线程都隶属于一个线程组。那可以是一个默认线程组，亦可是一个创建线程时明确指定的组。在创建之初，线程被限制到一个组里，而且不能改变到一个不同的组。每个应用都至少有一个线程从属于系统线程组。若创建多个线程而不指定一个组，它们就会自动归属于系统线程组。\n线程组也必须从属于其他线程组。必须在构建器里指定新线程组从属于哪个线程组。若在创建一个线程组的时候没有指定它的归属，则同样会自动成为系统线程组的一名属下。因此，一个应用程序中的所有线程组最终都会将系统线程组作为自己的“父”。 之所以要提出“线程组”的概念，很难从字面上找到原因。这多少为我们讨论的主题带来了一些混乱。一般地说，我们认为是由于“安全”或者“保密”方面的理由才使用线程组的。根据Arnold和Gosling的说法：“线程组中的线程可以修改组内的其他线程，包括那些位于分层结构最深处的。一个线程不能修改位于自己所在组或者下属组之外的任何线程”（注释①）。然而，我们很难判断“修改”在这儿的具体含义是什么。下面这个例子展示了位于一个“叶子组”内的线程能修改它所在线程组树的所有线程的优先级，同时还能为这个“树”内的所有线程都调用一个方法。\n①：《The Java Programming Language》第179页。该书由Arnold和Jams Gosling编著，Addison-Wesley于1996年出版 //: TestAccess.java // How threads can access other threads // in a parent thread group public class TestAccess { public static void main(String[] args) { ThreadGroup x = new ThreadGroup(\u0026#34;x\u0026#34;), y = new ThreadGroup(x, \u0026#34;y\u0026#34;), z = new ThreadGroup(y, \u0026#34;z\u0026#34;); Thread one = new TestThread1(x, \u0026#34;one\u0026#34;), two = new TestThread2(z, \u0026#34;two\u0026#34;); } } class TestThread1 extends Thread { private int i; TestThread1(ThreadGroup g, String name) { super(g, name); } void f() { i++; // modify this thread System.out.println(getName() + \u0026#34; f()\u0026#34;); } } class TestThread2 extends TestThread1 { TestThread2(ThreadGroup g, String name) { super(g, name); start(); } public void run() { ThreadGroup g = getThreadGroup().getParent().getParent(); g.list(); Thread[] gAll = new Thread[g.activeCount()]; g.enumerate(gAll); for(int i = 0; i \u0026lt; gAll.length; i++) { gAll[i].setPriority(Thread.MIN_PRIORITY); ((TestThread1)gAll[i]).f(); } g.list(); } } ///:~ 在main()中，我们创建了几个ThreadGroup（线程组），每个都位于不同的“叶”上：x没有参数，只有它的名字（一个String），所以会自动进入“system”（系统）线程组；y位于x下方，而z位于y下方。注意初始化是按照文字顺序进行的，所以代码合法。\n有两个线程创建之后进入了不同的线程组。其中，TestThread1没有一个run()方法，但有一个f()，用于通知线程以及打印出一些东西，以便我们知道它已被调用。而TestThread2属于TestThread1的一个子类，它的run()非常详尽，要做许多事情。首先，它获得当前线程所在的线程组，然后利用getParent()在继承树中向上移动两级（这样做是有道理的，因为我想把TestThread2在分级结构中向下移动两级）。随后，我们调用方法activeCount()，查询这个线程组以及所有子线程组内有多少个线程，从而创建由指向Thread的句柄构成的一个数组。enumerate()方法将指向所有这些线程的句柄置入数组gAll里。然后在整个数组里遍历，为每个线程都调用f()方法，同时修改优先级。这样一来，位于一个“叶子”线程组里的线程就修改了位于父线程组的线程。\n调试方法list()打印出与一个线程组有关的所有信息，把它们作为标准输出。在我们对线程组的行为进行调查的时候，这样做是相当有好处的。下面是程序的输出：\njava.lang.ThreadGroup[name=x,maxpri=10]\rThread[one,5,x]\rjava.lang.ThreadGroup[name=y,maxpri=10]\rjava.lang.ThreadGroup[name=z,maxpri=10]\rThread[two,5,z]\rone f()\rtwo f()\rjava.lang.ThreadGroup[name=x,maxpri=10]\rThread[one,1,x]\rjava.lang.ThreadGroup[name=y,maxpri=10]\rjava.lang.ThreadGroup[name=z,maxpri=10]\rThread[two,1,z] list()不仅打印出ThreadGroup或者Thread的类名，也打印出了线程组的名字以及它的最高优先级。对于线程，则打印出它们的名字，并接上线程优先级以及所属的线程组。注意list()会对线程和线程组进行缩排处理，指出它们是未缩排的线程组的“子”。 大家可看到f()是由TestThread2的run()方法调用的，所以很明显，组内的所有线程都是相当脆弱的。然而，我们只能访问那些从自己的system线程组树分支出来的线程，而且或许这就是所谓“安全”的意思。我们不能访问其他任何人的系统线程树。\n线程组的控制 抛开安全问题不谈，线程组最有用的一个地方就是控制：只需用单个命令即可完成对整个线程组的操作。下面这个例子演示了这一点，并对线程组内优先级的限制进行了说明。括号内的注释数字便于大家比较输出结果：\n//: ThreadGroup1.java // How thread groups control priorities // of the threads inside them. public class ThreadGroup1 { public static void main(String[] args) { // Get the system thread \u0026amp; print its Info: ThreadGroup sys = Thread.currentThread().getThreadGroup(); sys.list(); // (1) // Reduce the system thread group priority: sys.setMaxPriority(Thread.MAX_PRIORITY - 1); // Increase the main thread priority: Thread curr = Thread.currentThread(); curr.setPriority(curr.getPriority() + 1); sys.list(); // (2) // Attempt to set a new group to the max: ThreadGroup g1 = new ThreadGroup(\u0026#34;g1\u0026#34;); g1.setMaxPriority(Thread.MAX_PRIORITY); // Attempt to set a new thread to the max: Thread t = new Thread(g1, \u0026#34;A\u0026#34;); t.setPriority(Thread.MAX_PRIORITY); g1.list(); // (3) // Reduce g1\u0026#39;s max priority, then attempt // to increase it: g1.setMaxPriority(Thread.MAX_PRIORITY - 2); g1.setMaxPriority(Thread.MAX_PRIORITY); g1.list(); // (4) // Attempt to set a new thread to the max: t = new Thread(g1, \u0026#34;B\u0026#34;); t.setPriority(Thread.MAX_PRIORITY); g1.list(); // (5) // Lower the max priority below the default // thread priority: g1.setMaxPriority(Thread.MIN_PRIORITY + 2); // Look at a new thread\u0026#39;s priority before // and after changing it: t = new Thread(g1, \u0026#34;C\u0026#34;); g1.list(); // (6) t.setPriority(t.getPriority() -1); g1.list(); // (7) // Make g2 a child Threadgroup of g1 and // try to increase its priority: ThreadGroup g2 = new ThreadGroup(g1, \u0026#34;g2\u0026#34;); g2.list(); // (8) g2.setMaxPriority(Thread.MAX_PRIORITY); g2.list(); // (9) // Add a bunch of new threads to g2: for (int i = 0; i \u0026lt; 5; i++) new Thread(g2, Integer.toString(i)); // Show information about all threadgroups // and threads: sys.list(); // (10) System.out.println(\u0026#34;Starting all threads:\u0026#34;); Thread[] all = new Thread[sys.activeCount()]; sys.enumerate(all); for(int i = 0; i \u0026lt; all.length; i++) if(!all[i].isAlive()) all[i].start(); // Suspends \u0026amp; Stops all threads in // this group and its subgroups: System.out.println(\u0026#34;All threads started\u0026#34;); sys.suspend(); // Deprecated in Java 1.2 // Never gets here... System.out.println(\u0026#34;All threads suspended\u0026#34;); sys.stop(); // Deprecated in Java 1.2 System.out.println(\u0026#34;All threads stopped\u0026#34;); } } ///:~ 下面的输出结果已进行了适当的编辑，以便用一页能够装下（java.lang.已被删去），而且添加了适当的数字，与前面程序列表中括号里的数字对应：\n(1) ThreadGroup[name=system,maxpri=10]\rThread[main,5,system]\r(2) ThreadGroup[name=system,maxpri=9]\rThread[main,6,system]\r(3) ThreadGroup[name=g1,maxpri=9]\rThread[A,9,g1]\r(4) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1]\r(5) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1]\rThread[B,8,g1]\r(6) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,6,g1]\r(7) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1]\r(8) ThreadGroup[name=g2,maxpri=3]\r(9) ThreadGroup[name=g2,maxpri=3]\r(10)ThreadGroup[name=system,maxpri=9]\rThread[main,6,system]\rThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1]\rThreadGroup[name=g2,maxpri=3]\rThread[0,6,g2]\rThread[1,6,g2]\rThread[2,6,g2]\rThread[3,6,g2]\rThread[4,6,g2]\rStarting all threads:\rAll threads started 所有程序都至少有一个线程在运行，而且main()采取的第一项行动便是调用Thread的一个static（静态）方法，名为currentThread()。从这个线程开始，线程组将被创建，而且会为结果调用list()。输出如下：\n(1) ThreadGroup[name=system,maxpri=10]\rThread[main,5,system] 我们可以看到，主线程组的名字是system，而主线程的名字是main，而且它从属于system线程组。 第二个练习显示出system组的最高优先级可以减少，而且main线程可以增大自己的优先级：\n(2) ThreadGroup[name=system,maxpri=9]\rThread[main,6,system] 第三个练习创建一个新的线程组，名为g1；它自动从属于system线程组，因为并没有明确指定它的归属关系。我们在g1内部放置了一个新线程，名为A。随后，我们试着将这个组的最大优先级设到最高的级别，并将A的优先级也设到最高一级。结果如下：\n(3) ThreadGroup[name=g1,maxpri=9]\rThread[A,9,g1] 可以看出，不可能将线程组的最大优先级设为高于它的父线程组。 第四个练习将g1的最大优先级降低两级，然后试着把它升至Thread.MAX_PRIORITY。结果如下：\n(4) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1] 同样可以看出，提高最大优先级的企图是失败的。我们只能降低一个线程组的最大优先级，而不能提高它。此外，注意线程A的优先级并未改变，而且它现在高于线程组的最大优先级。也就是说，线程组最大优先级的变化并不能对现有线程造成影响。 第五个练习试着将一个新线程设为最大优先级。如下所示：\n(5) ThreadGroup[name=g1,maxpri=8]\rThread[A,9,g1]\rThread[B,8,g1] 因此，新线程不能变到比最大线程组优先级还要高的一级。 这个程序的默认线程优先级是6；若新建一个线程，那就是它的默认优先级，而且不会发生变化，除非对优先级进行了特别的处理。练习六将把线程组的最大优先级降至默认线程优先级以下，看看在这种情况下新建一个线程会发生什么事情：\n(6) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,6,g1] 尽管线程组现在的最大优先级是3，但仍然用默认优先级6来创建新线程。所以，线程组的最大优先级不会影响默认优先级（事实上，似乎没有办法可以设置新线程的默认优先级）。 改变了优先级后，接下来试试将其降低一级，结果如下：\n(7) ThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1] 因此，只有在试图改变优先级的时候，才会强迫遵守线程组最大优先级的限制。 我们在(8)和(9)中进行了类似的试验。在这里，我们创建了一个新的线程组，名为g2，将其作为g1的一个子组，并改变了它的最大优先级。大家可以看到，g2的优先级无论如何都不可能高于g1：\n(8) ThreadGroup[name=g2,maxpri=3]\r(9) ThreadGroup[name=g2,maxpri=3] 也要注意在g2创建的时候，它会被自动设为g1的线程组最大优先级。 经过所有这些实验以后，整个线程组和线程系统都会被打印出来，如下所示：\n(10)ThreadGroup[name=system,maxpri=9]\rThread[main,6,system]\rThreadGroup[name=g1,maxpri=3]\rThread[A,9,g1]\rThread[B,8,g1]\rThread[C,3,g1]\rThreadGroup[name=g2,maxpri=3]\rThread[0,6,g2]\rThread[1,6,g2]\rThread[2,6,g2]\rThread[3,6,g2]\rThread[4,6,g2] 所以由线程组的规则所限，一个子组的最大优先级在任何时候都只能低于或等于它的父组的最大优先级。\n本程序的最后一个部分演示了用于整组线程的方法。程序首先遍历整个线程树，并启动每一个尚未启动的线程。例如，system组随后会被挂起（暂停），最后被中止（尽管用suspend()和stop()对整个线程组进行操作看起来似乎很有趣，但应注意这些方法在Java 1.2里都是被“反对”的）。但在挂起system组的同时，也挂起了main线程，而且整个程序都会关闭。所以永远不会达到让线程中止的那一步。实际上，假如真的中止了main线程，它会“掷”出一个ThreadDeath违例，所以我们通常不这样做。由于ThreadGroup是从Object继承的，其中包含了wait()方法，所以也能调用wait(秒数×1000)，令程序暂停运行任意秒数的时间。当然，事前必须在一个同步块里取得对象锁。\nThreadGroup类也提供了suspend()和resume()方法，所以能中止和启动整个线程组和它的所有线程，也能中止和启动它的子组，所有这些只需一个命令即可（再次提醒，suspend()和resume()都是Java 1.2所“反对”的）。 从表面看，线程组似乎有些让人摸不着头脑，但请注意我们很少需要直接使用它们。\n14.5 回顾runnable 在本章早些时候，我曾建议大家在将一个程序片或主Frame当作Runnable的实现形式之前，一定要好好地想一想。若采用那种方式，就只能在自己的程序中使用其中的一个线程。这便限制了灵活性，一旦需要用到属于那种类型的多个线程，就会遇到不必要的麻烦。\n当然，如果必须从一个类继承，而且想使类具有线程处理能力，则Runnable是一种正确的方案。本章最后一个例子对这一点进行了剖析，制作了一个RunnableCanvas类，用于为自己描绘不同的颜色（Canvas是“画布”的意思）。这个应用被设计成从命令行获得参数值，以决定颜色网格有多大，以及颜色发生变化之间的sleep()有多长。通过运用这些值，大家能体验到线程一些有趣而且可能令人费解的特性：\n//: ColorBoxes.java // Using the Runnable interface import java.awt.*; import java.awt.event.*; class CBox extends Canvas implements Runnable { private Thread t; private int pause; private static final Color[] colors = { Color.black, Color.blue, Color.cyan, Color.darkGray, Color.gray, Color.green, Color.lightGray, Color.magenta, Color.orange, Color.pink, Color.red, Color.white, Color.yellow }; private Color cColor = newColor(); private static final Color newColor() { return colors[ (int)(Math.random() * colors.length) ]; } public void paint(Graphics g) { g.setColor(cColor); Dimension s = getSize(); g.fillRect(0, 0, s.width, s.height); } public CBox(int pause) { this.pause = pause; t = new Thread(this); t.start(); } public void run() { while(true) { cColor = newColor(); repaint(); try { t.sleep(pause); } catch(InterruptedException e) {} } } } public class ColorBoxes extends Frame { public ColorBoxes(int pause, int grid) { setTitle(\u0026#34;ColorBoxes\u0026#34;); setLayout(new GridLayout(grid, grid)); for (int i = 0; i \u0026lt; grid * grid; i++) add(new CBox(pause)); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); } public static void main(String[] args) { int pause = 50; int grid = 8; if(args.length \u0026gt; 0) pause = Integer.parseInt(args[0]); if(args.length \u0026gt; 1) grid = Integer.parseInt(args[1]); Frame f = new ColorBoxes(pause, grid); f.setSize(500, 400); f.setVisible(true); } } ///:~ ColorBoxes是一个典型的应用（程序），有一个构建器用于设置GUI。这个构建器采用int grid的一个参数，用它设置GridLayout（网格布局），使每一维里都有一个grid单元。随后，它添加适当数量的CBox对象，用它们填充网格，并为每一个都传递pause值。在main()中，我们可看到如何对pause和grid的默认值进行修改（如果用命令行参数传递）。 CBox是进行正式工作的地方。它是从Canvas继承的，并实现了Runnable接口，使每个Canvas也能是一个Thread。记住在实现Runnable的时候，并没有实际产生一个Thread对象，只是一个拥有run()方法的类。因此，我们必须明确地创建一个Thread对象，并将Runnable对象传递给构建器，随后调用start()（在构建器里进行）。在CBox里，这个线程的名字叫作t。 请留意数组colors，它对Color类中的所有颜色进行了列举（枚举）。它在newColor()中用于产生一种随机选择的颜色。当前的单元（格）颜色是cColor。\npaint()则相当简单——只是将颜色设为cColor，然后用那种颜色填充整张画布（Canvas）。\n在run()中，我们看到一个无限循环，它将cColor设为一种随机颜色，然后调用repaint()把它显示出来。随后，对线程执行sleep()，使其“休眠”由命令行指定的时间长度。\n由于这种设计方案非常灵活，而且线程处理同每个Canvas元素都紧密结合在一起，所以在理论上可以生成任意多的线程（但在实际应用中，这要受到JVM能够从容对付的线程数量的限制）。\n这个程序也为我们提供了一个有趣的评测基准，因为它揭示了不同JVM机制在速度上造成的戏剧性的差异。\n14.5.1 过多的线程 有些时候，我们会发现ColorBoxes几乎陷于停顿状态。在我自己的机器上，这一情况在产生了10×10的网格之后发生了。为什么会这样呢？自然地，我们有理由怀疑AWT对它做了什么事情。所以这里有一个例子能够测试那个猜测，它产生了较少的线程。代码经过了重新组织，使一个Vector实现了Runnable，而且那个Vector容纳了数量众多的色块，并随机挑选一些进行更新。随后，我们创建大量这些Vector对象，数量大致取决于我们挑选的网格维数。结果便是我们得到比色块少得多的线程。所以假如有一个速度的加快，我们就能立即知道，因为前例的线程数量太多了。如下所示：\n//: ColorBoxes2.java // Balancing thread use import java.awt.*; import java.awt.event.*; import java.util.*; class CBox2 extends Canvas { private static final Color[] colors = { Color.black, Color.blue, Color.cyan, Color.darkGray, Color.gray, Color.green, Color.lightGray, Color.magenta, Color.orange, Color.pink, Color.red, Color.white, Color.yellow }; private Color cColor = newColor(); private static final Color newColor() { return colors[ (int)(Math.random() * colors.length) ]; } void nextColor() { cColor = newColor(); repaint(); } public void paint(Graphics g) { g.setColor(cColor); Dimension s = getSize(); g.fillRect(0, 0, s.width, s.height); } } class CBoxVector extends Vector implements Runnable { private Thread t; private int pause; public CBoxVector(int pause) { this.pause = pause; t = new Thread(this); } public void go() { t.start(); } public void run() { while(true) { int i = (int)(Math.random() * size()); ((CBox2)elementAt(i)).nextColor(); try { t.sleep(pause); } catch(InterruptedException e) {} } } } public class ColorBoxes2 extends Frame { private CBoxVector[] v; public ColorBoxes2(int pause, int grid) { setTitle(\u0026#34;ColorBoxes2\u0026#34;); setLayout(new GridLayout(grid, grid)); v = new CBoxVector[grid]; for(int i = 0; i \u0026lt; grid; i++) v[i] = new CBoxVector(pause); for (int i = 0; i \u0026lt; grid * grid; i++) { v[i % grid].addElement(new CBox2()); add((CBox2)v[i % grid].lastElement()); } for(int i = 0; i \u0026lt; grid; i++) v[i].go(); addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { System.exit(0); } }); } public static void main(String[] args) { // Shorter default pause than ColorBoxes: int pause = 5; int grid = 8; if(args.length \u0026gt; 0) pause = Integer.parseInt(args[0]); if(args.length \u0026gt; 1) grid = Integer.parseInt(args[1]); Frame f = new ColorBoxes2(pause, grid); f.setSize(500, 400); f.setVisible(true); } } ///:~ 在ColorBoxes2中，我们创建了CBoxVector的一个数组，并对其初始化，使其容下各个CBoxVector网格。每个网格都知道自己该“睡眠”多长的时间。随后为每个CBoxVector都添加等量的Cbox2对象，而且将每个Vector都告诉给go()，用它来启动自己的线程。\nCBox2类似CBox——能用一种随机选择的颜色描绘自己。但那就是CBox2能够做的全部工作。所有涉及线程的处理都已移至CBoxVector进行。\nCBoxVector也可以拥有继承的Thread，并有一个类型为Vector的成员对象。这样设计的好处就是addElement()和elementAt()方法可以获得特定的参数以及返回值类型，而不是只能获得常规Object（它们的名字也可以变得更短）。然而，这里采用的设计表面上看需要较少的代码。除此以外，它会自动保留一个Vector的其他所有行为。由于elementAt()需要大量进行“封闭”工作，用到许多括号，所以随着代码主体的扩充，最终仍有可能需要大量代码。\n和以前一样，在我们实现Runnable的时候，并没有获得与Thread配套提供的所有功能，所以必须创建一个新的Thread，并将自己传递给它的构建器，以便正式“启动”——start()——一些东西。大家在CBoxVector构建器和go()里都可以体会到这一点。run()方法简单地选择Vector里的一个随机元素编号，并为那个元素调用nextColor()，令其挑选一种新的随机颜色。\n运行这个程序时，大家会发现它确实变得更快，响应也更迅速（比如在中断它的时候，它能更快地停下来）。而且随着网格尺寸的壮 大，它也不会经常性地陷于“停顿”状态。因此，线程的处理又多了一项新的考虑因素：必须随时检查自己有没有“太多的线程”（无论对什么程序和运行平台）。若线程太多，必须试着使用上面介绍的技术，对程序中的线程数量进行“平衡”。如果在一个多线程的程序中遇到了性能上的问题，那么现在有许多因素需要检查：\n(1) 对sleep，yield()以及／或者wait()的调用足够多吗？\n(2) sleep()的调用时间足够长吗？\n(3) 运行的线程数是不是太多？\n(4) 试过不同的平台和JVM吗？\n象这样的一些问题是造成多线程应用程序的编制成为一种“技术活”的原因之一。\n14.6 总结 何时使用多线程技术，以及何时避免用它，这是我们需要掌握的重要课题。骼它的主要目的是对大量任务进行有序的管理。通过多个任务的混合使用，可以更有效地利用计算机资源，或者对用户来说显得更方便。资源均衡的经典问题是在IO等候期间如何利用CPU。至于用户方面的方便性，最经典的问题就是如何在一个长时间的下载过程中监视并灵敏地反应一个“停止”（stop）按钮的按下。 多线程的主要缺点包括：\n(1) 等候使用共享资源时造成程序的运行速度变慢。\n(2) 对线程进行管理要求的额外CPU开销。\n(3) 复杂程度无意义的加大，比如用独立的线程来更新数组内每个元素的愚蠢主意。\n(4) 漫长的等待、浪费精力的资源竞争以及死锁等多线程症状。\n线程另一个优点是它们用“轻度”执行切换（100条指令的顺序）取代了“重度”进程场景切换（1000条指令）。由于一个进程内的所有线程共享相同的内存空间，所以“轻度”场景切换只改变程序的执行和本地变量。而在“重度”场景切换时，一个进程的改变要求必须完整地交换内存空间。 线程处理看来好象进入了一个全新的领域，似乎要求我们学习一种全新的程序设计语言——或者至少学习一系列新的语言概念。由于大多数微机操作系统都提供了对线程的支持，所以程序设计语言或者库里也出现了对线程的扩展。不管在什么情况下，涉及线程的程序设计：\n(1) 刚开始会让人摸不着头脑，要求改换我们传统的编程思路；\n(2) 其他语言对线程的支持看来是类似的。所以一旦掌握了线程的概念，在其他环境也不会有太大的困难。尽管对线程的支持使Java语言的复杂程度多少有些增加，但请不要责怪Java。毕竟，利用线程可以做许多有益的事情。 多个线程可能共享同一个资源（比如一个对象里的内存），这是运用线程时面临的最大的一个麻烦。必须保证多个线程不会同时试图读取和修改那个资源。这要求技巧性地运用synchronized（同步）关键字。它是一个有用的工具，但必须真正掌握它，因为假若操作不当，极易出现死锁。\n除此以外，运用线程时还要注意一个非常特殊的问题。由于根据Java的设计，它允许我们根据需要创建任意数量的线程——至少理论上如此（例如，假设为一项工程方面的有限元素分析创建数以百万的线程，这对Java来说并非实际）。然而，我们一般都要控制自己创建的线程数量的上限。因为在某些情况下，大量线程会将场面变得一团糟，所以工作都会几乎陷于停顿。临界点并不象对象那样可以达到几千个，而是在100以下。一般情况下，我们只创建少数几个关键线程，用它们解决某个特定的问题。这时数量的限制问题不大。但在较常规的一些设计中，这一限制确实会使我们感到束手束脚。\n大家要注意线程处理中一个不是十分直观的问题。由于采用了线程“调度”机制，所以通过在run()的主循环中插入对sleep()的调用，一般都可以使自己的程序运行得更快一些。这使它对编程技巧的要求非常高，特别是在更长的延迟似乎反而能提高性能的时候。当然，之所以会出现这种情况，是由于在正在运行的线程准备进入“休眠”状态之前，较短的延迟可能造成“sleep()结束”调度机制的中断。这便强迫调度机制将其中止，并于稍后重新启动，以便它能做完自己的事情，再进入休眠状态。必须多想一想，才能意识到事情真正的麻烦程度。\n本章遗漏的一件事情是一个动画例子，这是目前程序片最流行的一种应用。然而，Java JDK配套提供了解决这个问题的一整套方案（并可播放声音），大家可到java.sun.com的演示区域下载。此外，我们完全有理由相信未来版本的Java会提供更好的动画支持——尽管目前的Web涌现出了与传统方式完全不同的非Java、非程序化的许多动画方案。如果想系统学习Java动画的工作原理，可参考《Core Java——核心Java》一书，由Cornell\u0026amp;Horstmann编著，Prentice-Hall于1997年出版。若欲更深入地了解线程处理，请参考《Concurrent Programming in Java——Java中的并发编程》，由Doug Lea编著，Addison-Wiseley于1997年出版；或者《Java Threads——Java线程》，Oaks\u0026amp;Wong编著，O\u0026rsquo;Reilly于1997年出版。\n14.7 练习 第15章 网络编程 历史上的网络编程都倾向于困难、复杂，而且极易出错。\n程序员必须掌握与网络有关的大量细节，有时甚至要对硬件有深刻的认识。一般地，我们需要理解连网协议中不同的“层”（Layer）。而且对于每个连网库，一般都包含了数量众多的函数，分别涉及信息块的连接、打包和拆包；这些块的来回运输；以及握手等等。这是一项令人痛苦的工作。\n但是，连网本身的概念并不是很难。我们想获得位于其他地方某台机器上的信息，并把它们移到这儿；或者相反。这与读写文件非常相似，只是文件存在于远程机器上，而且远程机器有权决定如何处理我们请求或者发送的数据。\nJava最出色的一个地方就是它的“无痛苦连网”概念。有关连网的基层细节已被尽可能地提取出去，并隐藏在JVM以及Java的本机安装系统里进行控制。我们使用的编程模型是一个文件的模型；事实上，网络连接（一个“套接字”）已被封装到系统对象里，所以可象对其他数据流那样采用同样的方法调用。除此以外，在我们处理另一个连网问题——同时控制多个网络连接——的时候，Java内建的多线程机制也是十分方便的。\n本章将用一系列易懂的例子解释Java的连网支持。\n15.1 机器的标识 当然，为了分辨来自别处的一台机器，以及为了保证自己连接的是希望的那台机器，必须有一种机制能独一无二地标识出网络内的每台机器。早期网络只解决了如何在本地网络环境中为机器提供唯一的名字。但Java面向的是整个因特网，这要求用一种机制对来自世界各地的机器进行标识。为达到这个目的，我们采用了IP（互联网地址）的概念。IP以两种形式存在着：\n(1) 大家最熟悉的DNS（域名服务）形式。我自己的域名是bruceeckel.com。所以假定我在自己的域内有一台名为Opus的计算机，它的域名就可以是Opus.bruceeckel.com。这正是大家向其他人发送电子函件时采用的名字，而且通常集成到一个万维网（WWW）地址里。\n(2) 此外，亦可采用“四点”格式，亦即由点号（.）分隔的四组数字，比如202.98.32.111。 不管哪种情况，IP地址在内部都表达成一个由32个二进制位（bit）构成的数字（注释①），所以IP地址的每一组数字都不能超过255。利用由java.net提供的static InetAddress.getByName()，我们可以让一个特定的Java对象表达上述任何一种形式的数字。结果是类型为InetAddress的一个对象，可用它构成一个“套接字”（Socket），大家在后面会见到这一点。\n①：这意味着最多只能得到40亿左右的数字组合，全世界的人很快就会把它用光。但根据目前正在研究的新IP编址方案，它将采用128 bit的数字，这样得到的唯一性IP地址也许在几百年的时间里都不会用完。\n作为运用InetAddress.getByName()一个简单的例子，请考虑假设自己有一家拨号连接因特网服务提供者（ISP），那么会发生什么情况。每次拨号连接的时候，都会分配得到一个临时IP地址。但在连接期间，那个IP地址拥有与因特网上其他IP地址一样的有效性。如果有人按照你的IP地址连接你的机器，他们就有可能使用在你机器上运行的Web或者FTP服务器程序。当然这有个前提，对方必须准确地知道你目前分配到的IP。由于每次拨号连接获得的IP都是随机的，怎样才能准确地掌握你的IP呢？ 下面这个程序利用InetAddress.getByName()来产生你的IP地址。为了让它运行起来，事先必须知道计算机的名字。该程序只在Windows 95中进行了测试，但大家可以依次进入自己的“开始”、“设置”、“控制面板”、“网络”，然后进入“标识”卡片。其中，“计算机名称”就是应在命令行输入的内容。\n//: WhoAmI.java // Finds out your network address when you\u0026#39;re // connected to the Internet. package c15; import java.net.*; public class WhoAmI { public static void main(String[] args) throws Exception { if(args.length != 1) { System.err.println( \u0026#34;Usage: WhoAmI MachineName\u0026#34;); System.exit(1); } InetAddress a = InetAddress.getByName(args[0]); System.out.println(a); } } ///:~ 就我自己的情况来说，机器的名字叫作“Colossus”（来自同名电影，“巨人”的意思。我在这台机器上有一个很大的硬盘）。所以一旦连通我的ISP，就象下面这样执行程序：\njava whoAmI Colossus 得到的结果象下面这个样子（当然，这个地址可能每次都是不同的）：\nColossus/202.98.41.151 假如我把这个地址告诉一位朋友，他就可以立即登录到我的个人Web服务器，只需指定目标地址 http://202.98.41.151 即可（当然，我此时不能断线）。有些时候，这是向其他人发送信息或者在自己的Web站点正式出台以前进行测试的一种方便手段。\n15.1.1 服务器和客户机 网络最基本的精神就是让两台机器连接到一起，并相互“交谈”或者“沟通”。一旦两台机器都发现了对方，就可以展开一次令人愉快的双向对话。但它们怎样才能“发现”对方呢？这就象在游乐园里那样：一台机器不得不停留在一个地方，侦听其他机器说：“嘿，你在哪里呢？”\n“停留在一个地方”的机器叫作“服务器”（Server）；到处“找人”的机器则叫作“客户机”（Client）或者“客户”。它们之间的区别只有在客户机试图同服务器连接的时候才显得非常明显。一旦连通，就变成了一种双向通信，谁来扮演服务器或者客户机便显得不那么重要了。\n所以服务器的主要任务是侦听建立连接的请求，这是由我们创建的特定服务器对象完成的。而客户机的任务是试着与一台服务器建立连接，这是由我们创建的特定客户机对象完成的。一旦连接建好，那么无论在服务器端还是客户机端，连接只是魔术般地变成了一个IO数据流对象。从这时开始，我们可以象读写一个普通的文件那样对待连接。所以一旦建好连接，我们只需象第10章那样使用自己熟悉的IO命令即可。这正是Java连网最方便的一个地方。\norigin/master\n15.2 套接字 15.3 服务多个客户 15.4 数据报 15.5 一个Web应用 15.6 Java与CGI的沟通 15.7 用JDBC连接数据库 15.8 远程方法 15.9 总结 15.10 练习 第16章 设计范式 16.1 范式的概念 16.2 观察器范式 16.3 模拟垃圾回收站 16.4 改进设计 16.5 抽象的应用 16.6 多重派遣 16.7 访问器范式 16.8 RTTI真的有害吗 16.9 总结 16.10 练习 第17章 项目 17.1 文字处理 17.2 方法查找工具 17.3 复杂性理论 17.4 总结 17.5 练习 附录A 使用非JAVA代码 附录B 对比C++和Java 附录C Java编程规则 附录D 性能 附录E 关于垃圾收集的一些话 附录F 推荐读物 (9) 第9章：违例差错控制 (10) 第10章：Java IO系统 (11) 第11章：运行期类型鉴定 (12) 第12章：传递和返回对象 (13) 第13章：创建窗口和程序片 (14) 第14章：多线程 (15) 第15章 网络编程 (16) 第16章 设计范式 (17) 第17章 项目 (18) 附录A：使用非Java代码 (19) 附录B：对比C++和Java (20) 附录C：Java编程规则 (21) 附录D：性能 (22) 附录E：关于垃圾收集的一些话 (23) 附录F：推荐读物\n"},{"id":154,"href":"/Tech/1Book/Thinking-In-Java/%E6%A0%87%E9%A2%98/","title":"标题","parent":"Thinking In Java","content":" Thinking In Java 标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk "},{"id":155,"href":"/Tech/1Book/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%AC%AC1%E7%AB%A0/","title":"加密与解密 基础篇 第1章","parent":"加密与解密","content":" 加密与解密 标签：加密与解密、基础 时间：2021年8月30日10点41分 连接：https://www.saveload.cn/html/html/1、Book/Tech/加密与解密/加密与解密-基础篇-第1章.html 加密与解密-基础篇-第1章 1.1 什么是加密与解密 1.1。1 软件的贾母与解密 "},{"id":156,"href":"/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0-%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","title":"数据结构与算法（ Java 描述） 第1章 数据结构和算法","parent":"数据结构与算法（Java 描述）","content":" 数据结构与算法（Java 描述） 标签：数据结构、算法、Java 时间：2022年7月13日 17点53分 连接： 来源：数据结构与算法（Java 描述） 邓俊辉 著 第一章 算法及其复杂度 13 §1.1 计算机与算法 14 1.1.1 过指定垂足的直角边 14 1.1.2 三等分线段 15 1.1.3 排序 16 起泡排序算法\n最大元素必然就位\n只 关注前面的n-1 个元素\n1.1.4 算法的定义 19 算法还必须具备以下要素： 输入：待处理的信息，即对具体问题的描述。比如，对于上述三个例子来说，输入分别是“任意给定的直线以及其上的一点”、“任意给定的一条线段”以及“由 n 个可比较元素组成的序列”。 输出：经过处理之后得到的信息，即问题的答案。比如，对于上述三个例子来说，输出分别是我们所要得到的“垂直线”、“三等分点”以及“完全有序的序列”。 确定性：任一算法都可以描述为由若干种基本操作组成的序列。在垂直线算法中，“取等长绳索”、“联结绳索”、“将绳结固定于一点”、“沿特定方向拉直绳索”等操作都属于基本操作。在三等分线段算法中，基本操作就是欧氏作图法所允许的所有尺规操作。而在起泡排序算法中，基本操作就是图灵机所允许的各种操作：“读取某一元素的内容”、“比较两个元素的大小”以及“修改某一元素的内容”等等。 可行性：在相应的计算模型中，每一基本操作都可以实现，且能够在常数时间内完成。 有穷性：对于任何输入，按照算法，经过有穷次基本操作都可以得到正确的输出。 §1.2 算法性能的分析与评价 20 1.2.1 三个层次 20 1.2.2 时间复杂度及其度量 20 1.2.3 空间复杂度 22 §1.3 算法复杂度及其分析 23 1.3.1 O(1)((取非极端元素 23 1.3.2 O(logn)((进制转换 23 1.3.3 O(n)((数组求和 24 1.3.4 O(n2)((起泡排序 25 1.3.5 O(2r)((幂函数 25 §1.4 计算模型 26 1.4.1 可解性 26 1.4.2 有效可解 27 1.4.3 下界 27 §1.5 递归 27 1.5.1 线性递归 28 1.5.2 递归算法的复杂度分析 32 1.5.3 二分递归 33 1.5.4 多分支递归 36 "},{"id":157,"href":"/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/","title":"数据结构与算法（ Java 描述）","parent":"数据结构与算法（Java 描述）","content":" 数据结构与算法（Java 描述） 标签：数据结构、算法、Java 时间：2022年7月13日 17点53分 连接： 来源：数据结构与算法（Java 描述） 邓俊辉 著 第一章 算法及其复杂度 13 §1.1 计算机与算法 14\r1.1.1 过指定垂足的直角边 14\r1.1.2 三等分线段 15\r1.1.3 排序 16\r1.1.4 算法的定义 19\r§1.2 算法性能的分析与评价 20\r1.2.1 三个层次 20\r1.2.2 时间复杂度及其度量 20\r1.2.3 空间复杂度 22\r§1.3 算法复杂度及其分析 23\r1.3.1 O(1)((取非极端元素 23\r1.3.2 O(logn)((进制转换 23\r1.3.3 O(n)((数组求和 24\r1.3.4 O(n2)((起泡排序 25\r1.3.5 O(2r)((幂函数 25\r§1.4 计算模型 26\r1.4.1 可解性 26\r1.4.2 有效可解 27\r1.4.3 下界 27\r§1.5 递归 27\r1.5.1 线性递归 28\r1.5.2 递归算法的复杂度分析 32\r1.5.3 二分递归 33\r1.5.4 多分支递归 36\r第二章 栈与队列 39 §2.1 栈 40\r2.1.1 栈ADT 41\r2.1.2 基于数组的简单实现 43\r2.1.3 Java虚拟机中的栈 47\r2.1.4 栈应用实例 49\r§2.2 队列 53\r2.2.1 队列ADT 54\r2.2.2 基于数组的实现 56\r2.2.3 队列应用实例 59\r§2.3 链表 61\r2.3.1 单链表 60\r2.3.2 基于单链表实现栈 64\r2.3.3 基于单链表实现队列 66\r§2.4 位置 69\r2.4.1 位置ADT 68\r2.4.2 位置ADT接口 68\r§2.5 双端队列 70\r2.5.1 双端队列的ADT 69\r2.5.2 双端队列的接口 70\r2.5.3 双向链表 71\r2.5.4 基于双向链表实现的双端队列 72\r第三章 向量、列表与序列 81 §3.1 向量与数组 82\r3.1.1 向量ADT 80\r3.1.2 基于数组的简单实现 83\r3.1.3 基于可扩充数组的实现 85\r3.1.4 java.util.ArrayList类和java.util.Vector类 89\r§3.2 列表 92\r3.2.1 基于节点的操作 90\r3.2.2 由秩到位置 90\r3.2.3 列表ADT 91\r3.2.4 基于双向链表实现的列表 95\r§3.3 序列 104\r3.3.1 序列ADT 102\r3.3.2 基于双向链表实现序列 103\r3.3.3 基于数组实现序列 105\r§3.4 迭代器 108\r3.4.1 简单迭代器的ADT 106\r3.4.2 迭代器接口 107\r3.4.3 迭代器的实现 108\r3.4.4 Java中的列表及迭代器 110\r第四章 树 115 §4.1 术语及性质 116\r4.1.1 节点的深度、树的深度与高度 115\r4.1.2 度、内部节点与外部节点 116\r4.1.3 路径 116\r4.1.4 祖先、后代、子树和节点的高度 117\r4.1.5 共同祖先及最低共同祖先 118\r4.1.6 有序树、m叉树 118\r4.1.7 二叉树 118\r4.1.8 满二叉树与完全二叉树 119\r§4.2 树抽象数据类型及其实现 123\r4.2.1 父亲-长子-弟弟”模型 121\r4.2.2 树ADT 122\r4.2.3 树的Java接口 123\r4.2.4 基于链表实现树 123\r§4.3 树的基本算法 127\r4.3.1 getSize()((统计（子）树的规模 125\r4.3.2 getHeight()((计算节点的高度 126\r4.3.3 getDepth()((计算节点的深度 126\r4.3.4 前序、后序遍历 126\r4.3.5 层次遍历 128\r4.3.6 树迭代器 129\r§4.4 二叉树抽象数据类型及其实现 133\r4.4.1 二叉树ADT 131\r4.4.2 二叉树类的Java接口 132\r4.4.3 二叉树类的实现 135\r§4.5 二叉树的基本算法 145\r4.5.1 getSize()、getHeight()和getDepth() 143\r4.5.2 updateSize() 143\r4.5.3 updateHeight() 144\r4.5.4 updateDepth() 144\r4.5.5 secede() 145\r4.5.6 attachL()和attachR() 146\r4.5.7 二叉树的遍历 147\r4.5.8 直接前驱、直接后继的定位算法 148\r§4.6 完全二叉树的Java实现 151\r4.6.1 完全二叉树类的Java接口 149\r4.6.2 基于向量的实现 150\r第五章 优先队列 157 §5.1 优先级、关键码、全序关系与优先队列 158\r§5.2 条目与比较器 159\r5.2.1 条目 157\r5.2.2 比较器 159\r5.2.3 Comparator接口及其实现 159\r§5.3 优先队列ADT及Java接口 163\r5.3.1 ADT描述 161\r5.3.2 Java接口 162\r5.3.3 基于优先队列的排序器 163\r§5.4 用向量实现优先队列 166\r§5.5 用列表实现优先队列 167\r5.5.1 基于无序列表的实现及分析 165\r5.5.2 基于有序列表的实现及分析 167\r§5.6 选择排序与插入排序 171\r5.6.1 选择排序 169\r5.6.2 插入排序 169\r5.6.3 效率比较 170\r§5.7 堆的定义及性质 173\r5.7.1 堆结构 171\r5.7.2 完全性 172\r§5.8 用堆实现优先队列 174\r5.8.1 基于堆的优先队列及其实现 172\r5.8.2 插入与上滤 175\r5.8.3 删除与下滤 178\r5.8.4 改变任意节点的关键码 180\r5.8.5 建堆 180\r§5.9 堆排序 184\r5.9.1 直接堆排序 182\r5.9.2 就地堆排序 183\r§5.10 Huffman树 187\r5.10.1 二叉编码树 185\r5.10.2 最优编码树 186\r5.10.3 Huffman编码与Huffman编码树 188\r5.10.4 Huffman编码树的构造算法 192\r5.10.5 基于优先队列的Huffman树构造算法 194\r第六章 映射与词典 197 §6.1 映射 198\r6.1.1 映射的ADT描述 197\r6.1.2 映射的Java接口 198\r6.1.3 判等器 199\r6.1.4 java.util包中的映射类 200\r6.1.5 基于列表实现映射类 201\r§6.2 散列表 205\r6.2.1 桶及桶数组 203\r6.2.2 散列函数 203\r6.2.3 散列码 204\r6.2.4 压缩函数 206\r6.2.5 冲突的普遍性((生日悖论 206\r6.2.6 解决冲突 207\r6.2.7 基于散列表实现映射类 212\r6.2.8 装填因子与重散列 214\r§6.3 无序词典 217\r6.3.1 无序词典的ADT描述 215\r6.3.2 无序词典的Java接口 216\r6.3.3 列表式无序词典及其实现 217\r6.3.4 散列表式无序词典及其实现 220\r§6.4 有序词典 225\r6.4.1 全序关系与有序查找表 223\r6.4.2 二分查找 223\r6.4.3 有序词典的ADT描述 225\r6.4.4 有序词典的Java接口 225\r6.4.5 基于有序查找表实现有序词典 226\r第七章 查找树 233 §7.1 二分查找树 235\r7.1.1 定义 233\r7.1.2 查找算法 234\r7.1.3 完全查找算法 238\r7.1.4 插入算法 238\r7.1.5 删除算法 241\r7.1.6 二分查找树节点类的实现 243\r7.1.7 二分查找树类的实现 244\r7.1.8 二分查找树的平均性能 247\r§7.2 AVL树 250\r7.2.1 平衡二分查找树 248\r7.2.2 等价二分查找树 249\r7.2.3 等价变换 249\r7.2.4 AVL树 251\r7.2.5 插入节点后的重平衡 252\r7.2.6 节点删除后的重平衡 257\r7.2.7 AVL树的Java实现 262\r§7.3 伸展树 267\r7.3.1 数据局部性 265\r7.3.2 逐层伸展 266\r7.3.3 双层伸展 268\r7.3.4 分摊复杂度 270\r7.3.5 伸展树的Java实现 272\r7.3.6 插入 276\r7.3.7 删除 277\r§7.4 B-树 279\r7.4.1 分级存储 279\r7.4.2 B-树的定义 280\r7.4.3 关键码的查找 280\r7.4.4 性能分析 282\r7.4.5 上溢节点的处理 283\r7.4.6 关键码的插入 284\r7.4.7 下溢节点的处理 288\r7.4.8 关键码的删除 289\r第八章 排序 293 §8.1 归并排序 294\r8.1.1 分治策略 292\r8.1.2 时间复杂度 293\r8.1.3 归并算法 294\r8.1.4 Mergesort的Java实现 296\r§8.2 快速排序 299\r8.2.1 分治策略 297\r8.2.2 轴点 297\r8.2.3 划分算法 298\r8.2.4 Quicksort的Java实现 299\r8.2.5 时间复杂度 300\r§8.3 复杂度下界 304\r8.3.1 比较树与基于比较的算法 302\r8.3.2 下界 303\r第九章 串 307 §9.1 串及其ADT 308\r§9.2 串模式匹配 310\r9.2.1 概念与记号 308\r9.2.2 问题 309\r9.2.3 算法效率的测试与评价 310\r§9.3 蛮力算法 312\r9.3.1 算法描述 310\r9.3.2 算法实现 311\r9.3.3 算法分析 312\r§9.4 Knuth-Morris-Pratt算法 315\r9.4.1 蛮力算法的改进 313\r9.4.2 next[]表的定义及含义 314\r9.4.3 KMP算法描述 315\r9.4.4 next[]表的特殊情况 315\r9.4.5 next[]表的构造 316\r9.4.6 next[]表的改进 316\r9.4.7 KMP算法的Java实现 318\r9.4.8 性能分析 320\r§9.5 BM算法 323\r9.5.1 坏字符策略 321\r9.5.2 好后缀策略 323\r9.5.3 BM算法 325\r9.5.4 BM算法的Java实现 326\r9.5.5 性能 330\r第十章 图 335 §10.1 概述 336\r10.1.1 无向图、混合图及有向图 334\r10.1.2 度 335\r10.1.3 简单图 335\r10.1.4 图的复杂度 336\r10.1.5 子图、生成子图与限制子图 337\r10.1.6 通路、环路及可达分量 337\r10.1.7 连通性、等价类与连通分量 338\r10.1.8 森林、树以及无向图的生成树 339\r10.1.9 有向图的生成树 340\r10.1.10 带权网络 341\r§10.2 抽象数据类型 344\r10.2.1 图 342\r10.2.2 顶点 343\r10.2.3 边 345\r§10.3 邻接矩阵 349\r10.3.1 表示方法 346\r10.3.2 时间性能 347\r10.3.3 空间性能 348\r§10.4 邻接表 351\r10.4.1 顶点表和边表 349\r10.4.2 顶点与邻接边表 350\r10.4.3 边 352\r10.4.4 基于邻接表实现图结构 355\r§10.5 图遍历及其算法模板 360\r§10.6 深度优先遍历 362\r10.6.1 深度优先遍历算法 360\r10.6.2 边分类 361\r10.6.3 可达分量与DFS树 362\r10.6.4 深度优先遍历算法模板 364\r10.6.5 可达分量算法 366\r10.6.6 单强连通分量算法 367\r10.6.7 强连通分量分解算法 368\r10.6.8 浓缩图与弱连通性 368\r§10.7 广度优先遍历 372\r10.7.1 广度优先遍历算法 370\r10.7.2 边分类 371\r10.7.3 可达分量与BFS树 372\r10.7.4 广度优先遍历算法模板 372\r10.7.5 最短距离算法 373\r§10.8 最佳优先遍历 377\r10.8.1 最佳优先遍历算法 375\r10.8.2 最佳优先遍历算法模板 376\r10.8.3 最短路径 378\r10.8.4 最短路径序列 381\r10.8.5 Dijkstra算法 384\r10.8.6 最小生成树 387\r10.8.7 Prim-Jarnik算法 389\r附录 396 DSA类关系图 396\r插图索引 399\r表格索引 403\r算法索引 405\r代码索引 407\r定义索引 410\r观察结论索引 413\r推论索引 416\r引理索引 417\r定理索引 418\r关键词索引 421 "},{"id":158,"href":"/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0--1Linux-%E7%9A%84-Page-Cache/","title":"文件 Io 简明概述 1、 Linux 的 Page Cache","parent":"文件 IO 简明概述","content":" 文件 I/O 简明概述 转自： Spongecaptain\n链接：https://spongecaptain.cool/SimpleClearFileIO/\nLinux 的 Page Cache 1. Page Cache 1.1 Page Cache 是什么？ 为了理解 Page Cache，我们不妨先看一下 Linux 的文件 I/O 系统，如下图所示： Figure1. Linux 文件 I/O 系统\nVFS 虚拟文件系统(Virtual File System)\rDevice Driver 设备驱动程序\rI/O Scheduler I/O 调度器\rBlock I/O Layer 块 I/O 层 上图中，红色部分为 Page Cache。可见 Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I/O 将文件读取到内存空间实际上都是读取到 Page Cache 中。\n1.2 如何查看系统的 Page Cache？ 通过读取 /proc/meminfo 文件，能够实时获取系统内存情况：\n$ cat /proc/meminfo\r...\rBuffers: 1224 kB\rCached: 111472 kB\rSwapCached: 36364 kB\rActive: 6224232 kB\rInactive: 979432 kB\rActive(anon): 6173036 kB\rInactive(anon): 927932 kB\rActive(file): 51196 kB\rInactive(file): 51500 kB\r...\rShmem: 10000 kB\r...\rSReclaimable: 43532 kB\r... 根据上面的数据，你可以简单得出这样的公式（等式两边之和都是 112696 KB）：\nBuffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached 两边等式都是 Page Cache，即：\nPage Cache = Buffers + Cached + SwapCached 通过阅读 1.4 以及 1.5 小节，就能够理解为什么 SwapCached 与 Buffers 也是 Page Cache 的一部分。\n1.3 page 与 Page Cache page 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits/64bits），而 Page Cache 的大小则为 4KB 的整数倍。\n另一方面，并不是所有 page 都被组织为 Page Cache。\nLinux 系统上供用户可访问的内存分为两个类型[2]，即：\nFile-backed pages：文件备份页也就是 Page Cache 中的 page，对应于磁盘上的若干数据块；对于这些页最大的问题是脏页回盘； Anonymous pages：匿名页不对应磁盘上的任何磁盘数据块，它们是进程的运行是内存空间（例如方法栈、局部变量表等属性）； 为什么 Linux 不把 Page Cache 称为 block cache，这不是更好吗？\n这是因为从磁盘中加载到内存的数据不仅仅放在 Page Cache 中，还放在 buffer cache 中。例如通过 Direct I/O 技术的磁盘文件就不会进入 Page Cache 中。当然，这个问题也有 Linux 历史设计的原因，毕竟这只是一个称呼，含义随着 Linux 系统的演进也逐渐不同。\n下面比较一下 File-backed pages 与 Anonymous pages 在 Swap 机制下的性能。\n内存是一种珍惜资源，当内存不够用时，内存管理单元（Memory Mangament Unit）需要提供调度算法来回收相关内存空间。内存空间回收的方式通常就是 swap，即交换到持久化存储设备上。\nFile-backed pages（Page Cache）的内存回收代价较低。 Page Cache 通常对应于一个文件上的若干顺序块，因此可以通过顺序 I/O 的方式落盘。另一方面，如果 Page Cache 上没有进行写操作（所谓的没有脏页），甚至不会将 Page Cache 回盘，因为数据的内容完全可以通过再次读取磁盘文件得到。\nPage Cache 的主要难点在于脏页回盘，这个内容会在第二节进行详细说明。\nAnonymous pages 的内存回收代价较高。这是因为 Anonymous pages 通常随机地写入持久化交换设备。另一方面，无论是否有写操作，为了确保数据不丢失，Anonymous pages 在 swap 时必须持久化到磁盘。\n1.4 Swap 与缺页中断 Swap 机制指的是当物理内存不够用，内存管理单元（Memory Mangament Unit，MMU）需要提供调度算法来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。\nSwap 机制存在的本质原因是 Linux 系统提供了虚拟内存管理机制，每一个进程认为其独占内存空间，因此所有进程的内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。\n操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为缺页中断，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。\n但主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement），替换操作又会触发 swap 机制。\n如果物理内存足够大，那么可能不需要 Swap 机制，但是 Swap 在这种情况下还是有一定优势：对于有发生内存泄漏几率的应用程序（进程），Swap 交换分区更是重要，这可以确保内存泄露不至于导致物理内存不够用，最终导致系统崩溃。但内存泄露会引起频繁的 swap，此时非常影响操作系统的性能。\nLinux 通过一个 swappiness 参数来控制 Swap 机制[2]：这个参数值可为 0-100，控制系统 swap 的优先级：\n高数值：较高频率的 swap，进程不活跃时主动将其转换出物理内存。 低数值：较低频率的 swap，这可以确保交互式不因为内存空间频繁地交换到磁盘而提高响应延迟。 最后，为什么 Buffers 也是 Page Cache 的一部分？\n这是因为当匿名页（Inactive(anon) 以及 Active(anon)）先被交换（swap out）到磁盘上后，然后再加载回（swap in）内存中，由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。这个过程如 Figure 2 所示。\nFigure2. 匿名页的被交换后也是 Page Cache\n1.5 Page Cache 与 buffer cache 执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-/+ buffers/cache”。\n~ free -m\rtotal used free shared buffers cached\rMem: 128956 96440 32515 0 5368 39900\r-/+ buffers/cache: 51172 77784\rSwap: 16002 0 16001 其中，cached 列表示当前的页缓存（Page Cache）占用量，buffers 列表示当前的块缓存（buffer cache）占用量。用一句话来解释：Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。\nPage Cache 与 buffer cache 的共同目的都是加速数据 I/O：写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。\n在 Linux 2.4 版本的内核之前，Page Cache 与 buffer cache 是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。所以在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了。只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到 buffer cache 里。因此，我们现在提起 Page Cache，基本上都同时指 Page Cache 和 buffer cache 两者，本文之后也不再区分，直接统称为 Page Cache。\n下图近似地示出 32-bit Linux 系统中可能的一种 Page Cache 结构，其中 block size 大小为 1KB，page size 大小为 4KB。\nPage Cache 中的每个文件都是一棵基数树（radix tree，本质上是多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见 英文维基 ，这里就不细说了。\n1.6 Page Cache 与预读 操作系统为基于 Page Cache 的读缓存机制提供预读机制（PAGE_READAHEAD），一个例子是：\n用户线程仅仅请求读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。 但是操作系统出于局部性原理[3]会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page； 下图代表了操作系统的预读机制：\nFigure.操作系统的预读机制；\n上图中，应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用 readahead 机制完成了 16KB 数据的读取。\n2. Page Cache 与文件持久化的一致性\u0026amp;可靠性 现代 Linux 的 Page Cache 正如其名，是对磁盘上 page（页）的内存缓存，同时可以用于读/写操作。任何系统引入缓存，就会引发一致性问题：内存中的数据与磁盘中的数据不一致，例如常见后端架构中的 Redis 缓存与 MySQL 数据库就存在一致性问题。\nLinux 提供多种机制来保证数据一致性，但无论是单机上的内存与磁盘一致性，还是分布式组件中节点 1 与节点 2 、节点 3 的数据一致性问题，理解的关键是 trade-off：吞吐量与数据一致性保证是一对矛盾。\n首先，需要我们理解一下文件的数据。文件 = 数据 + 元数据。元数据用来描述文件的各种属性，也必须存储在磁盘上。因此，我们说保证文件一致性其实包含了两个方面：数据一致+元数据一致。\n文件的元数据包括：文件大小、创建时间、访问时间、属主属组等信息。\n我们考虑如下一致性问题：如果发生写操作并且对应的数据在 Page Cache 中，那么写操作就会直接作用于 Page Cache 中，此时如果数据还没刷新到磁盘，那么内存中的数据就领先于磁盘，此时对应 page 就被称为 Dirty page。\n当前 Linux 下以两种方式实现文件一致性：\nWrite Through（写穿）：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性； Write back（写回）：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案； 上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：\n方法 含义 fsync(intfd) fsync(fd)： 将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。 fdatasync(int fd) fdatasync(fd)： 将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息 sync() sync()： 则是对系统中所有的脏的文件数据元数据刷新至磁盘中 上述三种系统调用可以分别由用户进程与内核进程发起。下面我们研究一下内核线程的相关特性。\n创建的针对回写任务的内核线程数由系统中持久存储设备决定，为每个存储设备创建单独的刷新线程； 关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。 刷新线程刷新设备上脏页面大致设计如下： 每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面； 系统中存在多个回写时机，第一是应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等），第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序/内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。 Write Through 与 Write back 在持久化的可靠性上有所不同：\nWrite Through 以牺牲系统 I/O 吞吐量作为代价，向上层应用确保一旦写入，数据就已经落盘，不会丢失； Write back 在系统发生宕机的情况下无法确保数据已经落盘，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘； 3. Page Cache 的优劣势 3.1 Page Cache 的优势 1.加快数据访问 如果数据能够在内存中进行缓存，那么下一次访问就不需要通过磁盘 I/O 了，直接命中内存缓存即可。\n由于内存访问比磁盘访问快很多，因此加快数据访问是 Page Cache 的一大优势。\n2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量 得益于 Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量。\n3.2 Page Cache 的劣势 page cache 也有其劣势，最直接的缺点是需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。\nPage Cache 的另一个缺陷是对应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些应用选择在用户空间实现自己的 page 管理，而不使用 page cache，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理。\nPage Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。这一点可以参考[4]。\nREFERENCE [1] Linux内核技术实战课 [2] Reconsidering swapping [3] 访问局部性 [4] DMA 与零拷贝技术 "},{"id":159,"href":"/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0--2DMA-%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/","title":"文件 Io 简明概述 2、 Dma 与零拷贝技术","parent":"文件 IO 简明概述","content":" 文件 I/O 简明概述 转自： Spongecaptain\n链接：https://spongecaptain.cool/SimpleClearFileIO/\n# 文件 I/O 简明概述 1. Page Cache 1.1 Page Cache 是什么？ "},{"id":160,"href":"/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/","title":"文件 Io 简明概述","parent":"文件 IO 简明概述","content":" 文件 I/O 简明概述 转自： Spongecaptain\n链接：https://spongecaptain.cool/SimpleClearFileIO/\n文件 I/O 简明概述 文件 I/O 性能是后台应用的主要瓶颈之一，一直以来想对文件 I/O 这个偌大的系统进行总结，故写此文。\n文件 I/O 内容较多，书籍的意义在于能更系统地说明问题，避免博客文章散乱的问题。\n书籍有涉及很大部分非原创内容，相关引用会在 REFERENCE 小节中指出。\n书籍内容包括：\n1.page cache 2.DMA 与零拷贝技术 3.mmap 4.文件分区 5.Java ByteBuffer与 Channel 6.FileChannel 7.JavaVisual 工具 8.Java ByteBuffer 测试 9.如何实现顺序读写 一些章节可能会需要一定的 Java 语言基础，其中：1~4 小节完全不需要 Java 基础，而 5~9 小节会涉及一定的 Java 代码。读者朋友可以有选择性地阅读。\nFigure1.Linux IO Stack Diagram\n推荐阅读 On Disk IO, Part 1: Flavors of IO On Disk IO, Part 2: More Flavours of IO Read, write \u0026amp; space amplification - pick 2 "},{"id":161,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E9%A2%98/","title":"标题","parent":"深入理解Java虚拟机","content":" 深入理解Java虚拟机 标签：Java、基础、深入理解Java虚拟机 、源码解读、进阶、Java开源框架 时间：2020年8月3日18:13:00 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk "},{"id":162,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-358/","title":"深入理解 Java虚拟机 第10章 前端编译与优化 358","parent":"深入理解Java虚拟机","content":" 第四部分　程序编译与代码优化 第10章　前端编译与优化 358 10.1　概述 358 10.2　Javac编译器 359 10.2.1　Javac的源码与调试 359 10.2.2　解析与填充符号表 362 10.2.3　注解处理器 363 10.2.4　语义分析与字节码生成 364 10.3　Java语法糖的味道 367 10.3.1　泛型 367 10.3.2　自动装箱、拆箱与遍历循环 375 10.3.3　条件编译 377 10.4　实战：插入式注解处理器 378 10.4.1　实战目标 379 10.4.2　代码实现 379 10.4.3　运行与测试 385 10.4.4　其他应用案例 386 10.5　本章小结 386 "},{"id":163,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-388/","title":"深入理解 Java虚拟机 第11章 后端编译与优化 388","parent":"深入理解Java虚拟机","content":" 第11章　后端编译与优化 388 11.1　概述 388 11.2　即时编译器 389 11.2.1　解释器与编译器 389 11.2.2　编译对象与触发条件 392 11.2.3　编译过程 397 11.2.4　实战：查看及分析即时编译结果 398 11.3　提前编译器 404 11.3.1　提前编译的优劣得失 405 11.3.2　实战：Jaotc的提前编译 408 11.4　编译器优化技术 411 11.4.1　优化技术概览 411 11.4.2　方法内联 415 11.4.3　逃逸分析 417 11.4.4　公共子表达式消除 420 11.4.5　数组边界检查消除 421 11.5　实战：深入理解Graal编译器 423 11.5.1　历史背景 423 11.5.2　构建编译调试环境 424 11.5.3　JVMCI编译器接口 426 11.5.4　代码中间表示 429 11.5.5　代码优化与生成 432 11.6　本章小结 436 "},{"id":164,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-438/","title":"深入理解 Java虚拟机 第12章 Java内存模型与线程 438","parent":"深入理解Java虚拟机","content":" 第五部分　高效并发 第12章　Java内存模型与线程 438 12.1　概述 438 12.2　硬件的效率与一致性 439 12.3　Java内存模型 440 12.3.1　主内存与工作内存 441 12.3.2　内存间交互操作 442 12.3.3　对于volatile型变量的特殊规则 444 12.3.4　针对long和double型变量的特殊规则 450 12.3.5　原子性、可见性与有序性 450 12.3.6　先行发生原则 452 12.4　Java与线程 455 12.4.1　线程的实现 455 12.4.2　Java线程调度 458 12.4.3　状态转换 460 12.5　Java与协程 461 12.5.1　内核线程的局限 461 12.5.2　协程的复苏 462 12.5.3　Java的解决方案 464 12.6　本章小结 465 "},{"id":165,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96-466/","title":"深入理解 Java虚拟机 第13章 线程安全与锁优化 466","parent":"深入理解Java虚拟机","content":" 第13章　线程安全与锁优化 466 13.1　概述 466 13.2　线程安全 466 13.2.1　Java语言中的线程安全 467 13.2.2　线程安全的实现方法 471 13.3　锁优化 479 13.3.1　自旋锁与自适应自旋 479 13.3.2　锁消除 480 13.3.3　锁粗化 481 13.3.4　轻量级锁 481 13.3.5　偏向锁 483 13.4　本章小结 485 附录A　在Windows系统下编译OpenJDK 6 486 附录B　展望Java技术的未来（2013年版） 493 附录C　虚拟机字节码指令表 499 附录D　对象查询语言（OQL）简介 506 附录E　JDK历史版本轨迹 512 "},{"id":166,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%91Java-2/","title":"深入理解 Java虚拟机 第1章 走近 Java 2","parent":"深入理解Java虚拟机","content":" 前言 致谢 第一部分　走近Java 第1章　走近Java 2 世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过 程。\n1.1　概述 当我们在使用一门技术时，不再依赖书本和他人就能得到这些问题的答案，那才算升华到了“不 惑”的境界。\n1.2　Java技术体系 从广义上讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序 都属于Java技术体系中的一员。如果仅从传统意义上来看，JCP官方[1]所定义的Java技术体系包括了以 下几个组成部分：\n·Java程序设计语言 ·各种硬件平台上的Java虚拟机实现 ·Class文件格式 ·Java类库API ·来自商业机构和开源社区的第三方Java类库 我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境，本书中为行文方便，在不产生歧义的地方常以JDK 来代指整个Java技术体系[2]。可以把Java类库API中的Java SE API子集[3]和Java虚拟机这两部分统称为 JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。\n1.3　Java发展史 1998年12月4日，JDK迎来了一个里程碑式的重要版本：工程代号为Playground（竞技场）的JDK 1.2，Sun在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。在这个版本中出现的代表性技术非常多，如EJB、Java Plug-in、Java IDL、Swing等，并且这个版本中Java虚拟机第一次内置了JIT（Just InTime）即时编译器（JDK 1.2中曾并存过三个虚拟机，Classic VM、HotSpot VM和Exact VM，其中Exact VM只在Solaris平台出现过；后面两款虚拟机都是内置了JIT即时编译器的，而之前版本所带的Classic VM只能以外挂的形式使用即时编译器）。在语言和API层面上，Java添加了strictfp关键字，Java类库添加了现在Java编码之中极为常用一系列Collections集合类等。在1999年3月和7月，分别有JDK 1.2.1和JDK 1.2.2两个小升级版本发布。\n1999年4月27日，HotSpot 虚拟机诞生。HotSpot最初由一家名为“Longview Techno-logies”的小公司开发，由于HotSpot的优异表现，这家公司在1997年被Sun公司收购。Hot-Spot虚拟机刚发布时是作为JDK 1.2的附加程序提供的，后来它成为JDK 1.3及之后所有JDK版本的默认Java虚拟机。\n2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布。相对于JDK 1.2，JDK 1.3的改进主要体现在Java类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始被作为一项平台级服务提供（以前JNDI仅仅是一项扩展服务），使用CORBA IIOP来实现RMI的通信协议，等等。这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且新添加了JavaSound类库。JDK1.3有1个修正版本JDK 1.3.1，工程代号为Ladybird（瓢虫），于2001年5月17日发布。\n自从JDK 1.3开始，Sun公司维持着稳定的研发节奏：大约每隔两年发布一个JDK的主版本，以动物命名，期间发布的各个修正版本则以昆虫作为工程代号。\n2002年2月13日，JDK 1.4发布，工程代号为Merlin（灰背隼）。JDK 1.4是标志着Java真正走向成熟的一个版本，Compaq、Fujitsu、SAS、Symbian、IBM等著名公司都有参与功能规划，甚至实现自己独立发行的JDK 1.4。哪怕是在近二十年后的今天，仍然有一些主流应用能直接运行在JDK 1.4之上，或者继续发布能运行在1.4上的版本。JDK 1.4同样带来了很多新的技术特性，如正则表达式、异常链、NIO、日志类、XML解析器和XSLT转换器，等等。JDK 1.4有两个后续修正版：2002年9月16日发布的工程代号为Grasshopper（蚱蜢）的JDK 1.4.1与2003年6月26日发布的工程代号为Mantis（螳螂）的JDK 1.4.2。\n2004年9月30日，JDK 5发布，工程代号为Tiger（老虎）。Sun公司从这个版本开始放弃了谦逊的“JDK 1.x”的命名方式，将产品版本号修改成了“JDK x”[1]。从JDK 1.2以来，Java在语法层面上的变动一直很小，而JDK 5在Java语法易用性上做出了非常大的改进。如：自动装箱、泛型、动态注解、枚举、可变长参数、遍历循环（foreach循环）等语法特性都是在JDK 5中加入的。在虚拟机和API层面上，这个版本改进了Java的内存模型（Java Memory Model，JMM）、提供了java.util.concurrent并发包等。另外，JDK 5是官方声明可以支持Windows 9x操作系统的最后一个JDK版本。\n2006年12月11日，JDK 6发布，工程代号为Mustang（野马）。在这个版本中，Sun公司终结了从JDK 1.2开始已经有八年历史的J2EE、J2SE、J2ME的产品线命名方式，启用Java EE 6、Java SE 6、JavaME 6的新命名来代替。JDK 6的改进包括：提供初步的动态语言支持（通过内置Mozilla JavaScriptRhino引擎实现）、提供编译期注解处理器和微型HTTP服务器API，等等。同时，这个版本对Java虚拟机内部做了大量改进，包括锁与同步、垃圾收集、类加载等方面的实现都有相当多的改动。\n在2006年11月13日的JavaOne大会上，Sun公司宣布计划要把Java开源，在随后的一年多时间内，它陆续地将JDK的各个部分在GPLv2（GNU General Public License v2）协议下公开了源码，并建立了OpenJDK组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码所有权不属于Sun公司，Sun本身也无权进行开源处理）外，OpenJDK几乎拥有了当时SunJDK 7的全部代码，OpenJDK的质量主管曾经表示在JDK 7中，SunJDK和OpenJDK除了代码文件头的版权注释之外，代码几乎是完全一样的，所以OpenJDK 7与SunJDK 7本质上就是同一套代码库出来的产品。\n从JDK 7最原始的功能清单来看，它本应是一个包含许多重要改进的JDK版本，其中规划的子项目都为Java业界翘首以盼，包括：\n·Lambda项目：支持Lambda表达式，支持函数式编程。 ·Jigsaw项目：虚拟机层面的模块化支持。 ·动态语言支持：Java是静态语言，为其他运行在Java虚拟机上的动态语言提供支持。 ·Garbage-First收集器。 ·Coin项目：Java语法细节进化。 令人惋惜的是，在JDK 7开发期间，Sun公司相继在技术竞争和商业竞争中陷入泥潭，公司的股票市值跌至仅有高峰时期的3%，已无力推动JDK 7的研发工作按计划继续进行。为了尽快结束JDK 7长期跳票的问题，Oracle收购Sun公司后随即宣布马上实行“B计划”，大幅裁剪了JDK 7预定目标，以保证JDK 7的正式版能够于2011年7月28日准时发布。“B计划”的主要措施是把不能按时完成的Lambda项目、Jigsaw项目和Coin项目的部分改进延迟到JDK 8之中。最终，JDK 7包含的改进有：提供新的G1收集器（G1在发布时依然处于Experimental状态，直至2012年4月的Update 4中才正式商用）、加强对非 Java语言的调用支持（JSR-292，这项特性在到JDK 11还有改动）、可并行的类加载架构等。\nOracle公司接手了JDK开发工作以后，迅速展现出了完全不同于Sun时期的、极具商业化的处事风格。面对Java中使用最广泛而又一直免费的Java SE产品线，Oracle很快定义了一套新的Java SESupport[2]产品计划，把JDK的更新支持作为一项商业服务。JDK 7发布的前80个更新仍然免费面向所有用户提供，但后续的其他更新包，用户[3]只能从“将Java SE升级到Java SE Support”与“将JDK 7升级到最新版本”两个选项里挑一个。JDK 7计划维护至2022年，迄今（面向付费用户）已发布了超过两百个更新补丁，最新版本为JDK 7 Update 221。对于JDK 7，还有一点值得提起的是，从JDK 7 Update 4起，Java SE的核心功能正式开始为MacOS X操作系统提供支持，并在JDK 7 Update 6中达到所有功能与Mac OS X完全兼容的程度；同时，JDK 7 Update 6还对ARM指令集架构提供了支持。至此，官方提供的JDK可以运行于Windows（不含Windows 9x）、Linux、Solaris和Mac OS X操作系统上，支持ARM、x86、x86-64和SPARC指令集架构，JDK 7也是可以支持Windows XP操作系统的最后一个版本[4]。\n1.4　Java虚拟机家族 12 1.4.1　虚拟机始祖：Sun Classic/Exact VM 12 Sun Classic虚拟机的技术已经相当原始，这款虚拟机的使命也早已终结。但仅凭它“世界上第一款商用Java虚拟机”的头衔，就足够有令历史记住它的理由。。这款虚拟机只能使用纯解释器方式来执行Java代码，如果要使用即时编译器那就必须进行外挂，但是假如外挂了即时编译器的话，即时编译器就会完全接管虚拟机的执行系统，解释器便不能再工作了。\n由于解释器和编译器不能配合工作，这就意味着如果要使用编译执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值。基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这个阶段的虚拟机虽然用了即时编译器输出本地代码，其执行效率也和传统的C/C++程序有很大差距，“Java语言很慢”的印象就是在这阶段开始在用户心中树立起来的。\n一款名为Exact VM的虚拟机，它的编译执行系统已经具备现代高性能虚拟机雏形，如热点探测、两级即时编译器、编译器与解释器混合工作模式等。Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。由于使用了准确式内存管理，Exact VM可以抛弃掉以前Classic VM基于句柄（Handle）的对象查找方式（原因是垃圾收集后对象将可能会被移动位置，如果地址为123456的对象移动到654321，在没有明确信息表明内存中哪些数据是引用类型的前提下，那虚拟机肯定是不敢把内存中所有为123456的值改成654321的，所以要使用句柄来保持引用值的稳定），这样每次定位对象都少了一次间接查找的开销，显著提升执行性能。\n1.4.2　武林盟主：HotSpot VM 13 HotSpot既继承了Sun之前两款商用虚拟机的优点（如前面提到的准确式内存管理），也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术（这里的描写带有“历史由胜利者书写”的味道，其实HotSpot与Exact虚拟机基本上是同时期的独立产品，HotSpot出现得还稍早一些，一开始HotSpot就是基于准确式内存管理的，而Exact VM之中也有与HotSpot几乎一样的热点探测技术，为了Exact VM和HotSpot VM哪个该成为Sun主要支持的虚拟机，在Sun公司内部还争吵过一场，HotSpot击败Exact并不能算技术上的胜利），HotSpot虚拟机的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译（On-StackReplacement，OSR）行为[1]。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更复杂的代码优化技术，输出质量更高的本地代码。\n得益于Sun/OracleJDK在Java应用中的统治地位，HotSpot理所当然地成为全世界使用最广泛的Java虚拟机，是虚拟机家族中毫无争议的“武林盟主”。\n1.4.3　小家碧玉：Mobile/Embedded VM 14 1.4.4　天下第二：BEA JRockit/IBM J9 VM 15 BEA System公司的JRockit与IBM公司的IBM J9。\nJRockit虚拟机曾经号称是“世界上速度最快的Java虚拟机”（广告词，IBM J9虚拟机也这样宣传过，总体上三大虚拟机的性能是交替上升的），它是BEA在2002年从Appeal Virtual Machines公司收购获得的Java虚拟机。BEA将其发展为一款专门为服务器硬件和服务端应用场景高度优化的虚拟机，由于专注于服务端应用，它可以不太关注于程序启动速度，因此JRockit内部不包含解释器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit的垃圾收集器和Java Mission Control故障处理套件等部分的实现，在当时众多的Java虚拟机中也处于领先水平。JRockit随着BEA被Oracle收购，现已不再继续发展，永远停留在R28版本，这是JDK 6版JRockit的代号。\nIBM J9直至今天仍旧非常活跃，IBM J9虚拟机的职责分离与模块化做得比HotSpot更优秀，由J9虚拟机中抽象封装出来的核心组件库（包括垃圾收集器、即时编译器、诊断监控子系统等）就单独构成了IBM OMR项目，可以在其他语言平台如Ruby、Python中快速组装成相应的功能。从2016年起，IBM逐步将OMR项目和J9虚拟机进行开源，完全开源后便将它们捐献给了Eclipse基金会管理，并重新命名为Eclipse OMR和OpenJ9[2]。如果为了学习虚拟机技术而去阅读源码，更加模块化的OpenJ9代码其实是比HotSpot更好的选择。如果为了使用Java虚拟机时多一种选择，那可以通过AdoptOpenJDK来获得采用OpenJ9搭配上OpenJDK其他类库组成的完整JDK。\n1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16 Zing虚拟机是一个从HotSpot某旧版代码分支基础上独立出来重新开发的高性能Java虚拟机，它可 以运行在通用的Linux/x86-64平台上。Azul公司为它编写了新的垃圾收集器，也修改了HotSpot内的许多实现细节，在要求低延迟、快速预热等场景中，Zing VM都要比HotSpot表现得更好。Zing的PGC、C4收集器可以轻易支持TB级别的Java堆内存，而且保证暂停时间仍然可以维持在不超过10毫秒的范围里，HotSpot要一直到JDK 11和JDK 12的ZGC及Shenandoah收集器才达到了相同的目标，而且目前效果仍然远不如C4。Zing的ReadyNow！功能可以利用之前运行时收集到的性能监控数据，引导虚拟机在启动后快速达到稳定的高性能水平，减少启动后从解释执行到即时编译的等待时间。Zing自带的ZVision/ZVRobot功能可以方便用户监控Java虚拟机的运行状态，从找出代码热点到对象分配监控、锁竞争监控等。Zing能让普通用户无须了解垃圾收集等底层调优，就可以使得Java应用享有低延迟、快速预热、易于监控的功能，这是Zing的核心价值和卖点，很多Java应用都可以通过长期努力在应用、框架层面优化来提升性能，但使用Zing的话就可以把精力更多集中在业务方面。\n1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17 1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18 1.4.8　百家争鸣 19 1.5　展望Java技术的未来 21 1.5.1　无语言倾向 21 1.5.2　新一代即时编译器 23 HotSpot虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译 器（简称为C1）以及编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2），通常它们 会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统（这部分具体内容将在 本书第11章展开讲解）。\nGraal编译器未来的前途可期，作为Java虚拟机执行代码的最新引擎，它的持续改进，会同时为 HotSpot与Graal VM注入更快更强的驱动力。\n使用-XX：+UnlockExperimentalVMOptions-XX：+UseJVMCICompiler参数来启用Graal编译器。 1.5.3　向 Native 迈进 24 1.5.4　灵活的胖子 26 1.5.5　语言语法持续增强 27 1.6　实战：自己编译JDK 29 1.6.1　获取源码 29 1.6.2　系统需求 31 1.6.3　构建编译环境 33 1.6.4　进行编译 34 1.6.5　在IDE工具中进行源码调试 36 1.7　本章小结 39 "},{"id":167,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8-42/","title":"深入理解 Java虚拟机 第2章 Java内存区域与内存溢出异常 42","parent":"深入理解Java虚拟机","content":" 第二部分　自动内存管理 第2章　Java内存区域与内存溢出异常 42 2.1　概述 42 本章是第二部分的第1章，笔者将从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作 用、服务对象以及其中可能产生的问题，这也是翻越虚拟机内存管理这堵围墙的第一步。\n2.2　运行时数据区域 42 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域 有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是 依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存 将会包括以下几个运行时数据区域，如图2-1所示。\n2.2.1　程序计数器 43 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里[1]，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。\n如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。\n2.2.2　Java虚拟机栈 43 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。\n局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。\n这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。\n在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。\n[1] 栈帧是方法运行期很重要的基础数据结构，在本书的第8章中还会对帧进行详细讲解。 [2] HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。 2.2.3　本地方法栈 44 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。\n《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。\n2.2.4　Java堆 44 对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配[1]”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换[2]优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。\nJava堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”[3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。\n如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。\n根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。\nJava堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。\n[1] 《Java虚拟机规范》中的原文：The heap is the runtime data area from which memory for all class instances and arrays is allocated。 [2] 逃逸分析与标量替换的相关内容，请参见第11章的相关内容。 [3] 指新生代（其中又包含一个Eden和两个Survivor）、老年代这种划分，源自UC Berkeley在20世纪80代中期开发的Berkeley Smalltalk。历史上有多款虚拟机采用了这种设计，包括HotSpot和它的前身Self 和Strongtalk虚拟机（见第1章），原始论文是：https://dl.acm.org/citation.cfm?id=808261。 2.2.5　方法区 46 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。\n说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法（例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta-space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。\n《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。\n根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。\n2.2.6　运行时常量池 47 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\nJava虚拟机对于Class文件每一部分（自然也包括常量池）的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中[1]。\n运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。\n[1] 关于Class文件格式、符号引用等概念可参见第6章。 2.2.7　直接内存 47 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。\n在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常\n2.3　HotSpot虚拟机对象探秘 48 介绍完Java虚拟机的运行时数据区域之后，我们大致明白了Java虚拟机内存模型的概况，相信读者 了解过内存中放了什么，也许就会更进一步想了解这些虚拟机内存中数据的其他细节，譬如它们是如何创建、如何布局以及如何访问的。对于这样涉及细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。基于实用优先的原则，笔者以最常用的虚拟机HotSpot和最常用的内存区域Java堆为例，深入探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。\n2.3.1　对象的创建 48 Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：复制、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？\n当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，本书第7章将探讨这部分细节。\n在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成 后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上[1]就只能采用较为复杂的空闲列表来分配内存。\n除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题 有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败 重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。\n内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。\n接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟 机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，稍后会详细介绍。\n在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。\n下面代码清单2-1是HotSpot虚拟机字节码解释器（bytecodeInterpreter.cpp）中的代码片段。这个 解释器实现很少有机会实际使用，大部分平台上都使用模板解释器；当代码通过即时编译器执行时差异就更大了。不过这段代码（以及笔者添加的注释）用于了解HotSpot的运作过程是没有什么问题的。\n代码清单2-1 HotSpot解释器代码片段\n2.3.2　对象的内存布局 51 2.3.3　对象的访问定位 52 2.4　实战：OutOfMemoryError异常 53 2.4.1　Java堆溢出 54 2.4.2　虚拟机栈和本地方法栈溢出 56 2.4.3　方法区和运行时常量池溢出 61 2.4.4　本机直接内存溢出 65 2.5　本章小结 66 "},{"id":168,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-67/","title":"深入理解 Java虚拟机 第3章 垃圾收集器与内存分配策略 67","parent":"深入理解Java虚拟机","content":" 第3章　垃圾收集器与内存分配策略 67 3.1　概述 67 3.2　对象已死？ 68 3.2.1　引用计数算法 68 3.2.2　可达性分析算法 70 3.2.3　再谈引用 71 3.2.4　生存还是死亡？ 72 3.2.5　回收方法区 74 3.3　垃圾收集算法 75 3.3.1　分代收集理论 75 3.3.2　标记-清除算法 77 3.3.3　标记-复制算法 78 3.3.4　标记-整理算法 79 3.4　HotSpot的算法细节实现 81 3.4.1　根节点枚举 81 3.4.2　安全点 82 3.4.3　安全区域 83 3.4.4　记忆集与卡表 84 3.4.5　写屏障 85 3.4.6　并发的可达性分析 87 3.5　经典垃圾收集器 89 3.5.1　Serial收集器 90 3.5.2　ParNew收集器 92 3.5.3　Parallel Scavenge收集器 93 3.5.4　Serial Old收集器 94 3.5.5　Parallel Old收集器 95 3.5.6　CMS收集器 96 3.5.7　Garbage First收集器 98 3.6　低延迟垃圾收集器 104 3.6.1　Shenandoah收集器 105 3.6.2　ZGC收集器 112 3.7　选择合适的垃圾收集器 121 3.7.1　Epsilon收集器 121 3.7.2　收集器的权衡 121 3.7.3　虚拟机及垃圾收集器日志 122 3.7.4　垃圾收集器参数总结 127 3.8　实战：内存分配与回收策略 129 3.8.1　对象优先在Eden分配 130 3.8.2　大对象直接进入老年代 131 3.8.3　长期存活的对象将进入老年代 132 3.8.4　动态对象年龄判定 134 3.8.5　空间分配担保 135 3.9　本章小结 137 "},{"id":169,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-138/","title":"深入理解 Java虚拟机 第4章 虚拟机性能监控、故障处理工具 138","parent":"深入理解Java虚拟机","content":" 第4章　虚拟机性能监控、故障处理工具 138 4.1　概述 138 4.2　基础故障处理工具 138 4.2.1　jps：虚拟机进程状况工具 141 4.2.2　jstat：虚拟机统计信息监视工具 142 4.2.3　jinfo：Java配置信息工具 143 4.2.4　jmap：Java内存映像工具 144 4.2.5　jhat：虚拟机堆转储快照分析工具 145 4.2.6　jstack：Java堆栈跟踪工具 146 4.2.7　基础工具总结 148 4.3　可视化故障处理工具 151 4.3.1　JHSDB：基于服务性代理的调试工具 152 4.3.2　JConsole：Java监视与管理控制台 157 4.3.3　VisualVM：多合-故障处理工具 164 4.3.4　Java Mission Control：可持续在线的监控工具 171 4.4　HotSpot虚拟机插件及工具 175 4.5　本章小结 180 "},{"id":170,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-181/","title":"深入理解 Java虚拟机 第5章 调优案例分析与实战 181","parent":"深入理解Java虚拟机","content":" 第5章　调优案例分析与实战 181 5.1　概述 181 5.2　案例分析 181 5.2.1　大内存硬件上的程序部署策略 182 5.2.2　集群间同步导致的内存溢出 184 5.2.3　堆外内存导致的溢出错误 185 5.2.4　外部命令导致系统缓慢 187 5.2.5　服务器虚拟机进程崩溃 187 5.2.6　不恰当数据结构导致内存占用过大 188 5.2.7　由Windows虚拟内存导致的长时间停顿 189 5.2.8　由安全点导致长时间停顿 190 5.3　实战：Eclipse运行速度调优 192 5.3.1　调优前的程序运行状态 193 5.3.2　升级JDK版本的性能变化及兼容问题 196 5.3.3　编译时间和类加载时间的优化 200 5.3.4　调整内存设置控制垃圾收集频率 203 5.3.5　选择收集器降低延迟 206 5.4　本章小结 209 "},{"id":171,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-212/","title":"深入理解 Java虚拟机 第6章 类文件结构 212","parent":"深入理解Java虚拟机","content":" 第三部分　虚拟机执行子系统 第6章　类文件结构 212 6.1　概述 212 6.2　无关性的基石 212 6.3　Class类文件的结构 214 6.3.1　魔数与Class文件的版本 215 6.3.2　常量池 218 6.3.3　访问标志 224 6.3.4　类索引、父类索引与接口索引集合 225 6.3.5　字段表集合 226 6.3.6　方法表集合 229 6.3.7　属性表集合 230 6.4　字节码指令简介 251 6.4.1　字节码与数据类型 251 6.4.2　加载和存储指令 253 6.4.3　运算指令 254 6.4.4　类型转换指令 255 6.4.5　对象创建与访问指令 256 6.4.6　操作数栈管理指令 256 6.4.7　控制转移指令 257 6.4.8　方法调用和返回指令 257 6.4.9　异常处理指令 258 6.4.10　同步指令 258 6.5　公有设计，私有实现 259 6.6　Class文件结构的发展 260 6.7　本章小结 261 "},{"id":172,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-262/","title":"深入理解 Java虚拟机 第7章 虚拟机类加载机制 262","parent":"深入理解Java虚拟机","content":" 第7章　虚拟机类加载机制 262 7.1　概述 262 7.2　类加载的时机 263 7.3　类加载的过程 267 7.3.1　加载 267 7.3.2　验证 268 7.3.3　准备 271 7.3.4　解析 272 7.3.5　初始化 277 7.4　类加载器 279 7.4.1　类与类加载器 280 7.4.2　双亲委派模型 281 7.4.3　破坏双亲委派模型 285 7.5　Java模块化系统 287 7.5.1　模块的兼容性 288 7.5.2　模块化下的类加载器 290 7.6　本章小结 292 "},{"id":173,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-293/","title":"深入理解 Java虚拟机 第8章 虚拟机字节码执行引擎 293","parent":"深入理解Java虚拟机","content":" 第8章　虚拟机字节码执行引擎 293 8.1　概述 293 8.2　运行时栈帧结构 294 8.2.1　局部变量表 294 8.2.2　操作数栈 299 8.2.3　动态连接 300 8.2.4　方法返回地址 300 8.2.5　附加信息 301 8.3　方法调用 301 8.3.1　解析 301 8.3.2　分派 303 8.4　动态类型语言支持 315 8.4.1　动态类型语言 316 8.4.2　Java与动态类型 317 8.4.3　java.lang.invoke包 318 8.4.4　invokedynamic指令 321 8.4.5　实战：掌控方法分派规则 324 8.5　基于栈的字节码解释执行引擎 326 8.5.1　解释执行 327 8.5.2　基于栈的指令集与基于寄存器的指令集 328 8.5.3　基于栈的解释器执行过程 329 8.6　本章小结 334 "},{"id":174,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC9%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98-335/","title":"深入理解 Java虚拟机 第9章 类加载及执行子系统的案例与实战 335","parent":"深入理解Java虚拟机","content":" 第9章　类加载及执行子系统的案例与实战 335 9.1　概述 335 9.2　案例分析 335 9.2.1　Tomcat：正统的类加载器架构 335 9.2.2　OSGi：灵活的类加载器架构 338 9.2.3　字节码生成技术与动态代理的实现 341 9.2.4　Backport工具：Java的时光机器 345 9.3　实战：自己动手实现远程执行功能 348 9.3.1　目标 348 9.3.2　思路 349 9.3.3　实现 350 9.3.4　验证 355 9.4　本章小结 356 "},{"id":175,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"深入理解 Java虚拟机","parent":"深入理解Java虚拟机","content":" 深入理解Java虚拟机 标签：Java、基础、深入理解Java虚拟机 、源码解读、进阶、Java开源框架 时间：2020年8月3日18:13:00 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 致谢 第一部分　走近Java 第1章　走近Java 2 1.1　概述 2 1.2　Java技术体系 3 1.3　Java发展史 4 1.4　Java虚拟机家族 12 1.4.1　虚拟机始祖：Sun Classic/Exact VM 12 1.4.2　武林盟主：HotSpot VM 13 1.4.3　小家碧玉：Mobile/Embedded VM 14 1.4.4　天下第二：BEA JRockit/IBM J9 VM 15 1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16 1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17 1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18 1.4.8　百家争鸣 19 1.5　展望Java技术的未来 21 1.5.1　无语言倾向 21 1.5.2　新一代即时编译器 23 1.5.3　向Native迈进 24 1.5.4　灵活的胖子 26 1.5.5　语言语法持续增强 27 1.6　实战：自己编译JDK 29 1.6.1　获取源码 29 1.6.2　系统需求 31 1.6.3　构建编译环境 33 1.6.4　进行编译 34 1.6.5　在IDE工具中进行源码调试 36 1.7　本章小结 39 第二部分　自动内存管理 第2章　Java内存区域与内存溢出异常 42 2.1　概述 42 2.2　运行时数据区域 42 2.2.1　程序计数器 43 2.2.2　Java虚拟机栈 43 2.2.3　本地方法栈 44 2.2.4　Java堆 44 2.2.5　方法区 46 2.2.6　运行时常量池 47 2.2.7　直接内存 47 2.3　HotSpot虚拟机对象探秘 48 2.3.1　对象的创建 48 2.3.2　对象的内存布局 51 2.3.3　对象的访问定位 52 2.4　实战：OutOfMemoryError异常 53 2.4.1　Java堆溢出 54 2.4.2　虚拟机栈和本地方法栈溢出 56 2.4.3　方法区和运行时常量池溢出 61 2.4.4　本机直接内存溢出 65 2.5　本章小结 66 第3章　垃圾收集器与内存分配策略 67 3.1　概述 67 3.2　对象已死？ 68 3.2.1　引用计数算法 68 3.2.2　可达性分析算法 70 3.2.3　再谈引用 71 3.2.4　生存还是死亡？ 72 3.2.5　回收方法区 74 3.3　垃圾收集算法 75 3.3.1　分代收集理论 75 3.3.2　标记-清除算法 77 3.3.3　标记-复制算法 78 3.3.4　标记-整理算法 79 3.4　HotSpot的算法细节实现 81 3.4.1　根节点枚举 81 3.4.2　安全点 82 3.4.3　安全区域 83 3.4.4　记忆集与卡表 84 3.4.5　写屏障 85 3.4.6　并发的可达性分析 87 3.5　经典垃圾收集器 89 3.5.1　Serial收集器 90 3.5.2　ParNew收集器 92 3.5.3　Parallel Scavenge收集器 93 3.5.4　Serial Old收集器 94 3.5.5　Parallel Old收集器 95 3.5.6　CMS收集器 96 3.5.7　Garbage First收集器 98 3.6　低延迟垃圾收集器 104 3.6.1　Shenandoah收集器 105 3.6.2　ZGC收集器 112 3.7　选择合适的垃圾收集器 121 3.7.1　Epsilon收集器 121 3.7.2　收集器的权衡 121 3.7.3　虚拟机及垃圾收集器日志 122 3.7.4　垃圾收集器参数总结 127 3.8　实战：内存分配与回收策略 129 3.8.1　对象优先在Eden分配 130 3.8.2　大对象直接进入老年代 131 3.8.3　长期存活的对象将进入老年代 132 3.8.4　动态对象年龄判定 134 3.8.5　空间分配担保 135 3.9　本章小结 137 第4章　虚拟机性能监控、故障处理工具 138 4.1　概述 138 4.2　基础故障处理工具 138 4.2.1　jps：虚拟机进程状况工具 141 4.2.2　jstat：虚拟机统计信息监视工具 142 4.2.3　jinfo：Java配置信息工具 143 4.2.4　jmap：Java内存映像工具 144 4.2.5　jhat：虚拟机堆转储快照分析工具 145 4.2.6　jstack：Java堆栈跟踪工具 146 4.2.7　基础工具总结 148 4.3　可视化故障处理工具 151 4.3.1　JHSDB：基于服务性代理的调试工具 152 4.3.2　JConsole：Java监视与管理控制台 157 4.3.3　VisualVM：多合-故障处理工具 164 4.3.4　Java Mission Control：可持续在线的监控工具 171 4.4　HotSpot虚拟机插件及工具 175 4.5　本章小结 180 第5章　调优案例分析与实战 181 5.1　概述 181 5.2　案例分析 181 5.2.1　大内存硬件上的程序部署策略 182 5.2.2　集群间同步导致的内存溢出 184 5.2.3　堆外内存导致的溢出错误 185 5.2.4　外部命令导致系统缓慢 187 5.2.5　服务器虚拟机进程崩溃 187 5.2.6　不恰当数据结构导致内存占用过大 188 5.2.7　由Windows虚拟内存导致的长时间停顿 189 5.2.8　由安全点导致长时间停顿 190 5.3　实战：Eclipse运行速度调优 192 5.3.1　调优前的程序运行状态 193 5.3.2　升级JDK版本的性能变化及兼容问题 196 5.3.3　编译时间和类加载时间的优化 200 5.3.4　调整内存设置控制垃圾收集频率 203 5.3.5　选择收集器降低延迟 206 5.4　本章小结 209 第三部分　虚拟机执行子系统 第6章　类文件结构 212 6.1　概述 212 6.2　无关性的基石 212 6.3　Class类文件的结构 214 6.3.1　魔数与Class文件的版本 215 6.3.2　常量池 218 6.3.3　访问标志 224 6.3.4　类索引、父类索引与接口索引集合 225 6.3.5　字段表集合 226 6.3.6　方法表集合 229 6.3.7　属性表集合 230 6.4　字节码指令简介 251 6.4.1　字节码与数据类型 251 6.4.2　加载和存储指令 253 6.4.3　运算指令 254 6.4.4　类型转换指令 255 6.4.5　对象创建与访问指令 256 6.4.6　操作数栈管理指令 256 6.4.7　控制转移指令 257 6.4.8　方法调用和返回指令 257 6.4.9　异常处理指令 258 6.4.10　同步指令 258 6.5　公有设计，私有实现 259 6.6　Class文件结构的发展 260 6.7　本章小结 261 第7章　虚拟机类加载机制 262 7.1　概述 262 7.2　类加载的时机 263 7.3　类加载的过程 267 7.3.1　加载 267 7.3.2　验证 268 7.3.3　准备 271 7.3.4　解析 272 7.3.5　初始化 277 7.4　类加载器 279 7.4.1　类与类加载器 280 7.4.2　双亲委派模型 281 7.4.3　破坏双亲委派模型 285 7.5　Java模块化系统 287 7.5.1　模块的兼容性 288 7.5.2　模块化下的类加载器 290 7.6　本章小结 292 第8章　虚拟机字节码执行引擎 293 8.1　概述 293 8.2　运行时栈帧结构 294 8.2.1　局部变量表 294 8.2.2　操作数栈 299 8.2.3　动态连接 300 8.2.4　方法返回地址 300 8.2.5　附加信息 301 8.3　方法调用 301 8.3.1　解析 301 8.3.2　分派 303 8.4　动态类型语言支持 315 8.4.1　动态类型语言 316 8.4.2　Java与动态类型 317 8.4.3　java.lang.invoke包 318 8.4.4　invokedynamic指令 321 8.4.5　实战：掌控方法分派规则 324 8.5　基于栈的字节码解释执行引擎 326 8.5.1　解释执行 327 8.5.2　基于栈的指令集与基于寄存器的指令集 328 8.5.3　基于栈的解释器执行过程 329 8.6　本章小结 334 第9章　类加载及执行子系统的案例与实战 335 9.1　概述 335 9.2　案例分析 335 9.2.1　Tomcat：正统的类加载器架构 335 9.2.2　OSGi：灵活的类加载器架构 338 9.2.3　字节码生成技术与动态代理的实现 341 9.2.4　Backport工具：Java的时光机器 345 9.3　实战：自己动手实现远程执行功能 348 9.3.1　目标 348 9.3.2　思路 349 9.3.3　实现 350 9.3.4　验证 355 9.4　本章小结 356 第四部分　程序编译与代码优化 第10章　前端编译与优化 358 10.1　概述 358 10.2　Javac编译器 359 10.2.1　Javac的源码与调试 359 10.2.2　解析与填充符号表 362 10.2.3　注解处理器 363 10.2.4　语义分析与字节码生成 364 10.3　Java语法糖的味道 367 10.3.1　泛型 367 10.3.2　自动装箱、拆箱与遍历循环 375 10.3.3　条件编译 377 10.4　实战：插入式注解处理器 378 10.4.1　实战目标 379 10.4.2　代码实现 379 10.4.3　运行与测试 385 10.4.4　其他应用案例 386 10.5　本章小结 386 第11章　后端编译与优化 388 11.1　概述 388 11.2　即时编译器 389 11.2.1　解释器与编译器 389 11.2.2　编译对象与触发条件 392 11.2.3　编译过程 397 11.2.4　实战：查看及分析即时编译结果 398 11.3　提前编译器 404 11.3.1　提前编译的优劣得失 405 11.3.2　实战：Jaotc的提前编译 408 11.4　编译器优化技术 411 11.4.1　优化技术概览 411 11.4.2　方法内联 415 11.4.3　逃逸分析 417 11.4.4　公共子表达式消除 420 11.4.5　数组边界检查消除 421 11.5　实战：深入理解Graal编译器 423 11.5.1　历史背景 423 11.5.2　构建编译调试环境 424 11.5.3　JVMCI编译器接口 426 11.5.4　代码中间表示 429 11.5.5　代码优化与生成 432 11.6　本章小结 436 第五部分　高效并发 第12章　Java内存模型与线程 438 12.1　概述 438 12.2　硬件的效率与一致性 439 12.3　Java内存模型 440 12.3.1　主内存与工作内存 441 12.3.2　内存间交互操作 442 12.3.3　对于volatile型变量的特殊规则 444 12.3.4　针对long和double型变量的特殊规则 450 12.3.5　原子性、可见性与有序性 450 12.3.6　先行发生原则 452 12.4　Java与线程 455 12.4.1　线程的实现 455 12.4.2　Java线程调度 458 12.4.3　状态转换 460 12.5　Java与协程 461 12.5.1　内核线程的局限 461 12.5.2　协程的复苏 462 12.5.3　Java的解决方案 464 12.6　本章小结 465 第13章　线程安全与锁优化 466 13.1　概述 466 13.2　线程安全 466 13.2.1　Java语言中的线程安全 467 13.2.2　线程安全的实现方法 471 13.3　锁优化 479 13.3.1　自旋锁与自适应自旋 479 13.3.2　锁消除 480 13.3.3　锁粗化 481 13.3.4　轻量级锁 481 13.3.5　偏向锁 483 13.4　本章小结 485 附录A　在Windows系统下编译OpenJDK 6 486 附录B　展望Java技术的未来（2013年版） 493 附录C　虚拟机字节码指令表 499 附录D　对象查询语言（OQL）简介 506 附录E　JDK历史版本轨迹 512 "},{"id":176,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","title":"深入理解计算机系统 第1章 计算机系统漫游","parent":"深入理解计算机系统","content":" 深入理解计算机系统 标签：计算机、操作系统 时间：2023年3月24日01点05分 连接：https://www.saveload.cn/Tech/1、Book/深入理解计算机系统/深入理解计算机系统.md 第 1 章　计算机系统漫游 计算机系统是由硬件和系统软件组成的,它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化,但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件,它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的,以此来提高自身的技能。本书便是为这些读者而写的。\n现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念,完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。\n你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字 错误。你将学会怎样通过一些小窍门来优化自己的C代码，以充分利用现代处理器和存储器系统的设计。你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓 冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学 会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。你将学会如何 编写自己的 Unix shell 、自己的动态存储分配包，甚至于自己的 Web 服务器 。你会认识并发 带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要 。\n"},{"id":177,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","title":"深入理解计算机系统","parent":"深入理解计算机系统","content":" 深入理解计算机系统 标签：计算机、操作系统 时间：2023年3月24日01点05分 连接：https://www.saveload.cn/Tech/1、Book/深入理解计算机系统/深入理解计算机系统.md "},{"id":178,"href":"/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AC%AC1%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/","title":"算法导论 第一部分 基础知识 第1章 算法在计算中的作用","parent":"算法导论","content":" 第一部分 基础知识 第1章 算法在计算中的作用 1.1 算法 1.2 作为一种技术的算法\n"},{"id":179,"href":"/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","title":"算法导论","parent":"算法导论","content":"第一部分 基础知识 第1章 算法在计算中的作用 1.1 算法 1.2 作为一种技术的算法 第2章 算法基础 2.1 插入排序 2.2 分析算法 2.3 设计算法 第3章 函数的增长 3.1 渐进记号 3.2 标准记号与常用函数 第4章 分治策略 4.1 最大子数组问题 4.2 矩阵乘法的Strassen算法 4.3 用代入法求解递归式 4.4 用递归树方法求解递归式 4.5 用主方法求解递归式 *4.6 证明主定理 第5章 概率分析和随机算法 5.1 雇用问题 5.2 指示器随机变量 5.3 随机算法 *5.4 概率分析和指示器随机变量的进一步使用 第二部分 排序和顺序统计量 第6章 堆排序 6.1 堆 6.2 维护堆的性质 6.3 建堆 6.4 堆排序算法 6.5 优先队列 第7章 快速排序 7.1 快速排序的描述 7.2 快速排序的性能 7.3 快速排序的随机化版本 7.4 快速排序分析 第8章 线性时间排序 8.1 排序算法的下界 8.2 计数排序 8.3 基数排序 8.4 桶排序 第9章 中位数和顺序统计量 9.1 最小值和最大值 9.2 期望为线性时间的选择算法 9.3 最坏情况为线性时间的选择算法 第三部分 数据结构 第10章 基本数据结构 10.1 栈和队列 10.2 链表 10.3 指针和对象的实现 10.4 有根树的表示 第11章 散列表 11.1 直接寻址表 11.2 散列表 11.3 散列函数 11.4 开放寻址法 11.5 完全散列 第12章 二叉搜索树 12.1 什么是二叉搜索树 12.2 查询二叉搜索树 12.3 插入和删除 12.4 随机构建二叉搜索树 第13章 红黑树 13.1 红黑树的性质 13.2 旋转 13.3 插入 13.4 删除 第14章 数据结构的扩张 14.1 动态顺序统计 14.2 如何扩张数据结构 14.3 区间树 第四部分 高级设计和分析技术 第15章 动态规划 15.1 钢条切割 15.2 矩阵链乘法 15.3 动态规划原理 15.4 最长公共子序列 15.5 最优二叉搜索树 第16章 贪心算法 16.1 活动选择问题 16.2 贪心算法原理 16.3 赫夫曼编码 *16.4 拟阵和贪心算法 *16.5 用拟阵求解任务调度问题 第17章 摊还分析 17.1 聚合分析 17.2 核算法 17.3 势能法 17.4 动态表 第五部分 高级数据结构 第18章 B树 18.1 B树的定义 18.2 B树上的基本操作 18.3 从B树中删除关键字 第19章 斐波那契堆 19.1 斐波那契堆结构 19.2 可合并堆操作 19.3 关键字减值和删除一个结点 19.4 最大度数的界 第20章 van Emde Boas 树 20.1 基本方法 20.2 递归结构 20.3 van Emde Boas 树及其操作 第21章 用于不相交集合的数据结构 21.1 不相交集合的操作 21.2 不相交集合的链表表示 21.3 不相交集合森林 *21.4 带路径压缩的按秩合并的分析 第六部分 图算法 第22章 基本的图算法 22.1 图的表示 22.2 广度优先搜索 22.3 深度优先搜索 22.4 拓扑排序 22.5 强连通分量 第23章 最小生成树 23.1 最小生成树的形成 23.2 Kruskal 算法和Prim 算法 第24章 单源最短路径 24.1 Bellman-Ford 算法 24.2 有向无环图中的单源最短路径问题 24.3 Dijkstra算法 24.4 差分约束和最短路径 24.5 最短路径性质的证明 第25章 所有结点对的最短路径问题 25.1 最短路径和矩阵乘法 25.2 Floyd-Warshall 算法 25.3 用于稀疏图的Johnson算法 第26章 最大流 26.1 流网络 26.2 Ford-Fulkerson 方法 26.3 最大二分匹配 *26.4 推送-重贴标签算法 *26.5 前置重贴标签算法 第七部分 算法问题选编 第27章 多线程算法 27.1 动态多线程基础 27.2 多线程矩阵乘法 27.3 多线程归并排序 第28章 矩阵运算 28.1 求解线性方程组 28.2 矩阵求逆 28.3 对称正定矩阵和最小二乘逼近 第29章 线性规划 29.1 标准型和松弛型 29.2 将问题表达为线性规划 29.3 单纯形算法 29.4 对偶性 29.5 初始基本可行解 第30章 多项式与快速傅里叶变换 30.1 多项式的表示 30.2 DFT与FFT 30.3 高效FFT实现 第31章 数论算法 31.1 基础数论概念 31.2 最大公约数 31.3 模运算 31.4 求解模线性方程 31.5 中国余数定理 31.6 元素的幂 31.7 RSA公钥加密系统 *31.8 素数的测试 *31.9 整数的因子分解 第32章 字符串匹配 32.1 朴素字符串匹配算法 32.2 Rabin-Karp算法 32.3 利用有限自动机进行字符串匹配 *32.4 Knuth-Morris-Pratt 第33章 计算几何学 33.1 线段的性质 33.2 确定任意一对线段是否相交 33.3 寻找凸包 33.4 寻找最近点对 第34章 NP完全性 34.1 多项式时间 34.2 多项式时间的验证 34.3 NP完全性与可归约性 34.4 NP完全性的证明 34.5 NP完全问题 第35章 近似算法 35.1 顶点覆盖问题 35.2 旅行商问题 35.3 集合覆盖问题 35.4 随机化和线性规划 35.5 子集和问题 第八部分 附录：数学基础知识 附录A 求和 附录B 集合等离散数学内容 附录C 计数与概率 附录D 矩阵 参考文献 索引\n"},{"id":180,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/","title":"计算机科学导论（原书第3版）","parent":"计算机科学导论（原书第3版）","content":" 计算机科学导论（原书第3版） 目录 出版者的话 译者序 前言 第1章绪论 1.1图灵模型 1.1.1数据处理器 1.1.2可编程数据处理器 1.1.3通用图灵机 1.2冯·诺依曼模型 1.2.1 4个子系统 1.2.2存储程序概念 1.2.3 指令的顺序执行 1.3计算机组成部分 1.3.1计算机硬件 1.3.2数据 1.3.3计算机软件 1.4历史 1.4.1机械计算机器（1930年以前） 1.4.2 电子计算机的诞生(1930～ 1950年) 1.4.3计算机的诞生（1950年至今） 1.5社会问题和道德问题 1.5.1社会问题 1.5.2道德问题 1.6计算机科学作为一门学科 1.7课程纲要 1.7.1 第一部分：数据的表示与运算 1.7.2第二部分：计算机硬件 1.7.3第三部分：计算机软件 1.7.4第四部分：数据组织与抽象 1.7.5第五部分：高级话题 1.8章末材料 1.9练习 第2章数字系统 2.1引言 2.2位置化数字系统 2.2.1 十进制系统（以10为底） 2.2.2二进制系统（以2为底） 2.2.3 十六进制系统（以16为底） 2.2.4八进制系统（以8为底） 2.2.5 4种位置化数字系统的小结 2.2.6转换 2.3非位置化数字系统 2.4章末材料 2.5练习 第3章数据存储 3.1数据类型 3.2存储数字 3.2.1存储整数 3.2.2 3种系统的比较 3.2.3 实数 3.3存储文本 3.4存储音频 3.4.1．采样 3.4.2量化 3.4.3编码 3.4.4声音编码标准 3.5存储图像 3.5.1光栅图 3.5.2矢量图 3.6存储视频 3.7章末材料 3.8练习 第4章数据运算 4.1逻辑运算 4.1.1位层次上的逻辑运算 6.7.1导向介质 6.7.2非导向介质 6.8章末材料 6.9练习 第7章操作系统 7.1引言 7.1.1操作系统 7.1.2自举过程 7.2演化 7.2.1批处理系统 7.2.2分时系统 7.2.3个人系统 7.2.4并行系统 7.2.5分布式系统 7.2.6实时系统 7.3组成部分 7.3.1 用户界面 7.3.2 内存管理器 7.3.3进程管理器 7.3.4 文件管理器 7.4主流操作系统 7.4.1 UNIX 7.4.2 Linux 7.4-3 WindOWS 7.5章末材料 7.6练习 第8章算法 8.1概念 8.1.1 非正式定义 8.1.2定义动作 8.1.3细化 8 .1.4泛化 8.2三种结构 8.2.1顺序 8.2.2一判断 8.2.3循环 8.3算法的表示 8.3.1 UML 8.3.2伪代码 8.4更正式的定义 8.4.1定义良好 8.4.2明确步骤 8.4.3产生结果 8.4.4在有限的时间内终止 8.5基本算法 8.5.1求和 8.5.2乘积 8.5.3 最大和最小 8.5.4排序 8.5.5查找 8.6子算法 8.7递归 8.7.1迭代的定义 8.7.2递归的定义 8.8章末材料 8.9练习 第9章程序设计语言 9.1演化 9.1.1机器语言 9.1.2汇编语言 9.1.3 高级语言 9.2翻译 9.2.1编译 9.2.2解释 9.2.3 翻译过程 9.3编程模式 9.3.1过程式模式 9.3.2面向对象模式 9.3.3 函数式模式 9.3.4说明式模式 9.4共同概念 9.4.1标识符 9.4.2数据类型 9.4.3语句 9.5章末材料 9.6练习 第10章软件工程 10.1软件生命周期 10.2分析阶段 10.2.1 面向过程分析 10.2.2 面向对象分析 10.3设计阶段 10.3.1 面向过程设计 10.3.2 面向对象设计 10.4实现阶段 10.4.1语言的选择 10.4.2软件质量 10.5测试阶段 10.5.1 白盒测试 10.5.2黑盒测试 10.6文档 10.6.1用户文档 10.6.2 系统文档 10.6.3技术文档 10.7章末材料 10.8练习 一 第11章数据结构 11.1数组 11.1.1数组名与元素名 11.1.2多维数组 11.1.3存储配置 11.1.4数组操作 11.1.5数组的应用 11.2记录 11.2.1 记录名与域名 11.2.2记录与数组的比较 11.2.3记录数组 11.2.4数组与记录数组 11.3链表 11.3.1数组与链表 11.3.2链表名与节点名 11.3.3链表操作 11.3.4链表的应用 11.4章末材料 11.5练习 第1 2章抽象数据类型 12.1背景 12.1.1 简单抽象数据类型 12.1.2复杂抽象数据类型 12.1.3定义 12.1.4抽象数据类型的模型 12.1.5实现 12.2栈 12.2.1栈的操作 12.2.2栈的抽象数据类型 12.2.3栈的应用 12.2.4栈的实现 12.3队列 12.3.1 队列的操作 12.3.2队列抽象数据类型 12.3.3 队列的应用 12.3.4 队列的实现 12.4广义线性表 12.4.1 广义线性表的操作 12.4.2广义线性表的抽象数据类型 12.4.3 广义线性表的应用 12.4.4广义线性表的实现 12.5树 12.5.1二叉树 12.5.2二叉树的操作 12.5.3二叉树的应用 12.5.4二叉树的实现 12.5.5二叉搜索树 12.5.6二叉搜索树的抽象数据 类型 12.5.7二叉搜索树的实现 12.6 图 12.7章末材料 12.8练习 第1 3章文件结构 13.1引言 13．¨顺序存取 13.1.2随机存取 13.2顺序文件 13.3索引文件 13.4散列文件 13.4.1散列方法 13.4.2冲突 13.5目录 13.6文本文件与二进制文件 13.6.1文本文件 13.6.2二进制文件 13.7章末材料 13.8练习 第14章数据库 14.1引言 14.1.1定义 14.1.2数据库的优点 14.1.3数据库管理系统 14.2数据库体系结构 14.2.1 内层 14.2.2概念层 14.2.3外层 一 14.3数据库模型 14.3.1层次模型 14.3.2 网状模型 14.3.3 关系模型 14.4关系数据库模型 14.5关系的操作 14.5.1 结构化查询语言 14.5.2插入 14.5.3删除 14.5.4更新 14.5.5选择 14.5.6投影 14.5.7连接 14.5.8并 14.5.9交 14.5.10差 14.6数据库设计 14.6.1 实体关系模型 14.6.2从E-R图至0关系 14.6.3规范化 14.7其他数据库模型 14.8章末材料 14.9练习 第1 5章数据压缩 15.1引言 15.2无损压缩 15.2.1 游程长度编码 15.2.2赫夫曼编码 15.2.3 LempelZiv编码 15.3有损压缩方法 15.3.1 图像压缩：JPEG- 15.3.2视频压缩：MPEG 15.3.3 音频压缩 15.4章末材料 15.5练习 第16章安全 16.1引言 16.1.1安全目标 16.1.2攻击 16.1.3服务和技术 16.2机密性 16.2.1 对称密钥密码术 16.2.2非对称密钥密码术 16.3其他安全服务 16.3.1 消息完整性 16.3.2消息验证 16.3.3数字签名 16.3.4实体验证 16.3.5 密钥管理 16.4防火墙 16.4.1 包过滤防火墙 16.4.2代理防火墙 16.5章末材料 16.6练习 第1 7章计算理论 17.1引言 ?17.2简单语言 17.2.1递增语句 17.2.2递减语句 17.2.3循环语句 17.2.4 简单语言的威力 17.3图灵机 17.3.1 图灵机组成部件 17.3.2对简单语言的模拟 17.3.3邱奇一图灵论题 17.4歌德尔数 17.4.1表示一个程序 17.4.2翻译一个数字 17.5停机问题 17.6问题的复杂度 17.6.1 不可解问题 17.6.2可解问题 17.7章末材料 17.8练习 第1 8章人工智能 18.1引言 18.1.1什么是人工智能 18.1.2人工智能简史 18.1.3 图灵测试 18.1.4智能体 18.1.5编程语言 18.2知识表示 18.2.1语义网 18.2.2框架 18.2.3谓词逻辑 18.2.4基于规则的系统 18.3专家系统 18.3.1抽取知识 18.3.2抽取事实 18.3.3体系结构 18.4感知 - 18.4.1图像处理 18.4.2语言理解 18.5搜索 - 18.6神经网络 18.6.1 生物神经元 18.6.2感知器 18.6.3多层网络 18.6.4应用 18.7章末材料 18.8练习 附录A Unicode 附录B UML 附录C伪代码 附录D结构图 附录E布尔代数和逻辑电路 附录FC、C++和Java程序示例 附录G数学知识 附录H误差检测和校正 缩略语 术语表\n"},{"id":181,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%8E%9F%E5%88%99-1-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA/","title":"计算机网络：原理、协议和实践，第三版 第 1 部分：原则 1 连接两台主机","parent":"计算机网络：原理、协议和实践，第三版","content":" 计算机网络：原理、协议和实践，第三版 第 1 部分：原则 连接两台主机 物理层 数据链路层 框架 从传输错误中恢复 在不完美链路之上实现可靠的数据传输 回溯 n 和选择性重复 连接两台主机 构建网络（甚至是 Internet 等全球网络）的第一步是将两台主机连接在一起。如下图所示。\n将两台主机连接在一起\n为了使两台主机能够交换信息，它们需要通过某种物理介质链接在一起。计算机网络已经使用各种类型的物理介质来交换信息，特别是：\n电缆。信息可以通过不同类型的电缆传输。最常见的是双绞线（用于电话网络，但也用于企业网络）和同轴电缆（仍在有线电视网络中使用，但不再用于企业网络）。某些网络技术通过经典电缆运行。 光纤。当通信设备之间的距离大于一公里时，光纤经常用于公共和企业网络。光纤主要有两种类型：多模和单模。多模比单模光纤便宜得多，因为LED可用于通过多模光纤发送信号，而单模光纤必须由激光驱动。由于光的传播模式不同，多模光纤仅限于几公里的距离，而单模光纤可以在几十公里以上的距离上使用。在这两种情况下，中继器都可用于在光纤的一个端点处再生光信号，以通过另一根光纤发送。 无线。在这种情况下，无线电信号用于对通信设备之间交换的信息进行编码。许多类型的调制技术用于通过无线信道发送信息，并且该领域每年都有很多创新，并且每年都会出现新技术。虽然大多数无线网络依赖于无线电信号，但有些使用激光将光脉冲发送到远程探测器。这些光学技术允许创建点对点链路，而基于无线电的技术可用于构建包含分布在小地理区域的设备的网络。 物理层 一旦这些信息被转换为合适的电信号，这些物理介质就可以用来交换信息。整个电信课程和教科书都致力于将模拟或数字信息转换为电信号的问题，以便可以通过给定的物理链路传输。在本书中，我们只考虑两种非常简单的方案，它们允许通过电缆传输信息。这使我们能够突出通过物理链路传输信息时的关键问题。我们只对允许通过有线传输数字信息的技术感兴趣。在这里，我们将重点介绍位的传输，即0或1。\n注意\n比特率 (Bit rate)\n在计算机网络中，物理层的比特率始终以每秒比特数表示。1 Mbps 是每秒 100 万位，1 Gbps 是 10 亿位/秒。这与通常以字节(bytes)（8 位(bits)）、千字节（1024 字节(bytes)）或兆字节（1048576 字节(bytes)）表示的内存规格形成鲜明对比。通过 1 Mbps 链路传输 1 MByte 可持续 8.39 秒。\nBit rate | Bits per second\n1 Kbps | 10^3\n1 Mbps | 10^6\n1 Gbps | 10^9\n1 Tbps | 10^12\n为了理解信息物理传输背后的一些原理，让我们考虑一下用于传输位的电线的简单情况。假设两个通信主机想要每秒传输一千位。要传输这些位，两个主机可以就以下规则达成一致：\n在发送方： +5V 在一毫秒内将电线上的电压设置为以传输设置为1的位 在一毫秒内将电线上的电压设置-5V为传输位设置为0 在接收器侧： 每毫秒，记录施加在电线上的电压。如果电压设置为+5V，记录位1的接收。否则，记录位0的接收 这种传输方案已经在一些早期的网络中使用。我们使用它作为了解主机如何通信的基础。从计算机科学的角度来看，处理电压是不寻常的。计算机科学家经常依赖模型，使他们能够推理他们面临的问题，而无需考虑所有实施细节。上述物理传输方案可以用时序图来表示。\n时序图描述了通信主机之间的交互。按照惯例，通信主机在图的左右部分表示，而电气链路位于图的中间。在这样的时序图中，时间从图的顶部流向底部。一位信息的传输由三个箭头表示。从左边开始，第一个水平箭头表示传输一位信息的请求。该请求由可以被视为一种过程调用的原语表示。该原语有一个参数（被传输的位）和一个名称（在本例中为DATA.request）。按照惯例，所有被命名的原语something.request对应于传输一些信息的请求。虚线箭头表示相应电信号在导线上的传输。电和光信号不会瞬间传播。对角虚线箭头表示电信号从主机 A传输到主机 B需要一些时间。接收到电信号后，主机 B的网络接口上的电子设备会检测电压并将其转换为位。该位作为DATA.indication原语提供。所有名为something.indication的原语对应于一些信息的接收。虚线还表示两个（或多个）基元之间的关系。这样的时序图提供了有关不同基元排序的信息，但两个基元之间的距离并不代表精确的时间量。\n当试图理解给定通信方案的特征时，时序图很有用。在考虑上述传输方案时，评估该方案是否允许两个通信主机可靠地交换信息是有用的。当主机传输的位序列在线路的另一端被正确接收时，数字传输被认为是可靠的。在实践中，使用上述方案传输信息时很难实现完美的可靠性。这种传输方案可能会出现几个问题。\n第一个问题是电传输会受到电磁干扰的影响。干扰可能有多种来源，包括自然现象（如雷暴、磁场变化……）以及其他电信号（例如来自相邻电缆的干扰、来自相邻天线的干扰……）。由于这些不同类型的干扰，不幸的是，无法保证当主机在线传输一个比特时，另一端会接收到相同的比特。如下图所示，左侧主机上的DATA.request(0)导致右侧主机上的Data.indication(1)。\n使用上述传输方案，通过在一段时间内将电缆上的电压设置为特定值来传输比特。我们已经看到，由于电磁干扰，接收器测量的电压可能与发射器设置的电压不同。这是传输错误的主要原因。但是，这不是唯一可能发生的问题类型。除了定义位0和1的电压，上述传输方案还规定了每个比特的持续时间。如果每秒发送一百万位，则每个位持续 1 微秒。在每个主机上，每个位的传输（或接收）由具有 1 MHz 频率的本地时钟触发。当通过线路传输位时，这些时钟是第二个问题来源。尽管这两个时钟具有相同的规格，但它们在不同的主机上运行，可能在不同的温度和不同的能源下运行。在实践中，两个时钟可能不会以完全相同的频率运行。假设发送主机的时钟正好工作在 1000000 Hz，而接收时钟工作在 999999 Hz。这是两个时钟之间的一个非常小的差异。然而，当使用时钟传输比特时，这种差异很重要。凭借其 1000000 Hz 的时钟，发送主机将在一秒钟内生成一百万位。在同一时期，接收主机将感应线路 999999 次，因此接收到的比特比最初传输的比特少。时钟频率的这种微小差异意味着位在电缆上传输期间可能会“消失”。如下图所示。\n当发送主机的时钟比接收主机的时钟慢时，类似的推理也适用。在这种情况下，接收方将感知到比发送方已发送的比特更多的比特。下图说明了这一点，其中右侧接收到的第二个位未由左侧主机发送。\n从计算机科学的角度来看，通过电线进行的信息物理传输通常被认为是一个允许传输比特的黑匣子。这个黑匣子通常被称为物理层服务，使用前面介绍的DATA.request和DATA.indication原语来表示。这种物理层服务通过将比特实际传输中涉及的技术细节抽象为电磁信号来促进比特的发送和接收。但是，重要的是要记住，物理层服务是不完善的，具有以下特点：\n物理层服务可能会改变，例如由于电磁干扰，正在传输的比特的值 物理层服务向接收方传递的比特可能比发送方发送的比特多 物理层服务向接收方传递的比特可能比发送方发送的比特少 许多其他类型的编码已被定义为通过电缆传输信息。所有物理层都能够发送和接收表示值0和1的物理符号。然而，由于本章范围之外的各种原因，几个物理层也交换了其他物理符号。例如，多个物理层中使用的曼彻斯特编码可以发送四个不同的符号。曼彻斯特编码是一种差分编码方案，其中时间被划分为固定长度的周期。每个周期分为两半，可以施加两个不同的电压电平。要发送符号，发送者必须在每个半周期内设置这两个电压电平之一。发送一个1 (resp. 0)，发送方必须在周期的前半段设置高（或低）电压，在后半段设置低（或高）电压。这种编码确保在每个周期的中间会有一个转换，并允许接收者将其时钟与发送者的时钟同步。除了0和1的编码，曼彻斯特编码还支持两个附加符号：InvH和InvB ，其中两个半周期使用相同的电压电平。根据定义，这两个符号不能出现在仅由0和1组成的框架内。一些技术使用这些特殊符号作为帧开始或结束的标记。\n曼彻斯特编码\n物理层\n与通过有线（或无线链路）进行物理传输或信息有关的所有功能通常称为物理层. 因此，物理层允许直接连接到同一传输介质的两个或多个实体交换比特。能够交换比特很重要，因为实际上任何信息都可以编码为比特序列。电气工程师习惯于处理比特流，但计算机科学家通常更喜欢处理更高层次的概念。文件存储也会出现类似的问题。诸如硬盘之类的存储设备也存储比特流。有一些硬件设备可以处理硬盘产生的比特流，但是计算机科学家已经设计了文件系统来允许应用程序轻松访问这些存储设备。这些文件系统通常也分为几层。硬盘存储 512 字节或更多的扇区。Unix 文件系统将扇区分组为更大的块，这些块可以包含数据或表示文件系统结构的inode 。最后，应用程序操作文件和目录，这些文件和目录由操作系统以块、扇区和最终位的形式进行转换。\n计算机网络使用类似的方法。每一层都提供了一个构建在底层之上的服务，并且更接近应用程序的需求。数据链路层建立在物理层提供的服务之上。我们将看到它还包含几个功能。\n物理层 从计算机科学的角度来看，通过电线进行的信息物理传输通常被认为是一个允许传输比特的黑匣子。这个黑匣子通常被称为物理层服务 与通过有线（或无线链路）进行物理传输或信息有关的所有功能通常称为物理层 数据链路层 计算机科学家通常对在两个主机之间交换位不感兴趣。他们更喜欢编写处理更大数据块的软件，以便传输消息或完整的文件。由于物理层服务，可以在两台主机之间发送连续的比特流。这个比特流可以包含逻辑数据块，但我们需要能够从比特流中提取每个数据块，尽管物理层存在缺陷。在许多网络中，两个直接连接的主机之间交换信息的基本单位通常称为帧。帧可以定义为具有特定语法或结构的位序列。我们将在本章后面看到此类框架的示例。\n为了实现帧的发送/接收，首先要解决的问题是如何将帧编码为比特序列，以便接收器可以轻松地恢复接收到的帧，而不受物理层的限制。\n如果物理层是完美的，问题就很简单了。我们只需要定义如何将每个帧编码为一系列连续位。然后，接收器将能够轻松地从接收到的位中提取帧。不幸的是，物理层的缺陷使这个成帧问题稍微复杂一些。已经提出了几种解决方案，并在不同的网络技术中实际使用。\n数据链路层 数据链路层建立在物理层提供的服务之上 两个直接连接的主机之间交换信息的基本单位通常称为帧。帧可以定义为具有特定语法或结构的位序列。 成帧问题可以定义为：“发送方如何对帧进行编码，以便接收方可以有效地从它从物理层接收到的比特流中提取它们”。 一个运行在物理层服务之上的可靠数据链路协议。 数据链路层旨在代表用户发送和接收帧 除了成帧之外，数据链路层还包括检测传输错误，有时甚至从传输错误中恢复的机制。 框架 成帧问题可以定义为：“发送方如何对帧进行编码，以便接收方可以有效地从它从物理层接收到的比特流中提取它们”。\n这个问题的第一个解决方案是要求物理层在每帧传输后保持空闲一段时间。这些空闲时段可以被接收器检测到，并用作描绘帧边界的标记。不幸的是，由于两个原因，这种解决方案是不可接受的。首先，一些物理层不能保持空闲并且总是需要传输比特。其次，在帧之间插入空闲周期会降低可以达到的最大比特率。\n笔记\n比特率和带宽\n比特率和带宽经常被用来表征物理服务的传输能力。韦伯斯特词典中列出的带宽的原始定义是由调制载波占用的无线电频率范围，分配给服务或设备可以在其上运行。该定义对应于给定传输介质或接收器的特性。例如，人耳能够解码大约 0-20 KHz 频率范围内的声音。通过扩展，带宽也用于表示通信系统的容量，以比特/秒为单位。例如，千兆以太网链路理论上能够每秒传输 10 亿比特。\n鉴于不能由所有物理层使用多符号编码，因此需要一种通用解决方案，该解决方案可以与任何能够仅发送和接收比特 0 和 1 的物理层一起使用。这种通用解决方案称为填充，存在两种变体：位填充和字符填充。为了使接收器能够轻松描绘帧边界，这两种技术保留特殊位串作为帧边界标记并对帧进行编码，使这些特殊位串不会出现在帧内。\n位填充保留 01111110 位串作为帧边界标记，确保一个帧内永远不会有六个连续的1符号由物理层传输。使用比特填充，帧被发送如下。首先，发送者发送标记，即 01111110。然后，它发送帧的所有位，并在每个连续五个1位的序列之后插入一个设置为0的附加位。这确保了发送的帧永远不会包含设置为1的六个连续位的序列. 因此，标记图案不能出现在发送的帧内。标记也被发送以标记帧的结束。接收器执行相反的操作来解码接收到的帧。由于 01111110 标记，它首先检测到帧的开始。然后，它处理接收到的位并计算设置为1的连续位的数量。如果0跟在设置为1的五个连续位之后，则该位被删除，因为它是由发送者插入的。如果1后面有五个连续的位设置为1，则如果它后面跟着一个设置为0的位，则表示标记。下表说明了位填充对某些帧的应用。\n原始框架 传输帧 0001001001001001001000011 01111110000100100100100100100001101111110 0110111111111111111110010 01111110011011111011111011111011001001111110 0111110 011111100111110001111110 01111110 0111111001111101001111110 例如，考虑 0110111111111111111110010 的传输。发送者将首先发送 01111110 标记，然后发送 011011111。在这五个连续的位设置为 1 之后，它插入一个设置为0的位，后跟 11111 。插入一个新的 0，然后是 11111 。插入一个新的 0，然后是帧110010的结尾和 01111110 标记。\n分析一下表格第二行的传输帧： 原文：0110111111111111111110010 传输帧：01111110011011111011111011111011001001111110 传输帧2：01111110 0110111110111110111110110010 01111110 传输帧3：01111110 011011111 0111110111110110010 01111110 传输帧4：01111110 011011111 0 111110111110110010 01111110 传输帧5：01111110 011011111 0 11111 0 111110110010 01111110 传输帧6：01111110 011011111 0 11111 0 11111 0 110010 01111110 在每个连续五个 1 位的序列之后插入一个设置为 0 的附加位。这确保了发送的帧永远不会包含设置为1的六个连续位的序列 位填充增加了传输每帧所需的位数。位填充的最坏情况当然是在帧内将一长串位设置为1 。如果发生传输错误，填充位或标记可能出错。在这些情况下，受错误影响的帧和可能的下一帧将不会被接收器正确解码，但它能够在下一个有效标记处重新同步自身。\n位填充可以很容易地在硬件中实现。然而，鉴于在软件中执行位操作的复杂性，在软件中实现它是困难的。软件实现更喜欢处理字符而不是位，基于软件的数据链路层通常使用字符填充。该技术适用于包含整数个字符的帧。在计算机网络中，字符通常依靠 ASCII 表进行编码。该表将各种字母数字字符的编码定义为位序列。RFC 20提供了 Internet 上许多协议使用的 ASCII 表。例如，该表定义了以下二进制表示：\nA : 1000011 b 0 : 0110000 b z : 1111010 b @ : 1000000 b space : 0100000 b 此外，ASCII 表还定义了几个不可打印或控制字符。这些字符旨在允许应用程序控制打印机或终端。这些控制字符包括用于终止行的 CR 和 LF 以及使终端发出声音的 BEL 字符。\nNUL: 0000000 b BEL: 0000111 b CR : 0001101 b LF : 0001010 b DLE: 0010000 b STX: 0000010 b ETX: 0000011 b 一些字符用作标记来描绘帧边界。许多字符填充技术使用 ASCII 字符集的 DLE、STX 和 ETX 字符。DLE STX (resp. DLE ETX ) 用于标记帧的开始（结束）。发送帧时，发送方在每个发送的 DLE 字符后添加一个DLE字符。这确保没有任何标记出现在传输的帧内。接收器在接收到两个连续的DLE字符时检测帧边界并移除第二个DLE 。例如，传输帧1 2 3 DLE STX 4，发送者将首先发送DLE STX作为标记，然后发送1 2 3 DLE。然后，发送方发送一个附加的DLE字符，后跟STX 4和DLE ETX标记。\n原始框架 传输帧 1 2 3 4 DLE STX 1 2 3 4 DLE ETX 1 2 3 DLE STX 4 DLE STX 1 2 3 DLE DLE STX 4 DLE ETX DLE STX DLE ETX DLE STX DLE DLE STX DLE DLE ETX DLE ETX 字符填充与位填充一样，会增加传输帧的长度。对于字符填充，最差帧是包含许多DLE字符的帧。当发生传输错误时，接收器可能会错误地解码一帧或两帧（例如，如果错误出现在标记中）。但是，它将能够与下一个正确接收的标记重新同步。\n位填充和字符填充允许从位或字节流中恢复帧。这种成帧机制提供了比物理层更丰富的服务。通过成帧服务，可以发送和接收完整的帧。这个成帧服务也可以通过使用DATA.request和DATA.indication原语来表示。下图说明了这一点，假设假设帧包含四个有用位和一个帧，出于图形原因。\n我们现在可以在成帧机制的基础上允许主机交换包含整数位或字节的帧。一旦解决了成帧问题，我们就可以专注于设计一种允许可靠地交换帧的技术。\n从传输错误中恢复 在本节中，我们开发了一个运行在物理层服务之上的可靠数据链路协议。为了设计这个协议，我们首先假设物理层提供了完善的服务。然后，我们将开发解决方案以从传输错误中恢复。\n数据链路层旨在代表用户发送和接收帧。我们使用 DATA.req 和 DATA.ind 原语对这些交互进行建模。然而，为了简化表示并避免数据链路层实体的用户发布的 DATA.req 原语与数据链路层实体本身发布的 DATA.req 之间的混淆，我们将使用以下术语：\n用户和数据链路层实体之间的交互使用经典的 DATA.req 和 DATA.ind 原语表示 数据链路层实体和成帧子层之间的交互使用 send 代替 DATA.req 和 recvd 代替 DATA.ind 来表示 当在完美的成帧子层之上运行时，数据链路实体可以在DATA.req(SDU)[1] 到达时简单地发出 send(SDU)。类似地，接收器在收到 recvd(SDU) 时发出 DATA.ind(SDU)。当发送单个 SDU 时，这样一个简单的协议就足够了。如下图所示\n不幸的是，这并不总是足以确保 SDU 的可靠交付。考虑客户端向服务器发送数十个 SDU 的情况。如果服务器比客户端快，它将能够接收和处理客户端发送的所有帧并将其内容传递给其用户。但是，如果服务器比客户端慢，则可能会出现问题。数据链路实体包含用于存储已作为 Data.request 接收的 SDU 的缓冲区但尚未发送。如果应用程序比物理链路快，则缓冲区可能已满。此时，操作系统暂停应用程序，让数据链路实体清空其传输队列。数据链路实体还使用缓冲区来存储接收到的尚未由应用程序处理的帧。如果应用程序处理数据的速度很慢，这个缓冲区可能会溢出，数据链路实体将无法接受任何额外的帧。数据链路实体的缓冲区大小有限，如果溢出，到达的帧将被丢弃，即使它们是正确的。\n为了解决这个问题，一个可靠的协议必须包括一个反馈机制，允许接收者通知发送者它已经处理了一个帧并且可以发送另一个帧。即使没有传输错误，也需要此反馈。为了包含这样的反馈，我们可靠的协议必须处理两种类型的帧：\n携带 SDU 的数据帧 带有确认的控制帧，表明之前的帧已被正确处理 这两种类型的帧可以通过将帧分为两部分来区分：\n包含一位在数据帧中设置为0并在控制帧中设置为1的标头 包含应用程序提供的 SDU 的有效负载 然后可以将数据链路实体建模为有限状态机，其中包含接收器的两个状态和发送器的两个状态。下图提供了这个状态机的图形表示，上面是发送者，下面是接收者。\n最简单可靠协议的有限状态机（发送者在上面，接收者在下面）\n上面的 FSM 表明发送方必须等待接收方的确认才能发送下一个 SDU。下图说明了两台主机之间的几个帧的交换。\n笔记\n服务和协议\n在学习计算机网络之前要了解的一个重要方面是服务和协议之间的区别. 为此，从现实世界的例子开始很有用。传统的 Post 提供一种邮递员向收件人投递信件的服务。The Post 精确定义了使用标准邮件服务可以递送哪些类型的信件（大小、重量等）。此外，还指定了信封的格式（发件人和收件人地址的位置、邮票的位置）。想要寄信的人必须将信件放在邮局或其中一个专用邮箱内。然后将收集这封信并将其交付给最终收件人。请注意，对于常规服务，邮政通常不保证每封特定信件的递送。有些信件可能会丢失，有些信件会被送错邮箱。如果一封信很重要，然后发件人可以使用注册的服务来确保信件将交付给收件人。一些邮政服务还提供比常规服务更快的确认服务或特快专递服务。\n在不完美链路之上实现可靠的数据传输 数据链路层必须处理传输错误。在实践中，我们主要要处理数据链路层的两类错误：\n帧可能因传输错误而损坏 可能会丢失帧或出现意外帧 乍一看，在单个链接上丢失帧可能看起来很奇怪。但是，如果我们考虑成帧，传输错误会影响帧描述机制，使帧不可读。出于同样的原因，在发送者发送一个帧之后，接收者可能会收到两个（可能是无效的）帧。\n为了处理这些类型的缺陷，可靠的协议依赖于不同类型的机制。第一个问题是传输错误。物理链路上的数据传输可能会受到以下错误的影响：\n由于传输错误而修改了单个位的值的随机隔离错误 随机突发错误，其中n个连续位的值由于传输错误而改变 由于传输错误而添加或删除位的，随机位创建和随机位删除 防止传输错误的唯一解决方案是向发送的帧添加冗余。信息论定义了两种机制，可用于在受随机错误影响的传输通道上传输信息。这两种机制为传输的信息添加了冗余，以允许接收器检测或有时甚至纠正传输错误。对这些机制的详细讨论超出了本章的范围，但考虑一个简单的机制来理解其操作及其局限性是有用的。\n信息论定义了编码方案。有不同类型的编码方案，但让我们专注于对二进制字符串进行操作的编码方案。编码方案是将编码为m位字符串的信息映射到n位字符串的函数。最简单的编码方案是（偶）奇偶编码。此编码方案采用m位源字符串并生成m+1位编码字符串，其中编码字符串的前m位是源字符串的位，并且选择编码字符串的最后一位，以便编码字符串将始终包含设置为 1 的偶数位。例如 ：\n1001编码为10010 1101编码为11011 这种奇偶校验方案已用于某些 RAM 以及对通过串行线路发送的字符进行编码。很容易表明，这种编码方案允许接收器检测到单个传输错误，但无法纠正它。然而，如果两个或更多位出错，接收器可能并不总是能够检测到错误。\n一些编码方案允许接收器纠正一些传输错误。例如，考虑如下编码每个源比特的编码方案：\n1编码为111 0编码为000 例如，考虑发送 111 的发件人。如果有一位错误，接收器可能会收到 011 或 101 或110 。在这三种情况下，接收器会将接收到的位模式解码为1 ，因为它包含设置为1的大多数位。如果有两位错误，接收器将无法再从传输错误中恢复。\n这种简单的编码方案强制发送方为每个源比特传输三个比特。但是，它允许接收器纠正单位错误。允许从错误中恢复的更高级的编码系统用于多种类型的物理层。\n除了成帧之外，数据链路层还包括检测传输错误，有时甚至从传输错误中恢复的机制。为了让接收方注意到传输错误，发送方必须在发送的帧中添加一些冗余信息作为错误检测代码。此错误检测代码由发送方在其传输的帧上计算。当接收器接收到带有错误检测码的帧时，它会重新计算它并验证接收到的错误检测码是否与计算出的错误检测码匹配. 如果它们匹配，则认为该帧是有效的。存在许多错误检测方案，并且已经就该主题编写了整本书。对这些技术的详细讨论超出了本书的范围，我们将仅讨论一些示例来说明关键原则。\n为了理解错误检测代码，让我们考虑两个交换包含N位的位串的设备。为了让接收方检测传输错误，发送方将每个N位串转换为N+r位串。通常，r个冗余位被添加在传输位串的开头或结尾，但有些技术将冗余位与原始位交织在一起。错误检测代码可以定义为一个函数，它计算对应于每个 N 字符串的r个冗余位位。最简单的错误检测代码是奇偶校验位。有两种奇偶校验方案：偶校验和奇校验。使用偶数（或奇数）奇偶校验方案，选择冗余位，以便在发送的N+r位的位串中将偶数（或奇数）位设置为1。接收器可以轻松地重新计算每个接收到的比特串的奇偶校验，并丢弃具有无效奇偶校验的字符串。交换 7 位字符时经常使用奇偶校验方案。在这种情况下，第八位通常是奇偶校验位。下表显示了为包含三位的位串计算的奇偶校验位。\n奇偶校验(Parity Check)是一种校验代码传输正确性的方法。根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验。采用奇数的称为奇校验，反之，称为偶校验。 假设存储的数据用位标示为1、1、1、0、0、1、0、1，那么把每个位相加（1+1+1+0+0+1+0+1=5），结果是奇数。对于偶校验，校验位就定义为1；对于奇校验，则相反。\n3位字符串 奇校验 偶校验 000 1 0 001 0 1 010 0 1 100 0 1 111 0 1 110 1 0 101 1 0 011 1 0 观察上面示例：\n1 出现 偶数次时，奇校验指是 1\n1 出现 奇数次时，奇校验指是 0\n奇偶校验位允许接收器检测已发送的N+r位中的单个位的传输错误。如果有两个或更多位错误，则接收器可能不一定能够检测到传输错误。已经定义了更强大的错误检测方案。循环冗余校验 (CRC) 广泛用于数据链路层协议。N 位 CRC 可以检测影响传输帧中少于 N 位的突发的所有传输错误以及影响奇数位的所有传输错误。更多关于 CRC 的细节可以在Williams1993中找到。\n还可以设计一种代码，允许接收器纠正传输错误。最简单的纠错码是三重模冗余（TMR）。为了发送设置为1的位（对应0），发送方发送111（对应000）。当没有传输错误时，接收器可以将111解码为1。如果传输错误影响了单个位，则接收器执行多数表决，如下表所示。该方案允许接收器纠正影响单个比特的所有传输错误。\n接收位 解码位 000 0 001 0 010 0 100 0 111 1 110 1 101 1 011 1 已经提出了其他更强大的纠错码并在某些应用中使用。汉明码是奇偶校验位的巧妙组合，可提供错误检测和纠正功能。\n可靠协议使用错误检测方案，但广泛使用的可靠协议都不依赖纠错方案。为了检测错误，帧通常分为两部分：\n包含可靠协议使用的字段以确保可靠传递的标头。标头包含校验和或循环冗余校验 (CRC) [Williams1993]，用于检测传输错误 包含用户数据的有效负载 一些报头还包括一个长度字段，它指示帧的总长度或有效载荷的长度。\n最简单的错误检测方案是校验和。校验和基本上是组成帧的所有字节的算术和。有不同类型的校验和。例如，可以将八位校验和计算为帧（头和尾）所有字节的算术和。校验和由发送方在发送帧之前计算，接收方在接收帧时验证校验和。接收器丢弃接收到的带有无效校验和的帧。校验和可以很容易地在软件中实现，但它们的错误检测能力是有限的。循环冗余校验 (CRC) 具有更好的错误检测能力[SGP98]，但在软件中实现时需要更多 CPU。\n笔记\n校验和，CRC，…\nTCP/IP 协议族中的大多数协议都依赖于简单的 Internet 校验和，以验证接收到的数据包没有受到传输错误的影响。尽管 Internet 校验和很受欢迎且易于实施，但它并不是唯一可用的校验和机制。循环冗余校验 ( CRC ) 是非常强大的错误检测方案，主要用于磁盘、许多数据链路层协议和文件格式（例如zip或png. 它们可以很容易地在硬件中有效地实现，并且比 Internet 校验和具有更好的错误检测能力[SGP98]. 然而，CRC 有时被认为对于软件实现来说 CPU 过于密集，因此首选其他校验和机制。TCP/IP 社区选择了 Internet 校验和，OSI 社区选择了 Fletcher 校验和[Sklower89]。现在有有效的技术可以在软件中快速计算 CRC [Feldmeier95]。\n由于接收方在收到每个数据帧后都会发送确认，因此处理丢失的最简单解决方案是使用重传计时器。当发送者发送一个帧时，它会启动一个重传定时器。这个重传定时器的值应该大于往返时间，即数据帧的传输和相应确认的接收之间的延迟。当重传定时器超时时，发送方认为数据帧已经丢失并重传。如下图所示。\n不幸的是，仅重传定时器不足以从丢失中恢复。作为一个例子，让我们考虑下面描述的确认丢失的情况。在这种情况下，发送方重新发送尚未确认的数据帧。但是，如下图所示，接收方将重传视为必须将其有效载荷传递给其用户的新帧。\n为了解决这个问题，数据链路协议将序列号关联到每个数据帧。该序列号是数据帧头中的字段之一。我们使用符号D(x,…)来表示序列号字段设置为值x的数据帧。确认还包含一个序列号，指示它正在确认的数据帧。我们使用OKx来表示确认接收到D(x,…)的确认帧。序列号被编码为固定长度的位串。最简单可靠的协议是交替比特协议 (ABP)。\n交替位协议使用单个位来编码序列号。它可以很容易地实现。发送者（分别是接收者）只需要一个四态（分别是三态）有限状态机。\n交替位协议：发送方 FSM\n发送者的初始状态是等待 D(0,…)。在这种状态下，发送者等待Data.request。它发送的第一个数据帧使用序列号0。发送此帧后，发送方等待OK0确认。在重传定时器到期或收到带有不正确序列号的确认时重传帧。\n接收者首先等待D(0,…)。如果帧包含正确的CRC，它将 SDU 传递给它的用户并发送OK0。如果帧包含无效的 CRC，则立即丢弃。然后，接收方等待D(1,…)。在这种状态下，它可能会收到一个重复的D(0,…)或带有无效 CRC 的数据帧。在这两种情况下，它都会返回一个OK0帧，以允许发送方从可能丢失的前一个OK0帧中恢复。\n交替位协议：接收器 FSM\n笔记\n处理损坏的帧\n交替比特协议的接收器 FSM 丢弃所有包含无效 CRC 的帧。这是最安全的方法，因为接收到的帧可能与远程主机发送的帧完全不同。接收器不应尝试从损坏的帧中提取信息，因为它无法知道帧的哪个部分已受到错误的影响。\n下图说明了交替位协议的操作。\n交替位协议可以从数据或控制帧的丢失中恢复。这在下面的两个图中进行了说明。第一个图显示了一个数据帧的丢失。\n第二个图说明了主机如何处理一个控制帧的丢失。\n交替位协议可以从传输错误和帧丢失中恢复。然而，它有一个重要的缺点。考虑通过具有 250 毫秒传播延迟的 50 Kbits/sec 卫星链路直接连接的两台主机。如果这些主机发送 1000 比特帧，那么交替比特协议可以实现的最大吞吐量是每帧一帧。20 + 250 + 250 = 520 如果我们忽略确认的传输时间，则为毫秒。这小于 2 Kbits/sec ！\nGo-back-n 和选择性重复 为了克服交替比特协议的性能限制，可靠的协议依赖于流水线。这种技术允许发送方发送几个连续的帧，而不必在每个帧之后等待确认。每个数据帧都包含一个编码为n位字段的序列号。\n流水线允许发送方以更高的速率传输帧。然而，这种较高的传输速率可能会使接收器过载。在这种情况下，发送方发送的帧将不会被其最终目的地正确接收。依赖于流水线的可靠协议允许发送方在被迫等待接收实体的确认之前传输W个未确认的帧。\n这是通过使用滑动窗口来实现的。滑动窗口是发送方在发送帧时可以使用的一组连续序列号，而无需强制等待确认。下图显示了一个包含五个帧（6、7、8、9和10）的滑动窗口。这些序列号中的两个（6和7）已用于发送帧，只有三个序列号（8、9和10 ）保留在滑动窗口中。一旦包含在滑动窗口中的所有序列号都已被使用，则称滑动窗口关闭。\n下图说明了滑动窗口的操作。它使用三个框架的滑动窗口。因此，发送者可以在被迫等待确认之前发送三个帧。滑动窗口在收到每个确认后移动到更高的序列号。当收到第一个确认 ( OK0 ) 时，它使发送方能够将其滑动窗口向右移动，并且序列号3变为可用。此序列号稍后用于传输包含d的帧。\n实际上，由于帧头包含一个n位字段来编码序列号，因此只有0 和2^n - 1 可以使用。这意味着，在长传输期间，相同的序列号将用于不同的帧，并且滑动窗口将换行。下图说明了这一点，假设使用2位对帧头中的序列号进行编码。请注意，在收到 OK1后，发送方会滑动其窗口并可以再次使用序列号0。\n不幸的是，帧丢失并没有消失，因为可靠的协议使用滑动窗口。为了从损失中恢复，滑动窗口协议必须定义：\n检测帧丢失的启发式方法 重传丢失帧的重传策略 最简单的滑动窗口协议使用go-back-n恢复。直观地说，go-back-n 的操作如下。go-back-n接收器尽可能简单。它只接受按顺序到达的帧。go-back-n接收器丢弃它接收到的任何无序帧。当go-back-n接收到一个数据帧时，它总是返回一个确认，其中包含它接收到的最后一个有序帧的序列号。据说这种确认是累积的。当一个go-back-n接收器发送一个对序列号x的确认时，它隐式地确认所有序列号早于x的帧的接收。这些累积确认的一个关键优势是很容易从确认丢失中恢复。例如，考虑接收帧1、2和3的返回 n接收器。它发送了OK1、OK2和OK3。不幸的是，OK1和OK2丢失了。由于累积确认，当发送方收到OK3时，它知道所有三个帧都已正确接收。\n下图显示了一个简单的go-back-n接收器的 FSM。该接收器使用两个变量：lastack和next。next是下一个预期的序列号，而lastack是已确认的最后一个数据帧的序列号。接收方只接受按顺序接收的帧。maxseq是不同序列号的数量（）。\ngo-back-n 发件人也很简单。它使用可以存储帧的整个滑动窗口的发送缓冲区[2]。帧以递增的序列号（模maxseq）发送。一旦发送缓冲区已满，发送者必须等待确认。当go-back-n发送方接收到确认时，它会从发送缓冲区中删除所有确认的帧，并使用重传计时器来检测帧丢失。一个简单的 go-back-n发送者为每个连接维护一个重传计时器。该定时器在发送第一帧时启动。当go-back-n 发件人收到确认后，仅当其发送缓冲区中仍有未确认的帧时，它才重新启动重传计时器。当重传计时器到期时，返回-n发送方假定当前存储在其发送缓冲区中的所有未确认帧都已丢失。因此，它重传缓冲区中所有未确认的帧并重新启动其重传计时器。\ngo-back-n 的操作如下图所示。在该图中，请注意，在接收到失序帧D(2,c)时，接收器返回一个累积确认C(OK,0)，它确认已按顺序接收到的所有帧。丢失的帧在重传定时器到期时被重传。\ngo-back-n 的主要优点是可以很容易地实现，并且在只有几帧丢失的情况下也能提供很好的性能。但是，当损失很多时，go-back-n 的性能会迅速下降，原因有两个：\ngo-back-n 接收器不接受乱序帧 go-back-n 发送方在检测到丢失后重新传输所有未确认的帧 选择性重复是从损失中恢复的更好策略。直观地说，选择性重复允许接收器接受失序帧。此外，当选择性重复发送端检测到丢失时，它只重传已经丢失的帧，而不重传已经正确接收的帧。\n选择性重复接收器维护W帧的滑动窗口，并将其接收到的无序帧存储在缓冲区中。下图显示了已经接收到帧7和9的接收器上的五帧接收窗口。\n选择性重复接收器丢弃所有具有无效 CRC 的帧，并保持变量 lastack 作为它接收到的最后一个按序帧的序列号。接收方总是在它发送的确认中包含 lastack 的值。一些协议还允许选择性重复接收器确认它已接收到的失序帧。例如，这可以通过将正确接收但无序帧的列表与 lastack 值一起放在确认中来完成。\n选择性重复接收端接收到数据帧时，首先验证数据帧是否在其接收窗口内。 如果是，则将帧放入接收缓冲区。如果不是，则丢弃接收到的帧，并向发送方发送包含 lastack 的确认。然后，接收器从接收缓冲区中删除从 lastack 开始的所有连续帧（如果有的话）。这些帧的有效载荷被传递给用户，更新 lastack 和接收窗口，并发送确认按顺序接收到的最后一个帧的确认。\n选择性重复发送器维护一个发送缓冲区，最多可以存储W个未确认的帧。只要发送缓冲区未满，就会发送这些帧。选择性重复发送器的几种实现方式是可能的。一个简单的实现将一个重传定时器与每一帧相关联。发送帧时启动定时器，并在接收到覆盖该帧的确认时取消定时器。当重传定时器超时时，相应的帧被重传并且这个重传定时器被重新启动。当接收到确认时，所有被此确认覆盖的帧都从发送缓冲区中删除，并更新滑动窗口。\n下图说明了丢帧时选择性重复的操作。在该图中，C(OK,x)用于指示所有帧，包括序列号x都已正确接收。\n纯累积确认适用于go-back-n策略。然而，仅通过累积确认，选择性重复发送方无法轻易确定在数据帧丢失后哪些帧已正确接收。例如，在上图中，第二个C(OK,0)没有明确通知发送方接收到D(2,c)，发送方可以重新发送该帧，尽管它已经收到。提高选择性重复性能的可能解决方案是在接收方返回的确认中提供有关接收到的帧的附加信息。例如，接收方可以在返回的确认中添加已经接收到的所有帧的序列号列表。这种确认有时称为选择性确认。如上图所示。\n在上图中，当发送方接收到C(OK,0,[2])时，它知道直到并包括D(0,…)的所有帧都已正确接收。它还知道已经接收到帧D(2,…) ，并且可以取消与该帧关联的重传计时器。但是，在接收到覆盖该帧的累积确认（上图中的C(OK,2)）之前，不应从发送缓冲区中删除该帧。\n笔记\ngo-back-n 和选择性重复的最大窗口大小\n使用 n 位对其序列号进行编码的可靠协议最多可以发送 2^n 连续的帧。但是，为了确保可靠地传递帧，返回 n 和选择性重复不能使用发送窗口 2^n 帧。首先考虑 go-back-n 并假设发送者发送 2^n 帧。这些帧由目的地按顺序接收，但所有返回的确认都丢失了。发送方将重新传输所有帧。这些帧都将被接收者接受并再次发送给用户。很容易看出，如果发送窗口的最大尺寸为 2^n - 1 帧。选择性重复也会出现类似的问题。然而，当接收方接受失序帧时，发送窗口为 2^n - 1 帧不足以确保可靠的交付。很容易证明，为了避免这个问题，选择性重复发送者不能使用大于 2^n / 2 帧。\n可靠的协议通常需要双向发送数据。为了减少由确认引起的开销，大多数可靠的协议都使用捎带。多亏了这种技术，数据链路实体可以将它为数据流的相反方向通告的确认和接收窗口放置在它发送的数据帧的标头内。捎带的主要优点是它减少了开销，因为不需要发送完整的帧来携带确认。下图说明了这一点，其中确认号在数据帧中带有下划线。仅当数据双向流动时才使用捎带。如图底部所示，当接收方不向相反方向发送数据时，接收方将生成纯确认。\n[1] SDU 是服务数据单元的首字母缩写。我们用它作为一个通用术语来表示协议传输的数据。\n[2] 对于给定的协议，滑动窗口的大小可以是固定的，也可以在连接建立阶段协商。一些协议允许在数据传输期间更改最大窗口大小。稍后我们将使用真实的协议来解释这些技术。\n"},{"id":182,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%8E%9F%E5%88%99-2-%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%BB%9C/","title":"计算机网络：原理、协议和实践，第三版 第 1 部分：原则 2 建立网络","parent":"计算机网络：原理、协议和实践，第三版","content":" 计算机网络：原理、协议和实践，第三版 转自：Computer Networking : Principles, Protocols and Practice, third edition\n链接：https://beta.computer-networking.info/syllabus/default/index.html\n第 1 部分：原则 构建网络 数据报组织 计算转发表 平面或分层地址 处理异构数据链层 虚拟线路组织 控制平面 距离矢量路由 链路状态路由 构建网络 在上一节中，我们已经解释了可靠协议如何允许主机可靠地交换数据，即使底层物理层不完善并因此不可靠。通过电线将两台主机连接在一起是构建网络的第一步。然而，这还不够。主机通常需要与其他不通过直接物理层链路直接连接的主机进行交互。这可以通过在数据链路层之上添加一层来实现：网络层。\n网络层\n网络层的主要目标是:允许连接到不同网络的主机通过称为路由器的中间系统交换信息。网络层的信息单位称为数据包。\n在解释网络层的操作之前，记住数据链路层提供的服务的特性是很有用的。数据链路层有许多变体。有些提供可靠的服务，而有些则不提供任何交付保证。可靠的数据链路层服务在传输错误频繁的无线网络等环境中很受欢迎。另一方面，当物理层提供几乎可靠的服务时，通常使用不可靠的服务（即只有极少部分的帧受到传输错误的影响）。这种几乎可靠的服务经常用于有线和光网络。在本章中，我们将假设数据链路层服务提供了一个几乎可靠的服务，因为这既是最通用的服务，也是部署最广泛的服务。\n有两种主要类型的数据链路层。最简单的数据链路层是当只有两个通信系统通过物理层直接连接时。当两个通信系统之间存在点对点链路时，使用这种数据链路层。这两个系统可以是主机或路由器。PPP（点对点协议），定义在RFC 1661 是这种点对点数据链路层的示例。数据链路层实体交换帧。左侧数据链路层实体发送的数据链路帧通过物理层传输，可以到达右侧数据链路层实体。点对点数据链路层既可以提供不可靠的服务（帧可能损坏或丢失），也可以提供可靠的服务（在这种情况下，数据链路层包括重传机制）。\n第二种类型的数据链路层是在局域网 (LAN) 中使用的层。从概念上讲，LAN 是一组通信设备，因此任何两个设备都可以通过数据链路层直接交换帧。主机和路由器都可以连接到 LAN。有的局域网只连接几个设备，但也有可以连接成百上千台设备的局域网。在本章中，我们关注点对点数据链路层的利用。我们稍后将描述局域网的组织和操作以及它们对网络层的影响。\n即使我们只考虑点对点数据链路层，这些层也有一个我们不能忽视的重要特征。没有数据链路层能够发送无限大小的帧。每个数据链路层都有一个最大帧大小。有十多个不同的数据链路层，不幸的是，它们中的大多数使用不同的最大帧大小。当我们需要在连接到不同类型数据链路层的主机之间交换数据时，最大帧大小的这种异质性会导致问题。\n作为第一步，让我们假设我们只需要交换少量数据。在这种情况下，帧的最大长度没有问题。但是，还有其他更有趣的问题需要我们解决。为了理解这些问题，让我们考虑下图中表示的网络。\n该网络包含两种类型的设备。主机用圆圈表示，路由器用方框表示。主机是一种能够发送和接收数据以供自己使用的设备，而路由器在大多数情况下只是将数据转发到其最终目的地。路由器有多个链接到相邻的路由器或主机。主机通常通过单个链接连接到网络。如今，随着无线网络的发展，越来越多的主机配备了多个物理接口。这些主机通常称为多宿主。尽管如此，同时使用多个接口通常会导致超出本文档范围的实际问题。出于这个原因，我们在这本电子书中只考虑单宿主主机。\n要了解网络操作背后的关键原理，让我们分析一下需要执行的所有操作，以允许上述网络中的主机 A 向主机 B 发送一个字节。由于在 A-R1 链路之上使用了数据链路层，主机 A 可以轻松地在一个帧内向路由器 R1 发送一个字节。然而，在接收到这个帧后，路由器 R1 需要知道这个字节是发往主机 B 而不是它自己的。这是网络层的目标。\n网络层使不通过中间路由器直接连接的主机之间能够传输信息。这种传输是通过将要传输的信息放入称为数据包的数据结构中来执行的。作为包含有用数据和控制信息的帧，数据包还包含用户提供的数据和控制信息。网络层的一个重要问题是：识别网络内部节点（主机或路由器）的能力。该识别是通过将地址与每个节点相关联来执行的。地址_通常表示为一个比特序列。大多数网络使用固定长度的地址。在这个阶段，让我们简单地假设上述网络中的每个节点都有一个地址，该地址对应于图中其名称的二进制表示。\n为了向主机 B 发送一个字节的信息，主机 A 需要将该信息放入一个数据包中。除了正在传输的数据之外，数据包还包含源节点和目标节点的地址，或者指示到达目标需要遵循的路径的信息。\n网络层有两种可能的组织：\n数据报 虚电路 数据报组织 网络层的第一个也是最流行的组织是数据报组织。该组织的灵感来自邮政服务的组织。每个主机都由一个网络层地址标识。要将信息发送到远程主机，主机会创建一个数据包，其中包含：\n目的主机的网络层地址 自己的网络层地址 要发送的信息 为了理解数据报的组织，让我们考虑下图。一个由字母表示的网络层地址已分配给每个主机和路由器。为了向主机J发送一些信息，主机A创建一个包含它自己的地址、目标地址和要交换的信息的数据包。\n通过数据报组织，路由器使用逐跳转发。这意味着当路由器接收到一个不是发往自己的数据包时，它会在其转发表中查找该数据包的目标地址。转发表是一种数据结构，它将每个目标地址（或一组目标地址）映射到传出接口，发往该地址的数据包必须通过该传出接口转发以到达其最终目标。路由器查询其转发表来转发它处理的每个数据包。\n该图说明了该网络中一些可能的转发表。通过检查不同路由器的转发表，可以找到从源发送到特定目的地的数据包所遵循的路径。在上面的示例中，主机A将其数据包发送到路由器R1。R1查阅其转发表并将数据包转发给R2。根据自己的表，R2决定将数据包转发给R5，R5 可以将其传递到其目的地。因此，从 A 到 J 的路径是 A -\u0026gt; R1 -\u0026gt; R2 -\u0026gt; R5 -\u0026gt; J。\n网络内所有路由器的转发表的计算是网络正确运行的关键要素。该计算可以通过使用分布式或集中式算法来执行。这些算法提供不同的性能，可能导致不同类型的路径，但它们的组合必须导致有效路径。\n在网络中，路径可以定义为给定 源目标对 的所有中间路由器的列表。对于给定的 源/目标对，可以通过首先查询连接到源的路由器的转发表来确定路径上通往所选目标的下一个路由器，从而得出路径。然后，查询该路由器的转发表是否有相同的目的地……查询将继续，直到到达目的地。在具有有效转发表的网络中，所有源/目标对之间的所有路径都包含有限数量的中间路由器。但是，如果未正确计算转发表，则可能会出现两种类型的无效路径。\n一条路径可能导致一个黑洞。在网络中，黑洞是一种路由器，它接收至少一个给定源/目标对的数据包，但在其转发表中没有针对该目标的条目。由于不知道如何到达目的地，路由器无法转发接收到的数据包，必须丢弃它们。任何计算转发表的集中式或分布式算法都必须确保网络内部没有黑洞。\n第二类问题可能存在于使用数据报组织的网络中。考虑包含循环的路径。例如，路由器 R1 通过路由器 R2 将所有数据包发送到目的地 D。路由器 R2 将这些数据包转发到路由器 R3 ，最后路由器 R3 的转发表使用路由器 R1 作为其到达目的地 D 的下一跳。在这种情况下，如果路由器 R1 接收到发往 D 的数据包，它将在 R1 -\u0026gt; R2 -\u0026gt; R3 -\u0026gt; R1 上循环循环，永远不会到达最终目的地。与黑洞的情况一样，网络中的所有源都无法到达目的地。实际上，环路问题比黑洞问题更令人讨厌，因为当数据包陷入转发环路时，它会不必要地消耗带宽。在黑洞的情况下，有问题的数据包被迅速丢弃。稍后我们将看到网络层协议包括将此类转发循环的影响降至最低的技术。\n任何用于计算网络转发表的解决方案都必须确保所有目的地都可以从任何来源到达。这意味着它必须保证没有黑洞和转发循环。\n在网络内部交换的数据包的转发表和精确格式是网络数据平面的一部分。此数据平面包含主机和路由器用于创建和处理包含用户数据的数据包的所有协议和算法。在高端路由器上，出于性能原因，数据平面通常在硬件中实现。\n除数据平面外，网络的特征还在于其控制平面。控制平面包括计算转发表的所有协议和算法（通常是分布式的），这些转发表安装在网络内的所有路由器上。虽然对于给定的网络技术只有一个可能的数据平面，但使用相同技术的不同网络可能使用不同的控制平面。\n网络最简单的控制平面是手动计算网络内所有路由器的转发表。当网络（非常）小，通常最多几个路由器时，这个简单的控制平面就足够了。\n在大多数网络中，手动转发表不是解决方案，原因有两个。首先，大多数网络太大而无法手动计算转发表。其次，使用手动计算的转发表，很难处理链路和路由器故障。网络需要每年 365 天、每天 24 小时运行。许多事件会影响组成网络的路由器和链路。链路故障是已部署网络中的常规事件。链路可能因各种原因而失败，包括电磁干扰、光纤切断、终止路由器上的硬件或软件问题……有些链路还需要添加到网络中或从网络中删除，因为它们的利用率太低或成本太高.\n同样，路由器也会失败。有两种类型的故障会影响路由器。由于硬件或软件问题（例如，由于其操作系统崩溃），路由器可能会停止转发数据包。路由器可能还需要不时停止（例如，升级其操作系统或安装新的接口卡）。这些计划内和计划外事件会影响可用于在网络中转发数据包的一组链路和路由器。尽管如此，大多数网络用户仍希望他们的网络将继续正确转发数据包，尽管发生了所有这些事件。使用手动计算的转发表，通常不可能在考虑所有可能的故障情况的同时预先计算转发表。\n手动计算转发表的替代方法是使用网络管理平台，该平台跟踪网络状态，并在检测到对网络拓扑的任何修改时将新的转发表推送到路由器上。该解决方案为网络管理员在计算其网络内的路径时提供了一些灵活性。但是，该解决方案仅在网络管理平台始终能够到达所有路由器的情况下才有效，即使网络拓扑发生变化。这可能需要一个允许管理平台在转发表上推送信息的专用网络。Openflow 是此类解决方案的现代示例MAB2008. 简而言之，Openflow 是一种协议，它使网络控制器能够在远程路由器的转发表中安装特定条目等等。\n另一个值得讨论的有趣点是何时计算转发表。一种广泛使用的解决方案是计算所有路由器上所有目的地的转发表条目。这确保了每个路由器都有一条通往每个目的地的有效路由。当事件发生并且网络拓扑发生变化时，可以更新这些条目。这种方法的一个缺点是转发表在大型网络中可能会变得很大，因为每个路由器必须始终在其转发表中为每个目的地维护一个条目。\n一些网络使用数据包的到达作为触发器来计算转发表中的相应条目。一些技术已经建立在这个原则之上。当数据包到达时，路由器会查询其转发表以找到通往目的地的路径。如果目标存在于转发表中，则转发数据包。否则，路由器需要找到一种方法来转发数据包并更新其转发表。\n计算转发表 网络部署了多种技术来在数据包到达时更新转发表。在本节中，我们将简要介绍其中三种技术的基本原理。\n第一种技术假设底层网络拓扑是一棵树。树是转发数据包时要考虑的最简单的网络。使用树的主要优点是网络内任何一对节点之间只有一条路径。由于一棵树不包含任何循环，因此在树形网络中不可能有转发循环。\n在树形网络中，每个节点通过检查其接收到的数据包来自动计算其转发表是相对简单的。为此，每个节点都使用每个数据包中存在的源地址和目标地址。由于源地址，节点可以了解网络内不同源的位置。每个来源都有一个唯一的地址。当一个节点通过给定接口接收到一个数据包时，它会知道这个数据包的源（地址）可以通过这个接口到达。该节点维护一个将每个已知源地址映射到传入接口的数据结构。这种数据结构通常称为端口地址表，因为它指示接口（或端口）到达给定地址。\n仅了解源的位置是不够的，节点还需要将数据包转发到它们的目的地。当一个节点收到一个目标地址已经存在于其端口地址表中的数据包时，它只是在端口地址表中列出的接口上转发该数据包。在这种情况下，数据包将遵循下游节点中的端口地址表条目并到达目的地。如果目的地址不包括在端口地址表中，则节点仅在其所有接口上转发数据包，但接收数据包的接口除外。通过所有接口转发数据包通常称为广播在计算机网络的术语中。通过除一个以外的所有接口发送数据包是一项昂贵的操作，因为数据包是通过未到达目的地的链路发送的。给定网络的树形，数据包将探索树的所有下游分支并最终到达目的地。在实践中，广播操作不会经常发生，其性能影响仍然有限。\n为了理解端口地址表的操作，让我们考虑下图所示的示例网络。该网络包含三台主机：A、B和C，以及五台路由器，R1到R5。当网络启动时，所有节点的转发表都是空的。\n主机A向B发送一个数据包。当接收到这个数据包时，R1得知A可以通过它的West接口到达。由于它的端口地址表中没有目的地B的条目，因此它将数据包转发到R2和R3。当R2收到数据包时，它会更新自己的转发表并将数据包转发给C。由于C不是预期的接收者，它只是丢弃接收到的数据包。路由器R3也接收该数据包。它知道A可以通过它的西北到达接口并将数据包广播到R4和R5。R5还更新其转发表并最终将其转发到目的地B。现在让我们考虑当B向A发送回复时会发生什么。R5 首先得知B连接到其东北端口。然后它查阅其端口地址表并发现A可通过其西北接口到达。然后，该数据包被逐跳转发到A，而不进行任何广播。稍后，如果C向B发送一个数据包，该数据包将到达在其转发表中包含有效转发表项的R1 。\n通过检查数据包的源地址和目的地址，网络节点可以自动导出它们的转发表。正如我们稍后将讨论的，这种技术用于以太网。尽管被广泛使用，但它有两个重要的缺点。首先，即使目的地没有连接到网络，发送到未知目的地的数据包也会在网络中广播。考虑上述网络中以Z为目的地的十个数据包的传输。当一个节点接收到一个发往该目的地的数据包时，它只能广播该数据包。由于Z没有连接到网络，因此没有节点会收到源为Z的数据包更新其转发表。第二个也是更重要的问题是很少有网络具有树形拓扑。分析在包含循环的网络中使用端口地址表时会发生什么是很有趣的。考虑下面显示的具有单个主机的简单网络。\n假设网络已经启动并且所有的端口地址和转发表都是空的。主机A向B发送一个数据包。收到此数据包后，R1会更新其端口地址表。由于B不在端口地址表中，因此该数据包被广播。R2和R3都收到A发送的数据包的副本。他们都更新了他们的端口地址表。不幸的是，它们也都广播了接收到的数据包。B收到数据包的第一个副本，但R3和R2再次收到它。然后R3将这个数据包的副本广播给B和R1而R2将其副本广播到R1。虽然B已经收到了两份数据包，但它仍然在网络内部并继续循环。由于循环的存在，发往未知目的地的单个数据包会生成该数据包的许多副本，这些副本会循环并最终使网络饱和。使用端口地址表自动计算转发表的网络运营商也使用分布式算法来确保网络拓扑始终是一棵树。\n另一种称为源路由的技术可用于自动计算转发表。它已用于互连令牌环网络和一些无线网络。直观地说，源路由使目的地能够自动发现从给定源到自身的路径。这种技术需要节点在一些数据包内编码信息。为简单起见，让我们假设数据平面支持两种类型的数据包：\n数据包 控制包 数据包用于交换数据，而控制包用于发现主机之间的路径。使用源路由，可以使路由器尽可能简单，并将所有复杂性放在主机上。这与以前的技术形成对比，在以前的技术中，节点必须维护一个端口地址和一个转发表，而主机只是发送和接收数据包。每个节点都配置有一个唯一地址，并且每个传出链路都有一个标识符。为简单起见并避免将这些标识符与数字混淆，我们假设每个节点都使用北、西、南…\n在上面的网络中，路由器R2连接到两个传出链路。R2连接到R1和R3。通过与这两个节点交换数据包或观察它通过每个接口接收的数据包，R2可以很容易地确定它连接到这两个节点。例如，假设当一个节点（主机或路由器）启动时，它会通过其每个接口发送一个特殊的控制数据包，以将其自己的地址通告给它的邻居。当一个节点收到这样的数据包时，它会自动回复它自己的地址。此交换还可用于验证邻居（路由器或主机）是否仍然存在。使用源路由，数据平面数据包包括标识符列表。该列表称为源路由。它以链路标识符序列的形式指示数据包要遵循的路径。当节点接收到这样的数据平面数据包时，它首先检查数据包的目的地是否是直接邻居。在这种情况下，数据包被转发到这个邻居。否则，节点从列表中提取下一个地址并将其转发给邻居。这允许源为每个数据包指定要遵循的显式路径。例如，在上图中，A和B之间有两条可能的路径。要使用通过R2的路径，A将发送一个包含R1,R2,R3的数据包作为源路线。为了避免通过R2，A会将R1,R3作为其传输数据包中的源路由。如果A知道完整的网络拓扑和所有链路标识符，它就可以轻松地计算到每个目的地的源路由。它甚至可以使用不同的路径（例如为了冗余）到达给定的目的地。然而，在真实网络中的主机通常没有整个网络拓扑图。\n在依赖源路由的网络中，主机使用控制数据包自动发现最佳路径。除了源地址和目的地址之外，控制数据包还包含一个记录中间节点的列表。该列表通常称为记录路由，因为它允许记录给定数据包所遵循的路由。当一个节点收到这样一个控制包时，它首先检查它的地址是否包含在记录路由中。如果是，则该数据包已被该节点转发，并被静默丢弃。否则，它将自己的地址添加到记录路由并将数据包转发到它的所有接口，除了接收数据包的接口。多亏了这一点，控制包可以探索源和给定目的地之间的所有路径。\n例如，再次考虑上面的网络拓扑。A向B发送控制数据包。初始记录路径为空。当R1收到数据包时，它会将自己的地址添加到记录路由中，并将副本转发给R2，将另一个副本转发给R3。R2收到数据包，将自己添加到记录路由并将其转发给R3。R3接收到数据包的两个副本。第一个包含[R1,R2] 记录路由和第二个[R1]。最后，B将接收两个包含 [R1,R2,R3,R4]和[R1,R3,R4]的控制数据包作为记录路由。B可以保留这两条路径，或者选择最好的一条并丢弃第二条。一种流行的启发式方法是选择第一个接收到的数据包的记录路由作为最佳路由，因为这可能对应于最短延迟路径。\n有了收到的记录路由，B就可以向A发送一个数据包。为此，它只是反转所选的记录路线。但是，我们仍然需要将选择的路径传达给A。这可以通过将记录路由放入控制数据包中来完成，该控制数据包通过反向路径发送回A。另一种方法是简单地将数据包发送回A。该数据包将返回A。为了让A检查数据包所遵循的整个路径，它的源路由当A接收到它时，它必须包含所有中间路由器。这可以通过使用包含索引和有序节点地址列表的数据结构对源路由进行编码来实现。索引总是指向源路由中的下一个地址。它在每个中间节点创建和递增数据包时初始化为0 。\n计算转发表的第三种技术是依靠使用分布式算法的控制平面。路由器交换控制消息以发现网络拓扑并基于它们构建转发表。我们将在本节后面对此类分布式算法进行更详细的描述。\n平面或分层地址 关于依赖数据报模式的网络的数据平面，最后但重要的一点是它们的寻址方案。在上面的示例中，我们使用字母来表示主机和网络节点的地址。实际上，所有地址都被编码为位串。大多数网络技术使用固定大小的位串来表示源地址和目标地址。这些地址可以以两种不同的方式组织。\n第一个组织，也是我们迄今为止隐含假设的组织，是平面寻址方案。在这种方案下，每个主机和网络节点都有一个唯一的地址。地址的唯一性对于网络的运行很重要。如果两台主机具有相同的地址，网络将很难将数据包转发到该目的地。平面地址通常用于网络节点和主机需要能够立即与唯一地址通信的情况。这些平面地址通常嵌入在网络接口卡中。网卡制造商为每个接口创建一个唯一的地址，该地址存储在接口的只读存储器中。这种寻址方案的一个优点是它很容易支持非结构化和移动网络。当主机移动时，它可以连接到另一个网络，并确信其地址是唯一的，并使其能够在新网络内进行通信。\n使用平面寻址，转发表中的查找操作可以实现为精确匹配。转发表包含所有已知目标地址的（排序的）列表。当一个数据包到达时，网络节点只需要检查这个地址是否包含在转发表中。在软件中，如果列表已排序，这是一个O(log(n))操作。在硬件中，内容可寻址存储器 (Content Addressable Memories)可以有效地执行这种查找操作，但它们的大小通常是有限的。\n平面寻址方案的缺点是转发表随着网络中主机和路由器的数量线性增长。使用此寻址方案，每个转发表必须包含一个条目，该条目指向网络内部可到达的每个地址。由于大型网络可能包含数千万甚至更多的主机，这对于需要能够快速转发数据包的路由器来说是一个主要问题。作为说明，考虑以 10 Gbps 运行的接口的情况很有趣。如今，在高端服务器和各种路由器中都可以找到此类接口。假设数据包大小为 1000 位，这是一个相当大且保守的数字，这样的接口每秒必须转发一千万个数据包。这意味着通过此类链路接收数据包的路由器必须每 100 纳秒转发一个 1000 位的数据包。\n一种广泛使用的平面寻址方案的替代方案是分层寻址方案。这种寻址方案建立在网络通常包含比路由器多得多的主机这一事实的基础上。在这种情况下，减少转发表大小的第一个解决方案是创建地址层次结构。这是邮局选择的解决方案，因为邮政地址包含国家（有时是州或省）、城市、街道，最后是门牌号。当一个信封被异地的邮局转寄时，它只看目的地国家，而同省的邮局会看城市信息。只有负责给定城市的邮局才会查看街道名称，并且只有邮递员会使用街道号码。分层地址为网络地址提供了类似的解决方案。例如，连接到校园网络的 Internet 主机的地址可以在高阶位中包含为校园网络提供服务的 Internet 服务提供商 (ISP) 的标识。然后，随后的位块标识校园网，它是 ISP 的客户之一。最后，地址的低位标识校园网中的主机。\n这种分层的地址分配可以应用于任何类型的网络。实际上，地址的分配必须遵循网络拓扑。通常，这是通过将寻址空间划分为连续的块，然后将这些块分配给网络的不同部分来实现的。在小型网络中，最简单的解决方案是为每个网络节点分配一个地址块，并从所连接的节点分配主机地址。\n在上图中，假设网络使用 16 位地址，并且前缀 01001010 已分配给整个网络。由于网络包含四个路由器，网络运营商可以为每个路由器分配一组 64 个地址。R1 将使用地址 0100101000000000 而 A 可以使用地址 0100101000000001。可以为 R2 分配从 0100101001000000 到 0100101001111111 的所有地址。R4 然后可以使用 0100101011000000 并将 0100101011000001 分配给 B . 其他分配方案也是可能的。例如，可以为 R3 分配比 R2 更大的地址块，并且 R4 可以使用 R3 的地址块中的子块。\n类型 描述 R1 0100101000000000 A 0100101000000001 R2 0100101001000000 R2 0100101001111111 R4 0100101011000000 B 0100101011000001 分层地址的主要优点是可以显着减小转发表的大小。在许多网络中，路由器的数量可能比主机的数量少几个数量级。一个校园网可能包含十几台路由器和几千台主机。最大的 Internet 服务提供商通常包含不超过几万个路由器，但仍为数千万或数亿主机提供服务。\n尽管它们很受欢迎，但分层地址有一些缺点。他们的第一个缺点是转发表中的查找比使用平面地址时更复杂. 例如，在互联网上，网络节点必须执行最长匹配来转发每个数据包。这通过转发表大小的减少得到部分补偿，但是查找操作的额外复杂性一直是实现数据包转发的硬件支持的困难。使用分层地址的第二个缺点是当主机第一次连接到网络时，它必须联系一个路由器以确定它自己的地址。这需要在主机和一些路由器之间进行一些数据包交换。此外，如果主机移动并连接到另一台路由器，其网络地址也会发生变化。这可能是某些移动主机的问题。\n处理异构数据链路层 有时，网络层需要处理异构数据链路层。例如，连接到不同数据链路层的两台主机通过使用其他类型数据链路层的路由器交换数据包。多亏了网络层，这种数据包交换是可能的，前提是每个数据包在传输之前都可以放在数据链路层帧中。如果所有数据链路层都支持相同的帧大小，这很简单。当一个节点收到一个帧时，它解封装它包含的数据包，检查报头并将它转发，封装在另一个帧中，到传出接口。不幸的是，封装操作并不总是可行的。每个数据链路层都以其支持的最大帧大小为特征。数据链路层通常支持最多包含数百或数千字节的帧。给定数据链路层支持的最大帧大小取决于其底层技术。不幸的是，大多数数据链路层支持不同的最大帧大小。这意味着当主机将帧内的大数据包发送到其下一跳路由器时，存在该数据包必须穿越无法在单个帧内转发数据包的链路的风险。原则上，存在三种可能来解决这个问题。为了讨论它们，我们考虑一个简单的场景，其中两台主机连接到路由器，如下图所示。这意味着当主机将帧内的大数据包发送到其下一跳路由器时，存在该数据包必须穿越无法在单个帧内转发数据包的链路的风险。原则上，存在三种可能来解决这个问题。为了讨论它们，我们考虑一个简单的场景，其中两台主机连接到路由器，如下图所示。这意味着当主机将帧内的大数据包发送到其下一跳路由器时，存在该数据包必须穿越无法在单个帧内转发数据包的链路的风险。原则上，存在三种可能来解决这个问题。为了讨论它们，我们考虑一个简单的场景，其中两台主机连接到路由器，如下图所示。\n考虑在上面的网络中，主机 A 想要通过路由器 R1 向主机 B 发送一个 900 字节的数据包（870 字节的有效载荷和 30 字节的标头）。主机A将此数据包封装在一个帧中。该帧由提取数据包的路由器R1接收。路由器R1有三个可能的选项来处理此数据包。\n数据包太大，路由器R1无法将其转发到路由器R2。它拒绝数据包并将控制数据包发送回源（主机A）以指示它不能转发长度超过 500 字节（减去数据包标头）的数据包。源可以通过在较小的数据包中重新传输信息来对此控制数据包做出反应。 网络层能够对数据包进行分段。在我们的示例中，路由器可以将数据包分成两部分。第一部分包含有效载荷的开头，第二部分包含结尾。有两种可能的方法来执行此分段。 路由器R1将数据包分成两个片段，然后将它们传输到路由器R2。路由器R2将两个数据包片段重新组装成一个更大的数据包，然后在链路上将它们传输到主机B。 每个数据包片段都是一个有效的数据包，其中包含带有源（主机A）和目标（主机B）地址的标头。当路由器R2收到数据包片段时，它将此数据包视为常规数据包并将其转发到最终目的地（主机B）。主机B重新组装接收到的片段。 这三种解决方案各有优缺点。使用第一种解决方案，路由器仍然很简单，不需要执行任何分片操作。当路由器主要以硬件实现时，这一点很重要。然而，主机必须是复杂的，因为如果它们需要通过不支持大数据包的链路，它们需要存储它们产生的数据包。这会增加主机所需的缓冲。\n此外，单个大数据包可能需要多次重传。例如，考虑一个与上图类似但有四个路由器的网络。假设链路 R1-\u0026gt;R2 支持 1000 字节数据包，链路 R2-\u0026gt;R3 支持 800 字节数据包，链路 R3-\u0026gt;R4 支持 600 字节数据包。连接到 R1 的发送大数据包的主机必须首先尝试 1000 字节，然后是 800 字节，最后是 600 字节。幸运的是，这种情况在实践中并不经常发生，这就是为什么在实际网络中使用该解决方案的原因。\n以每个链路为基础对数据包进行分段，如第二种解决方案所示，可以最大限度地减少传输开销，因为数据包仅在需要分段的链路上进行分段。大数据包可以继续在仅接受小数据包的链路的下游使用。然而，这种开销的减少带来了两个缺点。首先，分段数据包（可能在所有链路上）会增加路由器的处理时间和缓冲区要求。其次，此解决方案会导致更长的端到端延迟，因为下游路由器必须在转发数据包之前重新组装所有数据包片段。\n最后一个解决方案是其他两个之间的折衷方案。路由器需要执行分片，但不需要重新组装数据包片段。只有主机需要有缓冲区来重组接收到的片段。该解决方案具有较低的端到端延迟，并且需要较少的路由器处理时间和内存。\n上面提出的分段问题的第一个解决方案建议使用控制数据包来通知源接收到一个太长的数据包。这只是网络层控制协议执行的功能之一。其他功能包括：\n如果路由器收到的数据包在其转发表中没有有效条目，则将控制数据包发送回源 如果路由器检测到数据包在网络内部循环，则将控制数据包发送回源 验证数据包是否可以到达给定的目的地 当我们描述在 TCP/IP 协议族的网络层中使用的协议时，我们将更详细地讨论这些功能。\n虚电路组织 网络层的第二种组织方式，称为虚电路, 受到电话网络组织的启发。电话网络被设计用来承载通常持续几分钟的电话呼叫。每部电话都由电话号码标识，并连接到电话交换机。要发起电话呼叫，电话首先需要将目的地的电话号码发送到其本地交换机。该交换机与网络中的其他交换机协作，通过网络在两部电话之间创建双向通道。该信道将在通话期间由两部电话使用，并在通话结束时释放。直到 1960 年代，这些频道中的大部分都是由电话接线员根据呼叫者的要求手动创建的。今天的电话网络使用自动交换机并允许在同一物理链路上传输多个信道，\n在使用虚电路的网络中，所有的主机也用一个网络层地址来标识。然而，数据包转发并不是通过查看每个数据包的目的地地址来执行的。采用虚电路组织，每个数据包包含一个标签[1]。标签是一个整数，它是数据包标头的一部分。路由器实现标签交换来转发带标签的数据包。收到数据包后，路由器会查询其标签转发表以找到该数据包的传出接口。与数据报模式相比，这种查找非常简单。标签转发表是一个存储在内存中的数组，传入数据包的标签是访问该数组的索引。这意味着与其他数据包转发技术相比，查找操作的复杂度为O(1) 。为确保每个节点上的数据包标签是标签转发表中的一个索引，每个转发数据包的路由器都将转发数据包的标签替换为在标签转发表中找到的标签。标签转发表的每个条目包含两条信息：\n数据包的传出接口 传出数据包的标签 例如，考虑下面网络节点的标签转发表。\n指数 出接口 标签 0 南 7 1个 没有任何 没有任何 2个 西方 2个 3个 东方 2个 如果此节点收到标签为 2 的数据包，它会在其西向接口上转发该数据包，并将传出数据包的标签设置为2。如果接收到的数据包的标签设置为3 ，则数据包通过East接口转发，而传出数据包的标签设置为2。如果接收到标签字段设置为1 的数据包，则丢弃该数据包，因为相应的标签转发表条目无效。\n标签交换可以完全控制网络内数据包所遵循的路径。考虑下面的网络并假设我们要使用两个虚拟电路：R1-\u0026gt;R3-\u0026gt;R4-\u0026gt;R2-\u0026gt;R5和R2-\u0026gt;R1-\u0026gt;R3-\u0026gt;R4-\u0026gt;R5。\n平面寻址（Flat addressing）VS 分层寻址（Hierarchical addressing）\n类型 描述 举例 平面寻址 地址按照顺序 MAC 地址 分层寻址 地址按照不同层级，包含网络部分和端口部分 IP 地址 处理异构数据链层 虚拟线路组织 控制平面 距离矢量路由 链路状态路由 "},{"id":183,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-4-%E9%83%A8%E5%88%86%E9%99%84%E5%BD%95/","title":"计算机网络：原理、协议和实践，第三版 第 4 部分：附录","parent":"计算机网络：原理、协议和实践，第三版","content":" 计算机网络：原理、协议和实践，第三版 转自：Computer Networking : Principles, Protocols and Practice, third edition\n链接：https://beta.computer-networking.info/syllabus/default/index.html\n附录 词汇表 地址 一串比特，用于标识网络层或数据链路层中的网络接口。大多数地址具有固定长度，例如IPv4为 32 位， IPv6为128 位，以太网和其他相关局域网为 48 位。\nAIMD 加法增加，乘法减少。一种速率自适应算法，主要由 TCP 使用，其中主机在网络不拥塞时以加法方式增加其传输速率，并在检测到拥塞时以乘法方式降低其传输速率。\n任播 一种传输模式，其中信息从一个源发送到属于指定组的一个接收器\n接口 应用程序接口\nARP 地址解析协议是IPv4设备用来获取局域网上一个IPv4地址对应的数据链路层地址的协议。ARP 定义在RFC 826\n阿帕 高级研究计划署 (ARPA) 网络是由美国网络科学家在美国国防部 ARPA 的资助下建立的网络。ARPANET 被认为是当今互联网的鼻祖。\nASCII 美国信息交换标准代码 (ASCII) 是一种字符编码方案，它定义了字符的二进制表示。ASCII 表包含可打印字符和控制字符。ASCII 字符以 7 位编码，仅包含用英语编写文本所需的字符。后来开发了其他字符集（例如 Unicode）以支持所有书面语言。\nASN.1 抽象语法符号一 (ASN.1) 由 ISO 和 ITU-T 设计。它是一种标准且灵活的符号，可用于描述数据结构，用于在应用程序之间表示、编码、传输和解码数据。它被设计用于 OSI 参考模型的表示层，但现在用于其他协议，例如SNMP。\n自动柜员机 异步传输模式\nBGP 边界网关协议是全球互联网中使用的域间路由协议。\nBNF Backus-Naur 形式 (BNF) 是一种通过使用句法和词法规则来描述语言的正式方式。BNF 经常用于定义编程语言，也用于定义网络应用程序之间交换的消息。RFC 5234解释了如何编写 BNF 来指定 Internet 协议。\n广播 一种传输模式，将相同的信息发送到网络中的所有节点\nCIDR 无类域间路由是 IP 版本 4 的当前地址分配架构。它定义在RFC 1518和RFC 4632。\n拨号线 普通电话线路的同义词，即可用于拨打任何电话号码的线路。\n域名解析 域名系统是一个分布式数据库，可以由主机查询以将名称映射到 IP 地址。它定义在RFC 1035\neBGP eBGP 会话是属于两个不同自治系统的两个直接连接的路由器之间的 BGP 会话。也称为外部 BGP 会话。\nEGP 外部网关协议。域间路由协议的同义词\nEIGRP 增强型内部网关路由协议 (EIGRP) 是一种专有的域内路由协议，通常用于企业网络。EIGRP 使用[Garcia1993]中描述的 DUAL 算法。\n以太网 最广泛使用的局域网技术。\n文件传输 使用户能够通过网络从远程服务器发送或接收文件的服务。文件传输协议FTP是一种流行的服务。它现在已被 HTTP/HTTPS 或更安全的协议（如SSH 文件传输协议）所取代。\n框架 帧是数据链路层中信息传输的单位\n帧中继 电信运营商部署的一种使用虚拟电路的广域网技术。\nftp 中定义的文件传输协议在广泛采用 HTTP 之前， RFC 959已成为通过 Internet 交换文件的事实协议RFC 2616。\nFTP 文件传输协议定义在RFC 959\n主机.txt 包含所有 Internet 主机列表的原始文件。该文件已被弃用，但 Unix 变体仍保持本地/etc/hosts包含名称和 IP 地址之间的映射。有关Linux 上此文件格式的说明，请参见http://man7.org/linux/man-pages/man5/hosts.5.html 。\nHTML 超文本标记语言指定在万维网上交换的文档的结构和语法。HTML由W3C的HTML 工作组维护\nHTTP 超文本传输​​协议定义在RFC 2616\n集线器 在物理层中运行的中继。\nIANA 互联网号码分配机构 (IANA) 负责协调 DNS 根、IP 寻址和其他互联网协议资源\nBGP iBGP 会话是属于同一自治系统的两个路由器之间的 BGP。也称为内部 BGP 会话。\nICANN Internet Corporation for Assigned Names and Numbers (ICANN) 协调域名、IP 地址和 AS 编号以及协议参数的分配。它还协调 DNS 根名称服务器的操作和发展。\nIETF Internet Engineering Task Force 是一个非营利组织，负责为 Internet 中使用的协议制定标准。IETF 主要涵盖传输层和网络层。一些应用层协议也在 IETF 中进行了标准化。IETF 的工作按工作组进行组织。大部分工作是通过交换电子邮件进行的，每年有 3 次 IETF 会议。任何人都可以参加。见https://www.ietf.org\nIGP¶ 内部网关协议。域内路由协议的同义词\nIGRP 内部网关路由协议 (IGRP) 是使用距离矢量的专有域内路由协议。IGRP 支持每个路由的多个指标，但已被EIGRP取代\n¶ Internet 消息访问协议 (IMAP)，定义于RFC 3501是一种应用程序级协议，允许客户端访问和操作存储在服务器上的电子邮件。使用 IMAP，电子邮件保留在服务器上，不会下载到客户端。\n互联网 公共互联网，即由运行IPv4或IPv6的不同网络组成的网络\n互联网 互联网是一个互联网络，即由不同网络组成的网络。互联网，大写字母I对应于我们今天使用的全球网络，但路径中使用了其他互联网。\n逆查询 对于 DNS 服务器和解析器，反向查询是对与给定 IP 地址对应的域名的查询。\n知识产权 Internet 协议是 TCP/IP 协议族中网络层协议的总称。IP 版本 4 被广泛使用，但 IP 版本 6 正在全球部署。\nIPv4 是 Internet 协议的第 4 版，是当今大多数 Internet 中使用的无连接网络层协议。IPv4 地址被编码为 32 位字段。\nIPv6 是 Internet 协议的第 6 版，旨在取代 IPv4 的无连接网络层协议。IP 版本 6 地址被编码为 128 位字段。\n是-是 中间系统——中间系统。一种链路状态域内路由，最初是为 ISO CLNP 协议定义的，但经过扩展以支持 IP v4 和 IP v6。IS-IS 常用于 ISP 网络。它在[ISO10589]中定义\n国际序列号 TCP 连接的初始序列号是客户端（或服务器）选择的序列号，在 TCP 连接建立期间放置在SYN（或SYN+ACK）段中。\n国际标准化组织 国际标准化组织是联合国的一个机构，总部设在日内瓦，负责制定各种主题的标准。在 ISO 内，国家代表投票决定批准或拒绝标准。大部分 ISO 标准的制定工作是在专家工作组中完成的。有关 ISO 的更多信息可从https://www.iso.org获得\nISO-3166 定义代码以代表国家及其细分的ISO标准。见http://www.iso.org/iso/country_codes.htm\n互联网服务 Internet 服务提供商，即为其客户提供 Internet 访问的网络。\n国际电联 国际电信联盟是联合国的一个机构，其目的是为电信行业制定标准。它最初是为了标准化基本电话系统而创建的，但后来扩展到数据网络。国际电联内部的工作主要由电信行业的网络专家（运营商和供应商）完成。更多信息见https://www.itu.int\nIXP 互联网交换点。属于不同域的路由器连接到同一局域网以建立对等会话并交换数据包的位置。有关 IXP 的部分列表，请参见http://www.euro-ix.net/或https://en.wikipedia.org/wiki/List_of_Internet_exchange_points_by_size。\n局域网 局域网\n专线 在两个端点之间永久可用的电话线。\n¶ 城域网\nMIME 中定义的多用途 Internet 邮件扩展 (MIME)RFC 2045是电子邮件格式的一组扩展，允许在邮件中使用非 ASCII 字符。MIME 消息可以由几个不同的部分组成，每个部分具有不同的格式。\nMIME 文档 MIME 文档是使用MIME格式编码的文档。\n小型机 小型机是一种多用户系统，通常在 1960 年代/1970 年代用于为部门服务。有关更多信息，请参阅相应的 Wikipedia 文章：https ://en.wikipedia.org/wiki/Minicomputer\n调制解调器 调制解调器（调制器-解调器）是一种通过调制（或解调）模拟信号来编码（或解码）数字信息的设备。调制解调器经常用于通过电话线和无线电链路传输数字信息。有关各种类型调制解调器的调查，请参阅https://en.wikipedia.org/wiki/Modem\n多发性 TCP 实体在 SYN 段中使用的 TCP 选项，用于指示它能够接收的最大段大小。\n多播 一种传输模式，其中信息被有效地发送到属于给定组的所有接收者\n名称服务器 实现 DNS 协议并可以回答对自己域内名称的查询的服务器。\nNAT¶ 网络地址转换器是转换 IP 数据包的中间盒。\nNBMA 非广播模式多址网络是支持多个主机/路由器的子网，但不提供将广播帧发送到连接到子网的所有设备的有效方式。ATM 子网是 NBMA 网络的一个例子。\n网络字节顺序 Internet 协议允许传输字节序列。这些字节序列足以承载 ASCII 字符。网络字节顺序是指 16 位和 32 位整数的 Big-Endian 编码。见https://en.wikipedia.org/wiki/Endianness\nNFS 网络文件系统定义在RFC 1094\nNTP 网络时间协议定义在RFC 1305\n¶ 开放系统互连。由ISO开发的一组网络标准，包括 7 层 OSI 参考模型。\nOSPF 首先打开最短路径。一种链路状态域内路由协议，通常用于企业和 ISP 网络。OSPF 在和RFC 2328 和RFC 5340\n数据包 数据包是网络层中信息传输的单位\nPBL 基于问题的学习是一种以问题为基础的教学方法。\n流行 邮局协议 (POP)，定义RFC 1939是一种应用程序级协议，允许客户端下载存储在服务器上的电子邮件消息。\n远程登录 使用户能够通过网络连接到远程服务器的服务。Telnet，定义在RFC 854和 BSD rlogin 服务定义在RFC 1282在过去很流行。出于安全原因，它们已被弃用，现在被ssh取代。\n解析器 实现 DNS 协议并可以解析查询的服务器。解析器通常服务于一组客户端（例如，校园内的所有主机或给定 ISP 的所有客户端）。它代表其客户端将 DNS 查询发送到各地的名称服务器，并将收到的答案存储在其缓存中。解析器必须知道根域名服务器的 IP 地址。\n翻录 路由信息协议。基于距离矢量的域内路由协议，有时用于企业网络。RIP 定义在RFC 2453。\nRIR 区域互联网注册。代表IANA管理 IP 地址和 AS 号码的组织。\n根域名服务器 负责域名层次结构根的名称服务器。目前有十几个根名称服务器和每个 DNS 解析器 有关这些根服务器的操作的更多信息，请参见http://www.root-servers.org/ 。\n往返时间 往返时间 (RTT) 是传输协议中段的传输和相应确认的接收之间的延迟。\n路由器 在网络层运行的中继。\nRPC¶ 已经定义了几种类型的远程过程调用。中定义的 RPC 机制NFS 等应用程序使用RFC 5531\nSDU（服务数据单元） 服务数据单元是应用程序之间传输的单元信息\n段 段是传输层中信息传输的单位\nSMTP 简单邮件传输协议定义在RFC 821\nSNMP 简单网络管理协议是为 TCP/IP 网络定义的管理协议。\n插座 最初在 Berkeley Unix 上定义的低级 API，允许程序员开发客户端和服务器。\n欺骗数据包 当数据包的发送者使用与其自己不同的地址作为源地址时，就称该数据包被欺骗。\nSSH 安全外壳 (SSH) 传输层协议定义在RFC 4253\n标准查询 对于 DNS 服务器和解析器，标准查询是对A或AAAA记录的查询。这样的查询通常会返回一个 IP 地址。\n开关 在数据链路层运行的中继。\n同步 cookie SYN cookie 是一种用于计算初始序列号 (ISN) 的技术\nTCB 传输控制块是由 TCP 实现为每个已建立的 TCP 连接维护的一组变量。\nTCP 传输控制协议是 TCP/IP 协议套件中传输层的协议，它在 IP 之上提供可靠的面向字节流连接的服务\nTCP/IP 指TCP和IP协议\n远程登录 telnet 协议定义在RFC 854\n顶级域名 顶级域名。TLD 有两种类型。ccTLD 是对应于两个字母ISO-3166国家/地区代码的 TLD。gTLD 是未分配给某个国家/地区的通用 TLD。\nTLS 传输层安全性，定义在RFC 5246是一种加密协议，用于为 Internet 应用程序提供通信安全。该协议用于传输服务之上，但详细描述超出了本书的范围。\nUDP 用户数据报协议是 TCP/IP 协议套件中传输层的协议，它提供不可靠的无连接服务，包括检测损坏的机制\n单播 一种信息从一个来源发送到一个接收者的传输模式\nvnc 允许远程访问计算机的图形用户界面的网络应用程序。请参阅https://en.wikipedia.org/wiki/Virtual_Network_Computing\nW3C 创建万维网联盟是为了标准化万维网中使用的协议和机制。因此，它专注于应用层的一个子集。见https://www.w3.org\n广域网 广域网\nX.25 电信运营商部署的一种使用虚拟电路的广域网技术。\nX11 XWindow 系统和相关协议在[SG1990]中定义\nXML 可扩展标记语言 (XML) 是一种源自 SGML 的灵活文本格式。它最初是为电子出版行业设计的，但现在被各种需要交换结构化数据的应用程序使用。XML 规范由W3C的几个工作组维护\n书目 "},{"id":184,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/","title":"计算机网络：原理、协议和实践，第三版","parent":"计算机网络：原理、协议和实践，第三版","content":" 计算机网络：原理、协议和实践，第三版 转自：Computer Networking : Principles, Protocols and Practice, third edition\n链接：https://beta.computer-networking.info/syllabus/default/index.html\n第 1 部分：原则 连接两台主机 物理层 数据链路层 框架 从传输错误中恢复 在不完美链路之上实现可靠的数据传输 回溯 n 和选择性重复 构建网络 数据报组织 计算转发表 平面或分层地址 处理异构数据链层 虚拟线路组织 控制平面 距离矢量路由 链路状态路由 应用 传输层 传输层服务 无连接服务 以连接为导向的服务 请求-响应服务 传输层 无连接运输 连接建立 数据传输 连接版本 命名和寻址 名称的好处 共享资源 共享带宽 网络拥塞 在网络上分配负载 中型访问控制算法 静态分配方法 阿罗哈 载波感应多路访问 带碰撞检测的载波侦测多路访问 具有防撞功能的载波侦听多路访问 确定性介质访问控制算法 拥塞控制 使用基于窗口的传输协议进行拥塞控制 参考模型 五层参考模型 物理层 数据链路层 网络层 传输层 应用层 参考模型 TCP/IP 参考模型 OSI 参考模型 网络安全 威胁 加密基元 加密协议 密钥交换 第 2 部分：协议 应用层 域名系统 电子邮件 简单邮件传输协议 邮局协议 超文本传输协议 使 HTTP 更快 远程过程调用 编码数据 联系被叫方 远程登录 安全外壳 （ssh） 传输层安全性 红绿灯系统握手 TLS 记录协议 改进 TLS 保护域名系统 互联网传输协议 用户数据报协议 传输控制协议 TCP 连接建立 TCP 可靠的数据传输 分段传输策略 TCP 窗口 TCP 的重新传输超时 高级重传策略 TCP 连接释放 拥塞控制 在不丢失数据的情况下控制拥塞 对 TCP 拥塞控制进行建模 网络层 IP 版本 6 IPv6 寻址体系结构 IPv6 数据包格式 ICMP 版本 6 IPv6 子网 IPv6 与数据链层之间的交互 IP 网络中的路由 域内路由 把 OSPF 域间路由 边界网关协议 BGP 决策过程 BGP 收敛 数据链层技术 点对点协议 以太网 以太网交换机 生成树协议 （802.1d） 虚拟局域网 802.11 无线网络 第 3 部分：练习 习题 可靠的传输 开放性问题 实践 讨论问题 使用套接字进行进程间通信 使用套接字将数据发送到对等方 使用套接字从对等方接收数据 连接：将套接字连接到远程地址 创建一个新的套接字以通过网络进行通信 使用远程对等体的 IPv6 地址向其发送消息 字节序：在不同计算机之间交换整数 习题 构建网络 多项选择题 开放性问题 讨论问题 为应用程序提供服务 多项选择题 开放性问题 实践 讨论问题 共享资源 中型访问控制 公平和拥堵控制 讨论问题 应用层 域名解析 互联网电子邮件协议 超文本传输协议 TLS 和 ssh 分析数据包跟踪 TCP 基础知识 仔细研究 TCP 在 Linux TCP 堆栈中注入段 开放性问题 IPv6 网络 有关 IPv6 网络的基本问题 设计问题 配置 IPv6 网络 IPv6 数据包 域间路由 习题 探索路由协议 探索 OSPF 探索 RIP 探索 BGP 习题 局域网：生成树协议和虚拟 LAN 习题 使用 IPMininet 测试生成树 附录 词汇表 书目 索引和表格 指数 搜索页面 "},{"id":185,"href":"/Tech/2Computer-Science/1Crash-Course-Computer-Science/Crash-Course-Computer-Science-README/","title":"Crash Course Computer Science Readme","parent":"1、Crash Course Computer Science","content":" 计算机科学速成课 :fire: 2018年5月1号 - 全40集完结撒花 精校版： https://www.bilibili.com/video/av21376839/\n## 字幕也放出来了(40集中英字幕) 两个版本： 所有字幕放一个文件里 每一集一个文件，共40个文件 另外，片头总结在 这篇文章的底部\n感谢观看，Don\u0026rsquo;t forget to be Awesome!\n感谢所有翻译人员！ 不想膨胀的小R - Github, 微博, B站 糖醋陈皮 - Github, 微博, 博客 ZireHao - B站 gilot - B站 晴空 Crazycat Cindy 出门去 TMC - RN LCAR979（推特 _lincr_） 第一版翻译（不推荐观看，看精校版即可）： 1 - 早期的计算 - Early Computing 2 - 电子计算 - Electronic Computing 3 - 布尔逻辑与逻辑电路 - Boolean Logic \u0026amp; Logic Gates 4 - 二进制 - Representing Numbers and Letters with Binary 5 - 算术逻辑单元 - How Computers Calculate - the ALU 6 - 寄存器 \u0026amp; 内存 - Registers and RAM 7 - 中央处理器 - The Central Processing Unit(CPU) 8 - 指令和程序 - Instructions \u0026amp; Programs 9 - 高级 CPU 设计 - Advanced CPU Designs 10 - 编程史话 - Early Programming 11 - 编程语言 - The First Programming Languages 12 - 编程原理：语句和函数 - Programming Basics: Statements \u0026amp; Functions 13 - 算法初步 - Intro to Algorithms 14 - 数据结构 - Data Structures 15 - 阿兰·图灵 - Alan Turing 16 - 软件工程 - Software Engineering 17 - 集成电路、摩尔定律 - Integrated Circuits \u0026amp; Moore’s Law 18 - 操作系统 - Operating Systems 19 - 内存 \u0026amp; 储存介质 - Memory \u0026amp; Storage 20 - 文件系统 - Files \u0026amp; File Systems 21 - 压缩 - Compression 22 - 命令行界面 - Keyboards \u0026amp; Command Line Interfaces 23 - 屏幕 \u0026amp; 2D 图形显示 - Screens \u0026amp; 2D Graphics 24 - 冷战和消费主义 - The Cold War and Consumerism 25 - 个人计算机革命 - The Personal Computer Revolution 26 - 图形用户界面 - Graphical User Interfaces 27 - 3D 图形 - 3D Graphics 28 - 计算机网络 - Computer Networks 29 - 互联网 - The Internet 30 - 万维网 - The World Wide Web 31 - 网络安全 - Cybersecurity 32 - 黑客与攻击 - Hackers \u0026amp; Cyber Attacks 33 - 加密 - Cryptography 34 - 机器学习与人工智能 - Machine Learning \u0026amp; Artificial Intelligence 35 - 计算机视觉 - Computer Vision 36 - 自然语言处理 - Natural Language Processing 37 - 机器人 - Robots 38 - 计算机中的心理学 - Psychology of Computing 39 - 教育型科技 - Educational Technology 40 - (完结) 奇点，天网，计算机的未来 - The Singularity, Skynet, and the Future of Computing 精校版质量更好，建议看精校版，之所以第一版目录不删：\n方便快速扫视，看都聊什么话题 方便翻阅之前的版本（如果有需要） 备注：精校负责人是 @糖醋陈皮\n翻译时间 英文版： 第 1 集发布： 2017年2月22号 第 40 集发布：2017年12月21号\n中文版： 第 1 集发布： 2017年2月27号\n全 40 集翻译完成：2018年3月24号\n全 40 集精校完成：2018年5月1号\n原视频 Youtube - Crash Course Computer Science Playlist Thank you Crash Course \u0026amp; Carrie Anne! Patron support Crash Course：https://www.patreon.com/crashcourse Crash Course website：https://thecrashcourse.com/ Youtube Crash Course: https://www.youtube.com/user/crashcourse 感谢速成课！感谢 Carrie Anne！ Patron 支持 Crash Course：https://www.patreon.com/crashcourse Crash Course 官方网站：https://thecrashcourse.com/ Youtube Crash Course: https://www.youtube.com/user/crashcourse 片头总结 第 1 集：计算机早期历史 提到的设备：算盘 → 步进计算器 → 差分机 → 分析机 → 打孔卡片制表机\n提到的人名：Charles Babbage, Ada Lovelace\n02:27 最早的计算设备是算盘，举例如何使用\n04:31 Computer 从指代职业变成指代机器\n04:57 机器里有名的是：步进计算器。第一个可以做加减乘除的机器\n06:44 炮弹为了精准，要计算弹道，二战是查表来做。但每次改设计了就需要做一张新表\n07:30 Charles Babbage 提出了 \u0026quot;差分机\u0026quot;, 在构造差分机期间，想出了分析机, 分析机是通用计算机\n08:50 Lovelace 给分析机写了假想程序，因此成为了第一位程序员\n09:25 人口普查 10 年一次. Herman Hollerith 的打孔卡片制表机大大提升了效率\n第 2 集：电子计算机 提到的设备：继电器 → 真空管 → 晶体管\n00:17 20世纪的发展要求更强的计算能力。柜子大小的计算机发展到房间大小\n01:06 哈佛 Mark 1 号，IBM 1944 年做的\n02:25 继电器，继电器一秒最多 50 次开关\n03:24 继电器出 bug\n03:49 1904 年，热电子管出现，第一个真空管。改进后变成和继电器的功能一样\n05:34 \u0026quot;巨人1号\u0026quot; 计算机在英国 布莱切利园 首次大规模使用真空管。但编程麻烦，还要配置\n06:40 1946 年，宾夕法尼亚大学的 ENIAC 是第一个通用可编程计算机\n07:36 1947 年，贝尔实验室做出了晶体管，晶体管有诸多好处，IBM 很快全面转向晶体管\n09:27 硅谷的典故：很多晶体管和半导体的开发都是这里做的。而生产半导体最常见的材料是硅\n09:41 肖克利半导体 → 仙童半导体 → 英特尔\n第 3 集：布尔逻辑和逻辑门 01:00 什么是二进制, 为什么用二进制, 布尔逻辑\n02:46 3个基本操作：NOT，AND，OR\n02:51 解释3个基本操作\n07:11 XOR 异或\n第 4 集：二进制 00:46 用十进制举例二进制的原理，演示二进制加法。存储单位 MB GB TB 等\n05:30 正数，负数，整数，浮点数的表示\n07:20 美国信息交换标准代码 - ASCII, 用来表示字符\n09:00 UNICODE 1992 年诞生，是字符编码标准， 解决 ASCII 不够表达所有语言的问题\n第 5 集：算数逻辑单元 - ALU 00:03 简单介绍 ALU ，英特尔 74181\n01:24 ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元\n01:32 算术单元\n半加器 (处理1个 bit，2个输入)\n全加器 (处理1个 bit，3个输入)\n8 bit 加法 (1个半加器，7个全加器）\n溢出的概念，吃豆人的例子\n乘法除法\n07:32 逻辑单元\n检测数字是否为 0 的电路（一堆 OR 门最后加个 NOT 门）\nALU 抽象成一个 V 符号\nFlag 标志（是否相等，是否小于，是否溢出等等）\n第 6 集：寄存器和内存 本集重点是 Memory （存储 / 内存 两种含义）\n03:30 存 1 位 (Gated Latch - 锁存器）\n04:48 存 8 位 (Register - 寄存器)\n05:46 16x16 的矩阵存 256 位\n数据选择器/多路复用器 (Multiplexer) 解码 8 位地址，定位到单个锁存器\n07:38 4 位代表行， 4 位代表列\n08:16 组合 256 位内存 + 多路复用器\n09:01 可寻址的 256 字节 内存\n一条1980年代的内存，1M 大小\n10:14 8个模块，每个模块有32个小方块，\n每个小方块有 4 个小块，每个小块是 128 位 x 64 位\n第 7 集：中央处理器（CPU) 重点\n拼个 CPU 出来 CPU 怎么执行命令 01:00 RAM + 寄存器 + ALU 做个 CPU\n04:00 解释 \u0026quot;取指令→解释→执行\u0026quot; 这个循环\n08:00 时钟是什么, 时钟速度和赫兹\n10:00 超频提升性能, 降频省电\n第 8 集：指令和程序 本集重点：一步步带你运行一遍程序\n00:45 回顾上集的例子程序，一步步讲解。介绍”指令集”的概念\nLOAD_A，LOAD_B，SUB，JUMP，ADD，HALT 等指令\n05:16 带条件跳转，JUMP NEGATIVE 是负数才跳转，还有其他类型的 JUMP\n08:00 真正现代 CPU 用更多指令集。位数更长。\n09:07 1971年的英特尔 4004 处理器，有 46 个指令\n09:36 如今英特尔酷睿 i7, 有上千条指令\n第 9 集：高级 CPU 设计 00:24 早期是加快晶体管切换速度，来提升 CPU 速度\n01:20 给 CPU 专门的除法电路 + 其他电路来做复杂操作，比如游戏，视频解码\n02:28 给 CPU 加缓存，提高数据存取速度，更快喂给 CPU，用计算餐馆销售额举例\n05:13 脏位 - Dirty bit\n05:33 流水线设计，用 1 个洗衣机和 1 个干燥机举例\n06:01 并行处理 - parallelize\n07:33 乱序执行 - out-of-order execution\n08:21 推测执行 - speculative execution\n08:50 分支预测 - branch prediction\n09:34 多个 ALU\n09:54 多核 (Core)\n10:11 多个独立 CPU\n10:52 超级计算机，中国的\u0026quot;神威 太湖之光\u0026quot;\n第 10 集：早期的编程方式 本集重点：早期计算机如何编程\n打孔纸卡 → 插线板 → 面板拨开关\n00:00 开头说本集重点：程序如何进入计算机\n00:53 拿纺织业举例，给机器编程的需求远在计算机出现前就有了\n01:41 打孔纸卡 - Punched card\n02:36 插线板 - Plugboard\n04:20 冯诺依曼架构 - Von Neumann Architecture\n07:00 面板编程 - Panel programming\n07:29 第一款取得商业成功的家用计算机: Altair 8800\n08:15 编程依然很困难，人们需要更友好更简单的方式编程\n08:44 下周主题：编程语言\n第 11 集：编程语言发展史 编程：二进制 → 助记符（汇编器）→ A-0（编译器）→ FORTRAIN\n01:45 二进制写程序，先纸上写伪代码，手工转二进制，很快就烦了\n02:28 用 \u0026quot;助记符” 写代码（LOAD_A 14）为了把助记符转二进制，汇编器诞生 (Assembler)\n04:32 葛丽丝·霍普 (Grace Hopper) - 哈佛1号计算机首批程序员, 海军军官\n05:13 Grace 设计了编程语言 A-0\n05:29 Grace 1952 年做了第一个编译器 (Compiler)，实现 A-0\n06:29 变量 (Variables)\n07:01 FORTRAN\n08:18 COBOL\n09:25 新语言\n1960 年代：ALGOL，LISP，BASIC\n1970 年代：Pascal，C，Smalltalk\n1980 年代：C++，Objective-C，Perl\n1990 年代：Python，Ruby，Java\n第 12 集：编程基础 - 语句和函数 00:50 变量, 赋值语句\n02:08 Grace Hopper 拍虫子游戏\n02:52 if 判断\n04:19 while 循环\n05:48 for 循环\n07:00 函数\n11:11 下集介绍算法\n第 13 集：算法入门 03:00 选择排序 - Selection sort\n03:52 大 O 表示法 - Big O notation\n04:31 归并排序 - Merge sort\n08:03 Dijkstra 算法\n第 14 集：数据结构 00:39 数组 - Array\n02:06 字符串 - String\n03:12 矩阵 - Matrix\n04:05 结构体 - Struct\n04:46 指针 - Pointer\n04:44 节点 - Node\n04:53 链表 - Linked List\n06:21 队列 - Queue\n06:21 栈 - Stack\n07:31 树 - Tree\n08:01 二叉树 - Binary Tree\n08:26 图 - Graph\n08:50 没时间讲红黑树和堆, 不同数据结构适用不同场景\n第 15 集：阿兰·图灵 00:33 介绍图灵\n00:52 可判定性问题\n01:14 阿隆佐·丘奇，Lambda 算子\n01:38 图灵机\n04:54 停机问题\n08:09 破解德军英格玛加密机\n10:40 图灵测试\n11:18 图灵的个人生活\n12:07 图灵奖\n第 16 集：软件工程 01:31 对象 Object\n02:39 面向对象编程 Object Oriented Programming.\n03:55 API Application Programming Interface\n04:33 public, private\n05:36 集成开发环境, IDE - Integrated Development Environments\n06:09 调试 debugging\n06:31 文档和注释 - readme, comment\n07:33 版本控制 Version control\n08:50 质量控制 Quality Assurance testing，QA\n09:21 Beta, Alpha\n第 17 集：集成电路与摩尔定律 本集重点：晶圆的制作流程：光刻 (04:21~07:42)\n00:51 分立元件 Discrete components\n01:09 数字暴政 Tyranny of Numbers - 是 1960 年代工程师碰到的问题\n意思是如果想加强电脑性能，就要更多部件，这导致更多线路，更复杂。所以很难做\n04:21 光刻 Photolithography\n04:26 晶圆 Wafer\n04:57 光刻胶 Photoresist\n05:08 光掩膜 Photomask\n06:00 掺杂 Doping\n09:09 摩尔定律 Moore’s Law.\n09:38 英特尔 Intel\n10:20 晶体管数量大幅度增长, 1980年三万个，1990年一百万个，2000年三千万个，2010年十亿个\n11:44 进一步小型化会碰到 2 个问题 1. 光的波长不足以制作更精细的设计 2. 量子隧穿效应\n第 18 集：操作系统 00:48 操作系统 Operating systems\n01:34 批处理 Batch processing\n01:58 计算机变便宜变多，有不同配置，写程序处理不同硬件细节很痛苦，因此操作系统负责抽象硬件\n02:12 外部设备 Peripherals\n02:48 设备驱动程序 Device drivers\n04:43 多任务处理 Multitasking\n05:54 虚拟内存 Virtual Memory\n07:09 动态内存分配 Dynamic memory allocation\n07:31 内存保护 Memory Protection\n07:54 1970年代，计算机足够便宜，大学买了让学生用，多个学生用多个 \u0026quot;终端\u0026quot; 连接到主机\n08:29 多用户分时操作系统，Multics\n09:32 Unix\n11:02 MS-DOS\n12:09 下集是内存\u0026amp;存储介质\n第 19 集：内存\u0026amp;储存介质 本集重点：存储技术的发展\n01:01 纸卡 Paper punch cards\n02:01 延迟线存储器 Delay Line Memory\n04:06 磁芯 Magnetic Core Memory\n06:08 磁带 Magnetic Tape\n07:08 磁鼓 Magnetic Drum Memory\n07:43 硬盘 Hard Disk Drives\n08:53 内存层次结构 Memory Hierarchy\n09:36 软盘 Floppy Disk\n10:09 光盘 Compact Disk\n10:51 固态硬盘 Solid State Drives\n第 20 集：文件系统 00:47 文件格式：可以随便存文件数据，但按格式存会更方便\n01:00 TXT 文本文件：ASCII\n01:31 WAV 音频文件：每秒上千次的音频采样数字\n02:47 BMP 图片文件：像素的红绿蓝 RGB 值\n04:43 文件系统：很早期时空间小，整个存储器就像一整个文件。后来随容量增长，多文件非常必要\n05:37 目录文件：用来解决多文件问题，存其他文件的信息，比如开头，结尾，创建时间等\n06:39 平面文件系统 - Flat File System：文件都在同一个层次，早期空间小，只有十几个文件，平面系统够用\n06:57 如果文件紧密的一个个前后排序会造成问题，所以文件系统会： 1. 把空间划分成一块块 2. 文件拆分存在多个块里\n08:30 文件的增删改查会不可避免的造成文件散落在各个块里，\n如果是磁带这样的存储介质就会造成问题，所以做碎片整理\n09:46 分层文件系统 - Hierarchical File System：有不同文件夹，文件夹可以层层嵌套\n第21集讲压缩\n第 21 集：压缩 00:26 压缩的好处是能存更多文件，传输也更快\n01:52 游程编码 Run-Length Encoding\n02:45 无损压缩 Lossless compression\n03:55 霍夫曼树 Huffman Tree\n05:56 \u0026quot;消除冗余\u0026quot;和\u0026quot;用更紧凑的表示方法\u0026quot;，这两种方法通常会组合使用\n06:07 字典编码 Dictionary coders, 游程编码 和 字典编码 都是无损压缩\n08:03 感知编码 Perceptual coding\n08:09 有损压缩 jpeg 格式\n09:39 时间冗余 Temporal redundancy\n10:30 MPEG-4 视频编码\n第 22 集：命令行界面 本集重点：计算机早期同时输入程序和数据（用纸卡/纸带）\n运行开始直到结束，中间没有人类进行操作，\n原因是计算机很贵，不能等人类慢慢输入，执行完结果打印到纸上 (02:34)\n到1950年代，计算机足够便宜+快，人类和计算机交互式操作变得可行\n为了让人类输入到计算机，改造之前就有的打字机，变成电传打字机 (02:44~05:38)\n到1970年代末，屏幕成本足够低，屏幕代替电传打字机，屏幕成为标配 (07:24)\n00:32 人机交互 Human-Computer Interaction\n00:50 早期输出数据是打印到纸上，而输入是用纸卡/纸带一次性把程序和数据都给进去\n03:00 QWERTY 打字机的发展，克里斯托弗·莱瑟姆·肖尔斯 发明于 1868 年\n05:38 电传打字机 Teletype machine\n06:32 命令行界面 Command line interface\n06:38 ls 命令\n08:22 早期文字游戏 Zork (1977年)\n08:47 cd 命令\n第 23 集：屏幕与 2D 图形显示 00:05 PDP-1 计算机。键盘和显示器分开，屏幕显示临时值\n01:14 阴极射线管 Cathode Ray Tube (CRT)\n01:38 CRT 有两种绘图方式：\n矢量扫描 Vector Scanning\n光栅扫描 Raster Scanning\n02:14 液晶显示器 Liquid Crystal Displays (LCD)，像素 (Pixel)\n03:32 字符生成器 Character generator\n03:45 屏幕缓冲区 Screen buffer\n05:09 矢量命令画图\n06:34 Sketchpad, 光笔 (Light pen)\n09:00 函数画线，矩形\n第 24 集：冷战和消费主义 本集重点：冷战导致美国往计算机领域投入大量资源 (00:00~01:43)\n范内瓦·布什 预见了计算机的潜力，提出假想机器 Memex\n帮助建立 国家科学基金会，给科学研究提供资金 (01:43~03:43)\n1950 年代消费者开始买晶体管设备，收音机大卖\n日本取得晶体管授权后，索尼做了晶体管收音机，为日本半导体行业崛起埋下种子 (03:43~04:29）\n苏联 1961 年把宇航员加加林送上太空，导致美国提出登月\nNASA 预算大大增加，用集成电路来制作登月计算机 (04:29~06:27)\n集成电路的发展实际上是由军事应用大大推进的，阿波罗登月毕竟只有 17 次\n美国造超级计算机进一步推进集成电路 (04:29~07:11)\n美国半导体行业一开始靠政府高利润合同活着，忽略消费者市场，1970年代冷战渐消，行业开始衰败\n很多公司倒闭，英特尔转型处理器 (07:11~08:23)\n末尾总结：政府和消费者推动了计算机的发展\n早期靠政府资金，让技术发展到足够商用，然后消费者购买商用产品继续推动产品发展 (08:23~10:41)\n第 25 集：个人计算机革命 本集：全是历史故事\n00:18 1970年代初成本下降，个人计算机变得可行\n01:51 Altair 8800\n02:32 比尔·盖茨 和 保罗·艾伦写 BASIC 解释器\n03:45 乔布斯提议卖组装好的计算机，Apple-I 诞生\n04:40 1977年出现3款开箱即用计算机：\n\u0026quot;Apple-II\u0026quot;，\u0026quot;TRS-80 Model I\u0026quot;，\u0026quot;Commodore PET 2001\u0026quot;\n06:26 IBM 意识到个人计算机市场\nIBM PC 发布，采用开放架构，兼容的机器都叫 IBM Compatible (IBM 兼容)\n生态系统产生雪球效应：\n因为用户多，软硬件开发人员更愿意花精力在这个平台\n因为软硬件多，用户也更乐意买 \u0026quot;IBM 兼容\u0026quot; 的计算机\n08:44 苹果选封闭架构，一切都自己来，只有苹果在非 \u0026quot;IBM 兼容\u0026quot; 下保持了足够市场份额\n第 26 集：图形用户界面 (GUI) 01:10 图形界面先驱：道格拉斯·恩格尔巴特（Douglas Engelbart）\n03:20 1970年成立 帕洛阿尔托研究中心（Palo Alto Research Center）\n03:29 1973年完成 Xerox Alto(施乐奥托) 计算机\n04:42 举例：写一个简单的 GUI 程序\n06:38 1981年的 Xerox Star system(施乐之星系统)\n08:18 史蒂夫·乔布斯去施乐参观\n07:45 所见即所得 WYSIWYG\n09:15 1983年推出 Apple Lisa\n09:31 1984年推出 Macintosh\n10:12 1985年推出 Windows 1.0，之后出到 3.1\n10:43 1995年推出 Windows 95 提供图形界面\n11:08 1995年微软做失败的 Microsoft Bob\n第 27 集：3D 图形 01:15 线框渲染 Wireframe Rendering\n01:39 正交投影 Orthographic Projection\n01:50 透视投射 Perspective Projection\n02:14 网格 Mesh\n02:37 三角形更常用因为能定义唯一的平面\n03:09 扫描线渲染 Scanline Rendering\n05:04 遮挡 Occlusion\n05:19 画家算法 Painter's Algorithm\n06:09 深度缓冲 Z Buffering\n07:45 Z Fighting 错误\n07:51 背面剔除 Back Face Culling\n08:53 表面法线 Surface Normal\n09:33 平面着色 Flat Shading\n09:43 高洛德着色 Gouraud shading, 冯氏着色 Phong Shading\n10:06 纹理映射 Texture Mapping\n11:24 图形处理单元 GPU, Graphics Processing Unit\n第 28 集：计算机网络 02:05 局域网 Local Area Networks - LAN\n02:36 媒体访问控制地址 Media Access Control address - MAC\n02:55 载波侦听多路访问 Carrier Sense Multiple Access - CSMA\n05:18 指数退避 Exponential Backoff\n05:36 冲突域 Collision Domain\n07:08 电路交换 Circuit Switching\n07:36 报文交换 Message Switching\n10:20 分组交换 Packet Switching\n第 29 集：互联网 02:23 IP - 互联网协议 - Internet Protocol\n03:00 UDP - 用户数据报协议 - User Datagram Protocol\n03:41 校验和 - Checksum\n05:26 TCP - 传输控制协议 - Transmission Control Protocol\n08:21 DNS - 域名系统 - Domain Name System\n10:47 OSI - 开放式系统互联通信参考模型 - Open System Interconnection\n第 30 集：万维网 01:01 超链接 Hyperlinks\n02:20 URL - 统一资源定位器 - Uniform Resource Locator\n03:01 HTTP - 超文本传输协议 - HyperText Transfer Protocol\n04:13 HTML - 超文本标记语言 - HyperText Markup Language\n04:24 写一个简单网页，用到了 \u0026lt;h1\u0026gt; \u0026lt;a\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt; 标签\n06:04 第一个浏览器和服务器是 Tim Berners-Lee 花了 2 个月在 CERN 写的\n06:32 1991年正式发布，万维网就此诞生\n07:19 开始讲搜索引擎的故事\n07:40 Jerry 和 David 的万维网指南 后来改名成 Yahoo\n07:52 搜索引擎 JumpStation\n09:07 搜索引擎 Google\n09:20 网络中立性\n第 31 集：计算机安全 01:00 Secrecy, Integrity, Availability\n保密性, 完整性, 可用性\n01:49 Threat Model 威胁模型\n03:14 身份验证 (Authentication) 的三种方式：\nWhat you know, 你知道什么\nWhat you have, 你有什么\nWhat you are, 你是什么\n07:34 访问控制 Access Control\n08:48 Bell LaPadula model 不能向上读取，不能向下写入\n11:00 隔离 Isolation, 沙盒 Sandbox\n第 32 集：黑客与攻击 01:28 社会工程学 Social Engineering\n01:38 钓鱼 Phishing\n02:06 假托 Pretexting\n02:50 木马 Trojan Horses\n03:32 NAND镜像 NAND Mirroring\n04:12 漏洞利用 Exploit\n04:16 缓冲区溢出 Buffer Overflow\n05:45 边界检查 Bounds Checking\n06:16 代码注入 Code Injection\n09:32 零日漏洞 Zero Day Vulnerability\n09:53 计算机蠕虫 Worms\n09:58 僵尸网络 Botnet\n10:11 拒绝服务攻击 DDoS\n第 33 集：加密 00:16 多层防御 Defence in depth\n01:00 加密 - Encryption，解密 - Decryption\n01:11 凯撒加密 Caesar cipher\n01:27 替换加密 Substitution cipher\n01:59 移位加密 Permutation cipher\n02:03 列移位加密 Columnar transposition cipher\n02:37 德国 Enigma 加密机\n04:54 1977年\u0026quot;数据加密标准\u0026quot; - Data Encryption Standard (DES)\n05:24 2001年\u0026quot;高级加密标准\u0026quot; - Advanced Encryption Standard (AES)\n07:06 密钥交换 - Key exchange\n07:33 用颜色来举例\u0026quot;单向函数\u0026quot;和\u0026quot;密钥加密\u0026quot;的原理\n08:24 迪菲-赫尔曼密钥交换 - Diffie-Hellman Key Exchange\n10:18 非对称加密 - Asymmetric encryption\n11:22 非对称加密算法 RSA\n第 34 集：机器学习与人工智能 01:23 分类 Classification\n01:25 分类器 Classifier\n01:34 特征 Feature\n02:03 标记数据 Labeled data\n02:38 决策边界 Decision boundaries\n03:00 混淆矩阵 Confusion matrix\n03:39 未标签数据 Unlabeled data\n03:49 决策树 Decision tree\n04:25 支持向量机 Support Vector Machines\n05:52 人工神经网络 Artificial Neural Network\n08:34 深度学习 Deep learning\n09:21 弱AI, 窄AI Weak AI, Narrow AI\n09:43 强AI Strong AI\n10:42 强化学习 Reinforcement Learning\n第 35 集：计算机视觉 02:41 检测垂直边缘的算法\n03:26 核/过滤器 kernel or filter\n03:56 卷积 convolution\n04:23 Prewitt 算子 Prewitt Operators\n05:34 维奥拉·琼斯 人脸检测 Viola-Jones Face Detection\n05:35 卷积神经网络 Convolutional Neural Networks\n07:33 识别出脸之后，可以进一步用其他算法定位面部标志，如眼睛和眉毛具体位置，从而判断心情等信息\n08:52 跟踪全身的标记点，如肩部，手臂等\n第 36 集：自然语言处理 01:50 词性 Parts of speech\n02:15 短语结构规则 Phrase structure rules\n02:32 分析树 Parse tree\n05:30 语音识别 Speech recognition\n07:26 谱图 Spectrogram\n07:44 快速傅立叶变换 Fast Fourier Transform\n08:42 音素 Phonemes\n09:29 语音合成 Speech Synthesis\n第 37 集：机器人 02:08 法国吃饭鸭 - Digesting Duck, Canard Digerateur\n02:23 土耳其行棋傀儡, 下国际象棋\n02:43 第一台计算机控制的机器出现在1940年代晚期，叫数控机器, Computer Numerical Control(CNC)\n03:32 1960年 Unimate，第一个商业贩卖的 可编程工业机器人\n03:47 简单控制回路 simple control loop\n04:08 负反馈回路 negative feedback loop\n05:17 比例-积分-微分控制器 Proportional–Integral–Derivative controller PID 控制器\n10:48 机器人三定律 Three Laws of Robotics\n第 38 集：计算机心理学 00:45 我们需要了解人类心理学，做出更好的计算机\n01:12 易用度 - Usability\n01:31 颜色强度排序 和 颜色排序\n02:30 分组更好记，电话号码 317-555-3897 比 3175553897 好记\n03:25 直观功能 - Affordances\n04:33 认出 vs 回想 Recognition vs Recall\n05:45 让机器有一定情商以及 Facebook 的研究\n08:40 用软件修正注视位置。让视频通话时看起来像盯着对方，而不是盯着下方\n09:58 把机器人做的像人，恐怖谷理论\n11:35 有很多开放式的问题，心理学帮助我们明白不同选择可能带来的影响\n第 39 集：教育科技 02:15 通过调速，暂停等技巧，加强学习效率\n03:15 大型开放式在线课程 - Massive Open Online Courses (MOOC)\n05:08 智能辅导系统 - Intelligent Tutoring Systems\n05:22 判断规则 - Production rule\n06:10 域模型 - Domain Model\n06:46 贝叶斯知识追踪 Bayesian knowledge tracing\n学生已经学会的概率 瞎猜的概率 失误的概率 做题过程中学会的概率\n09:27 教育数据挖掘 Educational Data Mining （完结）第 40 集：奇点，天网，计算机的未来 01:21 普适计算 Ubiquitous Computing\n04:55 奇点 Singularity\n06:51 把工作分为4个象限，讨论自动化带来的影响\n10:15 机器人的存在时间可能长过人类，可以长时间探索宇宙\n"},{"id":186,"href":"/Tech/2Computer-Science/2Data-Structure-Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/","title":"数据结构与算法（ Java 描述）","parent":"2、Data Structure \u0026 Algorithms","content":" 第一章 算法及其复杂度 1.1.4 算法的定义 一个算法还必须具备以下要素： 输入：待处理的信息，即对具体问题的描述。比如，对于上述三个例子来说，输入分别是“任 意给定的直线以及其上的一点”、“任意给定的一条线段”以及“由 n 个可比较元素组成的序 列”。 输出：经过处理之后得到的信息，即问题的答案。比如，对于上述三个例子来说，输出分别 是我们所要得到的“垂直线”、“三等分点”以及“完全有序的序列”。 确定性：任一算法都可以描述为由若干种基本操作组成的序列。在垂直线算法中，“取等长 绳索”、“联结绳索”、“将绳结固定于一点”、“沿特定方向拉直绳索”等操作都属于基本操作。 在三等分线段算法中，基本操作就是欧氏作图法所允许的所有尺规操作。而在起泡排序算法 中，基本操作就是图灵机所允许的各种操作：“读取某一元素的内容”、“比较两个元素的大 小”以及“修改某一元素的内容”等等。 可行性：在相应的计算模型中，每一基本操作都可以实现，且能够在常数时间内完成。 有穷性：对于任何输入，按照算法，经过有穷次基本操作都可以得到正确的输出。 1.2.2 时间复杂度及其度量 时间频度\n一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度\n在时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。 算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。 记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C * f(n)。 简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大(小于等于)。也就是说当n趋于正无穷时T (n)的上界是C * f(n)。 其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n^2+n +1) = O (3n^2+n+3) = O (7n^2 + n) = O ( n^2 ) ，一般都只用O(n^2)表示就可以了。 在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 算法中语句执行次数为一个常数，则时间复杂度为O(1) 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log n),线性阶O(n), 线性对数阶O((n * log n),平方阶O(n^2)，立方阶O(n^3),\u0026hellip;， k次方阶O(n^k),指数阶O(2^n)。 复杂度举例：\nO(1) 常数级复杂度，也就是说程序运行的时间与需要处理的数据大小无关。通常把比较大小、加减乘除等简单的运算都当做常数级复杂度。 值得注意的是，在处理大数（二进制下数据长度超过32位或者十进制下超过8位）时，将加减乘除等运算当做常数复杂度不再适用。 O(log n) 将一个10进制整数转化为2进制整数 O(n)：判断一个元素是否属于一个大小为n的集合/列表；找出n个数中的最大值； O(n * log n) 快速排序法 O(n^2) 最直白的两两比较然后排序方法，需要n*(n-1)/2次比较，所以是O(n^2)级。 O(2^n) 列出所有长度为n的0,1字符串之类的穷举计算 O(n!) 列出n个元素的全排列之类的穷举计算 "},{"id":187,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Design-Patterns/","title":"设计模式 Design Patterns","parent":"3、Design Patterns","content":" 设计模式 Design Patterns 学习自：\nhttp://www.cyc2018.xyz/\n一、前言 设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。（面对相似问题的经典解决方案）\n创建型：如何创建对象\n结构型：如何将多个对象组件成更大的对象，就像发动机、就像汽车\n行为型：如果处理 对象 与 对象的关系，也就是说，当两个分开的对象，如何通过信息沟通，各自处理问题，以及 信息沟通的拓扑结构\nThinking In Java 里面总结：\n将保持不变的东西身上发生的变化孤立出来 变化的影响隔离出来 设计范式：可以说对问题不变的地方抽象总结 二、创建型 单例 简单工厂 工厂方法 抽象工厂 生成器 原型模式 三、行为型 责任链 命令 解释器 迭代器 中介者 备忘录 观察者 状态 策略 模板方法 访问者 空对象 四、结构型 适配器 桥接 组合 装饰 外观 享元 代理 "},{"id":188,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B1%E5%8D%95%E4%BE%8BSingleton/","title":"设计模式：一、创建型：1、单例（ Singleton）","parent":"3、Design Patterns","content":" 1、单例（Singleton） Intent 确保一个类只有一个实例，并提供该实例的全局访问点。\nClass Diagram 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。\n私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。\nImplementation Ⅰ 懒汉式-线程不安全 以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。\n这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance\npublic class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } Ⅱ 饿汉式-线程安全 线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。\n但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。\nprivate static Singleton uniqueInstance = new Singleton(); Ⅲ 懒汉式-线程安全 只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。\n但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用\npublic static synchronized Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } Ⅳ 双重校验锁-线程安全 uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。\n双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。\npublic class Singleton { private volatile static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\n为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1\u0026gt;3\u0026gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\nⅤ 静态内部类实现 当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。\n这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。\npublic class Singleton { private Singleton() { } private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getUniqueInstance() { return SingletonHolder.INSTANCE; } } Ⅵ 枚举实现 public enum Singleton {\rINSTANCE;\rprivate String objName;\rpublic String getObjName() {\rreturn objName;\r}\rpublic void setObjName(String objName) {\rthis.objName = objName;\r}\rpublic static void main(String[] args) {\r// 单例测试\rSingleton firstSingleton = Singleton.INSTANCE;\rfirstSingleton.setObjName(\u0026#34;firstName\u0026#34;);\rSystem.out.println(firstSingleton.getObjName());\rSingleton secondSingleton = Singleton.INSTANCE;\rsecondSingleton.setObjName(\u0026#34;secondName\u0026#34;);\rSystem.out.println(firstSingleton.getObjName());\rSystem.out.println(secondSingleton.getObjName());\r// 反射获取实例测试\rtry {\rSingleton[] enumConstants = Singleton.class.getEnumConstants();\rfor (Singleton enumConstant : enumConstants) {\rSystem.out.println(enumConstant.getObjName());\r}\r} catch (Exception e) {\re.printStackTrace();\r}\r}\r} firstName\rsecondName\rsecondName\rsecondName 该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。\n该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。\n"},{"id":189,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B2%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82Simple-Factory/","title":"设计模式：一、创建型：2、简单工厂（ Simple Factory）","parent":"3、Design Patterns","content":" 2、简单工厂（Simple Factory） Intent 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。\nClass Diagram 简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。\n这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。\nImplementation public interface Product { } public class ConcreteProduct implements Product { } public class ConcreteProduct1 implements Product { } public class ConcreteProduct2 implements Product { } 以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。\npublic class Client { public static void main(String[] args) { int type = 1; Product product; if (type == 1) { product = new ConcreteProduct1(); } else if (type == 2) { product = new ConcreteProduct2(); } else { product = new ConcreteProduct(); } // do something with the product } } 以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。\npublic class SimpleFactory { public Product createProduct(int type) { if (type == 1) { return new ConcreteProduct1(); } else if (type == 2) { return new ConcreteProduct2(); } return new ConcreteProduct(); } } public class Client { public static void main(String[] args) { SimpleFactory simpleFactory = new SimpleFactory(); Product product = simpleFactory.createProduct(1); // do something with the product } } "},{"id":190,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B3%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95Factory-Method/","title":"设计模式：一、创建型：3、工厂方法（ Factory Method）","parent":"3、Design Patterns","content":" 3、工厂方法（Factory Method） Intent 定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。\nClass Diagram 在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。\n下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。\nImplementation public abstract class Factory { abstract public Product factoryMethod(); public void doSomething() { Product product = factoryMethod(); // do something with the product } } public class ConcreteFactory extends Factory { public Product factoryMethod() { return new ConcreteProduct(); } } public class ConcreteFactory1 extends Factory { public Product factoryMethod() { return new ConcreteProduct1(); } } public class ConcreteFactory2 extends Factory { public Product factoryMethod() { return new ConcreteProduct2(); } } "},{"id":191,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B4%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Abstract-Factory/","title":"设计模式：一、创建型：4、抽象工厂（ Abstract Factory）","parent":"3、Design Patterns","content":" 4、抽象工厂（Abstract Factory） Intent 提供一个接口，用于创建 相关的对象家族 。\nClass Diagram 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。\n抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。\n至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。\n从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。\nImplementation public class AbstractProductA { } public class AbstractProductB { } public class ProductA1 extends AbstractProductA { } public class ProductA2 extends AbstractProductA { } public class ProductB1 extends AbstractProductB { } public class ProductB2 extends AbstractProductB { } public abstract class AbstractFactory { abstract AbstractProductA createProductA(); abstract AbstractProductB createProductB(); } public class ConcreteFactory1 extends AbstractFactory { AbstractProductA createProductA() { return new ProductA1(); } AbstractProductB createProductB() { return new ProductB1(); } } public class ConcreteFactory2 extends AbstractFactory { AbstractProductA createProductA() { return new ProductA2(); } AbstractProductB createProductB() { return new ProductB2(); } } public class Client { public static void main(String[] args) { AbstractFactory abstractFactory = new ConcreteFactory1(); AbstractProductA productA = abstractFactory.createProductA(); AbstractProductB productB = abstractFactory.createProductB(); // do something with productA and productB } } "},{"id":192,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B5%E7%94%9F%E6%88%90%E5%99%A8Builder/","title":"设计模式：一、创建型：5、生成器（ Builder）","parent":"3、Design Patterns","content":" 5、生成器（Builder） Intent 封装一个对象的构造过程，并允许按步骤构造。\nClass Diagram Implementation 以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。\npublic class AbstractStringBuilder { protected char[] value; protected int count; public AbstractStringBuilder(int capacity) { count = 0; value = new char[capacity]; } public AbstractStringBuilder append(char c) { ensureCapacityInternal(count + 1); value[count++] = c; return this; } private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code if (minimumCapacity - value.length \u0026gt; 0) expandCapacity(minimumCapacity); } void expandCapacity(int minimumCapacity) { int newCapacity = value.length * 2 + 2; if (newCapacity - minimumCapacity \u0026lt; 0) newCapacity = minimumCapacity; if (newCapacity \u0026lt; 0) { if (minimumCapacity \u0026lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; } value = Arrays.copyOf(value, newCapacity); } } public class StringBuilder extends AbstractStringBuilder { public StringBuilder() { super(16); } @Override public String toString() { // Create a copy, don\u0026#39;t share the array return new String(value, 0, count); } } public class Client { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); final int count = 26; for (int i = 0; i \u0026lt; count; i++) { sb.append((char) (\u0026#39;a\u0026#39; + i)); } System.out.println(sb.toString()); } } abcdefghijklmnopqrstuvwxyz "},{"id":193,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B6%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FPrototype/","title":"设计模式：一、创建型：6、原型模式（ Prototype）","parent":"3、Design Patterns","content":" 6、原型模式（Prototype） Intent 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。\nClass Diagram Implementation public abstract class Prototype { abstract Prototype myClone(); } public class ConcretePrototype extends Prototype { private String filed; public ConcretePrototype(String filed) { this.filed = filed; } @Override Prototype myClone() { return new ConcretePrototype(filed); } @Override public String toString() { return filed; } } public class Client { public static void main(String[] args) { Prototype prototype = new ConcretePrototype(\u0026#34;abc\u0026#34;); Prototype clone = prototype.myClone(); System.out.println(clone.toString()); } } abc "},{"id":194,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B1-%E9%80%82%E9%85%8D%E5%99%A8Adapter/","title":"设计模式：三、结构型：1、 适配器（ Adapter）","parent":"3、Design Patterns","content":" 1、适配器（Adapter） Intent 把一个类接口转换成另一个用户需要的接口。\nJava 的 IO 流设计就有利用适配器模式，将不同来源的数据转为字节流或字符流\nClass Diagram Implementation 鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。\n要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！\npublic interface Duck { void quack(); } public interface Turkey { void gobble(); } public class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(\u0026#34;gobble!\u0026#34;); } } public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.gobble(); } } public class Client { public static void main(String[] args) { Turkey turkey = new WildTurkey(); Duck duck = new TurkeyAdapter(turkey); duck.quack(); } } gobble! "},{"id":195,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B2-%E6%A1%A5%E6%8E%A5Bridge/","title":"设计模式：三、结构型：2、 桥接（ Bridge）","parent":"3、Design Patterns","content":" 2、 桥接（Bridge） Intent 将抽象与实现分离开来，使它们可以独立变化。\nClass Diagram Abstraction：定义抽象类的接口 Implementor：定义实现类接口 Implementation RemoteControl 表示遥控器，指代 Abstraction。\nTV 表示电视，指代 Implementor。\n桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。\npublic abstract class TV { public abstract void on(); public abstract void off(); public abstract void tuneChannel(); } public class Sony extends TV { @Override public void on() { System.out.println(\u0026#34;Sony.on()\u0026#34;); } @Override public void off() { System.out.println(\u0026#34;Sony.off()\u0026#34;); } @Override public void tuneChannel() { System.out.println(\u0026#34;Sony.tuneChannel()\u0026#34;); } } public class RCA extends TV { @Override public void on() { System.out.println(\u0026#34;RCA.on()\u0026#34;); } @Override public void off() { System.out.println(\u0026#34;RCA.off()\u0026#34;); } @Override public void tuneChannel() { System.out.println(\u0026#34;RCA.tuneChannel()\u0026#34;); } } public abstract class RemoteControl { protected TV tv; public RemoteControl(TV tv) { this.tv = tv; } public abstract void on(); public abstract void off(); public abstract void tuneChannel(); } public class ConcreteRemoteControl1 extends RemoteControl { public ConcreteRemoteControl1(TV tv) { super(tv); } @Override public void on() { System.out.println(\u0026#34;ConcreteRemoteControl1.on()\u0026#34;); tv.on(); } @Override public void off() { System.out.println(\u0026#34;ConcreteRemoteControl1.off()\u0026#34;); tv.off(); } @Override public void tuneChannel() { System.out.println(\u0026#34;ConcreteRemoteControl1.tuneChannel()\u0026#34;); tv.tuneChannel(); } } public class ConcreteRemoteControl2 extends RemoteControl { public ConcreteRemoteControl2(TV tv) { super(tv); } @Override public void on() { System.out.println(\u0026#34;ConcreteRemoteControl2.on()\u0026#34;); tv.on(); } @Override public void off() { System.out.println(\u0026#34;ConcreteRemoteControl2.off()\u0026#34;); tv.off(); } @Override public void tuneChannel() { System.out.println(\u0026#34;ConcreteRemoteControl2.tuneChannel()\u0026#34;); tv.tuneChannel(); } } public class Client { public static void main(String[] args) { RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA()); remoteControl1.on(); remoteControl1.off(); remoteControl1.tuneChannel(); RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony()); remoteControl2.on(); remoteControl2.off(); remoteControl2.tuneChannel(); } } "},{"id":196,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B3-%E7%BB%84%E5%90%88Composite/","title":"设计模式：三、结构型：3、 组合（ Composite）","parent":"3、Design Patterns","content":" 3、 组合（Composite） Intent 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。\nClass Diagram 组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。\n组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。\nImplementation RemoteControl 表示遥控器，指代 Abstraction。\nTV 表示电视，指代 Implementor。\n桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。\npublic abstract class Component { protected String name; public Component(String name) { this.name = name; } public void print() { print(0); } abstract void print(int level); abstract public void add(Component component); abstract public void remove(Component component); } public class Composite extends Component { private List\u0026lt;Component\u0026gt; child; public Composite(String name) { super(name); child = new ArrayList\u0026lt;\u0026gt;(); } @Override void print(int level) { for (int i = 0; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(\u0026#34;Composite:\u0026#34; + name); for (Component component : child) { component.print(level + 1); } } @Override public void add(Component component) { child.add(component); } @Override public void remove(Component component) { child.remove(component); } } public class Leaf extends Component { public Leaf(String name) { super(name); } @Override void print(int level) { for (int i = 0; i \u0026lt; level; i++) { System.out.print(\u0026#34;--\u0026#34;); } System.out.println(\u0026#34;left:\u0026#34; + name); } @Override public void add(Component component) { throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点 } @Override public void remove(Component component) { throw new UnsupportedOperationException(); } } public class Client { public static void main(String[] args) { Composite root = new Composite(\u0026#34;root\u0026#34;); Component node1 = new Leaf(\u0026#34;1\u0026#34;); Component node2 = new Composite(\u0026#34;2\u0026#34;); Component node3 = new Leaf(\u0026#34;3\u0026#34;); root.add(node1); root.add(node2); root.add(node3); Component node21 = new Leaf(\u0026#34;21\u0026#34;); Component node22 = new Composite(\u0026#34;22\u0026#34;); node2.add(node21); node2.add(node22); Component node221 = new Leaf(\u0026#34;221\u0026#34;); node22.add(node221); root.print(); } } Composite:root\r--left:1\r--Composite:2\r----left:21\r----Composite:22\r------left:221\r--left:3 "},{"id":197,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B4-%E8%A3%85%E9%A5%B0Decorator/","title":"设计模式：三、结构型：4、 装饰（ Decorator）","parent":"3、Design Patterns","content":" 4、 装饰（Decorator） Intent 为对象动态添加功能。\nClass Diagram 装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。\nImplementation 设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。\n下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。\n/** * 饮料 */ public interface Beverage { /** * 费用，成本 * @return */ double cost(); } /** * 焦炒咖啡 */ public class DarkRoast implements Beverage { @Override public double cost() { return 1; } } /** * 首选咖啡 */ public class HouseBlend implements Beverage { @Override public double cost() { return 1; } } /** * 调味品装饰 */ public abstract class CondimentDecorator implements Beverage { protected Beverage beverage; } public class Milk extends CondimentDecorator { public Milk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 1 + beverage.cost(); } } public class Mocha extends CondimentDecorator { public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 1 + beverage.cost(); } } public class Client { public static void main(String[] args) { Beverage beverage = new HouseBlend(); beverage = new Mocha(beverage); beverage = new Milk(beverage); System.out.println(beverage.cost()); } } 3.0 设计原则 类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。\n不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。\n"},{"id":198,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B5-%E5%A4%96%E8%A7%82Facade/","title":"设计模式：三、结构型：5、 外观（ Facade）","parent":"3、Design Patterns","content":" 5、 外观（Facade） Intent 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。\nClass Diagram Implementation 观看电影需要操作很多电器，使用外观模式实现一键看电影功能。\npublic class SubSystem { public void turnOnTV() { System.out.println(\u0026#34;turnOnTV()\u0026#34;); } public void setCD(String cd) { System.out.println(\u0026#34;setCD( \u0026#34; + cd + \u0026#34; )\u0026#34;); } public void startWatching(){ System.out.println(\u0026#34;startWatching()\u0026#34;); } } public class Facade { private SubSystem subSystem = new SubSystem(); public void watchMovie() { subSystem.turnOnTV(); subSystem.setCD(\u0026#34;a movie\u0026#34;); subSystem.startWatching(); } } public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.watchMovie(); } } 设计原则 最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。\n"},{"id":199,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B6-%E4%BA%AB%E5%85%83Flyweight/","title":"设计模式：三、结构型：6、 享元（ Flyweight）","parent":"3、Design Patterns","content":" 6、 享元（Flyweight） Intent 利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。\nClass Diagram Flyweight：享元对象 IntrinsicState：内部状态，享元对象共享内部状态 ExtrinsicState：外部状态，每个享元对象的外部状态不同\nImplementation Flyweight：享元对象 IntrinsicState：内部状态，享元对象共享内部状态 ExtrinsicState：外部状态，每个享元对象的外部状态不同 public interface Flyweight { void doOperation(String extrinsicState); } public class ConcreteFlyweight implements Flyweight { private String intrinsicState; public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void doOperation(String extrinsicState) { System.out.println(\u0026#34;Object address: \u0026#34; + System.identityHashCode(this)); System.out.println(\u0026#34;IntrinsicState: \u0026#34; + intrinsicState); System.out.println(\u0026#34;ExtrinsicState: \u0026#34; + extrinsicState); } } public class FlyweightFactory { private HashMap\u0026lt;String, Flyweight\u0026gt; flyweights = new HashMap\u0026lt;\u0026gt;(); Flyweight getFlyweight(String intrinsicState) { if (!flyweights.containsKey(intrinsicState)) { Flyweight flyweight = new ConcreteFlyweight(intrinsicState); flyweights.put(intrinsicState, flyweight); } return flyweights.get(intrinsicState); } } public class Client { public static void main(String[] args) { FlyweightFactory factory = new FlyweightFactory(); Flyweight flyweight1 = factory.getFlyweight(\u0026#34;aa\u0026#34;); Flyweight flyweight2 = factory.getFlyweight(\u0026#34;aa\u0026#34;); flyweight1.doOperation(\u0026#34;x\u0026#34;); flyweight2.doOperation(\u0026#34;y\u0026#34;); } } Object address: 1163157884\rIntrinsicState: aa\rExtrinsicState: x\rObject address: 1163157884\rIntrinsicState: aa\rExtrinsicState: y 设计原则 JDK Java 利用缓存来加速大量小对象的访问时间。\n"},{"id":200,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B7-%E4%BB%A3%E7%90%86Proxy/","title":"设计模式：三、结构型：7、 代理（ Proxy）","parent":"3、Design Patterns","content":" 7、 代理（Proxy） Intent 控制对其它对象的访问。\nClass Diagram 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。 Implementation 以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。\npublic interface Image { void showImage(); } public class HighResolutionImage implements Image { private URL imageURL; private long startTime; private int height; private int width; public int getHeight() { return height; } public int getWidth() { return width; } public HighResolutionImage(URL imageURL) { this.imageURL = imageURL; this.startTime = System.currentTimeMillis(); this.width = 600; this.height = 600; } public boolean isLoad() { // 模拟图片加载，延迟 3s 加载完成 long endTime = System.currentTimeMillis(); return endTime - startTime \u0026gt; 3000; } @Override public void showImage() { System.out.println(\u0026#34;Real Image: \u0026#34; + imageURL); } } public class ImageProxy implements Image { private HighResolutionImage highResolutionImage; public ImageProxy(HighResolutionImage highResolutionImage) { this.highResolutionImage = highResolutionImage; } @Override public void showImage() { while (!highResolutionImage.isLoad()) { try { System.out.println(\u0026#34;Temp Image: \u0026#34; + highResolutionImage.getWidth() + \u0026#34; \u0026#34; + highResolutionImage.getHeight()); Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } highResolutionImage.showImage(); } } public class ImageViewer { public static void main(String[] args) throws Exception { String image = \u0026#34;http://image.jpg\u0026#34;; URL url = new URL(image); HighResolutionImage highResolutionImage = new HighResolutionImage(url); ImageProxy imageProxy = new ImageProxy(highResolutionImage); imageProxy.showImage(); } } 设计原则 JDK java.lang.reflect.Proxy RMI。 "},{"id":201,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B10-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95Template-Method/","title":"设计模式：二、行为型：10、 模板方法（ Template Method）","parent":"3、Design Patterns","content":" 10、 模板方法（Template Method） Intent 定义算法框架，并将一些步骤的实现延迟到子类。\n通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。\nClass Diagram Implementation 冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 public abstract class CaffeineBeverage { final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } abstract void brew(); abstract void addCondiments(); void boilWater() { System.out.println(\u0026#34;boilWater\u0026#34;); } void pourInCup() { System.out.println(\u0026#34;pourInCup\u0026#34;); } } public class Coffee extends CaffeineBeverage { @Override void brew() { System.out.println(\u0026#34;Coffee.brew\u0026#34;); } @Override void addCondiments() { System.out.println(\u0026#34;Coffee.addCondiments\u0026#34;); } } public class Tea extends CaffeineBeverage { @Override void brew() { System.out.println(\u0026#34;Tea.brew\u0026#34;); } @Override void addCondiments() { System.out.println(\u0026#34;Tea.addCondiments\u0026#34;); } } public class Client { public static void main(String[] args) { CaffeineBeverage caffeineBeverage = new Coffee(); caffeineBeverage.prepareRecipe(); System.out.println(\u0026#34;-----------\u0026#34;); caffeineBeverage = new Tea(); caffeineBeverage.prepareRecipe(); } } boilWater\rCoffee.brew\rpourInCup\rCoffee.addCondiments\r-----------\rboilWater\rTea.brew\rpourInCup\rTea.addCondiments "},{"id":202,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B11-%E8%AE%BF%E9%97%AE%E8%80%85Visitor/","title":"设计模式：二、行为型：11、 访问者（ Visitor）","parent":"3、Design Patterns","content":" 11、 访问者（Visitor） Intent 为一个对象结构（比如组合结构）增加新能力。\nClass Diagram Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor：具体访问者，存储遍历过程中的累计结果 ObjectStructure：对象结构，可以是组合结构，或者是一个集合。 Implementation /** * Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 */ public interface Visitor { /** * 访问，参观； * @param customer 顾客 */ void visit(Customer customer); void visit(Order order); void visit(Item item); } /** * 具体访问者，存储遍历过程中的累计结果 */ public class GeneralReport implements Visitor { private int customersNo; private int ordersNo; private int itemsNo; public void visit(Customer customer) { System.out.println(customer.getName()); customersNo++; } public void visit(Order order) { System.out.println(order.getName()); ordersNo++; } public void visit(Item item) { System.out.println(item.getName()); itemsNo++; } /** * 显示结果 */ public void displayResults() { System.out.println(\u0026#34;Number of customers: \u0026#34; + customersNo); System.out.println(\u0026#34;Number of orders: \u0026#34; + ordersNo); System.out.println(\u0026#34;Number of items: \u0026#34; + itemsNo); } } /** * 元素，对象结构，可以是组合结构，或者是一个集合。 */ public interface Element { /** * 接受；承认；承担；承兑；容纳 * @param visitor 访问者，参观者；视察者； */ void accept(Visitor visitor); } /** * 顾客； */ public class Customer implements Element { private String name; private List\u0026lt;Order\u0026gt; orders = new ArrayList\u0026lt;\u0026gt;(); Customer(String name) { this.name = name; } String getName() { return name; } void addOrder(Order order) { orders.add(order); } public void accept(Visitor visitor) { visitor.visit(this); for (Order order : orders) { order.accept(visitor); } } } /** * 顾客 组 */ class CustomerGroup { private List\u0026lt;Customer\u0026gt; customers = new ArrayList\u0026lt;\u0026gt;(); void accept(Visitor visitor) { for (Customer customer : customers) { customer.accept(visitor); } } void addCustomer(Customer customer) { customers.add(customer); } } public class Order implements Element { private String name; private List\u0026lt;Item\u0026gt; items = new ArrayList(); Order(String name) { this.name = name; } Order(String name, String itemName) { this.name = name; this.addItem(new Item(itemName)); } String getName() { return name; } void addItem(Item item) { items.add(item); } public void accept(Visitor visitor) { visitor.visit(this); for (Item item : items) { item.accept(visitor); } } } public class Item implements Element { private String name; Item(String name) { this.name = name; } String getName() { return name; } public void accept(Visitor visitor) { visitor.visit(this); } } public class Client { public static void main(String[] args) { Customer customer1 = new Customer(\u0026#34;customer1\u0026#34;); customer1.addOrder(new Order(\u0026#34;order1\u0026#34;, \u0026#34;item1\u0026#34;)); customer1.addOrder(new Order(\u0026#34;order2\u0026#34;, \u0026#34;item1\u0026#34;)); customer1.addOrder(new Order(\u0026#34;order3\u0026#34;, \u0026#34;item1\u0026#34;)); Order order = new Order(\u0026#34;order_a\u0026#34;); order.addItem(new Item(\u0026#34;item_a1\u0026#34;)); order.addItem(new Item(\u0026#34;item_a2\u0026#34;)); order.addItem(new Item(\u0026#34;item_a3\u0026#34;)); Customer customer2 = new Customer(\u0026#34;customer2\u0026#34;); customer2.addOrder(order); CustomerGroup customers = new CustomerGroup(); customers.addCustomer(customer1); customers.addCustomer(customer2); GeneralReport visitor = new GeneralReport(); customers.accept(visitor); visitor.displayResults(); } } customer1\rorder1\ritem1\rorder2\ritem1\rorder3\ritem1\rcustomer2\rorder_a\ritem_a1\ritem_a2\ritem_a3\rNumber of customers: 2\rNumber of orders: 4\rNumber of items: 6 "},{"id":203,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B12-%E7%A9%BA%E5%AF%B9%E8%B1%A1Null/","title":"设计模式：二、行为型：12、 空对象（ Null）","parent":"3、Design Patterns","content":" 12、 空对象（Null） Intent 使用什么都不做\n的空对象来代替 NULL。\n一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。\nClass Diagram Implementation public abstract class AbstractOperation { abstract void request(); } public class RealOperation extends AbstractOperation { @Override void request() { System.out.println(\u0026#34;do something\u0026#34;); } } public class NullOperation extends AbstractOperation{ @Override void request() { // do nothing } } public class Client { public static void main(String[] args) { AbstractOperation abstractOperation = func(-1); abstractOperation.request(); } public static AbstractOperation func(int para) { if (para \u0026lt; 0) { return new NullOperation(); } return new RealOperation(); } } boilWater\rCoffee.brew\rpourInCup\rCoffee.addCondiments\r-----------\rboilWater\rTea.brew\rpourInCup\rTea.addCondiments "},{"id":204,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B1%E8%B4%A3%E4%BB%BB%E9%93%BEChain-Of-Responsibility/","title":"设计模式：二、行为型：1、责任链（ Chain of Responsibility）","parent":"3、Design Patterns","content":" 1、责任链（Chain Of Responsibility） Intent 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。\nClass Diagram Handler：定义处理请求的接口，并且实现后继链（successor） Implementation public abstract class Handler { protected Handler successor; public Handler(Handler successor) { this.successor = successor; } protected abstract void handleRequest(Request request); } public class ConcreteHandler1 extends Handler { public ConcreteHandler1(Handler successor) { super(successor); } @Override protected void handleRequest(Request request) { if (request.getType() == RequestType.TYPE1) { System.out.println(request.getName() + \u0026#34; is handle by ConcreteHandler1\u0026#34;); return; } if (successor != null) { successor.handleRequest(request); } } } public class ConcreteHandler2 extends Handler { public ConcreteHandler2(Handler successor) { super(successor); } @Override protected void handleRequest(Request request) { if (request.getType() == RequestType.TYPE2) { System.out.println(request.getName() + \u0026#34; is handle by ConcreteHandler2\u0026#34;); return; } if (successor != null) { successor.handleRequest(request); } } } public class Request { private RequestType type; private String name; public Request(RequestType type, String name) { this.type = type; this.name = name; } public RequestType getType() { return type; } public String getName() { return name; } } public enum RequestType { TYPE1, TYPE2 } public class Client { public static void main(String[] args) { Handler handler1 = new ConcreteHandler1(null); Handler handler2 = new ConcreteHandler2(handler1); Request request1 = new Request(RequestType.TYPE1, \u0026#34;request1\u0026#34;); handler2.handleRequest(request1); Request request2 = new Request(RequestType.TYPE2, \u0026#34;request2\u0026#34;); handler2.handleRequest(request2); } } request1 is handle by ConcreteHandler1\rrequest2 is handle by ConcreteHandler2 "},{"id":205,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B2%E5%91%BD%E4%BB%A4Command/","title":"设计模式：二、行为型：2、命令（ Command）","parent":"3、Design Patterns","content":" 2、命令（Command） Intent 将命令封装成对象中，具有以下作用：\n使用命令来参数化其它对象 将命令放入队列中进行排队 将命令的操作记录到日志中 支持可撤销的操作 Class Diagram Command：命令 Receiver：命令接收者，也就是命令真正的执行者 Invoker：通过它来调用命令 Client：可以设置命令与命令的接收者 Implementation 设计一个遥控器，可以控制电灯开关。\npublic interface Command { void execute(); } public class LightOnCommand implements Command { Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.on(); } } public class LightOffCommand implements Command { Light light; public LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.off(); } } public class Light { public void on() { System.out.println(\u0026#34;Light is on!\u0026#34;); } public void off() { System.out.println(\u0026#34;Light is off!\u0026#34;); } } /** * 遥控器 */ public class Invoker { private Command[] onCommands; private Command[] offCommands; private final int slotNum = 7; public Invoker() { this.onCommands = new Command[slotNum]; this.offCommands = new Command[slotNum]; } public void setOnCommand(Command command, int slot) { onCommands[slot] = command; } public void setOffCommand(Command command, int slot) { offCommands[slot] = command; } public void onButtonWasPushed(int slot) { onCommands[slot].execute(); } public void offButtonWasPushed(int slot) { offCommands[slot].execute(); } } public class Client { public static void main(String[] args) { Invoker invoker = new Invoker(); Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); invoker.setOnCommand(lightOnCommand, 0); invoker.setOffCommand(lightOffCommand, 0); invoker.onButtonWasPushed(0); invoker.offButtonWasPushed(0); } } "},{"id":206,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B3%E8%A7%A3%E9%87%8A%E5%99%A8Interpreter/","title":"设计模式：二、行为型：3、解释器（ Interpreter）","parent":"3、Design Patterns","content":" 3、解释器（Interpreter） Intent 为语言创建解释器，通常由语言的语法和语法分析来定义。\nClass Diagram TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。 Context：上下文，包含解释器之外的一些全局信息。 Implementation public interface Aggregate { Iterator createIterator(); } public class ConcreteAggregate implements Aggregate { private Integer[] items; public ConcreteAggregate() { items = new Integer[10]; for (int i = 0; i \u0026lt; items.length; i++) { items[i] = i; } } @Override public Iterator createIterator() { return new ConcreteIterator\u0026lt;Integer\u0026gt;(items); } } public interface Iterator\u0026lt;Item\u0026gt; { Item next(); boolean hasNext(); } public class ConcreteIterator\u0026lt;Item\u0026gt; implements Iterator { private Item[] items; private int position = 0; public ConcreteIterator(Item[] items) { this.items = items; } @Override public Object next() { return items[position++]; } @Override public boolean hasNext() { return position \u0026lt; items.length; } } public class Client { public static void main(String[] args) { Aggregate aggregate = new ConcreteAggregate(); Iterator\u0026lt;Integer\u0026gt; iterator = aggregate.createIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } "},{"id":207,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B4%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/","title":"设计模式：二、行为型：4、迭代器（ Iterator）","parent":"3、Design Patterns","content":" 4、迭代器（Iterator） Intent 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。\nClass Diagram Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator； Iterator 主要定义了 hasNext() 和 next() 方法； Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。 Implementation 以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。\n例如一颗解析树为 D And (A Or (B C))，文本 \u0026ldquo;D A\u0026rdquo; 满足该解析树定义的规则。\n这里的 Context 指的是 String\npublic abstract class Expression { public abstract boolean interpret(String str); } public class TerminalExpression extends Expression { private String literal = null; public TerminalExpression(String str) { literal = str; } public boolean interpret(String str) { StringTokenizer st = new StringTokenizer(str); while (st.hasMoreTokens()) { String test = st.nextToken(); if (test.equals(literal)) { return true; } } return false; } } public class AndExpression extends Expression { private Expression expression1 = null; private Expression expression2 = null; public AndExpression(Expression expression1, Expression expression2) { this.expression1 = expression1; this.expression2 = expression2; } public boolean interpret(String str) { return expression1.interpret(str) \u0026amp;\u0026amp; expression2.interpret(str); } } public class OrExpression extends Expression { private Expression expression1 = null; private Expression expression2 = null; public OrExpression(Expression expression1, Expression expression2) { this.expression1 = expression1; this.expression2 = expression2; } public boolean interpret(String str) { return expression1.interpret(str) || expression2.interpret(str); } } public class Client { /** * 构建解析树 */ public static Expression buildInterpreterTree() { // Literal Expression terminal1 = new TerminalExpression(\u0026#34;A\u0026#34;); Expression terminal2 = new TerminalExpression(\u0026#34;B\u0026#34;); Expression terminal3 = new TerminalExpression(\u0026#34;C\u0026#34;); Expression terminal4 = new TerminalExpression(\u0026#34;D\u0026#34;); // B C Expression alternation1 = new OrExpression(terminal2, terminal3); // A Or (B C) Expression alternation2 = new OrExpression(terminal1, alternation1); // D And (A Or (B C)) return new AndExpression(terminal4, alternation2); } public static void main(String[] args) { Expression define = buildInterpreterTree(); String context1 = \u0026#34;D A\u0026#34;; String context2 = \u0026#34;A B\u0026#34;; System.out.println(define.interpret(context1)); System.out.println(define.interpret(context2)); } } true false "},{"id":208,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B5%E4%B8%AD%E4%BB%8B%E8%80%85Mediator/","title":"设计模式：二、行为型：5、中介者（ Mediator）","parent":"3、Design Patterns","content":" 5、中介者（Mediator） Intent 集中相关对象之间复杂的沟通和控制方式。（改变多个对象间的拓扑结构）\nClass Diagram Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。 Colleague：同事，相关对象 Implementation Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：\n使用中介者模式可以将复杂的依赖结构变成星形结构：\n/** * Colleague 同事类 * Mediator 中介物 */ public abstract class Colleague { public abstract void onEvent(Mediator mediator); } public class Alarm extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;alarm\u0026#34;); } public void doAlarm() { System.out.println(\u0026#34;doAlarm()\u0026#34;); } } public class CoffeePot extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;coffeePot\u0026#34;); } public void doCoffeePot() { System.out.println(\u0026#34;doCoffeePot()\u0026#34;); } } public class Calender extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;calender\u0026#34;); } public void doCalender() { System.out.println(\u0026#34;doCalender()\u0026#34;); } } public class Sprinkler extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(\u0026#34;sprinkler\u0026#34;); } public void doSprinkler() { System.out.println(\u0026#34;doSprinkler()\u0026#34;); } } public abstract class Mediator { public abstract void doEvent(String eventType); } public class ConcreteMediator extends Mediator { private Alarm alarm; private CoffeePot coffeePot; private Calender calender; private Sprinkler sprinkler; public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) { this.alarm = alarm; this.coffeePot = coffeePot; this.calender = calender; this.sprinkler = sprinkler; } @Override public void doEvent(String eventType) { switch (eventType) { case \u0026#34;alarm\u0026#34;: doAlarmEvent(); break; case \u0026#34;coffeePot\u0026#34;: doCoffeePotEvent(); break; case \u0026#34;calender\u0026#34;: doCalenderEvent(); break; default: doSprinklerEvent(); } } public void doAlarmEvent() { alarm.doAlarm(); coffeePot.doCoffeePot(); calender.doCalender(); sprinkler.doSprinkler(); } public void doCoffeePotEvent() { // ... } public void doCalenderEvent() { // ... } public void doSprinklerEvent() { // ... } } public class Client { public static void main(String[] args) { Alarm alarm = new Alarm(); CoffeePot coffeePot = new CoffeePot(); Calender calender = new Calender(); Sprinkler sprinkler = new Sprinkler(); Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler); // 闹钟事件到达，调用中介者就可以操作相关对象 alarm.onEvent(mediator); } } doAlarm()\rdoCoffeePot()\rdoCalender()\rdoSprinkler() "},{"id":209,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B6%E5%A4%87%E5%BF%98%E5%BD%95Memento/","title":"设计模式：二、行为型：6、备忘录（ Memento）","parent":"3、Design Patterns","content":" 6、备忘录（Memento） Intent 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。\nClass Diagram Originator：原始对象 Caretaker：负责保存好备忘录 Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。 Implementation 以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。\n/** * Originator Interface */ public interface Calculator { // Create Memento PreviousCalculationToCareTaker backupLastCalculation(); // setMemento void restorePreviousCalculation(PreviousCalculationToCareTaker memento); int getCalculationResult(); void setFirstNumber(int firstNumber); void setSecondNumber(int secondNumber); } /** * Originator Implementation */ public class CalculatorImp implements Calculator { private int firstNumber; private int secondNumber; @Override public PreviousCalculationToCareTaker backupLastCalculation() { // create a memento object used for restoring two numbers return new PreviousCalculationImp(firstNumber, secondNumber); } @Override public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) { this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber(); this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber(); } @Override public int getCalculationResult() { // result is adding two numbers return firstNumber + secondNumber; } @Override public void setFirstNumber(int firstNumber) { this.firstNumber = firstNumber; } @Override public void setSecondNumber(int secondNumber) { this.secondNumber = secondNumber; } } /** * Memento Interface to Originator * * This interface allows the originator to restore its state */ public interface PreviousCalculationToOriginator { int getFirstNumber(); int getSecondNumber(); } /** * Memento interface to CalculatorOperator (Caretaker) */ public interface PreviousCalculationToCareTaker { // no operations permitted for the caretaker } /** * Memento Object Implementation * \u0026lt;p\u0026gt; * Note that this object implements both interfaces to Originator and CareTaker */ public class PreviousCalculationImp implements PreviousCalculationToCareTaker, PreviousCalculationToOriginator { private int firstNumber; private int secondNumber; public PreviousCalculationImp(int firstNumber, int secondNumber) { this.firstNumber = firstNumber; this.secondNumber = secondNumber; } @Override public int getFirstNumber() { return firstNumber; } @Override public int getSecondNumber() { return secondNumber; } } /** * CareTaker object */ public class Client { public static void main(String[] args) { // program starts Calculator calculator = new CalculatorImp(); // assume user enters two numbers calculator.setFirstNumber(10); calculator.setSecondNumber(100); // find result System.out.println(calculator.getCalculationResult()); // Store result of this calculation in case of error PreviousCalculationToCareTaker memento = calculator.backupLastCalculation(); // user enters a number calculator.setFirstNumber(17); // user enters a wrong second number and calculates result calculator.setSecondNumber(-290); // calculate result System.out.println(calculator.getCalculationResult()); // user hits CTRL + Z to undo last operation and see last result calculator.restorePreviousCalculation(memento); // result restored System.out.println(calculator.getCalculationResult()); } } 110\r-273\r110 "},{"id":210,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B7%E8%A7%82%E5%AF%9F%E8%80%85Observer/","title":"设计模式：二、行为型：7、观察者（ Observer）","parent":"3、Design Patterns","content":" 7、观察者（Observer） Intent 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。\n主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。\nClass Diagram 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。 Implementation 天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。\n/** * 主题 */ public interface Subject { /** * 登记 观察者 * @param o */ void registerObserver(Observer o); /** * 删除 观察者 * @param o */ void removeObserver(Observer o); /** * 通知 观察者 */ void notifyObserver(); } public class WeatherData implements Subject { private List\u0026lt;Observer\u0026gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList\u0026lt;\u0026gt;(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); } @Override public void registerObserver(Observer o) { observers.add(o); } @Override public void removeObserver(Observer o) { int i = observers.indexOf(o); if (i \u0026gt;= 0) { observers.remove(i); } } @Override public void notifyObserver() { for (Observer o : observers) { o.update(temperature, humidity, pressure); } } } /** * 观察者 */ public interface Observer { /** * * @param temp * @param humidity * @param pressure */ void update(float temp, float humidity, float pressure); } public class StatisticsDisplay implements Observer { public StatisticsDisplay(Subject weatherData) { weatherData.registerObserver(this); } @Override public void update(float temp, float humidity, float pressure) { System.out.println(\u0026#34;StatisticsDisplay.update: \u0026#34; + temp + \u0026#34; \u0026#34; + humidity + \u0026#34; \u0026#34; + pressure); } } public class CurrentConditionsDisplay implements Observer { public CurrentConditionsDisplay(Subject weatherData) { weatherData.registerObserver(this); } @Override public void update(float temp, float humidity, float pressure) { System.out.println(\u0026#34;CurrentConditionsDisplay.update: \u0026#34; + temp + \u0026#34; \u0026#34; + humidity + \u0026#34; \u0026#34; + pressure); } } public class WeatherStation { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); } } CurrentConditionsDisplay.update: 0.0 0.0 0.0\rStatisticsDisplay.update: 0.0 0.0 0.0\rCurrentConditionsDisplay.update: 1.0 1.0 1.0\rStatisticsDisplay.update: 1.0 1.0 1.0 "},{"id":211,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B8%E7%8A%B6%E6%80%81State/","title":"设计模式：二、行为型：8、状态（ State）","parent":"3、Design Patterns","content":" 8、状态（State） Intent 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。\nClass Diagram Implementation 糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。 public interface State { /** * 投入 25 分钱 */ void insertQuarter(); /** * 退回 25 分钱 */ void ejectQuarter(); /** * 转动曲柄 */ void turnCrank(); /** * 发放糖果 */ void dispense(); } public class HasQuarterState implements State { private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;You can\u0026#39;t insert another quarter\u0026#34;); } @Override public void ejectQuarter() { System.out.println(\u0026#34;Quarter returned\u0026#34;); gumballMachine.setState(gumballMachine.getNoQuarterState()); } @Override public void turnCrank() { System.out.println(\u0026#34;You turned...\u0026#34;); gumballMachine.setState(gumballMachine.getSoldState()); } @Override public void dispense() { System.out.println(\u0026#34;No gumball dispensed\u0026#34;); } } public class NoQuarterState implements State { GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;You insert a quarter\u0026#34;); gumballMachine.setState(gumballMachine.getHasQuarterState()); } @Override public void ejectQuarter() { System.out.println(\u0026#34;You haven\u0026#39;t insert a quarter\u0026#34;); } @Override public void turnCrank() { System.out.println(\u0026#34;You turned, but there\u0026#39;s no quarter\u0026#34;); } @Override public void dispense() { System.out.println(\u0026#34;You need to pay first\u0026#34;); } } public class SoldOutState implements State { GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;You can\u0026#39;t insert a quarter, the machine is sold out\u0026#34;); } @Override public void ejectQuarter() { System.out.println(\u0026#34;You can\u0026#39;t eject, you haven\u0026#39;t inserted a quarter yet\u0026#34;); } @Override public void turnCrank() { System.out.println(\u0026#34;You turned, but there are no gumballs\u0026#34;); } @Override public void dispense() { System.out.println(\u0026#34;No gumball dispensed\u0026#34;); } } public class SoldState implements State { GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(\u0026#34;Please wait, we\u0026#39;re already giving you a gumball\u0026#34;); } @Override public void ejectQuarter() { System.out.println(\u0026#34;Sorry, you already turned the crank\u0026#34;); } @Override public void turnCrank() { System.out.println(\u0026#34;Turning twice doesn\u0026#39;t get you another gumball!\u0026#34;); } @Override public void dispense() { gumballMachine.releaseBall(); if (gumballMachine.getCount() \u0026gt; 0) { gumballMachine.setState(gumballMachine.getNoQuarterState()); } else { System.out.println(\u0026#34;Oops, out of gumballs\u0026#34;); gumballMachine.setState(gumballMachine.getSoldOutState()); } } } public class GumballMachine { private State soldOutState; private State noQuarterState; private State hasQuarterState; private State soldState; private State state; private int count = 0; public GumballMachine(int numberGumballs) { count = numberGumballs; soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); if (numberGumballs \u0026gt; 0) { state = noQuarterState; } else { state = soldOutState; } } public void insertQuarter() { state.insertQuarter(); } public void ejectQuarter() { state.ejectQuarter(); } public void turnCrank() { state.turnCrank(); state.dispense(); } public void setState(State state) { this.state = state; } public void releaseBall() { System.out.println(\u0026#34;A gumball comes rolling out the slot...\u0026#34;); if (count != 0) { count -= 1; } } public State getSoldOutState() { return soldOutState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getSoldState() { return soldState; } public int getCount() { return count; } } public class Client { public static void main(String[] args) { GumballMachine gumballMachine = new GumballMachine(5); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); } } You insert a quarter\rYou turned...\rA gumball comes rolling out the slot...\rYou insert a quarter\rQuarter returned\rYou turned, but there\u0026#39;s no quarter\rYou need to pay first\rYou insert a quarter\rYou turned...\rA gumball comes rolling out the slot...\rYou insert a quarter\rYou turned...\rA gumball comes rolling out the slot...\rYou haven\u0026#39;t insert a quarter\rYou insert a quarter\rYou can\u0026#39;t insert another quarter\rYou turned...\rA gumball comes rolling out the slot...\rYou insert a quarter\rYou turned...\rA gumball comes rolling out the slot...\rOops, out of gumballs\rYou can\u0026#39;t insert a quarter, the machine is sold out\rYou turned, but there are no gumballs\rNo gumball dispensed "},{"id":212,"href":"/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B9-%E7%AD%96%E7%95%A5Strategy/","title":"设计模式：二、行为型：9、 策略（ Strategy）","parent":"3、Design Patterns","content":" 9、策略（Strategy） Intent 定义一系列算法，封装每个算法，并使它们可以互换。\n策略模式可以让算法独立于使用它的客户端。\nClass Diagram Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。 状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。\n状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。\nImplementation 设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。\npublic interface QuackBehavior { void quack(); } public class Quack implements QuackBehavior { @Override public void quack() { System.out.println(\u0026#34;quack!\u0026#34;); } } public class Squeak implements QuackBehavior{ @Override public void quack() { System.out.println(\u0026#34;squeak!\u0026#34;); } } public class Duck { private QuackBehavior quackBehavior; public void performQuack() { if (quackBehavior != null) { quackBehavior.quack(); } } public void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; } } public class Client { public static void main(String[] args) { Duck duck = new Duck(); duck.setQuackBehavior(new Squeak()); duck.performQuack(); duck.setQuackBehavior(new Quack()); duck.performQuack(); } } squeak!\rquack! "},{"id":213,"href":"/Tech/2Computer-Science/4Operating-System/ASCII/","title":"Ascii","parent":"4、Operating System","content":"美国信息交换标准代码 (ASCII) 是一种字符编码方案，它定义了字符的二进制表示。ASCII 表包含可打印字符和控制字符。ASCII 字符以 7 位编码，仅包含用英语编写文本所需的字符。后来开发了其他字符集（例如 Unicode）以支持所有书面语言。\n"},{"id":214,"href":"/Tech/2Computer-Science/4Operating-System/CMD_diskpart/","title":"Cmd Diskpart","parent":"4、Operating System","content":"DISKPART\u0026gt; list disk\r磁盘 ### 状态 大小 可用 Dyn Gpt\r-------- ------------- ------- ------- --- ---\r磁盘 0 联机 238 GB 0 B *\r磁盘 1 联机 931 GB 1024 KB *\r* 磁盘 2 联机 14 TB 1024 KB *\r磁盘 3 联机 7452 GB 7452 GB\rDISKPART\u0026gt; list volume\r卷 ### LTR 标签 FS 类型 大小 状态 信息\r---------- --- ----------- ----- ---------- ------- --------- --------\r卷 0 G 系统 NTFS 磁盘分区 237 GB 正常\r卷 1 FAT32 磁盘分区 300 MB 正常 已隐藏\r卷 2 NTFS 磁盘分区 596 MB 正常 已隐藏\r卷 3 C 系统 NTFS 磁盘分区 329 GB 正常 启动\r卷 4 D 新加卷 NTFS 磁盘分区 599 GB 正常\r卷 5 NTFS 磁盘分区 596 MB 正常 已隐藏\r卷 6 FAT32 磁盘分区 300 MB 正常 系统\r卷 7 NTFS 磁盘分区 597 MB 正常 已隐藏\r卷 8 E 新加卷 NTFS 磁盘分区 14 TB 正常\rDISKPART\u0026gt; detail disk\rJMicron H/W RAID5 SCSI Disk Device\r磁盘 ID: {FE5CC930-993A-4CF0-96A0-32EE693BD091}\r类型 : USB\r状态 : 联机\r路径 : 0\r目标 : 0\rLUN ID : 0\r位置路径 : UNAVAILABLE\r当前只读状态: 是\r只读: 是\r启动磁盘: 否\r页面文件磁盘: 否\r休眠文件磁盘: 否\r故障转储磁盘: 否\r群集磁盘 : 否\r卷 ### LTR 标签 FS 类型 大小 状态 信息\r---------- --- ----------- ----- ---------- ------- --------- --------\r卷 8 E 新加卷 NTFS 磁盘分区 14 TB 正常\rDISKPART\u0026gt; list partition\r分区 ### 类型 大小 偏移量\r------------- ---------------- ------- -------\r* 分区 1 保留 15 MB 17 KB\r分区 2 主要 14 TB 16 MB\r新磁盘首次被发现后，即被假定为 MBR 磁盘。在试图创建 GPT 分区之前，必须显式地将磁盘转换为 GPT。建议您将 MSR 创建为每个数据磁盘上的第一个分区以及任何系统或启动盘上的第二个分区（在 ESP 之后）。从 MBR 转换为 GPT 后，MSR 分区将在磁盘上自动创建。创建任何新的分区后，最近创建的分区会得到分区焦点。删除任何分区后，分区焦点也会丢失。磁盘焦点在任何情况下都保持不变。\r取消只读模式步骤：\r1、管理员模式打开 CMD；\r2、输入 diskpart，回车；\r3、输入 list volume 获得分区列表；\r4、输入 select volume [number] 指定分区；\r5、输入 attributes volume set readonly 设置只读模式。\r5、输入 attributes volume clear readonly 取消只读模式。 "},{"id":215,"href":"/Tech/2Computer-Science/4Operating-System/NTFS/NTFS%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BANTFS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/","title":"Ntfs格式化为 Ntfs后的原盘数据恢复方法","parent":"NTFS","content":" NTFS格式化为NTFS后的原盘数据恢复方法 NTFS的安全性能给数据恢复提供了很大的便利，在NTFS上出错后数据恢复的成功率还是不错的。 下面根据我自己的经历谈一谈NTFS格式化为NTFS后原盘数据恢复的方法。 NTFS格式化为NTFS后，在XP系统下只是重写了前32个MFT项，在WIN7系统下重写了前255个MFT项，在这种情况下，用软件扫一般都能恢复，但如果分区比较大，文件比较多的话，第一需要很长时间，第二碎片文件可能不容易恢复成功。所以我谈一下手工恢复的方法。 首先说一下手工恢复的思路，既然只是重写了前32个或前255个MFT，后面的MFT不变，所以只要在0号MFT上修改一下链接指向这些MFT，那么就能够实现原盘恢复了。 具体要修改的地方主要有4处（根据实际情况不同）：MFT起始簇号、80H属性的起始和结束VCN、属性体的分配、实际、初始大小和DATARUN数据。 具体步骤如下： 第一、MFT起始簇号。首先判断现在的MFT起始簇号是不是格式化前的MFT起始簇号。转到31号或是255号MFT，前后看看MFT号是否连续，如果连续，表明格式化前后的MFT起始簇号相同，如果不连续，表明格式化前后的MFT起始簇号不相同。起始簇号相同，则不用管它，记下这个起始簇号，后面要用到它的；起始簇号不相同，就要找原来的MFT起始簇号，也就是把现在的MFT起始簇号向前或向后提一下，同样记下现在的MFT起始簇号。 第二、80H属性的起始和结束VCN。搜索最后一项MFT，依据MFT头标志“46494C45”来搜索。这个地方要注意一些技巧，要先估计MFT的大小（一般300G的分区MFT应该不超过100M，当然特殊情况例外），然后相对0号MFT向后跳转估计大小的扇区，向上搜索最后一项MFT。由最后一项MFT即可确定MFT的簇数，从而确定结束的VCN。 第三、属性体的大小。由簇数×每簇扇区数×每扇区字节数，即可得到属性体的大小。 第四、DATARUN数据。包含簇数和起始簇号，这在前面已经算出来了，只需要转换成16进制填入即可。 当然，为了方便起见，用模板填写更容易。 这四步做完后，保存退出，然后重新加载，即可在winhex中看到找回的数据，原来的MFT记录在31号（XP系统）或255号（WIN7系统）之前是看不到的。当然在分区中还是没有数据，把这些数据导出保存（为了保险起见）。为什么在分区中没有数据呢？因为我们只修改了0号MFT，1——31号或1——255号MFT没有修改，手工修改太麻烦了，这时我们可用磁盘管理工具CHKDSK来帮忙，在运行中输入“CHKDSK G：/F”(G:表示要恢复数据分区的盘符），重新加载后，即可在分区中看到消失的数据又回来了（有一小部分数据没有回来，可在winhex中导出） "},{"id":216,"href":"/Tech/2Computer-Science/4Operating-System/NTFS/window/","title":"Window","parent":"NTFS","content":"偶然发现两个注册表分支中含有当前用户运行过的exe文件名，会在一定程度上造成信息泄露（仅在Windows10系统中测试过）\nHKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Compatibility Assistant\rHKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FeatureUsage\\AppSwitched chkdsk d: /r\nOSK.EXE 屏幕键盘 “osk.exe” 在命令提示符窗口输入\u0026quot;explorer.exe\u0026quot;启动桌面,成功进入SYSTEM账户桌面后按下“微软键+R\u0026quot;打开运行框,点击其中的“浏览\u0026quot; ,在打开的图形化窗口即可进行文件查找、浏览等操作\n"},{"id":217,"href":"/Tech/2Computer-Science/4Operating-System/NTFS/Windows-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","title":"Windows 文件系统","parent":"NTFS","content":" 分区表 转载自：嘿_lele\r链接：https://www.jianshu.com/p/8471b7f4152a\r来源：简书 1、硬盘基础知识 硬盘上的一个物理记录块要用三个参数来定位：柱面号、扇区号、磁头号。\n磁头数(Heads)： 表示硬盘总共有几个磁头,也就是有几面盘片， 最大为 255 (用 8 个二进制位存储)；\n磁道： 当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。\n扇区数(Sectors)： 磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，表示每一条磁道上有几个扇区, 最大为 63(用 6个二进制位存储)；每个扇区一般是 512个字节，理论上讲这不是必须的，但（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）。距离轴心近的磁道上包含的扇区比远的磁道要少很多。硬盘的读写以扇区为基本单位。\n柱面数（Cylinders）： 是指硬盘多个盘片上相同磁道的组合，盘片上的同心圆（磁道）圈数即是柱面数。表示硬盘每一面盘片上有几条磁道；硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。当向一个磁盘读写数据的时候,如果是连续IO,磁盘会比较倾向于按照柱面来进行,因为写完一个盘片的磁道,切换到另外一个盘片的相同磁道,只需要切换磁头就可以了,如果是连续在一个盘片上写几个磁道,就涉及到磁臂换道,这个是机械动作 ,就慢的多了,如果是离散IO,那磁臂基本就像振动的蜜蜂翅膀.\n低级格式化: 磁盘生产出来的时候,上面是没有什么磁道,扇区的东西的,低级格式化就是在每个盘片上划分,标明这些东西,而高级格式化,比如 WINDOWS 里面的格式化,他是绝对不会影响一个磁盘的磁道,扇区结构的,这好比低级格式化是造房子,打框架,高级格式化是给房子里面做装潢\n磁盘容量计算： 所以磁盘一柱面：512byte x 63 x 255＝8225280bytes ＝7.84423828125 MB\n硬盘容量 = 磁头数 × 柱面数（磁道数）× 扇区数 × 512字节，扇区越多，容量越大。\n块/簇： 磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。通俗的来讲，在 Windows 下如 NTFS 等文件系统中叫做簇；在 Linux 下如 Ext4 等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区\n2、扇区、块/簇、page 的关系 扇区： 硬盘的最小读写单元 块/簇： 是操作系统针对硬盘读写的最小单元 page： 是内存与操作系统之间操作的最小单元。 扇区 \u0026lt;= 块/簇 \u0026lt;= page 3、分区表基础知识 分区表是将大表的数据分成称为分区的许多小的子集，类型有 FAT32, NTFST32,NTFS。另外，分区表的种类划分主要有：range，list，和hash分区。划分依据主要是根据其表内部属性。同时，分区表可以创建其独特的分区索引。倘若硬盘丢失了分区表，数据就无法按顺序读取和写入，导致无法操作。\n硬盘分区结构信息： 偏移 长度（字节） 意义 00H 1 分区状态：00-\u0026gt;非活动分区；80-\u0026gt;活动分区；其他数值没有意义 01H 1 分区起始磁头号（HEAD），用到全部8位 02H 2 分区起始扇区号(SECTOR),占据02H的位0-5;该分区的起始磁柱号(CYLINDER),占据02H的位6-7和03H的全部8位 04H 1 文件系统标志 05H 1 分区结束磁头号（HEAD），用到全部8位 06H 2 分区结束扇区号(SECTOR),占据06H的位0-5;该分区的起始磁柱号(CYLINDER),占据06H的位6-7和07H的全部8位 08H 4 分区起始相对扇区号 0CH 4 分区总的扇区数 4、MBR 分区表 传统的分区方案(称为 MBR 分区方案)是将分区信息保存到磁盘的第一个扇区(MBR扇区)中的64个字节中，每个分区项占用16个字节，这16个字节中存有活动状态标志、文件系统标识、起止柱面号、磁头号、扇区号、隐含扇区数目(4个字节)、分区总扇区数目(4个字节)等内容。由于MBR扇区只有64个字节用于分区表，所以只能记录4个分区的信息。这就是硬盘主分区数目不能超过4个的原因。后来为了支持更多的分区，引入了扩展分区及逻辑分区的概念。但每个分区项仍用16个字节存储。\n主分区数目不能超过 4 个的限制，很多时候，4 个主分区并不能满足需要。另外最关键的是 MBR 分区方案无法支持超过 2TB 容量的磁盘。因为这一方案用 4 个字节存储分区的总扇区数，最大能表示 2 的 32 次方的扇区个数，按每扇区 512 字节计算，每个分区最大不能超过 2TB。磁盘容量超过 2TB 以后，分区的起始位置也就无法表示了。在硬盘容量突飞猛进的今天，2TB的限制早已被突破。由此可见，MBR 分区方案现在已经无法再满足需要了。\n5、GPT分区表 一种由基于 Itanium 计算机中的可扩展固件接口 (EFI) 使用的磁盘分区架构。与主启动记录(MBR) 分区方法相比，GPT 具有更多的优点，因为它允许每个磁盘有多达 128 个分区，支持高达 18 千兆兆字节的卷大小，允许将主磁盘分区表和备份磁盘分区表用于冗余，还支持唯一的磁盘和分区 ID (GUID)。 与支持最大卷为 2 TB (terabytes) 并且每个磁盘最多有 4 个主分区（或 3 个主分区，1 个扩展分区和无限制的逻辑驱动器）的主启动记录 (MBR) 磁盘分区的样式相比，GUID 分区表 (GPT) 磁盘分区样式支持最大卷为 18 EB (exabytes，1EB=1024PB，1PB=1024TB，1TB=1024GB，1GB=1024MB，1MB=1024KB。18EB=19　327　352　832GB) 并且每磁盘最多有 128 个分区。与 MBR 分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT 分区磁盘有多余的主要及备份分区表来提高分区数据结构的完整性。\n6、Ntfs文件系统在磁盘上的分布 一个 ntfs 文件系统由引导扇区、主文件表MFT（包含MFT元数据）和数据区组成。\nNTFS中存储了两份 MFT 备份以防 MFT 文件损坏，两 MFT 备份（备份在数据区）的具体起始位置都存储在引导扇区中。\n引导扇区（$Boot） 引导扇区是从NTFS文件系统的第一个扇区开始，以55 AA结尾。我们主要关注前88字节的信息，其中重要的就是“NTFS”标识、扇区大小、每簇扇区数、MFT起始簇以及MFT备份MFTMirr位置这些信息。我们可以根据MFT起始簇信息找到MFT，或者根据MFT备份MFTMirr位置找到MFT的另外一个MFT备份。如下图所示：\n第0个扇区数据 buf 偏移0x03开始的8个Bytes就是\u0026quot;NTFS \u0026ldquo;，表示这个扇区就是NTFS的引导记录。这第0个扇区也就是$Boot扇区，这个扇区包含了该卷的 BPB 和扩展BPB参数，可以得到该卷的卷大小，磁头数，扇区大小，簇大小等等参数；要解析一个NTFS卷的文件结构也是从这里的BPB参数开始的。解析时有用到的是这个扇区的前 88 (0x58) 个Bytes，剩余的是引导代码和结束标志\u0026quot;55 AA\u0026rdquo;，前88个字节具体结构如下：\ntypedef struct NTFS_BPB{　// 在cmd 输入 fsutil fsinfo ntfsinfo d: 查询 NTFS 信息 UCHAR jmpCmd[3]; UCHAR s_ntfs[8]; // \u0026#34;NTFS \u0026#34; 标志 // 0x0B UCHAR bytesPerSec[2]; // 0x0200　扇区大小，512B UCHAR SecsPerClu; // 0x08　每簇扇区数，4KB UCHAR rsvSecs[2]; // 保留扇区 UCHAR noUse01[5]; // // 0x15 UCHAR driveDscrp; // 0xF8 磁盘介质 -- 硬盘 UCHAR noUse02[2]; // // 0x18 UCHAR SecsPerTrack[2]; // 0x003F 每道扇区数 63 UCHAR Headers[2]; //　0x00FF 磁头数 UCHAR secsHide[4]; // 0x3F　隐藏扇区 UCHAR noUse03[8]; // // 0x28 UCHAR allSecsNum[8]; // 卷总扇区数, 高位在前, 低位在后 // 0x30 UCHAR MFT_startClu[8]; // MFT 起始簇 UCHAR MFTMirr_startClu[8];　// MTF 备份 MFTMirr 位置 //0x40 UCHAR cluPerMFT[4];　// 每记录簇数 0xF6 UCHAR cluPerIdx[4];　// 每索引簇数 //0x48 UCHAR SerialNum[8];　// 卷序列号 UCHAR checkSum[8];　// 校验和 }Ntfs_Bpb,*pNtfs_Bpb; (2) 关于簇 在一个分区中引导记录扇区所在的簇编号为0，往后的簇编号1,2,3等等一直到卷尾，这就是一个分区的逻辑簇号(LCN)；计算\n逻辑扇区号：LCN * 簇大小，簇的大小在BPB参数中找到，一般为8个扇区4KB；以此可以由 MFT 起始簇 MFT_startClu 计算出第一个 MFT 项(记录)的位置。\nVCN，虚拟簇号，给一个文件从它的首簇开始编号，为0，依次递增一直到文件的尾簇，在物理上不一定连续\n主文件表 (Master File Table, MFT) MFT 是由一条条 MFT 项(记录)所组成的，而且每项大小是固定的(一般为1KB)，MFT保留了前16项用于特殊文件记录，称为元数据，元数据在磁盘上是物理连续的，编号为0~15；如果$MFT的偏移为0x0C0000000,那么下一项的偏移就是0x0C0000400，在下一项就是 0x0C0000800等等；\nMFT记录了整个卷的所有文件信息（包括MFT本身、数据文件、文件夹等等）信息，包括空间占用，文件基本属性，文件位置索引，创建时间用户权限，加密信息等等，都存储在MFT。每一个文件在 MFT 中都有一个或多个 MFT 项记录文件属性信息。这里的属性包括数据，如果这个文件很小在 MFT 项中就可以放下，那么这条属性就定义为常驻属性，常驻标志位记为1，如果是非常驻，则有一个索引指向另一条记录(称为一个运行)。\n第一条 MFT 项: $MFT MFT 的第一项记录$MFT描述的是主分区表MFT本身，它的编号为0，MFT项的头部都是如下结构：\n在一个MFT项中前56字节是MFT头部信息，其中比较重要的是FILE标识、第一个属性的偏移和flags。 flags 显示了此文件是否是正常文件，或者是删除文件等。 typedef struct MFT_HEADER{ UCHAR mark[4]; // \u0026#34;FILE\u0026#34; 标志 UCHAR UsnOffset[2]; // 更新序列号偏移 30 00 UCHAR usnSize[2]; // 更新序列数组大小+1 03 00 UCHAR LSN[8]; // 日志文件序列号(每次记录修改后改变) 58 8E 0F 34 00 00 00 00 // 0x10 UCHAR SN[2]; // 序列号 随主文件表记录重用次数而增加 UCHAR linkNum[2]; // 硬连接数 (多少目录指向该文件) 01 00 UCHAR firstAttr[2]; // 第一个属性的偏移　38 00 UCHAR flags[2]; // 0已删除 1正常文件 2已删除目录 3目录正使用 // 0x18 UCHAR MftUseLen[4]; // 记录有效长度 A8 01 00 00 UCHAR maxLen[4]; // 记录占用长度 00 04 00 00 // 0x20 UCHAR baseRecordNum[8]; // 索引基本记录, 如果是基本记录则为0 UCHAR nextAttrId[2]; // 下一属性Id　07 00 UCHAR border[2]; // UCHAR xpRecordNum[4]; // 用于xp, 记录号 // 0x30 UCHAR USN[8]; // 更新序列号(2B) 和 更新序列数组 }Mft_Header, *pMft_Header; 上面的头部结构体在扇区的数据偏移 0x00 ~0x38；\n在0x38之后的4大块颜色数据是4条属性，描述名称，时间，索引等等信息，最后以\u0026quot;FF FF FF FF\u0026quot;结束。它们分别以0x10,0x30, 0x80, 0xB0作为标志；这里的四种属性所描述的的信息类型可以由下表查得，对照数据和结构体可以把这4条属性解析出来。\n（二）MFT项的4个属性 每条属性都包含属性头和属性结构。每条属性的前4字节显示该属性的类型，不同类型的属性有不同的属性结构。\n属性头 //------------------ 属性头通用结构 ---- typedef struct NTFSAttribute //所有偏移量均为相对于属性类型 Type 的偏移量 { UCHAR Type[4]; // 属性类型 0x10, 0x20, 0x30, 0x40,...,0xF0,0x100 UCHAR Length[4]; // 属性的长度 UCHAR NonResidentFiag; // 是否是非常驻属性，l 为非常驻属性，0 为常驻属性 00 UCHAR NameLength; // 属性名称长度，如果无属性名称，该值为 00 UCHAR ContentOffset[2]; // 属性内容的偏移量 18 00 UCHAR CompressedFiag[2]; // 该文件记录表示的文件数据是否被压缩过 00 00 UCHAR Identify[2]; // 识别标志 00 00 //--- 0ffset: 0x10 --- //-------- 常驻属性和非常驻属性的公共部分 ---- union CCommon { //---- 如果该属性为 常驻 属性时使用该结构 ---- struct CResident { UCHAR StreamLength[4]; // 属性值的长度, 即属性具体内容的长度。\u0026#34;48 00 00 00\u0026#34; UCHAR StreamOffset[2]; // 属性值起始偏移量 \u0026#34;18 00\u0026#34; UCHAR IndexFiag[2]; // 属性是否被索引项所索引，索引项是一个索引(如目录)的基本组成 00 00 }; //------- 如果该属性为 非常驻 属性时使用该结构 ---- struct CNonResident { UCHAR StartVCN[8]; // 起始的 VCN 值(虚拟簇号：在一个文件中的内部簇编号,0起） UCHAR LastVCN[8]; // 最后的 VCN 值 UCHAR RunListOffset[2]; // 运行列表的偏移量 UCHAR CompressEngineIndex[2]; // 压缩引擎的索引值，指压缩时使用的具体引擎。 UCHAR Reserved[4]; UCHAR StreamAiiocSize[8]; // 为属性值分配的空间 ，单位为B，压缩文件分配值小于实际值 UCHAR StreamRealSize[8]; // 属性值实际使用的空间，单位为B UCHAR StreamCompressedSize[8]; // 属性值经过压缩后的大小, 如未压缩, 其值为实际值 }; }; }; 由这个结构体可以知道，属性头的长度取决于是否有属性名，属性名长度是多少；是否常驻，如果常驻，属性内容长度是多少，如果非常驻，运行列表有多长。\n(0x08)日志文件序列号，它又叫文件参考号、文件引用号，一共 8Byte，前6个字节是文件称为文件号；后2个字节是文件顺序号，文件顺序号随重用而增加\n具体属性头的大小根据是否是常驻属性来进行计算。 是否是常驻属性根据属性头的第9个字节判断，1为非常驻，0为常驻。 如果是非常驻属性，属性头大小为64；如果是常驻属性，属性头大小为24字节。 常驻和非常驻的区别： 常驻属性是直接保存再MFT中，非常驻属性保存再MFT之外的其他地方。如果文件或文件夹小于1500字节，那么它们的所有属性，包括内容都会常驻在MFT中。 属性结构 不同类型的属性有不同的属性结构，这里主要介绍10H属性、30H属性和80H属性。\n（1）10H属性 $STANDART_INFORMATION 10H属性$STANDART_INFORMATION，描述的是文件的创建、访问、修改时间，传统属性，以及版本信息等等。\nstruct Value0x10 { UCHAR fileCreateTime[8]; // 文件创建时间 UCHAR fileChangeTime[8]; // 文件修改时间 UCHAR MFTChangeTime[8]; // MFT修改时间 UCHAR fileLatVisited[8]; // 文件最后访问时间 UCHAR tranAtrribute[4]; // 文件传统属性 UCHAR otherInfo[28]; // 版本，所有者，配额，安全等等信息(详细略) UCHAR updataNum[8]; // 文件更新序列号 }; 下面的偏移都是相对于属性首字节，其值加上0x38 就是实际偏移(图中的offset)。\n0x00 4B: (0x10) 类型标志 0x04 4B: (0x60) 整条10H属性的长度 0x08 1B: (0x00) 非常驻 0x09 1B: (0x00) 无属性名称 0x0A 2B: (0x18) 属性内容偏移位置 0x18 8B: (ED 46 39 6B 6B 93 CF 01) 8个字节是文件创建时间，紧随其后的3x8个字节分别是文件最后修改时间，MFT修改时间，文件最后访问时间。64位数值是相对于1601-01-01零点整的千万分之一秒数。可以用FileTimeToSystemTime()转换成我们通常见到的形式。 0x38 8B: (06 00 00 00 00 00 00 00)传统属性，这里是系统隐含文件，位描述： 后面还有0x28个字节是版本和管理信息等等。\n（2）20H类型 $ATTRIBUTE_LIST 当一个文件需要多个MFT项来记录，20H是用来描述属性的属性列表；当非常驻属性依然不够空间，则需要属性列表。20H类属性也有可能为常驻或非常驻，可以应用上面的通用属性头。以此结构体得到属性值的偏移地址，进而得到属性内容。\n//------- 这个结构只是数据内容部分，不包括属性头 NTFSAttribute ----\r//------- 由属性头的属性值偏移量确定属性值的起始位置 ---\rstruct Value0x20{\rUCHAR type[4]; // 类型\rUCHAR recordType[2]; // 记录类型\rUCHAR nameLen[2]; // 属性名长度\rUCHAR nameOffset; // 属性名偏移\rUCHAR startVCN[8]; // 起始 VCN\rUCHAR baseRecordNum[8]; // 基本文件记录索引号\rUCHAR attributeId[2]; // 属性 id\r//---- 属性名(Unicode) 长度取决于 nameLen 的值 ---\r}; （3）30H属性 $FILE_NAME 这个属性比较重要，包含了文件的详细资料和父目录的参考号等。根据父目录参考号可以知道文件之间的父子关系，从而构建文件的子父关系。\n其实在10H属性中已经描述了文件的部分信息(时间、标志等)，30H属性主要关注父目录的参考号、文件名命名空间和文件名。\n30H 类型属性描述的是文件或文件夹的名字和创建基本信息，属性头不在赘述，属性值的结构如下：\nstruct Value0x30\r{\rUCHAR parentFileNum[8]; // 父目录的文件参考号,前 6B 的文件记录号，后 2B 的文件引用计数；当文件记录号为0x05时，是根目录。\rUCHAR createTime[8]; // 文件创建时间\rUCHAR changeTime[8]; // 文件修改时间\rUCHAR MFTchangeTime[8]; // MFT 修改时间 UCHAR lastVisitTime[8] // 最后一次访问时间 UCHAR AllocSize[8]; // 文件分配大小 UCHAR realSize[8]; // 实际大小 UCHAR fileFlag[4]; // 文件标志，系统 隐藏 压缩等等 UCHAR EAflags[4] // EA扩展属性和重解析点\rUCHAR nameLength; // 文件名长 UCHAR nameSpace; // 文件命名空间：0 --- POSIX, 1 -- Win32, 2 --- DOS, 3 --- Win32 \u0026amp; DOS\r//----- Name (Unicode编码) 长度为 2 * nameLength ---- } NTFS通过为一个文件创建多个30H属性实现POSIX (Portable Operating System Interface, 可移植操作系统接口) 式硬连接，每个30H属性都有自己的详细资料和父目录；一个硬连接删除时，就从MFT中删除这个文件名，最后一个硬连接被删除时，这个文件就算是真正被删除了。\n（4）40H 属性 $OBJECT_ID MTFS统一给所有 MFT 记录分配的一个标识 \u0026mdash; 对象ID，即结构体第一个16B，可能只有一个全局对象ID，后面的3个ID可能没有。\nstruct Value0x40\r{\rUCHAR GObjectId[16]; // 全局对象ID 给文件的唯一ID号 UCHAR GOriginalVolumeId[16]; // 全局原始卷ID 永不改变 UCHAR GOriginalObjectId[16]; // 全局原始对象ID 派给本MFT记录的第一个对象ID UCHAR GDomain[16]; // 全局域ID (未使用)\r}; （5）50H 属性 $SECURITY_DESCRIPTOR ( 安全描述符) 略。 （6）60H 属性 $VOLUME_NAME 卷名属性 struct Value0x60\r{\r//---- 通用属性头 --\rUCHAR VolumeName[N]; //(Unicode) N 最大为 127 外加一个结束符\u0026#39;\\0\u0026#39;\r}; （7）60H 属性 $VOLUME_NAME 卷名属性 70H 属性 $VOLUME_INFORMATION 卷版本、状态 struct Value0x70\r{ //----- 通用属性头 --- UCHAR noUsed1[8]; // 00\rUCHAR mainVersion; // 主版本号 1--winNT, 3--Win2000/XP\rUCHAR SecVersion; // 次版本号 当主为3, 0--win2000, 1--WinXP/7\rUCHAR flag[2]; // 标志 UCHAR noUsed2[4]; // 00 };\r/* flag:\r* 0x0001 坏区标志 下次重启时chkdsk/f进行修复\r* 0x0002 调整日志文件大小 * 0x0004 更新装载 * 0x0008 装载到 NT4 * 0x0010 删除进行中的USN * 0x0020 修复对象 Ids * 0x8000 用 chkdsk 修正卷 */ （8）80H属性$DATA 80H 属性 $DATA 容纳文件数据(未命名数据流)，文件的大小一般指是未命名数据流的大小，没有长度限制，当它为常驻时，数据长度最小。它的结构为属性头加上数据流，如果数据流太大，则标记为非常驻，以运行的方式索引到外部。例如找一个MP3文件，从它的MFT项中0x80属性中可以看到它一定是非常驻，它的运行所指向的一系列簇就是音乐文件数据流；\nLCN(logical cluster number)：整个文件卷的相对位置，单位(簇)。 VCN(virtual cluster number)：文件内部的相对位置，单位(簇)。 struct Value0x80\r{\rUCHAR len; // 低4位表示运行簇大小的len，高4位表示起始簇的len\rUCHAR *filesize; // 运行簇大小\rUCHAR *start; // 起始簇 LCN/VCN\r} 每个运行列表中第一个字节的低4位表示运行簇大小（filesize）的len，高4位表示起始簇（start）的len。如果一个运行列表后面的第一个字节是00，说明运行列表结束，后面的数值暂时不用管；如果不是00，则是下一个运行列表开始。\n①非常驻\u0026ndash;\u0026gt;一个运行列表 0x00~0x3F 是属性头；运行列表在橘黄色框中，0x40开始，可以得到运行列表 33 40 BC 00 00 00 0C。\n分析如下: 首先0x33，低4位是3，表示紧随其后的3Byte 0xBC40作为运行簇大小（簇个数），即文件所占总大小；高4位是3，表示簇大小之后的3个Byte 0x0C0000 是起始簇，即文件起始，这里是说的是LCN。 ②非常驻\u0026ndash;\u0026gt;多个运行列表 分析如下： 第一个运行列表，首先是0x31，低4位是1，表示紧接着的1Byte(03)是运行簇大小；高4位是3，表示紧接着3Byte(65 9A 00)是起始簇，这里说的是LCN； 第二个运行列表，首先是0x11，低4位是1，表示紧接着的1Byte(01)是运行簇大小；高4位是1，表示紧接着3Byte(13)是起始簇，这里说的是VCN。 注意，只有第一个运行列表的起始簇说的是LCN，从第二个运行列表开始每个运行列表的起始簇都说的是VCN。想要得到LCN需要按下面的公式计算： 第n个运行列表的LCN = 第一个运行列表的起始簇(LCN) + 第二个运行列表的起始簇(VCN) +\u0026hellip;+第n个运行列表的起始簇(VCN) ③常驻 （9）90H 属性 $INDEX_ROOT 索引根。 $INDEX_ROOT 索引根。实现NTFS的B+树索引的根节点，总是常驻。索引根属性由属性头、索引根和索引项组成。属性头是通用属性头的常驻部分。结构体如下(可能有些偏差)：\nstruct indexHeader {\rUCHAR type[4]; // 属性类型 UCHAR checkRule[4]; // 校对规则 UCHAR allocSize[4]; // 索引项分配大小 UCHAR CluPerIdx; // 每索引记录的簇数\rUCHAR noUse01[3]; // 填充 UCHAR firstIdxOffset[4]; // 第一个索引项偏移 UCHAR idxTotalSize[4]; // 索引项总大小 UCHAR indxAllocSize[4]; // 索引项分配大小 UCHAR flag; // 标志\rUCHAR noUse02[3];\r};\r// 一般小目录在90属性中有常驻目录项，目录项的结构与INDX缓存中的目录项一样\rstruct indexItem\r{ UCHAR MFTnum[8] // 文件的 MFT 记录号，前6B是MFT编号,用于定位此文件记录\rUCHAR ItemLen:[2]; // 索引项大小\rUCHAR IndexIdentifier:[2]; // 索引标志 R\rUCHAR isNode[2]; // 1---此索引包含一个子节点，0---此为最后一项 UCHAR noUse03[2]; // 填充\rUCHAR FMFTnum[8]; // 父目录 MFT文件参考号 0x05表示根目录 UCHAR CreateTime[8]; //文件创建时间\rUCHAR fileModifyTime[8]; //文件修改时间\rUCHAR MFTModifyTime[8]; //文件记录最后修改时间\rUCHAR LastVisitTime[8]; //文件最后访问时间\rUCHAR FileAllocSize[8]; //文件分配大小 (B)\rUCHAR FileRealSize[8]; //文件实际大小 (B)\rUCHAR FileIdentifier[8]; //文件标志\rUCHAR FileNameLen; //文件名长度\rUCHAR FileNameSpace； //文件名命名空间\r//---- 0x52 --- //FileName; // 文件名 (末尾填满 8 字节)\rUCHAR nextItemVCN[8]; // 下一项的 VCN (有子节点才有)\r}; A0H 属性 $INDEX_ALLOCATION 索引分配属性，也是索引，由属性头和运行列表组成，一般指向一个或多个目录文件(INDX文件，即4K缓存)；\nA0H属性和90H属性共同描述了磁盘文件和目录的 MFT 记录的位置。第5项MFT的A0H属性记录根目录的位置。\nB0H 属性 $BITMAP 位图属性，虚拟簇使用(占用)情况，这条属性用在$MFT和索引中；在Bitmap文件中，每一个 Bit 代表分区的一个簇，置1代表其已使用；\n第0个字节的第0位表示分区第0簇，之后依次递增。\nC0H 属性 $REPARSE_POINT 重解析点。使应用程序为文件或目录关联一个应用程序数据块，详细略。\nD0H $EA_INFORMATION 扩充信息属性。为在NTFS下实现HPFS的OS/2子系统信息，及WinNT服务器的OS/2客户端应用而设置的，一般为非常驻；\nE0H $EA 扩充属性 也是为了实现NTFS下的 HPFS，一般为非常驻；\n100H $LOGGED_UTILITY_STREAM，EFS加密属性，存储用于实现EFS加密有关的信息，合法用户列表，解密密钥等等\n四、常见问题 （一）如何从NTFS文件系统中找到$MFT文件的起始和总大小 1、从引导扇区找到“MFT起始簇”或者”MFT备份MFTMirr位置“； 2、根据“MFT起始簇”或者”MFT备份MFTMirr位置“找到第一个MFT项（1KB），第一个MFT项就是$MFT的属性内容； 3、在第一个MFT项中找到80H属性，根据80H属性的属性结构找到文件起始和总大小； 4、上面3找到的就是MFT文件的起始和总大小了。 （二）MFT文件和MFTMirr文件的区别 MFT文件是对NTFS中全部MFT（卷上的所有文件，包括文件名、时间戳、流名和数据流所在的群集号列表、索引、安全标识符以及诸如“只读”、“压缩”、“加密”之类的文件属性）的存储，可以根据MFT文件快速的查找卷上的所有文件；而MFTMirr文件是对MFT文件中比较重要项的复制，一般是4KB。 参考： https://www.cnblogs.com/mwwf-blogs/archive/2015/05/04/4467687.html https://en.wikipedia.org/wiki/NTFS#Master_File_Table?tdsourcetag=s_pcqq_aiomsg https://wenku.baidu.com/view/f204bb89e518964bce847cae.html 五、解析一个磁盘分区的文件目录的顺序： 引导扇区($Boot) \u0026mdash;-\u0026gt; 第0项记录($MFT) \u0026mdash;-\u0026gt; 根目录记录(第5项，90H,A0H) \u0026mdash;-\u0026gt; 根目录(INDX)小\nstruct indxHeader　// A0H外部缓存文件结构，最大长度一般为4K\r{\rUCHAR mark[4]; // 标志 \u0026#34;INDX\u0026#34;\rUCHAR usnOffset[2]; // 更新序列偏移\rUCHAR usnSize[2]; // 更新序列数组大小S\rUCHAR LSN[8]; // 日志文件序列号\rUCHAR indxVCN[8]; // 本索引缓存在分配索引中的VCN\rUCHAR itemOffset[4]; // 第一项索引的偏移(从这里开始计算)\rUCAHR itemSize[4]; // 索引项实际大小(B)\rUCHAR itemAlloc[4]; // 索引项分配大小(B)(不包括头部) 略小于4K\rUCHAR isNode; // 是结点置1，表示有子节点\rUCHAR noUse[3]; //UCHAR USN[2S]; // 更新序列号和数组\r}; 在文件头之后就是目录项了，项的结构就是在上面90H的介绍里定义的indexItem，每一个项代表一个文件或目录的MFT项，通过项的 MFT 记录号可以计算出MFT项的磁盘地址，它等于$MFT 的偏移地址 + 编号*0x400，以此可以找到该索引项对应的文件或子目录的MFT项。\n六、搜索一个已删除的文件或目录的MFT项 上面说了，一个文件的MFT项的地址等于$MFT的地址+MFT编号*0x400，如果目录中的对应项删除了，那么可以从MFT的首部开始检索，因为MFT一般是连续的，而一个MFT项的大小又是固定的，一项项读取，找到各自的0x30属性，解析出文件名，进行比较 (MFT中有一些空白区域需要跳过)。\n七、关于文件名 一般在文件名的前一个字节是文件名的命名空间，不管是INDX文件中，还是0x30属性中。\n0x00 \u0026mdash;- POSI ，最大的命名空间，大小写敏感，支持除 \u0026lsquo;\\0\u0026rsquo; 和 \u0026lsquo;/\u0026rsquo; 所有Unicode字符，最大程度255个字符； 0x01 \u0026mdash;- Win32，是POSI的子集，不支持字符：* / \u0026lt; \u0026gt; | \\ : ? ，不能用句点或空格结束； 0x02 \u0026mdash;- DOS , 是Win32的子集，字符必须比空格0x20大，文件名1~8个字符，然后句点分割接后缀扩展名1~3个字符； 0x03 \u0026mdash; DOS\u0026amp;Win32，必须兼容Win32和DOS命名方式 在INDX文件中，经常可以看到含有0x02和0x03或者0x01的两个不同命名空间、相同MFT编号的项，也就是说这两个目录项指向同一个记录，同样的在这个文件的MFT项中也有两个0X30属性，其中一个是0x01或0x03，表示的是完整的文件名；另一个是0x02，DOS命名方式，它是一个短文件名，它在我们命名的基础上，截断 \u0026lsquo;.\u0026rsquo; 之前的超出6个字符的所有字符，只剩前6个，之后接上\u0026quot;~1\u0026quot; ，这样正好8个字符，当然后面的句点和扩展名保留。另外，它必须满足DOS命名规则，必须大写，删除禁止使用的字符等等。如果文件名重复了，在 \u0026ldquo;~1\u0026rdquo; 基础上递增，\u0026quot;~2\u0026quot;,\u0026quot;~3\u0026quot;等等。检索比对时，我们自然要使用前者\n八、关于字符集 字符集是字符在计算机上的编码方式，可以看成一种协议，一种约定规则，我们处理一串二进制数所代表的字符时，必须清楚它用的是哪一种编码方式；在windows系统中文件的命名是固定用两个字节表示一个字符，在MFT中可以发现英文文件名字符之间都填充一个 \u0026lsquo;\\0\u0026rsquo; ，这是宽字符集与变长字符集兼容，在宽字符集中，小于128的字符数值上是等于ASCII码；我们的文件数据一般用的是变长字符集(GB2312等等)；为了比较输入的文件名和NTFS中的文件名，我们必须要先转换；两个WinAPI 函数，用于宽字符和变长字符转换\n// 函数原型\rint WideCharToMultiByte(\rUINT CodePage, // code page\rDWORD dwFlags, // performance and mapping flags\rLPCWSTR lpWideCharStr, // address of wide-character string\rint cchWideChar, // number of characters in string\rLPSTR lpMultiByteStr, // address of buffer for new string\rint cchMultiByte, // size of buffer\rLPCSTR lpDefaultChar, // address of default for unmappable // characters\rLPBOOL lpUsedDefaultChar // address of flag set when default // char. used\r);\rint MultiByteToWideChar(\rUINT CodePage, // code page\rDWORD dwFlags, // character-type options\rLPCSTR lpMultiByteStr, // address of string to map\rint cchMultiByte, // number of bytes in string\rLPWSTR lpWideCharStr, // address of wide-character buffer\rint cchWideChar // size of buffer\r);\r//--- WCHAR 定义在tchar.h中 ----\rvoid charTest()\r{\rTCHAR tc1[16] ;　//= _T(\u0026#34;后来\u0026#34;);\rWCHAR tc2[8] = {0x540E, 0x6765, 0, 0, 0, 0, 0, 0};\r// memset(tc2, 0, 20);\r// MultiByteToWideChar(CP_ACP, 0, tc1, 4, (LPWSTR)tc2, 4);\rWideCharToMultiByte(CP_ACP, 0 ,(WCHAR*)tc2, 2, tc1, sizeof(tc1), 0, 0);　cout\u0026lt;\u0026lt;\u0026#34;tc1 \u0026#34;\u0026lt;\u0026lt;tc1\u0026lt;\u0026lt;sizeof(tc1)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;strlen(tc1)\u0026lt;\u0026lt;endl;\rPrintHex(tc1);\rcout\u0026lt;\u0026lt;endl;\rcout\u0026lt;\u0026lt;\u0026#34;tc2 \u0026#34;\u0026lt;\u0026lt;sizeof(tc2)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;wcslen((LPWSTR)tc2)\u0026lt;\u0026lt;endl;\rPrintHex(tc2);\rcout\u0026lt;\u0026lt;endl;\r} "},{"id":218,"href":"/Tech/2Computer-Science/4Operating-System/NTFS/%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%8B%E7%BB%8D/","title":"硬盘分区和文件系统格式化介绍","parent":"NTFS","content":" 硬盘分区和文件系统格式化介绍 作者：rosy_dawn 链接：https://www.jianshu.com/p/670a22556868\n分区 全新硬盘装系统之前，必须对其进行分区，硬盘分区初始化的格式主要有两种：传统的 MBR（Master Boot Record ，即主引导记录） 和新的 GPT（ GUID Partition Table）。后者功能更强大，解决了 MBR 的许多限制。\nMBR MBR 早在 1983 年 IBM PC DOS 2.0 中就已经提出。之所以叫“主引导记录”，是因为它位于驱动器开始部分的主引导扇区，是硬盘的第一扇区。它由三个部分组成：Boot loader、硬盘分区表 DPT 和结束标志字。\n第一部分为 Boot loader，位于主引导扇区的前 446 个字节，偏移地址为 0000H\u0026ndash;0088H，是一小段代码，用于加载硬盘上其他分区上更大的加载器（如操作系统的启动加载器）。如果你安装了 Windows，Windows 启动加载器的初始信息就放在这个区域里。如果 MBR 的信息被覆盖导致 Windows不能启动，你就需要使用启动优盘中 DiskGenius 软件提供的重建 MBR 功能来使其恢复正常。如果你安装了 Linux，则这里通常存储的是 GRUB 启动加载器的初始信息。该区域主要提供以下三个功能：\n提供启动引导菜单：使用者可以在该菜单中选择启动不同的开机项。在系统未加载前按下主板快速启动的快捷键就可以看到该菜单； 指向开机所需的核心文件来启动操作系统； 还可将开机引导权交给其它 loader。每个分区也拥有自己的启动扇区（Boot sector），开机引导程序除了可以装在这里外，还可装在各分区的启动扇区。 第二部分为 Disk partition table 区（DPT 分区表），占 64 个字节，偏移地址为 01BEH\u0026ndash;01FDH，记录整个磁盘分区的状态，每 16 个字节标记一个分区，因此最多可记录 4 个分区。分区的单位是柱面，每个 16 字节的记录区记录了该分区从开始到结束的柱面号。所谓的分区操作即是对分区表进行设置，当文件系统要写入磁盘时，首先会参考分区表。在 MBR 分区表中，逻辑块地址采用 32 位二进制数表示，因此一共可表示 2 的 32 次方个逻辑块地址，所以，MBR 硬盘最大分区容量仅为 2.2 TB = 2^32 × 512 bytes；\n第三部分是结束标志字，占 2 个字节，偏移地址为 01FEH\u0026ndash;01FFH。固定为 55AA，是检验主引导记录是否有效的标志。该标志错误将导致系统不能启动。\n上面所说的分区为主分区（primary partition）。一个磁盘或者 RAID 卷上只能有 4 个可启动的主分区。如果 MBR 分区方案需要使用 4 个以上的分区，那就需将至少一个主分区作为扩展分区（extend partition），然后在该扩展分区上面建立若干个逻辑分区（logic partition）。扩展分区可以被看作是容纳逻辑分区的容器。硬盘上最多只能有 1 个扩展分区（操作系统的限制）且其本身不能格式化，必须划分逻辑分区后才能使用，但扩展分区中的逻辑分区没有数量限制。扩展分区也被看作是一个主分区，因此，在存在扩展分区的情况下最多只能再建 3 个主分区（3 个主分区加 1 个可包含多个逻辑分区的扩展分区）。\n扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和 MBR 结构类似的扩展引导记录（EBR），其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的 EBR，分区表第三、第四项没有用到。简而言之，扩展分区严格地讲它不是一个实际意义的分区，它仅仅是一个指向下一个 逻辑分区的指针，这种指针结构是一个单向链表。\nBIOS BIOS（Basic Input Output System）即基本输入输出系统 ，它是个人电脑启动时加载的第一个软件。其实，它是一个存储在计算机内主板 BOIS 芯片上的程序，它保存着计算机最重要的基本输入输出的程序、加电自检程序（Power On Self Test，简称 POST 自检）和系统启动程序等。\n一般在计算机启动时按 F2 或者 Delete 即可进入 BIOS 程序进行设置（一些特殊机型按 F1、Esc、F12 等进行设置）。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。\nUEFI UEFI 的全称是 Unified Extensible Firmware Interface，意即统一可扩展固件接口，它是基于 EFI 1.10 标准为基础发展而来，值得注意的是在 UEFI 正式确立之前，Intel 就开始积极推进传统 BIOS 的升级方案，并最终确立了过渡方案 EFI 标准，直到 2007 年 Intel 将 EFI 标准的改进与完善工作交给 Unified EFI Form 进行全权负责，EFI 标准则正式更名为 UEFI。UEFI 其实和 BIOS 是同一类程序，是随着硬件发展而出现的 BIOS 升级版，被看做是有近20多年历史的传统的（Legacy）BIOS 的继任者。UEFI 一般就是指 UEFI BIOS 环境，而和 UEFI 比较时的所说的 BOIS 则是指传统的 BIOS 环境。\n相比 BIOS，UEFI 的一些优点在于：\n高效开发。BIOS 开发一般采用汇编语言，代码多是硬件相关的代码。而在 UEFI 中，绝大部分代码采用 C 语言编写，UEFI 应用程序和驱动甚至可以使用 C++ 编写。UEFI通过固件操作系统接口（BS 和 RT 服务）为 OS 和 OS 加载器屏蔽了底层硬件细节，使得 UEFI 上层应用可以方便重用。 可扩展性。UEFI 的模块化设计在逻辑上分为硬件控制与 OS（操作系统）软件管理两部分，硬件控制为所有 UEFI 版本所共有，而 OS 软件管理其实是一个可编程的开放接口。借助这个接口，主板厂商可以实现各种丰富的功能。比如我们熟悉的各种备份及诊断功能可通过 UEFI 加以实现，主板或固件厂商可以将它们作为自身产品的一大卖点。UEFI 也提供了强大的联网功能，其他用户可以对你的主机进行可靠的远程故障诊断，而这一切并不需要进入操作系统。 缩短启动和休眠恢复时间。UEFI 可运行于 32 位或 64 位模式，突破了传统 16 位代码的寻址能力，达到处理器的最大寻址，此举克服了 BIOS 代码运行缓慢的弊端。 启动的安全性。当系统的安全启动功能被打开后，UEFI 在执行应用程序和驱动前会先检测程序和驱动的证书，仅当证书被信任时才会执行这个应用程序或驱动。UEFI 应用程序和驱动采用 PE/COFF 格式，其签名放在签名块中。 更大的磁盘容量和分区数量。传统 MBR 分区最大只能支持 2.2 TB 的硬盘和 4 个主分区，而 UEFI 规范之一的 GPT 分区格式，则可以支持过百 TB 大小的硬盘和 100 个主分区。 兼容性。与 BIOS 不同的是，UEFI 体系的驱动并不是由直接运行在 CPU 上的代码组成的，而是用 EFI Byte Code（EFI字节代码）编写而成的。EFI Byte Code 是一组类似于 Java 类文件的虚拟机器指令，必须在 UEFI 驱动运行环境下被解释运行，由此保证了充分的向下兼容性。 鼠标操作。UEFI 内置图形驱动功能，可以提供一个高分辨率的彩色图形环境，用户进入后能用鼠标点击调整配置，一切就像操作 Windows 系统下的应用软件一样简单。 相比传统的 BIOS，UEFI 还提供了文件系统的支持，它能够直接读取 FAT、FAT32 分区中的文件，例如华硕、华擎等主板在 UEFI 环境下更新 BIOS 就可以直接读取 U 盘中的 BIOS 及其他文件，另外新的 UEFI 主板基本都提供了截屏功能，这些截屏图片都可以存储在U盘当中。\nUEFI 还有一个重要特性就是在 UEFI 下运行应用程序，这类程序文件通常以 efi 结尾。利用 UEFI 可以直接识别 FAT 分区中的文件，又可直接在其中运行应用程序。我们就可以将 Windows 安装程序做成 efi 类型应用程序，然后把它放到任意 FAT 分区中直接运行即可。\n当然由于 UEFI 主要由高级语言编写（C语言），相比于传统 BIOS 的汇编语言，UEFI BIOS 在安全防护性方面相比传统 BIOS 要弱，比较容易遭到病毒的攻击，安全性有待进一步提升。不过在图形化界面、应用程序扩展面前，UEFI BIOS 还是非常成功的。\n现在，多数主板为了兼容 MBR 分区表，一般会提供 Legacy BIOS 和 UEFI BIOS 启动模式选项，如果要使用 UEFI 模式安装操作系统，就必须开启 UEFI 模式。UEFI 模式可切换回 BIOS 模式，而仅有 BIOS 模式时无法切换为 UEFI 模式。\n目前 64bit Windows Vista、7、8、8.1、10 都已经支持 GPT 分区表，而 Windows 8、8.1、10 都已经原生支持 UEFI，安装这些系统的时候：只要硬盘设置为 GPT 分区表 主板设置为 UEFI 启动后，就可以直接开始安装操作系统了。自 Win8 发布以来，新出厂的预装 Win8/Win8.1 的电脑都默认在 UEFI 式下启动操作系统。\n而对于 Windows Vista、7 系统，就需要手动添加 UEFI 支持，我们可以找一份 Windows 8 或者 10 安装镜像，从安装文件中提取 Bootmgfw.efi 文件，重命名为 BOOTX64.EFI，拷贝到 Win7 安装文件的 \\EFI\\Boot\\ 下，如果没有 BOOT 文件夹就新建一个。\nGPT GPT 的全称是 Globally Unique Identifier Partition Table，意即 GUID 分区表。UEFI BOIS 将逐渐取代 Legacy BOIS ，而 GPT 也将逐渐取代 MBR。UEFI 和 GPT 是相辅相成的，二者缺一不可，要想使用 GPT 分区表则必须是 UEFI BIOS 环境。\n与支持最大 2T 磁盘和 RAID 卷且至多有 4 个主分区的 MBR 分区表相比， GPT 分区表能支持最大 18 EB（Exabytes）磁盘和 RAID 卷。并且磁盘和 RAID 卷的分区数没有上限，只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区）。比如，在 Windows 系统上，由于系统的限制 GPT 最多只能支持 128个 磁盘分区，基本可以满足所有用户的存储需求。在每一个分区上，这个标识符是一个随机生成的字符串，可以保证为地球上的每一个 GPT 分区都分配完全唯一的标识符。\n在安全性方面，GPT 分区表也进行了全方位改进。在早期的 MBR 磁盘上，分区和启动信息是保存在一起的。如果这部分数据被覆盖或破坏，事情就麻烦了。相对的，GPT 在整个磁盘上保存多个这部分信息的副本，因此它更为健壮，并可以恢复被破坏的这部分信息。GPT 还为这些信息保存了循环冗余校验码（CRC）以保证其完整性和正确性——如果数据被破坏，GPT 会发觉这些破坏，并从磁盘上的其他地方进行恢复。\n查看操作系统的引导方式 高版本的 Windows 系统。按 Win+R 打开运行，输入 msinfo32，回车查看系统信息。在 BIOS 模式中如果显示“传统”，表示系统启动方式为 Legacy BIOS；如果为 UEFI，则显示 UEFI。\n文件系统 文件系统概述 分区建立后，在将数据存储到分区之前，还必须要用某种文件系统对其进行格式化，这样操作系统才能使用它。创建文件系统的操作就是平时我们所说的格式化。格式化是指对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除。\n**文件系统（File System）**是操作系统中负责管理和存储文件信息的软件机构，用于向用户提供底层数据访问。它将设备中的空间划分为特定大小的块（或称为簇），一般每块 512 字节，一个块可能由若干个扇区组成。数据存储在这些块中，大小被修正为占用整数个块，由文件系统软件来负责将这些块组织为文件和树形目录，并记录哪些块被分配给了哪个文件，以及哪些块没有被使用。文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备实际使用数据块的概念，用户使用文件系统来保存数据时不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。\n文件系统是数据的组织者和提供者，并不一定只在特定存储设备上出现，实际上文件系统可能仅仅是一种访问数据的界面而已，实际的数据是通过网络协议（如 NFS、SMB、9P 等）提供的或者在内存上，甚至可能根本没有对应的文件（如 PROC 文件系统）。严格地说，文件系统是一套实现了数据的存储、分级组织、访问和获取等操作的抽象数据类型（Abstract data type）。\n格式化通常分为低格（低级格式化）和高格（高级格式化）。\n低级格式化（Low-Level Formatting）又称低层格式化或物理格式化（Physical Format），对于部分硬盘制造厂商，它也被称为初始化（initialization）。大多数的硬盘制造商将低级格式化（Low-Level Formatting）定义为创建硬盘扇区使硬盘具备存储能力的操作。 高级格式化又称逻辑格式化，即创建文件系统的过程。高格是根据用户选定的文件系统在磁盘的特定区域写入特定数据，以初始化磁盘或磁盘分区、清除原磁盘或磁盘分区中所有文件的一个操作。高级格式化包括对主引导记录（MBR）中分区表相应区域的重写，根据用户选定的文件系统在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间以便用户使用该分区管理文件。 低格在硬盘出厂时已经完成。如果没有特别指明，对硬盘的格式化通常是指高格 下图为一个全新的、未使用的磁盘驱动器的一种形象表示。\n要在磁盘驱动器中保存数据，则首先需要格式化该磁盘驱动器。格式化（通常称“ 生成文件系统” ）是向驱动器中写入信息，在未格式化驱动器中为空白空间建立顺序。下图表示一个有文件系统的磁盘驱动器。\n如上图所示，文件系统所指派的顺序涉及了一些折衷方案：\n驱动器中的一小部分可用空间被用来存储与文件系统有关的数据，这可以被视作额外部分。 文件系统将剩余的空间分成小的一定大小的片段。在 Linux 中，这些片段就是块。 注：没有单一、通用的文件系统。不同的文件系统会彼此不兼容，也就是说，支持某一文件系统（或者相关的文件系统类型）的操作系统可能不支持另外一种文件系统。比如 Windows 不支持 ext4 等日志文件系统，而 Red Hat Enterprise Linux 就支持很多文件系统（包括许多被其他操作系统使用的文件系统），这就使得在不同文件系统之间的数据交换变得容易了。\n在磁盘中写入文件系统只是第一步。这个进程的目的实际上是要保存和检索数据。下图显示了写入数据后的磁盘驱动器：\n某些之前的空数据块现在也存放着数据。然而，只看这个框图，我们不能确认这个磁盘中有多少个文件系统。这有可能是一个，也有可能是多个，因为所有的文件都使用至少一个数据块，而有些文件则使用多个块。另外一个值得注意的地方是，已经被使用的块不一定组成连续的空间；未使用的和已使用的块可以散布排列。这被称作碎片。当尝试调整现存分区的大小时，碎片会对其产生影响。\n和大多数与计算机相关的技术一样，与磁盘驱动器刚发明时相比，文件系统已经有了很大的变化。特别是保存信息的容量变得越来越大。同时额外的容量让使用磁盘驱动器的方法发生了根本改变。\n生活中我们所说的磁盘格式就是指文件系统。不同的操作系统所使用的文件系统也不同。\n驱动器：在计算机领域，驱动器指的是磁盘驱动器。通过某个文件系统格式化并带有一个驱动器号的存储区域。\n硬盘驱动器（hard disk drive，HDD）指的是个人计算机中控制硬盘寻址以及存取数据的装置。通过硬盘驱动器，计算机才能存储数据。尽管硬盘驱动器和硬盘（hard disk）是两个概念，但是由于两者通常被封装在一起，所以无论是硬盘还是硬盘驱动器通常都是指二者结合在一起所形成的设备。\n主引导扇区：硬盘的第一个扇区被保留为主引导扇区，它位于整个硬盘的0磁头0柱面1扇区，包括硬盘主引导记录MBR(Main Boot Record)和分区表DPT(Disk Partition Table)。其中主引导记录的作用就是检查分区表是否正确以及确定哪个分区为引导分区，并在程序结束时把该分区的启动程序（也就是操作系统引导扇区）调入内存加以执行。至于分区表，很多人都知道，以80H或00H为开始标志，以55AAH为结束标志，共64字节，位于本扇区的最末端。硬盘主引导扇区= 硬盘主引导记录（MBR) + 硬盘分区表（DPT)\n物理位置：0柱面0磁头1扇区（Cylinder 0,Head 0,Sector 1） 系统扇区（System Sectors）：0C-0H-2S,0C-0H-63S，共 62 Sectors 大小：512字节 其中：MBR 446字节（0000\u0026ndash;01BD),DPT 64字节（01BE\u0026ndash;01FD），结束标志2字节（55 AA) 功能：MBR通过检查DPT分区信息引导系统跳转至DBR 硬盘分区表（DPT)\nDPT 总共64字节（01BE\u0026ndash;01FD），如上所示每个分区占16个字节，所以可以表示四个分区，这也就是为什么一个磁盘的主分区和扩展分区之和总共只能有四个的原因.\nMBR下的硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。\n一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干个。\n分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，那剩的部分就浪费了。\n扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分。\n激活的主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，正常分的话就是C驱。\n主分区也可成为“引导分区”，会被操作系统和主板认定为这个硬盘的第一个分区。所以C盘永远都是排在所有磁盘分区的第一的位置上。\n主分区，也称为主磁盘分区，和扩展分区、逻辑分区一样，是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘（在这一点上主分区和逻辑分区很相似，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中）。早期MBR模式分区只能划分四个分区，现在的GPT分区至少可以划分128个主分区，未来很有可能将不存在扩展分区和逻辑分区的概念。\n硬盘的主分区包含操作系统启动所必需的文件和数据的硬盘分区，要在硬盘上安装操作系统，则硬盘必须有一个主分区。\n主引导程序是它的一部分，此段程序主要用于检测硬盘分区的正确性，并确定活动分区，负责把引导权移交给活动分区的DOS或其他操作系统。此段程序损坏将无法从硬盘引导，但从软驱或光驱引导之后可对硬盘进行读写。\n在MBR分区模式中，硬盘只能分4个分区，而4个分区肯定不够用，所以就催生了扩展分区和逻辑分区的概念，而之前的分区类型便起名为主分区了。实际上在早期的硬盘分区中并没有主分区、扩展分区和逻辑分区的概念，每个分区的类型都是现在所称的主分区。\nGPT，即 Globally Unique Identifier Partition Table Format，全局唯一标识符的分区表的格式,它至少可以分出128个分区，完全不需要扩展分区和逻辑分区来帮忙就可以分出任何想要的分区来。\nMBR（主引导记录）的分区表（主分区表）只能存放4个分区，如果要分更多的分区的话就要一个扩展分区表（EBR），扩展分区表放在一个系统ID为0x05的主分区上，这个主分区就是扩展分区，扩展分区能可以分若干个分区，每个分区都是个逻辑分区。\n逻辑分区的信息都被保存在扩展分区内，而主分区和扩展分区的信息被保存在硬盘的MBR内。这也就是说无论硬盘有多少个分区，其MBR（主引导记录）中只包含主分区(也就是启动分区)和扩展分区两个分区的信息。\n扩展分区是硬盘磁盘分区的一种。\n一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干个。\n所谓扩展分区，严格地讲它不是一个实际意义的分区，它仅仅是一个指向下一个分区的指针，这种指针结构将形成一个单向链表。这样在主引导扇区中除了主分区外，仅需要存储一个被称为扩展分区的分区数据，通过这个扩展分区的数据可以找到下一个分区(实际上也就是下一个逻辑磁盘)的起始位置，以此起始位置类推可以找到所有的分区。无论系统中建立多少个逻辑磁盘，在主引导扇区中通过一个扩展分区的参数就可以逐个找到每一个逻辑磁盘\n扩展分区不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。\n由主分区和逻辑分区构成的逻辑磁盘称为驱动器(Drive)或卷(Volume)。\n系统分区与启动分区的区别：激活的主分区会成为“系统分区”，系统分区包含硬件相关文件和 Boot 文件夹，通过这个文件夹计算机可以获取启动 Windows 的位置,该分区大小为 100 MB。启动分区是包含 Windows 操作系统文件的分区。系统分区和启动分区是硬盘上的分区（或卷）的名称，Windows 在启动时将使用该硬盘。这两个术语很容易混淆，这是因为系统分区实际上包含的是用于启动 Windows 的文件，而启动分区包含的则是系统文件。\n逻辑分区是硬盘上一块连续的区域,不同之处在于，每个主分区只能分成一个驱动器，每个主分区都有各自独立的引导块，可以用fdisk设定为启动区。一个硬盘上最多可以有4个主分区，而扩展分区上可以划分出多个逻辑驱动器。这些逻辑驱动器没有独立的引导块，不能用fdisk设定为启动区。主分区和扩展分区都是dos分区。\n理论上可以划分为无数个逻辑分区。\n扩展分区中逻辑驱动器的引导记录是链式的。每一个逻辑分区都有一个和MBR结构类似的扩展引导记录(EBR)，其分区表的第一项指向该逻辑分区本身的引导扇区，第二项指向下一个逻辑驱动器的EBR，分区表第三、第四项没有用到。\n硬盘DBR(Dos Boot Record)：分区引导扇区也称DBR，是由FORMAT高级格式化命令写到该扇区的内容，DBR是由硬盘的MBR装载的程序段。DBR装入内存后，即开始执行该引导程序段，其主要功能是完成操作系统的自举并将控制权交给操作系统。每个分区都有引导扇区，但只有被设为活动分区的DBR才会被MBR装入内存运行。\nDBR位于柱面0、磁头1、扇区1，其逻辑扇区号为0 DBR包含DOS引导程序和BPB。 BPB十分重要，由此可算出逻辑地址与物理地址。 准确地说，DBR应该改称为OBR（OS Boot Record）即操作系统引导扇区. OBR（DBR）是高级格式化程序产生的，如FORMAT、PM、DM、DISKPART、WINXP磁盘管理器。 DBR（DOS BOOT RECORD，DOS引导记录），位于柱面0，磁头1，扇区1，即逻辑扇区0。DBR分为两部分：DOS引导程序和BPB（BIOS参数块）。其中DOS引导程序完成DOS系统文件（IO.SYS，MSDOS.SYS）的定位与装载，而BPB用来描述本DOS分区的磁盘信息，BPB位于DBR偏移0BH处，共13字节。 它包含逻辑格式化时使用的参数，可供DOS计算磁盘上的文件分配表，目录区和数据区的起始地址，BPB之后三个字提供物理格式化（低格）时采用的一些参数。引导程序或设备驱动程序根据这些信息将磁盘逻辑地址（DOS扇区号）转换成物理地址（绝对扇区号）。 "},{"id":219,"href":"/Tech/2Computer-Science/4Operating-System/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%BC%80%E5%90%AF%E5%90%AF%E5%8A%A8%E9%A1%B9/","title":"注册表开启启动项","parent":"4、Operating System","content":" 注册表开启启动项 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\nHKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n一、经典的启动——“启动”文件夹\n单击“开始→程序”，你会发现一个“启动”菜单，这就是最经典的Windows启动位置，右击“启动”菜单选择“打开”即可将其打开，其中的程序和快捷方式都会在系统启动时自动运行。\n二、有名的启动——注册表启动项\n注册表是启动程序藏身之处最多的地方，主要有以下几项：\n1.Run键\nRun键是病毒最青睐的自启动之所，该键位置是[HKEY_CURRENT_ USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]和[HKEY_ LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]，其下的所有程序在每次启动登录时都会按顺序自动执行。\n还有一个不被注意的Run键，位于注册表[HKEY_CURRENT_ USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run]和[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\nPolicies\\Explorer\\Run]，也要仔细查看。\n2.RunOnce键\nRunOnce位于[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\nCurrentVersion\\RunOnce]和[HKEY_LOCAL_MACHINE\\Software\\Microsoft\nWindows\\CurrentVersion\\RunOnce]键，与Run不同的是，RunOnce下的程序仅会被自动执行一次。\n3.RunServicesOnce键\nRunServicesOnce键位于[HKEY_CURRENT_USER\\Software\\Microsoft\nWindows\\CurrentVersion\\RunServicesOnce]和[HKEY_LOCAL_MACHINE\nSoftware\\Microsoft\\Windows\\CurrentVersion\\RunServicesOnce]下，其中的程序会在系统加载时自动启动执行一次。\n4.RunServices键\nRunServices继RunServicesOnce之后启动的程序，位于注册表[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices]和[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\nRunServices]键。\n5.RunOnceEx键\n该键是Windows XP/2003特有的自启动注册表项，位于[HKEY_ CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx]和[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx]。\n6.load键 [HKEY_CURRENT_USER\\Software\\Microsoft\\WindowsNT\\CurrentVersion\\Windows]下的load键值的程序也可以自启动。\n7.Winlogon键\n该键位于位于注册表[HKEY_CURRENT_USER\\SOFTWARE\nMicrosoft\\Windows NT\\CurrentVersion\\Winlogon]和[HKEY_LOCAL_MACHINE\nSOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon]，注意下面的Notify、Userinit、Shell键值也会有自启动的程序，而且其键值可以用逗号分隔，从而实现登录的时候启动多个程序。\n8.其他注册表位置\n还有一些其他键值，经常会有一些程序在这里自动运行，如：[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\Shell] [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellServiceObjectDelayLoad] [HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\System\\Scripts] [HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\System\\Scripts]\n小提示：\n注册表的[HKEY_LOCAL_MACHINE]和[HKEY_CURRENT_USER]键的区别：前者对所有用户有效，后者只对当前用户有效。\n三、古老的启动——自动批处理文件\n从DOS时代过来的朋友肯定知道autoexec.bat（位于系统盘根目录）这个自动批处理文件，它会在电脑启动时自动运行，早期许多病毒就看中了它，使用deltree、format等危险命令来破坏硬盘数据。如“C盘杀手”就是用一句“deltree /y c:*.*”命令，让电脑一启动就自动删除C盘所有文件，害人无数。\n小提示\n★在Windows 98中，Autoexec.bat还有一个哥们——Winstart.bat文件，winstart.bat位于Windows文件夹，也会在启动时自动执行。 ★在Windows Me/2000/XP中，上述两个批处理文件默认都不会被执行。\n四、常用的启动——系统配置文件\n在Windows的配置文件（包括Win.ini、System.ini和wininit.ini文件）也会加载一些自动运行的程序。\n1.Win.ini文件\n使用“记事本”打开Win.ini文件，在[windows]段下的“Run=”和“LOAD=”语句后面就可以直接加可执行程序，只要程序名称及路径写在“＝”后面即可。\n小提示\n“load=”后面的程序在自启动后最小化运行，而“run=”后程序则会正常运行。\n2.System.ini文件\n使用“记事本”打开System.ini文件，找到[boot]段下“shell=”语句，该语句默认为“shell=Explorer.exe”，启动的时候运行Windows外壳程序explorer.exe。病毒可不客气，如“妖之吻”病毒干脆把它改成“shell=c:\\yzw.exe”，如果你强行删除“妖之吻”病毒程序yzw.exe，Windows就会提示报错，让你重装Windows，吓人不？也有客气一点的病毒，如将该句变成“shell=Explorer.exe 其他程序名”，看到这样的情况，后面的其他程序名一定是病毒程序如图2所示。\n3.wininit.ini\nwininit.ini文件是很容易被许多电脑用户忽视的系统配置文件，因为该文件在Windows启动时自动执后会被自动删除，这就是说该文件中的命令只会自动执行一次。该配置文件主要由软件的安装程序生成，对那些在Windows图形界面启动后就不能进行删除、更新和重命名的文件进行操作。若其被病毒写上危险命令，那么后果与“C盘杀手”无异。\n小提示\n★如果不知道它们存放的位置，按F3键打开“搜索”对话框进行搜索； ★单击“开始→运行”，输入sysedit回车，打开“系统配置编辑程序”，在这里也可以方便的对上述文件进行查看与修改。\n五、智能的启动——开/关机/登录/注销脚本\n在Windows 2000/XP中，单击“开始→运行”，输入gpedit.msc回车可以打开“组策略编辑器”，在左侧窗格展开“本地计算机策略→用户配置→管理模板→系统→登录”，然后在右窗格中双击“在用户登录时运行这些程序”，单击“显示”按钮，在“登录时运行的项目”下就显示了自启动的程序。\n六、定时的启动——任务计划\n在默认情况下，“任务计划”程序随Windows一起启动并在后台运行。如果把某个程序添加到计划任务文件夹，并将计划任务设置为“系统启动时”或“登录时”，这样也可以实现程序自启动。通过“计划任务”加载的程序一般会在任务栏系统托盘区里有它们的图标。大家也可以双击“控制面板”中的“计划任务”图标查看其中的项目。\n小提示\n“任务计划”也是一个特殊的系统文件夹，单击“开始→程序→附件→系统工具→任务计划”即可打开该文件夹，从而方便进行查看和管理.\n"},{"id":220,"href":"/Tech/2Computer-Science/5Computer-Networks/Computer-Networks/","title":"Computer Networks","parent":"5、Computer Networks","content":"computer networks\n"},{"id":221,"href":"/Tech/2Computer-Science/6Database/MySQL-%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/","title":"My SQL 应知应会","parent":"6、Database","content":""},{"id":222,"href":"/Tech/2Computer-Science/6Database/MySql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"My SQL 数据类型","parent":"6、Database","content":" MySql 数据类型 一、MySQL的数据类型 主要包括以下五大类：\n整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT\n浮点数类型：FLOAT、DOUBLE、DECIMAL\n字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB\n日期类型：Date、DateTime、TimeStamp、Time、Year\n其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection 等。\n1、整数\n类型 说明 存储需求（取值范围） tinyin 很小整数 1字节（[0~255]、[-128~127]）；255 = 2^8-1；127=2^7-1 smallint 小整数 2字节（[0~65535]、[-32768~32767]）；65535 = 2^16-1 mediumint 中等 3字节（[0~16777215]）；16777215 = 2^24-1 int(intege) 普通 4字节（[0~4294967295]）；4294967295 = 2^32-1 bigint 大整数 8字节（[0~18446744073709551615]）；18446744073709551615 = 2^64-1 注： 取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。\n2、浮点数\u0026amp;定点数\n类型 说明 存储需求（取值范围） float(m,d) 单精度浮点数 4字节(8位精度) m总个数，d小数位 double(m,d) 双精度浮点数 8字节(16位精度) m总个数，d小数位 decimal(m,d) 压缩的“严格”定点数 m\u0026lt;65 ，d\u0026lt;30 注： 定点数以字符串形式存储，对精度要求高时使用decimal较好；尽量避免对浮点数进行减法和比较运算。\n3、时间/日期类型\n数据类型 格式 date YYYY-MM-DD time HH:MM:SS year YYYY datetime YYYY-MM-DD HH:MM:SS timestamp YYYYMMDD HHMMSS 注： 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。\n4、字符串(char,varchar,_text)\nMySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 "},{"id":223,"href":"/Tech/2Computer-Science/6Database/%E7%BF%BB%E8%AF%91-Mysql-%E7%9A%84-API-%E4%B9%8B%E9%AB%98%E4%BD%8E%E7%89%88%E6%9C%ACMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A-springboot-%E9%85%8D%E7%BD%AE/","title":"翻译 Mysql 的 API 之：高低版本 My Sql数据库的区别及 Springboot 配置","parent":"6、Database","content":" 高低版本MySQL数据库的 springboot 配置 1、概述 MySQL为使用MySQL Connector / J的Java编程语言开发的客户端应用程序提供连接。Connector /J实现了Java数据库连接（JDBC）API，以及它的许多增值扩展。它还支持新的X DevAPI。\nMySQL Connector / J是JDBC Type 4驱动程序。可以使用与JDBC 3.0和 JDBC 4.2规范兼容的不同版本 （请参阅 第2章，Connector / J版本以及它们支持的MySQL和Java版本）。Type 4标识表示驱动程序是MySQL协议的纯Java实现，不依赖于MySQL客户端库。\n对于使用通用设计模式的数据访问的大型程序，请考虑使用一种流行的持久性框架，如 Hibernate，Spring的JDBC模板或MyBatis SQL Maps，以减少用于调试，调整，保护和调试的JDBC代码量。保持。\n2、版本差异 目前有两个MySQL Connector / J版本可用：\nConnector / J 8.0（以前的Connector / J 6.0; 有关版本号更改的说明，请参阅 MySQL Connector / J 8.0.7中的更改）是Java 8平台的Type 4纯Java JDBC 4.2驱动程序。它提供了与MySQL 5.5,5.6,5.7和8.0的所有功能的兼容性。Connector / J 8.0提供了易于开发的功能，包括使用Driver Manager自动注册，标准化有效性检查，分类SQLExceptions，支持大量更新计数，支持包中的本地和偏移日期时间变体java.time ，支持JDBC-4 .x XML处理，支持每个连接客户端信息，并支持 NCHAR， NVARCHAR和 NCLOB数据类型。\nConnector / J 5.1也是Type 4纯Java JDBC驱动程序，符合JDBC 3.0,4.0,4.1和4.2规范。它提供了与MySQL 5.5,5.6,5.7和8.0的所有功能的兼容性。\nConnector / J版本的摘要：\nConnector / J版本 JDBC版本 MySQL服务器版 JRE支持 编译需要JDK 状态 8 4.2 5.5,5.6,5.7,8.0 1.8.x的 1.8.x的 一般可用性。推荐版本。 5.1 3.0,4.0,4.1,4.2 5.5,5.6 *，5.7 *，8.0 * 1.5.x，1.6.x，1.7.x，1.8.x * 1.5.x和1.8.x. 一般可用性 *使用某些密码套件时，Connector / J 5.1需要JRE 1.8.x才能使用SSL / TLS连接到MySQL 5.6,5.7和8.0。\n3、Connector / J 8.0新功能 它支持MySQL 5.5,5.6,5.7和8.0。\n它支持JDBC 4.2规范。\n它是Java 8平台的MySQL驱动程序。对于Java 7或更早版本，请改用Connector / J 5.1。\n它支持新的X DevAPI，通过它可以为Java应用程序提供MySQL 5.7和8.0对JSON，NoSQL，文档集合和其他功能的本机支持。有关详细信息，请参阅将MySQL用作文档存储和 X DevAPI用户指南。\n4、从旧版本升级 以下是Connector / J从5.1到8.0的一些更改，可能需要进行调整：\n1、Java 8平台上运行： Connector / J 8.0专门为在Java8平台上运行而创建。虽然已知Java8与早期Java版本强烈兼容，但确实存在不兼容性，并且在Java 8上运行之前可能需要调整设计用于Java7的代码。开发人员应参考Oracle提供的 不兼容性信息。\n2、连接属性的变化：以下是已从Connector / J 5.1更改（删除，添加，更改其名称或更改其默认值）的连接属性从Connector / J 5.1到8.0。\n已删除的属性（在连接期间不使用它们）： useDynamicCharsetInfo useBlobToStoreUTF8OutsideBMP， utf8OutsideBmpExcludedColumnNamePattern和 utf8OutsideBmpIncludedColumnNamePattern：MySQL 5.5及更高版本支持utf8mb4字符集，这是连接器/ J应用程序应使用的字符集，用于支持Unicode版本3的基本多语言平面（BMP）之外的字符。 以下日期和时间属性： dynamicCalendars noTzConversionForTimeType noTzConversionForDateType cacheDefaultTimezone useFastIntParsing useFastDateParsing useJDBCCompliantTimezoneShift useLegacyDatetimeCode useSSPSCompatibleTimezoneShift useTimezone useGmtMillisForDatetimes dumpMetadataOnColumnNotFound relaxAutoCommit strictFloatingPoint runningCTS13 retainStatementAfterResultSetClose nullNamePatternMatchesAll （自8.0.9发布以来删除） 已添加的属性： mysqlx.useAsyncProtocol 名称已更改的属性： com.mysql.jdbc.faultInjection.serverCharsetIndex 变成 com.mysql.cj.testsuite.faultInjection.serverCharsetIndex loadBalanceEnableJMX 至 ha.enableJMX replicationEnableJMX 至 ha.enableJMX 更改了默认值的属性： nullCatalogMeansCurrent现在 false默认情况下 5、Connector / J API的变化： 从版本5.1到8.0的Connector / J API的更改。您可能需要相应地调整API调用：\njava.sql.Driver在MySQL Connector / J 中实现的类的名称 已从更改 com.mysql.jdbc.Driver为 com.mysql.cj.jdbc.Driver。旧类名已被弃用。 这些常用接口的名称也已更改： ExceptionInterceptor：from com.mysql.jdbc.ExceptionInterceptor to com.mysql.cj.exceptions.ExceptionInterceptor StatementInterceptor：from com.mysql.jdbc.StatementInterceptorV2 to com.mysql.cj.interceptors.QueryInterceptor ConnectionLifecycleInterceptor：从。 com.mysql.jdbc.ConnectionLifecycleInterceptor 到 com.mysql.cj.jdbc.interceptors.ConnectionLifecycleInterceptor AuthenticationPlugin：from com.mysql.jdbc.AuthenticationPlugin to com.mysql.cj.protocol.AuthenticationPlugin BalanceStrategy：从 com.mysql.jdbc.BalanceStrategy 到 com.mysql.cj.jdbc.ha.BalanceStrategy。 6、Ant构建属性的更改 从源代码构建Connector / J的 许多Ant属性 已重命名：\n旧名 新名字 com.mysql.jdbc.extra.libs com.mysql.cj.extra.libs com.mysql.jdbc.jdk com.mysql.cj.build.jdk debug.enable com.mysql.cj.build.addDebugInfo com.mysql.jdbc.noCleanBetweenCompiles com.mysql.cj.build.noCleanBetweenCompiles com.mysql.jdbc.commercialBuild com.mysql.cj.build.commercial com.mysql.jdbc.filterLicense com.mysql.cj.build.filterLicense com.mysql.jdbc.noCryptoBuild com.mysql.cj.build.noCrypto com.mysql.jdbc.noSources com.mysql.cj.build.noSources com.mysql.jdbc.noMavenSources com.mysql.cj.build.noMavenSources major_version com.mysql.cj.build.driver.version.major minor_version com.mysql.cj.build.driver.version.minor subminor_version com.mysql.cj.build.driver.version.subminor version_status com.mysql.cj.build.driver.version.status extra.version com.mysql.cj.build.driver.version.extra snapshot.version com.mysql.cj.build.driver.version.snapshot version com.mysql.cj.build.driver.version full.version com.mysql.cj.build.driver.version.full prodDisplayName com.mysql.cj.build.driver.displayName prodName com.mysql.cj.build.driver.name fullProdName com.mysql.cj.build.driver.fullName buildDir com.mysql.cj.build.dir buildDriverDir com.mysql.cj.build.dir.driver mavenUploadDir com.mysql.cj.build.dir.maven distDir com.mysql.cj.dist.dir toPackage com.mysql.cj.dist.dir.prepare packageDest com.mysql.cj.dist.dir.package com.mysql.jdbc.docs.sourceDir com.mysql.cj.dist.dir.prebuilt.docs 已重命名或删除了 许多用于测试Connector / J的Ant属性：\n旧名 新名字 buildTestDir com.mysql.cj.testsuite.build.dir junit.results com.mysql.cj.testsuite.junit.results com.mysql.jdbc.testsuite.jvm com.mysql.cj.testsuite.jvm test com.mysql.cj.testsuite.test.class methods com.mysql.cj.testsuite.test.methods com.mysql.jdbc.testsuite.url com.mysql.cj.testsuite.url com.mysql.jdbc.testsuite.admin-url com.mysql.cj.testsuite.url.admin com.mysql.jdbc.testsuite.ClusterUrl com.mysql.cj.testsuite.url.cluster com.mysql.jdbc.testsuite.url.sha256default com.mysql.cj.testsuite.url.openssl com.mysql.jdbc.testsuite.cantGrant com.mysql.cj.testsuite.cantGrant com.mysql.jdbc.testsuite.no-multi-hosts-tests com.mysql.cj.testsuite.disable.multihost.tests com.mysql.jdbc.test.ds.host com.mysql.cj.testsuite.ds.host com.mysql.jdbc.test.ds.port com.mysql.cj.testsuite.ds.port com.mysql.jdbc.test.ds.db com.mysql.cj.testsuite.ds.db com.mysql.jdbc.test.ds.user com.mysql.cj.testsuite.ds.user com.mysql.jdbc.test.ds.password com.mysql.cj.testsuite.ds.password com.mysql.jdbc.test.tabletype com.mysql.cj.testsuite.loadstoreperf.tabletype com.mysql.jdbc.testsuite.loadstoreperf.useBigResults com.mysql.cj.testsuite.loadstoreperf.useBigResults com.mysql.jdbc.testsuite.MiniAdminTest.runShutdown com.mysql.cj.testsuite.miniAdminTest.runShutdown com.mysql.jdbc.testsuite.noDebugOutput com.mysql.cj.testsuite.noDebugOutput com.mysql.jdbc.testsuite.retainArtifacts com.mysql.cj.testsuite.retainArtifacts com.mysql.jdbc.testsuite.runLongTests com.mysql.cj.testsuite.runLongTests com.mysql.jdbc.test.ServerController.basedir com.mysql.cj.testsuite.serverController.basedir com.mysql.jdbc.ReplicationConnection.isSlave com.mysql.cj.testsuite.replicationConnection.isSlave com.mysql.jdbc.test.isLocalHostnameReplacement 删除 com.mysql.jdbc.testsuite.driver 删除 com.mysql.jdbc.testsuite.url.default 删除。不再需要，因为已从测试套件中删除了多JVM测试。 7、Exceptions 的变化 从版本5.1到8.0的Connector / J已删除了一些例外。用于捕获已删除异常的应用程序现在的相应异常捕获在下面表中列出：\n在Connector / J 5.1中删除了异常 Connector / J 8.0中的Catch异常 com.mysql.jdbc.exceptions.jdbc4.CommunicationsException com.mysql.cj.jdbc.exceptions.CommunicationsException com.mysql.jdbc.exceptions.[jdbc4.]MySQLDataException java.sql.SQLDataException com.mysql.jdbc.exceptions.[jdbc4.]MySQLIntegrityConstraintViolationException java.sql.SQLIntegrityConstraintViolationException com.mysql.jdbc.exceptions.[jdbc4.]MySQLInvalidAuthorizationSpecException java.sql.SQLInvalidAuthorizationSpecException com.mysql.jdbc.exceptions.[jdbc4.]MySQLNonTransientConnectionExceptioñ java.sql.SQLNonTransientConnectionException com.mysql.jdbc.exceptions.[jdbc4.]MySQLNonTransientException java.sql.SQLNonTransientException com.mysql.jdbc.exceptions.[jdbc4.]MySQLQueryInterruptedException com.mysql.cj.jdbc.exceptions.MySQLQueryInterruptedException com.mysql.jdbc.exceptions.MySQLStatementCancelledException com.mysql.cj.jdbc.exceptions.MySQLStatementCancelledException com.mysql.jdbc.exceptions.[jdbc4.]MySQLSyntaxErrorException java.sql.SQLSyntaxErrorException com.mysql.jdbc.exceptions.[jdbc4.]MySQLTimeoutException java.sql.SQLTimeoutException com.mysql.jdbc.exceptions.[jdbc4.]MySQLTransactionRollbackException java.sql.SQLTransactionRollbackException com.mysql.jdbc.exceptions.[jdbc4.]MySQLTransientConnectionException Ĵava.sql.SQLTransientConnectionException com.mysql.jdbc.exceptions.[jdbc4.]MySQLTransientException java.sql.SQLTransientException com.mysql.jdbc.exceptions.[jdbc4.]MySQLIntegrityConstraintViolationException java.sql.SQLIntegrityConstraintViolationException 8、其他变更 以下是Connector / J 8.0的其他更改：\n删除了ReplicationDriver。现在，您只需使用该jdbc:mysql:replication://方案即可获得复制设置的连接，而不是使用单独的驱动程序 。 Connector / J 8.0始终对日期时间值执行时间偏移调整，并且调整需要满足以下条件之一： MySQL服务器配置了Java可识别的规范时区（例如，Europe / Paris，Etc / GMT-5，UTC等） 通过设置Connector / J连接属性serverTimezone（例如， serverTimezone=Europe/Paris）来覆盖服务器的时区 。 9、Testing Connector/J 测试连接器 随源代码一起提供的Connector / J源代码库或包包含一个扩展的测试套件，其中包含可以独立执行的测试用例。测试用例分为以下几类：\nUnit tests: They are methods located in packages aligning with the classes that they test. \u0026gt; 单元测试：它们是位于包中的方法，与它们测试的类对齐。 Functional tests: Classes from the package testsuite.simple. Include test code for the main features of Connector/J. \u0026gt; 功能测试：包中的类testsuite.simple。包含Connector / J主要功能的测试代码。 Performance tests: Classes from the package testsuite.perf. Include test code to make measurements for the performance of Connector/J. \u0026gt; 性能测试：包中的类testsuite.perf。包括测试代码以测量Connector / J的性能。 Regression tests: Classes from the package testsuite.regression. Includes code for testing bug and regression fixes. \u0026gt; 回归测试：包中的类testsuite.regression。包括用于测试错误和回归修复的代码。 X DevAPI and X Protocol tests: Classes from the package testsuite.x for testing X DevAPI and X Protocol functionality. X DevAPI和X协议测试：来自包的类， testsuite.x用于测试X DevAPI和X协议功能。 要使用Ant运行测试：请阅读 MySQL 8.0 Reference Manual 10、Connector / J示例 一些使用Connector / J的示例的摘要\n例7.1，“Connector / J：从DriverManager” 获取连接 “ 例7.2，“Connector / J：使用java.sql.Statement执行 SELECT查询” 例7.3，“Connector / J：调用存储过程” 例7.4，“Connector / J：Using Connection.prepareCall()” 例7.5，“Connector / J：注册输出参数” 例7.6，“Connector / J：设置CallableStatement输入参数” 例7.7，“Connector / J：检索结果和输出参数值” 例7.8，“Connector / J：AUTO_INCREMENT使用Statement.getGeneratedKeys()” 检索列值“ 例7.9，“Connector / J：AUTO_INCREMENT使用SELECT LAST_INSERT_ID()” 检索列值“ 例7.10，“Connector / J：检索AUTO_INCREMENT列值Updatable ResultSets” 例8.1，“Connector / J：使用与J2EE应用程序服务器的连接池” 例14.1，“Connector / J：具有重试逻辑的事务示例” 11、Connector / J参考 6.1驱动程序/数据源类名 java.sql.Driver在MySQL Connector / J 中实现的类的名称 是 com.mysql.cj.jdbc.Driver。\n6.2连接URL语法 连接URL的通用格式：\nprotocol//[hosts][/database][?properties]\n针对URL任何保留的字符（例如, /, :, @, (, ), [, ], \u0026amp;, #, =, ?, and space)出现在连接URL的任何部分空间必须％的编码。\nprotocol 连接有四种可能的协议：\njdbc:mysql: 用于普通和基本的故障转移连接。 jdbc:mysql:loadbalance:用于配置负载平衡。有关 详细信息，请参见 第9.3节“使用Connector / J配置负载平衡”。 jdbc:mysql:replication:用于配置复制设置。有关详细信息，请参见 第9.4节“使用Connector / J配置主/从复制” 。 mysqlx: 用于使用X协议的连接。 hosts hosts 部分可能只包含主机名，也可能是由多个主机名，端口号，主机特定属性和用户凭证等各种元素组成的复杂结构。。\n单主机连接不添加特定于主机的属性： \u0026gt; \u0026gt; - 该hosts部分的格式为 host：port。连接URL的示例： \u0026gt; \u0026gt; - jdbc:mysql://host1:33060/sakila host可以是IPv4或IPv6主机名字符串，在后一种情况下，它必须放在方括号内，例如 “ [1000：2000 :: abcd]。”当 host没有指定，默认值localhost 被使用。 port是一个标准端口号，即1到65535之间的整数。普通MySQL连接的默认端口号是3306，使用X协议的连接是33060。如果 port未指定，则使用相应的默认值。 单主机连接添加特定于主机的属性： \u0026gt; \u0026gt; - 在这种情况下，主机被定义为一系列 。密钥用于标识主机，端口以及任何特定于主机的属性。指定键有两种备用格式： key=value \u0026gt; \u0026gt; - 在“ address-equals ”格式： \u0026gt; \u0026gt; - address=(host=host_or_ip)(port=port)(key1=value1)(key2=value2)\u0026hellip;(keyN=valueN) 在“ address-equals ”示例： \u0026gt; \u0026gt; - jdbc:mysql://address=(host=myhost)(port=1111)(key1=value1)/db 在“ key-value”格式： \u0026gt; \u0026gt; - (host=host,port=port,key1=value1,key2=value2,\u0026hellip;,keyN=valueN) 在“ key-value”示例： \u0026gt; \u0026gt; - jdbc:mysql://(host=myhost,port=1111,key1=value1)/db 可以添加其他键包括 user， password， protocol，等等。它们会覆盖properties URL部分中设置的全局值 。将覆盖限制为用户，密码，网络超时以及语句和元数据高速缓存大小; 其他每个主机覆盖的影响未定义。 key区分大小写。仅在两种情况下不同的两个密钥被认为是冲突的，并且不能保证将使用哪一个密钥 多个主机： \u0026gt; \u0026gt; - 多个主机有两种格式： \u0026gt; \u0026gt; - 以逗号分隔的列表列出主机 格式： \u0026gt; \u0026gt; - host1,host2,\u0026hellip;,hostN 示例： \u0026gt; \u0026gt; - jdbc:mysql://myhost1:1111,myhost2:2222/db jdbc:mysql://address=(host=myhost1)(port=1111)(key1=value1),address=(host=myhost2)(port=2222)(key2=value2)/db jdbc:mysql://(host=myhost1,port=1111,key1=value1),(host=myhost2,port=2222,key2=value2)/db jdbc:mysql://myhost1:1111,(host=myhost2,port=2222,key2=value2)/db mysqlx://(address=host1:1111,priority=1,key1=value1),(address=host2:2222,priority=2,key2=value2)/db 以逗号分隔的列表中列出主机，然后用方括号括起列表 格式： \u0026gt; \u0026gt; - [host1,host2,\u0026hellip;,hostN] 这称为主机子列表表单，它允许列表中的所有主机共享 用户凭据，就好像它们是单个主机一样。列表中的每个主机都可以使用上面单个主机中描述的三种方式中的任何一种进行指定 。 示例： \u0026gt; \u0026gt; - jdbc:mysql://sandy:secret@[myhost1:1111,myhost2:2222]/db jdbc:mysql://sandy:secret@[address=(host=myhost1)(port=1111)(key1=value1),address=(host=myhost2)(port=2222)(key2=value2)]/db jdbc:mysql://sandy:secret@[myhost1:1111,address=(host=myhost2)(port=2222)(key2=value2)]/db 虽然无法递归编写主机子列表，但主机列表可能包含主机子列表作为其成员主机。 用户凭据 用户凭据可以在连接URL之外设置，使用连接URL设置时，有几种方法可以指定它们：\n使用以下用户凭据对 单个主机，主机子列表或主机列表中的任何主机进行前缀 @： \u0026gt; \u0026gt; - user:password@host_or_host_sublist 示例： \u0026gt; \u0026gt; - mysqlx://sandy:secret@[(address=host1:1111,priority=1,key1=value1),(address=host2:2222,priority=2,key2=value2))]/db 使用 keys： user 和 password 为每个主机指定凭据： \u0026gt; \u0026gt; - (user=sandy)(password=mypass) 示例： \u0026gt; \u0026gt; - jdbc:mysql://[(host=myhost1,port=1111,user=sandy,password=secret),(host=myhost2,port=2222,user=finn,password=secret)]/db jdbc:mysql://address=(host=myhost1)(port=1111)(user=sandy)(password=secret),address=(host=myhost2)(port=2222)(user=finn)(password=secret)/db database 要打开的默认数据库或目录。如果未指定数据库，则建立连接时不使用默认数据库。在这种情况下，要么setCatalog() 在Connection实例上调用方法，要么在SQL语句中使用数据库名称（即，）指定表名。\nproperties 应用于所有主机的一系列全局属性 ，以符号“?”开头，以符号“\u0026amp;”分隔\n示例： \u0026gt; \u0026gt; - jdbc:mysql://(host=myhost1,port=1111),(host=myhost2,port=2222)/db?key1=value1\u0026amp;key2=value2\u0026amp;key3=value3 对于 key-value 对，以下情况如下： \u0026gt; \u0026gt; - key而且 value只是字符串。在Connector / J内部执行适当的类型转换和验证。 key区分大小写。仅在情况不同的两个密钥被认为是冲突的，并且不确定将使用哪个密钥。 使用键值对指定的任何特定于主机的值（如 具有主机特定属性的单个主机 和 上面的多个主机中所述）将覆盖此处设置的全局值。 12、JDBC相关 7.1使用JDBC DriverManager 接口连接MySQL 7.2使用JDBC Statement对象执行SQL 7.3使用JDBC CallableStatements执行存储过程 7.4 通过JDBC检索AUTO_INCREMENT列值 13、使用Connector / J连接池 14、多主机连接 以下各节讨论涉及多主机连接的许多主题，即服务器负载平衡，故障转移和复制。\n开发人员应该了解通过Connector / J管理的多主机连接的以下内容： \u0026gt; - 每个多主机连接都是底层物理连接的包装。 每个底层物理连接都有自己的会话。鉴于MySQL架构，无法跟踪，共享或复制会话。 物理连接之间的每个切换意味着会话之间的切换。 在事务边界内，物理连接之间没有切换。超出事务边界，无法保证不会发生切换。 9.1配置服务器故障转移 9.2使用X协议时配置客户端故障转移 9.3使用Connector / J配置负载平衡 9.4使用Connector / J配置主/从复制 9.5高级负载平衡和故障转移配置 15、使用Connector / J拦截器类 拦截器是一种软件设计模式，它提供了一种扩展或修改程序某些方面的透明方式，类似于用户出口。不需要重新编译。使用Connector / J，通过更新连接字符串来启用和禁用拦截器，以引用您实例化的不同拦截器类集。\n第6.3节“配置属性” 中介绍了控制拦截器的连接属性 ：\nconnectionLifecycleInterceptors，您可以在其中指定实现com.mysql.cj.jdbc.interceptors.ConnectionLifecycleInterceptor 接口的类的完全限定名称 。在这些类型的拦截器类中，您可以记录诸如回滚之类的事件，测量事务开始和结束之间的时间，或计算诸如调用之类的事件 setAutoCommit()。 exceptionInterceptors，您可以在其中指定实现com.mysql.cj.exceptions.ExceptionInterceptor 接口的类的完全限定名称 。在这些类型的拦截器类中，您可以向可能具有多个原因或指示服务器设置问题的异常添加额外的诊断信息。 exceptionInterceptors处理Exception从Connector / J代码抛出时调用类。 queryInterceptors，您可以在其中指定实现com.mysql.cj.interceptors.QueryInterceptor 接口的类的完全限定名称 。在这些类型的拦截器类中，您可以更改或扩充某些类型的语句所执行的处理，例如自动检查memcached服务器中的查询数据，重写慢速查询，记录有关语句执行的信息或将请求路由到远程服务器。 16、Spring中使用 Connector / J 13.1使用 JdbcTemplate NamedParameterJdbcTemplate，使用Spring的JDBC类来完全抽象出传统JDBC类的使用，NamedParameterJdbcTemplate可以使用全部jdbcTemplate方法，并支持 具名参数 。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34;\rxmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34;\rxsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd\rhttp://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\rhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd\u0026#34;\u0026gt;\r\u0026lt;!-- 自动扫描的包 --\u0026gt;\r\u0026lt;context:component-scan base-package=\u0026#34;com.happBKs.spring.jdbcSpring\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt;\r\u0026lt;!-- 导入资源文件 --\u0026gt;\r\u0026lt;context:property-placeholder location=\u0026#34;classpath:db.properties\u0026#34; /\u0026gt;\r\u0026lt;!-- 配置c3p0数据源 --\u0026gt;\r\u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.user}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.jdbcUrl}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${jdbc.driverClass}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;property name=\u0026#34;initialPoolSize\u0026#34; value=\u0026#34;${jdbc.initPoolSize}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;${jdbc.maxPoolSize}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;!-- 配置jdbc模板类 --\u0026gt;\r\u0026lt;bean id=\u0026#34;jdbcTemplate\u0026#34; class=\u0026#34;org.springframework.jdbc.core.JdbcTemplate\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;!-- 配置 NamedParameterJdbcTemplate，该对象可以使用具名参数。\r但它没有无参构造器，所以必须为其制定构造参数，这里指定的是出c3p0数据源\r--\u0026gt;\r\u0026lt;bean id=\u0026#34;namedParameterJdbcTemplate\u0026#34;\rclass=\u0026#34;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate\u0026#34;\u0026gt;\r\u0026lt;constructor-arg ref=\u0026#34;dataSource\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;/beans\u0026gt; Spring 中使用 Connector / J：\n// 1、Create a new application context. this processes the Spring config\rApplicationContext ctx =\rnew ClassPathXmlApplicationContext(\u0026#34;ex1appContext.xml\u0026#34;);\r// 2、Retrieve the data source from the application context\rDataSource ds = (DataSource) ctx.getBean(\u0026#34;dataSource\u0026#34;);\r// 3、Open a database connection using Spring\u0026#39;s DataSourceUtils\rConnection c = DataSourceUtils.getConnection(ds);\rtry {\r// 4、retrieve a list of three random cities\rPreparedStatement ps = c.prepareStatement(\r\u0026#34;select City.Name as \u0026#39;City\u0026#39;, Country.Name as \u0026#39;Country\u0026#39; \u0026#34; +\r\u0026#34;from City inner join Country on City.CountryCode = Country.Code \u0026#34; +\r\u0026#34;order by rand() limit 3\u0026#34;);\rResultSet rs = ps.executeQuery();\rwhile(rs.next()) {\rString city = rs.getString(\u0026#34;City\u0026#34;);\rString country = rs.getString(\u0026#34;Country\u0026#34;);\rSystem.out.printf(\u0026#34;The city %s is in %s%n\u0026#34;, city, country);\r}\r} catch (SQLException ex) {\r// something has failed and we print a stack trace to analyse the error 有些东西失败了，我们打印一个堆栈跟踪来分析错误\rex.printStackTrace();\r// 5、ignore failure closing connection 忽略故障关闭连接\rtry { c.close(); } catch (SQLException e) { }\r} finally {\r// 6、properly release our connection 正确释放连接\rDataSourceUtils.releaseConnection(c, ds);\r} 兼容配置 spring:\rprofiles: dev\rdatasource:\rurl: jdbc:mysql://192.168.100.220:3306/dts2?autoReconnect=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;zeroDateTimeBehavior=CONVERT_TO_NULL\u0026amp;useSSL=false\u0026amp;useAffectedRows=true\rusername: username\rpassword: password\rdriverClassName: com.mysql.cj.jdbc.Driver\rtype: com.alibaba.druid.pool.DruidDataSource\rinitialSize: 5\rsminIdle: 5\rmaxActive: 20\rmaxWait: 60000\rtimeBetweenEvictionRunsMillis: 60000\rminEvictableIdleTimeMillis: 300000\rvalidationQuery: SELECT 1 FROM DUAL\rtestWhileIdle: true\rtestOnBorrow: false\rtestOnReturn: false\rpoolPreparedStatements: true\rmaxPoolPreparedStatementPerConnectionSize: 20\rfilters: stat,wall,log4j "},{"id":224,"href":"/Tech/2Computer-Science/Computer-Science/","title":"Computer Science","parent":"2、Computer Science","content":" Computer Science 标签：计算机科学、《数据结构》、《计算机网络》、《计算机组成原理》、《计算机操作系统》、《离散数学》、《线性代数》、《编译原理》、《数据库原理》、《软件工程》、《软件系统设计》 时间：2020年8月7日17:33:00 连接：https://www.saveload.cn/html/templates/Thinking-In-Java.mk 清华课程表\n"},{"id":225,"href":"/Tech/2Computer-Science/Shell/","title":"Shell","parent":"2、Computer Science","content":" Shell Shell 的最通用含义是指用户用来键入命令的任何程序。shell 隐藏基础操作系统的详细信息，并管理操作系统的 应用程序编程接口（API） 的技术详细信息，该接口是在该操作系统上运行的程序使用的操作系统的级别。\n在类Unix操作系统中，用户通常有许多命令行解释器可供选择，用于交互式会话。当用户以交互方式登录系统时，shell 程序将在会话期间自动执行。shell的类型，可以为每个用户定制，通常存储在用户的配置文件中，例如在本地passwd文件或分布式配置系统（如NIS或LDAP）中;但是，用户可以交互方式执行任何其他可用的 shell。 在具有窗口系统的主机（如 macOS）上，某些用户可能永远不会直接使用 shell。在Unix系统上，shell历来是系统启动脚本的实现语言，包括启动窗口系统，配置网络和许多其他基本功能的程序。但是，一些系统供应商已经用不同的方法（如 systemd）取代了传统的基于 shell 的启动系统（init）。\nShell 在计算中，shell 是一种计算机程序，它将操作系统的服务公开给人类用户或其他程序。通常，操作系统 shell 使用命令行界面 （CLI） 或图形用户界面 （GUI），具体取决于计算机的角色和特定操作。它被命名为shell，因为它是操作系统周围的最外层。\n命令行 shell 要求用户熟悉命令及其调用语法，并了解有关特定于 shell 的脚本语言（例如 bash）的概念。\nShell 概述 操作系统为其用户提供各种服务，包括文件管理、进程管理（运行和终止应用程序）、批处理以及操作系统监视和配置。\n大多数操作系统 shell 都不是底层内核的直接接口，即使 shell 通过直接连接到计算机的外围设备与用户通信也是如此。Shell 实际上是特殊的应用程序，它们使用内核 API 的方式与其他应用程序使用内核 API 的方式相同。shell 通过提示用户输入、解释其输入，然后处理来自底层操作系统的输出（非常类似于读取-评估-打印循环，REPL）来管理用户与系统的交互。由于操作系统shell实际上是一个应用程序，对于大多数操作系统来说，它可以很容易地被另一个类似的应用程序所取代。\n除了在本地系统上运行的 shell 之外，还有不同的方法可以使本地用户可以使用远程系统。这种方法通常称为远程访问或远程管理。最初在多用户大型机上可用，通过串行线路或调制解调器连接到大型机的文本终端同时为每个活动用户提供基于文本的UI，远程访问已扩展到类Unix系统和Microsoft Windows。在类Unix系统上，Secure Shell协议通常用于基于文本的shell，而SSH隧道可用于基于X Window系统的图形用户界面（GUI）。在Microsoft Windows上，Remote Desktop Protocol可用于提供GUI远程访问，并且由于Windows Vista，PowerShell Remote可用于通过WMI，RPC和WS-Management进行基于文本的远程访问。\n大多数操作系统 shell 都属于以下两类之一：命令行和图形。命令行 shell 为操作系统提供命令行界面 （CLI），而图形 shell 提供图形用户界面 （GUI）。其他可能性虽然不那么常见，但包括语音用户界面和非 CLI 的基于文本的用户界面 （TUI） 的各种实现。基于 CLI 和 GUI 的 shell 的相对优点经常引起争论。\n终端仿真器 Terminal emulator 终端仿真器或终端应用程序是模拟其他显示体系结构中的视频终端的计算机程序。虽然术语终端通常与 shell 或文本终端同义，但术语 terminal 涵盖了所有远程终端，包括图形界面。图形用户界面中的终端仿真器通常称为终端窗口。\n终端窗口允许用户访问文本终端及其所有应用程序，如命令行界面 （CLI） 和文本用户界面 （TUI） 应用程序。它们可以在同一台计算机上运行，也可以通过 telnet、ssh、拨号或直接串行连接在另一台计算机上运行。在类Unix操作系统上，通常将一个或多个终端窗口连接到本地计算机。\nBash（Unix shell） Bash是一个Unix shell和命令语言，由Brian Fox为GNU工程编写，作为Bourne shell的自由软件替代品。它于1989年首次发布，它已被用作大多数Linux发行版的默认登录外壳。Windows 10也有一个版本可以通过Windows子系统 for Linux获得。它也是Solaris 11中的默认用户外壳。在2019年macOS Catalina发布之前，Bash也是所有苹果macOS版本的默认shell，后者将默认shell更改为zsh，尽管Bash仍然可以作为替代shell使用。\nBash 是一个命令处理器，通常在文本窗口中运行，用户在文本窗口中键入导致操作的命令。Bash 还可以从文件读取和执行命令，称为 shell 脚本。像大多数Unix shell一样，它支持文件名标注（通配符匹配），管道，此处文档，命令替换，变量以及用于条件测试和迭代的控制结构。该语言的关键字，语法，动态范围变量和其他基本功能都是从sh复制的。其他特征，例如历史，是从csh和ksh复制的。Bash是一个符合POSIX标准的shell，但有许多扩展。\nshell的名字是Bourne Again Shell的首字母缩写，是Bourne shell名称的双关语，它取代了和“重生”的概念。\nBash中有一个可追溯到1.03版本（1989年8月）的安全漏洞，被称为Shellshock，于2014年9月初被发现，并迅速导致互联网上的一系列攻击。修复这些漏洞的补丁在发现漏洞后不久就被提供。\nBash 特点 Bash 命令语法是 Bourne shell 命令语法的超集。Bash支持大括号扩展、命令行完成（可编程完成）、基本调试和信号处理（使用）自bash 2.05a以来的其他功能。Bash 可以在不进行修改的情况下执行绝大多数 Bourne shell 脚本，除了 Bourne shell 脚本在 Bash 中陷入不同解释的边缘语法行为，或者尝试运行与较新的 Bash 内置版本匹配的系统命令等。Bash命令语法包括从KornShell（ksh）和C shell（csh）中提取的思想，例如命令行编辑，命令历史（命令），目录堆栈，和变量以及POSIX命令替换语法。\nUnix shell Unix shell 是一个命令行解释器或 shell，它为类 Unix 操作系统提供命令行用户界面。shell 既是交互式命令语言又是脚本语言，操作系统使用它来控制使用 shell 脚本的系统执行。\n用户通常使用终端仿真器与Unix shell进行交互;但是，通过串行硬件连接或安全外壳直接操作对于服务器系统很常见。所有Unix shell都提供文件名通配符，管道，此处文档，命令替换，变量和控制结构，用于条件测试和迭代。\n命令行界面 命令行界面 （CLI） 以文本行的形式处理对计算机程序的命令。处理接口的程序称为命令行解释器或命令行处理器。操作系统在 shell 中实现命令行界面，以便对操作系统功能或服务进行交互式访问。从1960年代中期开始，这种访问主要由计算机终端提供给用户，并在整个1970年代和1980年代继续在VAX/VMS、Unix系统和个人计算机系统（包括DOS、CP/M和Apple DOS）上使用。\n如今，许多用户依赖于图形用户界面和菜单驱动的交互。但是，某些编程和维护任务可能没有图形用户界面，并且可能仍使用命令行。\n操作系统命令行界面 操作系统 （OS） 命令行界面通常是随操作系统提供的不同程序。实现此类文本接口的程序通常称为命令行解释器、命令处理器或 shell。\n命令行解释器的例子包括OpenVMS和RSX-11中的DEC的数字命令语言（DCL），各种Unix shell（sh，ksh，csh，tcsh，zsh，Bash等），CP / M的CCP，DOS的 COMMAND.COM，以及OS / 2和Windows CMD.EXE 计划，后者主要基于DEC的RSX-11和RSTS CLI。在大多数操作系统下，可以用替代方案替换默认的shell程序;示例包括用于 DOS 的 4DOS、用于 OS/2 的 4OS2 和适用于 Windows 的 4NT / Take Command。\n尽管术语“shell”通常用于描述命令行解释器，但严格来说，“shell”可以是构成用户界面的任何程序，包括完全面向图形的程序。例如，默认的 Windows GUI 是一个名为 EXPLORER 的 shell 程序。EXE，如 SHELL = EXPLORER 中所定义。赢单中的 EXE 行。INI 配置文件。这些程序是 shell，但不是 CLI。\n命令行解释器 在计算中，命令行解释器或命令语言解释器是一类程序的总称，旨在读取用户输入的文本行，从而实现命令行界面。\nBASIC (Beginners\u0026rsquo; All-purpose Symbolic Instruction Code)(初学者的通用符号指令代码) 在计算中，命令行解释器或命令语言解释器是一类程序的总称，旨在读取用户输入的文本行，从而实现命令行界面。\nBASIC 解释器 BASIC 解释器是一种解释器，它使用户能够以BASIC语言输入和运行程序，并且在微型计算机时代的第一部分，它是计算机将启动的默认应用程序。用户应使用 BASIC 解释器键入程序或从存储中加载程序（最初是盒式磁带，然后是软盘）。\n"},{"id":226,"href":"/Tech/2Computer-Science/SSH/","title":"SSH","parent":"2、Computer Science","content":" SSH 介绍、基本使用及原理 什么是 SSH ？ 先搬 Wikipedia:\n安全外壳协议 （SSH） 是一种加密网络协议，用于在不安全的网络上安全地操作网络服务。 它最值得注意的应用是远程登录和命令行执行。\nSSH 应用程序基于客户端-服务器体系结构，将 SSH 客户端实例与 SSH 服务器连接起来。SSH 作为一个分层协议套件运行，由三个主要的分层组件组成：传输层提供服务器身份验证，机密性和完整性;用户身份验证协议验证用户到服务器;并且连接协议将加密隧道多路复用到多个逻辑通信通道中。\nSSH 是在类 Unix 操作系统上设计的，作为 Telnet 和不安全的远程 Unix shell 协议的替代品，例如 Berkeley Remote Shell（rsh）以及相关的 rlogin 和 rexec 协议，它们都使用不安全的，明文的身份验证令牌传输。\nSSH 最初由芬兰计算机科学家 Tatu Ylönen 于 1995 年设计。协议套件的后续开发在几个开发人员组中进行，产生了几种实现变体。该协议规范区分了两个主要版本，称为 SSH-1 和 SSH-2 。最常实现的软件堆栈是 OpenSSH，由 OpenBSD 开发人员于 1999 年作为开源软件发布。实现适用于常用的所有类型的操作系统，包括嵌入式系统。\n定义 SSH 使用公钥加密对远程计算机进行身份验证，并允许它在必要时对用户进行身份验证。 SSH 可用于多种方法。以最简单的方式，通信通道的两端使用自动生成的公钥-私钥对对网络连接进行加密，然后使用密码对用户进行身份验证。\n当用户手动生成公钥-私钥对时，身份验证实质上是在创建密钥对时执行的，然后可以在没有密码提示的情况下自动打开会话。在这种情况下，公钥放置在所有计算机上，这些计算机上必须允许访问匹配私钥的所有者，该所有者保持私有。虽然身份验证基于私钥，但在身份验证期间，密钥永远不会通过网络传输。SSH 仅验证提供公钥的同一个人是否也拥有匹配的私钥。\n在所有版本的 SSH 中，在接受未知公钥为有效之前，验证未知公钥（即将公钥与身份相关联）非常重要。未经验证接受攻击者的公钥将授权未经授权的攻击者为有效用户。\n用法 SSH通常用于登录到远程计算机并执行命令，但它也支持隧道，转发TCP端口和X11连接;它可以使用关联的 SSH 文件传输 （SFTP） 或安全复制 （SCP） 协议传输文件。 SSH 使用客户端-服务器模型。\nSSH 客户端程序通常用于建立与接受远程连接的 SSH 守护程序的连接。两者都常见于大多数现代操作系统，包括macOS，Linux的大多数发行版，OpenBSD，FreeBSD，NetBSD，Solaris和OpenVMS。值得注意的是，Windows 10 版本 1709 之前的 Windows 版本默认情况下不包括 SSH。专有的、免费软件和开源的（例如PuTTY，和OpenSSH的版本，它是Cygwin的一部分）版本存在不同复杂程度和完整性的版本。类 UNIX 系统的文件管理器（例如 Konqueror）可以使用 FISH 协议来提供具有拖放功能的拆分窗格 GUI。开源Windows程序WinSCP使用PuTTY作为后端提供了类似的文件管理（同步，复制，远程删除）功能。WinSCP和PuTTY都可以打包在USB驱动器上运行，而无需在客户端计算机上安装。在 Windows 中设置 SSH 服务器通常涉及在“设置”应用中启用功能。在 Windows 10 版本 1709 中，可以使用 OpenSSH 的官方 Win32 端口。\nSSH在云计算中对于解决连接问题非常重要，避免了直接在互联网上公开基于云的虚拟机的安全问题。SSH 隧道可以通过 Internet 提供安全路径，通过防火墙到达虚拟机。\nIANA 已为此协议分配了 TCP 端口 22、UDP 端口 22 和 SCTP 端口 22。早在2001年，IANA就将SSH服务器的标准TCP端口22列为知名端口之一。SSH也可以使用SCTP而不是TCP作为面向连接的传输层协议来运行。\n用途 SSH是一种协议，可用于跨许多平台的许多应用程序，包括大多数Unix变体（Linux，包括Apple的macOS和Solaris在内的BSD）以及Microsoft Windows。下面的某些应用程序可能需要仅可用或与特定 SSH 客户端或服务器兼容的功能。例如，使用SSH协议实现VPN是可能的，但目前只有OpenSSH服务器和客户端实现。\n用于登录到远程主机上的 shell（替换 Telnet 和 rlogin) 用于在远程主机上执行单个命令（替换 rsh) 用于设置自动（无密码）登录到远程服务器（例如，使用OpenSSH[24]) 与 rsync 结合使用，可高效、安全地备份、复制和镜像文件 用于转发端口 用于隧道（不要与VPN混淆，VPN在不同网络之间路由数据包，或将两个广播域桥接到一个网络中）。 用作成熟的加密VPN。请注意，只有 OpenSSH 服务器和客户端支持此功能。 用于从远程主机转发 X（可通过多个中间主机） 用于通过与支持 SOCKS 协议的 SSH 客户端的加密代理连接浏览 Web。 用于使用 SSHFS 将远程服务器上的目录作为文件系统安全地挂载到本地计算机上。 用于通过上面讨论的一种或多种机制自动远程监视和管理服务器。 用于在支持 SSH 的移动或嵌入式设备上进行开发。 用于保护文件传输协议。 "},{"id":227,"href":"/Tech/2Computer-Science/UnicodeUTF-8UTF-16/","title":"Unicode、 Utf 8、 Utf 16","parent":"2、Computer Science","content":" ASCII、Unicode、UTF-8、UTF-16 ASCII 计算机只能理解二进制，二进制语言是面向机器的语言，人类能理解的是字符，编码 实际是一种 二进制 与 字符 的映射关系。 ASCII 码实际上是一种映射关系的具体实现，是从二进制字符到字母数字字符的映射\nBase64 Base64 也称为 Base64 内容传输编码。Base64 是将二进制数据编码为 ASCII 文本。但它只使用了 64 个字符，再加上大多数字符集中存在的一个填充字符。所以它是一种仅使用可打印字符表示二进制数据的方法。Base64 常用于在通常处理文本数据的场景，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。\nBase64 编码用于通过不能正确处理二进制数据的介质传输数据。因此，对数据进行 Base64 编码以确保数据完整，无需通过此介质进行任何修改。\nUnicode Unicode 是另一种字符编码（映射关系的具体实现），它仍然是：位查找 -\u0026gt; 字符，由 Unicode Consortium 维护，其负责制定国际使用的软件标准。IT 行业将 Unicode 标准化以对计算机和其他电子和通信设备中的字符进行编码和表示。\nUnicode 由许多代码点组成（将来自世界各地的大量字符映射到所有计算机都可以引用的键），代码点的集合称为字符集，这就是 Unicode。开发 Unicode 的目标是通过一种独特的方式将世界上任何语言的任何字符或符号转换成唯一的数字。可以在 unicode.org 上查找任何 Unicode 字符的编号，包括表情符号！\nUnicode ASCII 含义 通用字符集 美国信息交换标准代码 用法 由IT行业标准化,用于在计算机中编码和表示字符。 用于电子通信和HTML等编程语言。 表示内容 表示大量字符、公式、数学符号和来自不同语言的文本。 ASCII用于表示英文字母、数字、一些数学符号和语法符号,如标点符号、感叹号等 编码位数 使用四种编码格式，即UTF-7、UTF-8、UTF-16、UTF-32，分别使用7、8、16和32位。 使用 7 位或 8 位来表示各种字符。 内存占用 Unicode 的UTF-8、UTF-16 和UTF-32 编码方案分别使用8、16和32 位，因此占用的内存较多。 在编码中使用 7 或 8 位；因此，它在内存中占用的空间较小。 UTF-8、UTF-16、UTF-32 （1）基本概念 UTF 是 Unicode 编码方式的一种。UTF 编码由 Unicode 标准定义，能够对需要的每个 Unicode 代码点进行编码。Unicode 编码方案根据用于对字符进行编码的位数进行分类。目前使用的 Unicode 编码方案有 UTF-7、UTF-8、UTF-16 和 UTF-32 ，分别使用 7 位、8 位、16 位和 32 位来表示字符。\n那如何知道文件将使用哪种编码呢？有一种称为字节顺序标记(BOM，即 Byte Order Mark) 的东西，也称为编码签名。BOM是文件开头的一个两字节标记，用于标识文件是采用哪种格式的编码。\nUTF-8 在互联网上使用最多，在 HTML5 中也被指定为文档的首选编码。\n"},{"id":228,"href":"/Tech/2Computer-Science/%E7%BC%96%E7%A0%81%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E6%BC%94%E8%BF%9B%E7%AE%80%E5%8F%B2/","title":"编码，加密，与密码哈希演进简史","parent":"2、Computer Science","content":" 编码，加密，与密码哈希演进简史 转自：编码，加密，与密码哈希演进简史\n作者：logto\n链接：https://www.v2ex.com/t/957713#reply18\n来源：V2EX\n前言 字如其名，密码哈希是从密码计算哈希值的过程。哈希值通常存储在数据库中，在登录过程中，用户输入的密码的哈希值会被计算并与存储在数据库中的哈希值进行比较。如果匹配成功，则验证通过。\n在我们深入了解密码哈希算法的演进之前，我们先简单探讨一下为什么需要它。\n明文密码：一个重大的安全风险 想象一下，你是一个网站的用户，并在该网站注册了一个账户。有一天，该网站被黑客攻击，数据库泄漏了。如果网站以明文形式存储密码，黑客可以直接访问你的密码。由于许多人在多个网站上重复使用密码，黑客可以使用这个密码来未经授权地访问你的其他账户。如果你在电子邮件账户上使用相同或类似的密码，情况会变得更糟，因为黑客可以重置你的密码并接管你所有关联的账户。\n即使没有数据泄漏，在大型团队中，任何有数据库访问权限的人都可以看到密码。与其他信息相比，密码具有高度敏感性，你绝对不希望任何人能够访问它们。\n很明显，明文存储密码是一个业余的错误。不幸的是，如果你搜索“password leak plaintext”，你会发现像 Facebook、DailyQuiz 和 GoDaddy 这样的大公司都曾遭遇明文密码泄漏。很可能还有许多其他公司犯了同样的错误。\n编码（ encoding ），加密（ encryption ），哈希（ hashing ） 这三个术语经常被混淆，但它们是不同的概念。\n编码（ encoding ） 编码是密码存储中首先要排除的内容。例如，Base64 是一种编码算法，将二进制数据转换为字符字符串（ Node.js ）：\nconst data = \u0026#39;Hello, world!\u0026#39;;\rconst encoded = Buffer.from(data).toString(\u0026#39;base64\u0026#39;);\rconsole.log(encoded); // SGVsbG8sIHdvcmxkIQ== 知道编码算法后，任何人都可以解码编码后的字符串并恢复原始数据：\nconst encoded = \u0026#39;SGVsbG8sIHdvcmxkIQ==\u0026#39;;\rconst data = Buffer.from(encoded, \u0026#39;base64\u0026#39;).toString();\rconsole.log(data); // Hello, world! 对于黑客来说，大多数编码算法等同于明文。常见的编码有 ASCII、UTF－8、Unicode、Base64 等.\n加密（ encryption ） 在哈希算法流行之前，加密也被用于存储密码，例如使用 AES 。加密涉及使用密钥（或一对密钥）对数据进行加密和解密。\n加密的问题在于“解密”一词。这意味着加密是可逆的，如果黑客获得密钥，他们可以解密密码并获取明文密码。\n哈希（ hashing ） 哈希、编码和加密之间的主要区别在于哈希是不可逆的。一旦密码经过哈希处理，就无法解密回其原始形式。\n作为网站所有者，你实际上不需要知道密码本身，只要用户可以使用正确的密码登录即可。注册过程可以简化如下：\n用户输入密码。 服务使用哈希算法计算密码的哈希值。 服务将哈希值存储在数据库中。 用户登录时的过程是：\n用户输入密码。 服务使用相同的哈希算法计算密码的哈希值。 服务将哈希值与存储在数据库中的哈希值进行比较。 如果哈希值匹配，用户得到验证。 这两个过程都避免了以明文形式存储密码，并且由于哈希是不可逆的，即使数据库被入侵，黑客只能获取到看起来像随机字符串的哈希值。\n哈希算法入门包 哈希可能看起来是密码存储的完美解决方案，但事实并非如此简单。为了了解其中的原因，让我们探讨一下密码哈希算法的演进。\nMD5 1992 年，Ron Rivest 设计了 MD5 算法，这是一种消息摘要算法，可以从任意数据计算出一个 128 位的哈希值。MD5 已广泛用于各个领域，包括密码哈希。例如，\u0026ldquo;123456\u0026rdquo; 的 MD5 哈希值为：\ne10adc3949ba59abbe56e057f20f883e 如前所述，哈希值看起来像随机字符串，并且是不可逆的。此外，MD5 速度快、易于实现，使其成为最流行的密码哈希算法。\n然而，MD5 的优点也是密码哈希中的弱点。它的速度使得它容易受到暴力破解的攻击。如果黑客拥有常见密码列表和你的个人信息，他们可以计算每个组合的 MD5 哈希值，并将其与数据库中的哈希值进行比较。例如，他们可能将你的生日与你的姓名或宠物的名字组合起来。\n如今，计算机的计算能力远远超过以前，使得暴力破解 MD5 密码哈希变得容易。\nSHA 家族 那么，为什么不使用生成更长哈希值的算法呢？SHA 家族 似乎是一个不错的选择。SHA-1 是一种生成 160 位哈希值的哈希算法，而 SHA-2 是一系列生成 224 位、256 位、384 位和 512 位长度哈希值的哈希算法。让我们看看 \u0026ldquo;123456\u0026rdquo; 的 SHA-256 哈希值：\n8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 SHA-256 哈希值比 MD5 长得多，而且也是不可逆的。然而，还存在一个问题：如果你已经知道哈希值，比如上面那个哈希值，并且在数据库中看到了完全相同的哈希值，那么你就会知道密码是 \u0026ldquo;123456\u0026rdquo;。黑客可以创建一个常见密码和它们对应的哈希值列表，并将其与数据库中的哈希值进行比较。这个列表被称为彩虹表。\n盐值（ salt ） 为了减轻彩虹表攻击，引入了盐值的概念。盐值是在哈希之前添加到密码的随机字符串。例如，如果盐值是 \u0026ldquo;salt\u0026rdquo;，那就使用 SHA-256 将密码 \u0026ldquo;123456\u0026rdquo; 与盐值一起哈希。假设原有函数：\nsha256(\u0026#39;123456\u0026#39;); 改成这样即可：\nsha256(\u0026#39;salt123456\u0026#39;); // 9898410d7f5045bc673db80c1a49b74f088fd7440037d8ce25c7d272a505bce5 正如你所看到的，结果与不带盐值的哈希完全不同。通常，每个用户在注册过程中被分配一个随机的盐值，并且存储在数据库中的密码哈希值旁边。在登录过程中，盐值用于计算输入密码的哈希值，然后将其与存储的哈希值进行比较。\n迭代（ iteration ） 尽管添加了盐值，但随着硬件的增强，哈希值仍然容易受到暴力破解的攻击。为了增加难度，可以引入迭代（即多次运行哈希算法）。例如，将算法：\nsha256(\u0026#39;salt123456\u0026#39;); 改成这样：\nsha256(\u0026#39;salt\u0026#39; + sha256(\u0026#39;salt123456\u0026#39;)); 增加迭代次数使暴力破解更加困难。然而，这也会影响登录过程，使其变慢。因此，需要在安全性和性能之间取得平衡。\n总结 密码哈希算法的特点：\n不可逆（ preimage resistance ） 难以暴力破解 抵抗彩虹表攻击 你可能已经注意到，盐值和迭代都是满足所有这些要求所必需的。问题在于，MD5 和 SHA 家族都不是专门为密码哈希而设计的；它们广泛用于完整性检查（或“消息摘要”）。因此，每个网站可能都有自己的盐值和迭代实现，使得标准化和迁移具有挑战性。\n密码哈希算法 为了解决这个问题，一些专门为密码哈希而设计的哈希算法已经出现。让我们来看看其中一些。\nbcrypt bcrypt 是由 Niels Provos 和 David Mazières 设计的一种密码哈希算法。它在许多编程语言中广泛使用。下面是 bcrypt 哈希值的一个示例：\n$2y$12$wNt7lt/xf8wRJgPU7kK2juGrirhHK4gdb0NiCRdsSoAxqQoNbiluu 尽管它看起来像另一个随机字符串，但它包含了额外的信息。让我们拆分一下：\n[$2y][$12][$wNt7lt/xf8wRJgPU7kK2ju][GrirhHK4gdb0NiCRdsSoAxqQoNbiluu] 第一部分 $2y 表示算法，即 2y。 第二部分 $12 表示迭代次数，即 12。这意味着哈希算法将运行 2^12=4096 次（迭代）。 第三部分 wNt7lt/xf8wRJgPU7kK2ju 是盐值。 最后部分 GrirhHK4gdb0NiCRdsSoAxqQoNbiluu 是哈希值。 bcrypt 有一些限制：\n密码的最大长度为 72 个字节。 盐值的长度限制为 16 个字节。 哈希值的长度限制为 184 位。 Argon2 考虑到现有密码哈希算法的争议和限制（也许是大家累了），在 2015 年举行了一场 密码哈希竞赛。其中细节在此不表，让我们聚焦于获胜者：Argon2 。\nArgon2 是由 Alex Biryukov 、Daniel Dinu 和 Dmitry Khovratovich 设计的密码哈希算法。它引入了几个新特性：\nMemory-hard：该算法设计成难以并行化，使得使用 GPU 进行暴力破解变得具有挑战性。 Time-hard：该算法设计成难以优化，使得使用 ASIC （专用集成电路）进行暴力破解变得困难。 抵抗 side-channel 攻击：该算法设计成可以抵抗 side-channel 攻击，如 timing attack 。 Argon2 有两个主要版本，Argon2i 和 Argon2d 。Argon2i 对 side-channel 攻击最安全，而 Argon2d 对 GPU 破解攻击提供了最高的抵抗力。\n\u0026ndash; Argon2\n下面是 Argon2 哈希值的一个示例：\n$argon2i$v=19$m=16,t=2,p=1$YTZ5ZnpXRWN5SlpjMHBDRQ$12oUmJ6xV5bIadzZHkuLTg 让我们拆分一下：\n[$argon2i][$v=19][$m=16,t=2,p=1][$YTZ5ZnpXRWN5SlpjMHBDRQ][$12oUmJ6xV5bIadzZHkuLTg] 第一部分 $argon2i 表示算法，即 argon2i。 第二部分 $v=19 表示版本，即 19。 第三部分 $m=16,t=2,p=1 表示内存成本、时间成本和并行度，分别为 16、2 和 1。 第四部分 $YTZ5ZnpXRWN5SlpjMHBDRQ 是盐值。 最后部分 $12oUmJ6xV5bIadzZHkuLTg 是哈希值。 在 Argon2 中，密码的最大长度为 2^32-1 个字节，盐值的长度限制为 2^32-1 个字节，哈希值的长度限制为 2^32-1 个字节。这在大多数情况下应该够用了。:-)\n现在，Argon2 已经在许多编程语言中可用，比如 Node.js 的 node-argon2 和 Python 的 argon2-cffi。\n结论 多年来，密码哈希算法经历了显著的演进。我们应该感谢安全社区几十年来在使互联网更安全方面所做的努力。由于他们的贡献，使得广大开发者可以更加专注于构建更好的服务和产品，而不用担心密码哈希的安全性。于此同时，虽然无法构建 100% 安全的系统（例如 social engineering 总是防不胜防），但是我们可以通过不同的手段不断降低安全风险发生的概率。\n如果你想避免实现身份验证和授权的麻烦，可以尝试 Logto 。我们提供安全（ Logto 使用 Argon2 ！）、可靠和可扩展的开源及 cloud 解决方案。\n"},{"id":229,"href":"/Tech/3Java/About_System_Gc_And_Finalize/","title":"About System Gc and Finalize","parent":"3、Java","content":" 转：关于system.gc()与finalize()方法 注：本文的目的并不是鼓励使用finalize方法，而是大致理清其作用、问题以及GC执行finalize的过程。\n1、finalize的作用 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题] 2、finalize的问题 一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法 System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们 Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行 finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) 3、finalize的执行过程(生命周期) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。 具体的finalize流程： 对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下： unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的 finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行 finalized: 表示GC已经对该对象执行过finalize方法 reachable: 表示GC Roots引用可达 finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达 unreachable：对象不可通过上面两种途径可达 状态变迁图： 变迁说明： 新建对象首先处于[reachable, unfinalized]状态(A) 随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态 若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。 在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N) 处于finalizable状态的对象不能同时是unreachable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因 程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为 若JVM检测到finalized状态的对象变成unreachable，回收其内存(I) 若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O） 注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法 4、一些代码示例 对象复活 public class GC { public static GC SAVE_HOOK = null; public static void main(String[] args) throws InterruptedException { SAVE_HOOK = new GC(); SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (null != SAVE_HOOK) { //此时对象应该处于(reachable, finalized)状态 System.out.println(\u0026#34;Yes , I am still alive\u0026#34;); } else { System.out.println(\u0026#34;No , I am dead\u0026#34;); } SAVE_HOOK = null; System.gc(); Thread.sleep(500); if (null != SAVE_HOOK) { System.out.println(\u0026#34;Yes , I am still alive\u0026#34;); } else { System.out.println(\u0026#34;No , I am dead\u0026#34;); } } protected void finalize() throws Throwable { super.finalize(); System.out.println(\u0026#34;execute method finalize()\u0026#34;); SAVE_HOOK = this; } } 覆盖finalize方法以确保资源释放 作为一个补充操作，以防用户忘记“关闭“资源，JDK中FileInputStream、FileOutputStream、Connection类均用了此”技术“，下面代码摘自FileInputStream类\n/** * Ensures that the \u0026lt;code\u0026gt;close\u0026lt;/code\u0026gt; method of this file input stream is * called when there are no more references to it. * * @exception IOException if an I/O error occurs. * @see java.io.FileInputStream#close() */ protected void finalize() throws IOException { if ((fd != null) \u0026amp;\u0026amp; (fd != FileDescriptor.in)) { /* * Finalizer should not release the FileDescriptor if another * stream is still using it. If the user directly invokes * close() then the FileDescriptor is also released. */ runningFinalize.set(Boolean.TRUE); try { close(); } finally { runningFinalize.set(Boolean.FALSE); } } } 转自：https://blog.csdn.net/u013249965/article/details/52640335\n"},{"id":230,"href":"/Tech/3Java/Apache-Flink/Apache-Flink/","title":"Apache Flink","parent":"Apache Flink","content":""},{"id":231,"href":"/Tech/3Java/Apache-Shiro/Apache-Shiro/","title":"Apache Shiro","parent":"Apache Shiro","content":" Apache Shiro Apache Shiro（发音为“shee-roh”，日语中的\u0026rsquo;castle\u0026rsquo;）是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理，并可用于保护任何应用程序。\n核心概念：Subject, SecurityManager, and Realms Subject Subject这个词是一个安全术语，基本上是指“当前正在执行的用户”。它只是不被称为“用户”，因为“用户”这个词通常与人类有关。在安全的世界，术语“主题”可以指一个人，但也有可能是会谈进程，守护进程帐户，或任何类似。它只是意味着“当前与软件交互的东西”。可以将其视为Shiro的“用户”概念。可以在代码中的任何位置轻松获取Shiro Subject。\n例如：\nimport org.apache.shiro.subject.Subject;\rimport org.apache.shiro.SecurityUtils;\r...\rSubject currentUser = SecurityUtils.getSubject(); 获得 Subject 后，您可以立即访问当前用户希望使用Shiro执行的所有操作的90％，例如登录，注销，访问其会话，执行授权检查等等\nSecurityManager 安全管理器 Subject 的“幕后”对应物是SecurityManager。当Subject表示当前用户的安全操作时，SecurityManager管理所有用户的安全操作。它是Shiro架构的核心，充当一种“伞形”对象，它引用了许多形成对象图的内部嵌套安全组件。但是，一旦配置了SecurityManager及其内部对象图，通常就会将其保留，应用程序开发人员几乎将所有时间花在Subject API上。\nRealms Shiro的第三个也是最后一个核心概念是一个领域。Realm充当Shiro与应用程序安全数据之间的“桥接”或“连接器”。也就是说，当实际与安全相关的数据（如用户帐户）进行交互以执行身份验证（登录）和授权（访问控制）时，Shiro会从为应用程序配置的一个或多个领域中查找许多这些内容。\n从这个意义上讲，Realm本质上是一个特定于安全性的DAO：它封装了数据源的连接细节，并根据需要使相关数据可用于Shiro。配置Shiro时，必须至少指定一个Realm用于身份验证和/或授权。可以配置多个Realm，但至少需要一个。\nShiro提供了开箱即用的Realms，可以连接到许多安全数据源（也称为目录），如LDAP，关系数据库（JDBC），文本配置源（如INI和属性文件等）。如果默认域不符合您的需要，您可以插入自己的Realm实现来表示自定义数据源。\n认证 身份验证是验证用户身份的过程。也就是说，当用户使用应用程序进行身份验证时，他们证明他们实际上是他们所说的人。这有时也被称为“登录”。这通常是一个三步过程。\n收集用户的标识信息，称为主体，并支持身份证明，称为凭证。 将主体和凭据提交给系统。 如果提交的凭据与系统对该用户标识（主体）的期望值匹配，则认为该用户已通过身份验证。如果它们不匹配，则不会将用户视为已通过身份验证。 Shiro有一个以 Subject 为中心的API - 几乎所有你在运行时用Shiro做的事都是通过与当前正在执行的 Subject 进行交互来实现的。因此，要登录 Subject ，只需调用其登录方法，传递一个AuthenticationToken实例，该实例表示提交的主体和凭据（在本例中为用户名和密码）。\n例如：\n//1. Acquire submitted principals and credentials:\rAuthenticationToken token =\rnew UsernamePasswordToken(username, password);\r//2. Get the current Subject:\rSubject currentUser = SecurityUtils.getSubject();\r//3. Login:\rcurrentUser.login(token); 如您所见，Shiro的API很容易反映出常见的工作流程。您将继续将此简单性视为所有主题操作的主题。调用login方法时，SecurityManager将接收AuthenticationToken并将其分派给一个或多个已配置的域，以允许每个域根据需要执行身份验证检查。每个Realm都能够根据需要对提交的AuthenticationTokens做出反应。\n如果登录尝试失败会发生什么？如果用户指定了错误的密码该怎么办？您可以通过对Shiro的运行时AuthenticationException作出反应来处理故障\n可以选择捕获其中一个AuthenticationException子类并进行具体反应。\n在成功登录主题后，它们将被视为已通过身份验证，通常您允许它们使用您的应用程序。但仅仅因为用户证明了他们的身份并不意味着他们可以在您的应用程序中做任何他们想做的事情。这引出了下一个问题，“我如何控制允许用户做什么？”决定允许用户做什么称为 Authorization （授权）。\nAuthorization 授权本质上是访问控制 - 控制用户可以在应用程序中访问的内容，例如资源，网页等。大多数用户通过使用角色和权限等概念来执行访问控制。也就是说，通常允许用户基于分配给他们的角色和/或许可来做某事或不做某事。然后，您的应用程序可以根据对这些角色和权限的检查来控制公开的功能。正如您所料，Subject API允许您非常轻松地执行角色和权限检查。\n例如：\n//角色检查\rif ( subject.hasRole(“administrator”) ) {\r//show the ‘Create User’ button\r} else {\r//grey-out the button?\r} Permission （权限）\n为此，Shiro支持其 Permission （权限） 概念。权限是一个原始的功能声明，例如“打开一扇门”，“创建一个博客条目”，“删除\u0026rsquo;jsmith\u0026rsquo;用户\u0026rsquo;等。通过拥有反映应用程序原始功能的权限，您只需要更改权限更改应用程序的功能时检查。反过来，您可以在运行时根据需要为角色或用户分配权限。\n例如：\n//权限检查\rif ( subject.isPermitted(“user:create”) ) {\r//show the ‘Create User’ button\r} else {\r//grey-out the button?\r} “user：create”字符串是遵循某些解析约定的权限字符串的示例。Shiro通过WildcardPermission开箱即用，支持这种约定。instance-level\nWildcardPermission在创建安全策略时非常灵活，甚至支持instance-level (实例级)访问控制等内容。\n例如：\n//实例级权限检查\rif ( subject.isPermitted(“user:create:jsmith”) ) {\r//show the ‘Create User’ button\r} else {\r//grey-out the button?\r} Session Management 会话管理 Subject 的 Session ：\nSession session = subject.getSession（）; //该参数确定是否将创建新的Session（如果它尚不存在）\rSession session = subject.getSession（boolean create）; Cryptography 加密 密码学是隐藏或混淆数据的过程，因此窥探眼睛无法理解它。Shiro在加密方面的目标是简化并使JDK的加密支持变得可用。\n重要的是要注意密码学一般不是特定于受试者，因此它是Shiro API的一个非特定主题的区域。您可以在任何地方使用Shiro的加密支持，即使没有使用主题。Shiro真正关注其加密支持的两个领域是加密哈希（也称为消息摘要）和加密密码。\nShiro简化了散列和编码的程度。\n下面是实际代码： 认证 Subjects 第1步：收集主题的主体和凭据 //Example using most common scenario of username/password pair:\rUsernamePasswordToken token = new UsernamePasswordToken(username, password);\r//\u0026#34;Remember Me\u0026#34; built-in: token.setRememberMe(true); 这里需要注意的是，Shiro并不关心如何获取这些信息：数据可能是由提交HTML表单的用户获取的，也可能是从HTTP头中检索的，或者可能是从Swing或Flex中读取的GUI密码表单，或者可能通过命令行参数。\n- - 第2步：提交委托人和凭证\nSubject currentUser = SecurityUtils.getSubject();\r//对login方法的调用表示认证尝试。\rcurrentUser.login(token); 在收集了主体和凭据并将其表示为AuthenticationToken实例之后，我们需要将令牌提交给Shiro以执行实际的身份验证尝试。\n- - 第3步：处理成功或失败\nShiro具有丰富的运行时AuthenticationException层次结构，可以准确指示尝试失败的原因。\r- - 第4步：注销\n//removes all identifying information and invalidates their session too.\rcurrentUser.logout(); 调用 logout 时，任何现有的Session将被取消，并且任何身份将被取消关联（例如，在Web应用程序中，RememberMe cookie也将被删除）。强烈建议在调用后立即将最终用户重定向到新的视图或页面\nRealm 实现 AuthenticatingRealm 覆盖 doAuthenticationInfo 方法\n"},{"id":232,"href":"/Tech/3Java/CGLIBCode-Generation-Library-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86/","title":"Cglib( Code Generation Library) 介绍与原理","parent":"3、Java","content":""},{"id":233,"href":"/Tech/3Java/error/","title":"Error","parent":"3、Java","content":"error.md\nshardingsphere sql distinct 关键字支持异常， 当一个分库有数据，一个分库无数据时，会有异常。\n"},{"id":234,"href":"/Tech/3Java/FreeMarker/FreeMarker/","title":"Free Marker","parent":"FreeMarker","content":" FreeMarker 什么是 FreeMarker? FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。\n模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。\n模板开发指南 入门 本章内容只是对 FreeMarker 进行简略的介绍，在后续章节中将会详细展开讲述。 不过没有关系，在阅读了本章节的内容后，就能够编写简单，但却很有用的FreeMarker模板程序了。\n模板 + 数据模型 = 输出 "},{"id":235,"href":"/Tech/3Java/Java-Code/Java-Function/","title":"Java Function","parent":"Java Code","content":" Java 函数式编程 一、背景 1.Lambda表达式的语法 2.函数式接口 二、Lambda表达式的基本使用 三、语法精简 四、变量捕获 五、Lambda在集合当中的使用 1.Collection接口 六、Lambda 与四大函数接口的使用 七、总结 一、背景 Lambda 表达式是 Java8 中一个重要的新特性。lambda 表达式允许你通过 表达式 来代替功能接口。 lambda 表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码 块)。 Lambda 表达式（Lambda expression）可以看作是一个匿名函数，基于数学中的λ演算得名，也可称为闭包（Closure）\nLambda 表达式是对函数接口进行简单的实现 1.Lambda表达式的语法 基本语法: (parameters) -\u0026gt; expression 或 (parameters) -\u0026gt;{ statements; }\nLambda表达式由三部分组成： 1.paramaters：类似方法中的形参列表，这里的参数是函数式接口里的参数。这里的参数类型可以明确的声明 也可不声明而由JVM隐含的推断。另外当只有一个推断类型时可以省略掉圆括号。 2.-\u0026gt;：可理解为“被用于”的意思 3.方法体：可以是表达式也可以代码块，是函数式接口里方法的实现。代码块可返回一个值或者什么都不反 回，这里的代码块块等同于方法的方法体。如果是表达式，也可以返回一个值或者什么都不反回。 2.函数式接口 要了解Lambda表达式,首先需要了解什么是函数式接口，\n函数式接口定义： 一个接口有且只有一个抽象方法 。\n注意：\n1.如果一个接口只有一个抽象方法，那么该接口就是一个函数式接口 2.如果我们在某个接口上声明了 @FunctionalInterface 注解，那么编译器就会按照函数式接口的定义来要求该接口，这样如果有两个抽象方法，程序编译就会报错的。所以，从某种意义上来说，只要你保证你的接口 中只有一个抽象方法，你可以不加这个注解。加上就会自动进行检测的。 定义方式： @FunctionalInterface\rinterface NoParameterNoReturn {\r//注意：只能有一个抽象方法\rvoid test();\r} 但是这种方式也是可以的：\n@FunctionalInterface\rinterface NoParameterNoReturn {\rvoid test();\rdefault void test2() {\rSystem.out.println(\u0026#34;JDK1.8新特性，default默认方法可以有具体的实现\u0026#34;);\r}\r} 二、Lambda表达式的基本使用 首先，我们实现准备好几个接口：\n@FunctionalInterface\rinterface NoParameterNoReturn {\r//注意：只能有一个抽象方法\rvoid test();\r}\r//无返回值一个参数\r@FunctionalInterface\rinterface OneParameterNoReturn {\rvoid test(int a);\r}\r//无返回值多个参数\r@FunctionalInterface\rinterface MoreParameterNoReturn {\rvoid test(int a, int b);\r}\r//有返回值无参数\r@FunctionalInterface\rinterface NoParameterReturn {\rint test();\r}\r//有返回值一个参数\r@FunctionalInterface\rinterface OneParameterReturn {\rint test(int a);\r}\r//有返回值多参数\r@FunctionalInterface\rinterface MoreParameterReturn {\rint test(int a, int b);\r} 我们在上面提到过，Lambda 表达式本质是一个匿名函数，函数的方法是：返回值 方法名 参数列表 方法体。在，Lambda表达式中我们只需要关心：参数列表 方法体。\n具体使用见以下示例代码：\n@FunctionalInterface\rinterface NoParameterNoReturn {\r//注意：只能有一个抽象方法\rvoid test();\r}\r//无返回值一个参数\r@FunctionalInterface\rinterface OneParameterNoReturn {\rvoid test(int a);\r}\r//无返回值多个参数\r@FunctionalInterface\rinterface MoreParameterNoReturn {\rvoid test(int a, int b);\r}\r//有返回值无参数\r@FunctionalInterface\rinterface NoParameterReturn {\rint test();\r}\r//有返回值一个参数\r@FunctionalInterface\rinterface OneParameterReturn {\rint test(int a);\r}\r//有返回值多参数\r@FunctionalInterface\rinterface MoreParameterReturn {\rint test(int a, int b);\r}\rpublic class TestDemo2 {\rpublic static void main(String[] args) {\rNoParameterNoReturn noParameterNoReturn = () -\u0026gt; {\rSystem.out.println(\u0026#34;无参数无返回值\u0026#34;);\r};\r//test方法的主体内容在上述括号内\rnoParameterNoReturn.test();\rOneParameterNoReturn oneParameterNoReturn = (int a) -\u0026gt; {\rSystem.out.println(\u0026#34;无参数一个返回值：\u0026#34; + a);\r};\roneParameterNoReturn.test(10);\rMoreParameterNoReturn moreParameterNoReturn = (int a, int b) -\u0026gt; {\rSystem.out.println(\u0026#34;无返回值多个参数：\u0026#34; + a + \u0026#34; \u0026#34; + b);\r};\rmoreParameterNoReturn.test(20, 30);\rNoParameterReturn noParameterReturn = () -\u0026gt; {\rSystem.out.println(\u0026#34;有返回值无参数！\u0026#34;);\rreturn 40;\r};\r//接收函数的返回值\rint ret = noParameterReturn.test();\rSystem.out.println(ret);\rOneParameterReturn oneParameterReturn = (int a) -\u0026gt; {\rSystem.out.println(\u0026#34;有返回值有参数！\u0026#34;);\rreturn a;\r};\rret = oneParameterReturn.test(50);\rSystem.out.println(ret);\rMoreParameterReturn moreParameterReturn = (int a, int b) -\u0026gt; {\rSystem.out.println(\u0026#34;有返回值多个参数！\u0026#34;);\rreturn a + b;\r};\rret = moreParameterReturn.test(60, 70);\rSystem.out.println(ret);\r}\r} 三、语法精简 参数类型可以省略，如果需要省略，每个参数的类型都要省略。 参数的小括号里面只有一个参数，那么小括号可以省略 如果方法体当中只有一句代码，那么大括号可以省略 如果方法体中只有一条语句，其是return语句，那么大括号可以省略，且去掉return关键字。 四、变量捕获 Lambda 表达式中存在变量捕获 ，了解了变量捕获之后，我们才能更好的理解Lambda 表达式的作用域 。Java当中的匿名类中，会存在变量捕获。\n下面我们来讲下在Lambda当中也可以进行变量的捕获，具体我们看一下代码：\n@FunctionalInterface\rinterface NoParameterNoReturn {\rvoid test();\r}\rpublic class TestDemo2 {\rpublic static void main(String[] args) {\rint a = 10;\rNoParameterNoReturn noParameterNoReturn = () -\u0026gt; {\r/*\r注意此处不能够修改a的值，与匿名内部类中相同\ra = 99;\r*/\rSystem.out.println(\u0026#34;捕获变量：\u0026#34; + a);\r};\rnoParameterNoReturn.test();\r}\r} 执行结果\n捕获变量：10 五、Lambda在集合当中的使用 为了能够让Lambda和Java的集合类集更好的一起使用，集合当中，也新增了部分接口，以便与Lambda表达式对接。\n对应接口 新增方法 Collection removeIf() spliterator() stream() parallelStream() forEach() List replaceAll() sort() Map getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge() 注意：Collection的forEach()方法是从接口 java.lang.Iterable 拿过来的。\n1.Collection 接口 forEach() 方法演示\n该方法在接口 Iterable 当中，原型如下：\ndefault void forEach(Consumer\u0026lt;? super T\u0026gt; action) {\rObjects.requireNonNull(action);\rfor (T t : this) {\raction.accept(t);\r}\r} **forEach()**方法表示：对容器中的每个元素执行action指定的动作\n可以看到我们的参数 Consumer 其实是一个函数式接口： 这个函数式接口中有一个抽象方法accept:\n@FunctionalInterface\rpublic interface Consumer\u0026lt;T\u0026gt; {\r/**\r* Performs this operation on the given argument.\r*\r* @param t the input argument\r*/\rvoid accept(T t);\rdefault Consumer\u0026lt;T\u0026gt; andThen(Consumer\u0026lt;? super T\u0026gt; after) {\rObjects.requireNonNull(after);\rreturn (T t) -\u0026gt; { accept(t); after.accept(t); };\r}\r} public class TestDemo2 { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;bit\u0026#34;); list.add(\u0026#34;hello\u0026#34;); list.add(\u0026#34;lambda\u0026#34;); list.forEach(new Consumer\u0026lt;String\u0026gt;() { @Override public void accept(String s) { //简单遍历集合中的元素 System.out.println(s); } }); } } 我们可以修改为如下代码：\npublic class TestDemo2 { public static void main(String[] args) { ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;bit\u0026#34;); list.add(\u0026#34;hello\u0026#34;); list.add(\u0026#34;lambda\u0026#34;); list.forEach((String s) -\u0026gt; { System.out.println(s); }); } } 可以简化代码：\npublic class TestDemo2 {\rpublic static void main(String[] args) {\rArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();\rlist.add(\u0026#34;Hello\u0026#34;);\rlist.add(\u0026#34;bit\u0026#34;);\rlist.add(\u0026#34;hello\u0026#34;);\rlist.add(\u0026#34;lambda\u0026#34;);\rlist.forEach(s -\u0026gt; System.out.println(s));\r// 再简化 list.forEach(System.out::println);\r}\r} 六、Lambda 与四大函数接口的使用 1、Lambda 的延迟执行 public class PrintLog {\rpublic static void showLog(int level, String msg){\rif(level==1){\rSystem.out.println(msg);\r}\r}\rpublic static void main(String[] args) {\rString msg1 = \u0026#34;Hello\u0026#34;;\rString msg2 = \u0026#34;Java\u0026#34;;\rString msg3 = \u0026#34;heroC\u0026#34;;\rshowLog(1,msg1 + msg2 + msg3);\r}\r} 此打印日志程序，存在性能浪费，如果在main方法中，调用showLog方法，传入的等级不是1，那么字符串依然会被拼接，字符串拼接之后判断等级不是1，就白拼接了，也浪费了资源和性能。\n通过 Lambda 优化日志案例 函数式接口：\n// 创建一个函数式接口\r@FunctionalInterface\rpublic interface PrintLogInterface {\rpublic abstract String printLog();\r} 测试类：\npublic class PrintLog {\rpublic static void showLog(int level, PrintLogInterface printLogInterface){\rif(level == 1){\rSystem.out.println(printLogInterface.printLog());\r}\r}\rpublic static void main(String[] args) {\rString msg1 = \u0026#34;Hello\u0026#34;;\rString msg2 = \u0026#34;Java\u0026#34;;\rString msg3 = \u0026#34;heroC\u0026#34;;\rint level = 1;\rshowLog(level,() -\u0026gt; msg1 + msg2 + msg3);\r}\r} 通过使用Lambda表达式，Lambda表达式有一个很大的有点就是延迟执行，调用showLog方法，只将参数传递进去了，先判断是否等于1，判断了如果等于1才会去调用Lambda表达式实现的接口类，进行拼接字符串，然后输出，否则不会拼接字符串。\n2、使用Lambda作为参数和返回值 使用Lambda作为参数 // 写了一个函数式接口\r@FunctionalInterface\rpublic interface MyFunInterface {\rpublic abstract void method();\r} // 测试类\rpublic class Test{\r// 函数式接口作为方法参数\rpublic static void show(MyFunInterface myFunInterface){\rmyFunInterface.method();\r}\rpublic static void main(String[] args){\rshow(() -\u0026gt; System.out.println(\u0026#34;通过Lambda，实现函数式接口\u0026#34;));\r}\r} 使用Lambda作为返回值 public class Test {\rpublic static Comparator\u0026lt;String\u0026gt; newComparator(){\rreturn (a, b) -\u0026gt; a.length() - b.length(); // 这里就是作为返回值\r};\rpublic static void main(String[] args) {\rString[] arr = {\u0026#34;aaa\u0026#34;,\u0026#34;bb\u0026#34;,\u0026#34;c\u0026#34;};\rArrays.sort(arr,newComparator());\rSystem.out.println(Arrays.toString(arr));\r// 输出 [c, bb, aaa]\r}\r} 3、4大函数式接口 JDK 1.8 主要在java.util.function包中\n1、Supplier 接口 java.util.function Interface Supplier\u0026lt;T\u0026gt; 接口中包含了一个抽象方法 T get()。用来获取一个泛型参数指定类型的对象数据。\n该接口被称为生产型接口，指定接口是什么类型，那么接口中的get方法就会产生什么类型的数据。\npublic class SupplierTest {\rpublic static String getString(Supplier\u0026lt;String\u0026gt; sup){\rreturn sup.get();\r}\rpublic static int getInt(Supplier\u0026lt;Integer\u0026gt; sup){\rreturn sup.get();\r}\rpublic static void main(String[] args) {\rString str = getString(() -\u0026gt; \u0026#34;heroC\u0026#34;);\r/*getString(new Supplier\u0026lt;String\u0026gt;() {\r@Override\rpublic String get() {\rreturn \u0026#34;heroC\u0026#34;;\r}\r});*/\rSystem.out.println(str);\rint strInt = getInt(() -\u0026gt; 1130);\rSystem.out.println(strInt);\r}\r} 练习：求数组元素中最大的数 public class ArrayMaxNum {\rpublic static int getMax(Supplier\u0026lt;Integer\u0026gt; sup){\rreturn sup.get();\r}\rpublic static void main(String[] args) {\rint[] arr = {245,54,2366,23,6543,1130};\rint max1 = getMax(() -\u0026gt; {\rint max = arr[0];\rfor (int i = 0; i \u0026lt; arr.length-1; i++) {\rif (arr[i] \u0026lt; arr[i+1]) {\rmax = arr[i+1];\r}\r}\rreturn max;\r});\rSystem.out.println(max1);\r}\r} 2、Consumer 接口 java.util.function Interface Consumer\u0026lt;T\u0026gt; 接口正好与Supplier接口相反，它不是生产一个数据，而是消费（使用）一个数据，其数据类型由泛型决定。\n抽象方法：void accept(T t) ，意为消费一个数据类型。\npublic class ConsumerInterfaceImp {\rpublic static void consumerString(String str, Consumer\u0026lt;String\u0026gt; con){\rcon.accept(str);\r}\rpublic static void main(String[] args) {\rconsumerString(\u0026#34;heroC\u0026#34;,(str) -\u0026gt; {\r// 将字符串反转\rString s = new StringBuffer(str).reverse().toString();\rSystem.out.println(s);\r});\r}\r} 默认方法：default Consumer\u0026lt;T\u0026gt; andThen(Consumer\u0026lt;? super T\u0026gt; after) 需要两个Consumer接口，就可以把两个Consumer接口组合在一起，在对数据进行消费。\n// Consumer默认方法源码\rdefault Consumer\u0026lt;T\u0026gt; andThen(Consumer\u0026lt;? super T\u0026gt; after) {\rObjects.requireNonNull(after);\rreturn (T t) -\u0026gt; { accept(t); after.accept(t); };\r} eg：\npublic class ConsumerInterfaceImp {\rpublic static void consumerAndThen(String str, Consumer\u0026lt;String\u0026gt; con1, Consumer\u0026lt;String\u0026gt; con2){\r// 两个Consumer接口对象，使用默认方法andThen，调用accept方法\r// 执行步骤：con1.accept(str); con2.accept(str); 谁在前面谁先对数据进行消费\r// 如果由多个Consumer对象，可以一直链式调用andThen方法\rcon1.andThen(con2).accept(str);\r}\rpublic static void main(String[] args) {\rconsumerAndThen(\u0026#34;heroC\u0026#34;,\r(str) -\u0026gt; System.out.println(str.toUpperCase()),\r(str) -\u0026gt; System.out.println(str));\r}\r} 练习：格式化打印信息 下面字符串数组中，存储了很多信息，按照姓名：xxx，性别：xxx格式打印出来。使用Consumer接口的Lambda表达式。\npublic static void main(String[] args){\rString[] array = {\u0026#34;heroC,男\u0026#34;, \u0026#34;欧阳娜娜,女\u0026#34;};\r} 解答：\npublic class ConsumerInterfaceExample {\rpublic static void printInfo(String[] arr, Consumer\u0026lt;String\u0026gt; con1, Consumer\u0026lt;String\u0026gt; con2){\rfor(String str : arr){\rcon1.andThen(con2).accept(str);\r}\r}\rpublic static void main(String[] args) {\rString[] array = {\u0026#34;heroC,男\u0026#34;, \u0026#34;欧阳娜娜,女\u0026#34;};\rprintInfo(array, str -\u0026gt;{\rSystem.out.print(\u0026#34;姓名：\u0026#34; + str.split(\u0026#34;,\u0026#34;)[0] + \u0026#34;，\u0026#34;);\r}, str -\u0026gt;{\rSystem.out.println(\u0026#34;性别：\u0026#34; + str.split(\u0026#34;,\u0026#34;)[1]);\r});\r}\r} 总结： 优点： 代码简洁，开发迅速 方便函数式编程 非常容易进行并行计算 Java 引入 Lambda，改善了集合操作\n缺点： 代码可读性变差 在非并行计算中，很多计算未必有传统的 for 性能要高 不容易进行调试\n"},{"id":236,"href":"/Tech/3Java/Java-Code/Java-Lambda-Expressions/","title":"Java Lambda Expressions","parent":"Java Code","content":" Lambda Expressions 匿名类的一个问题是，如果匿名类的实现非常简单（例如仅包含一个方法的接口），则匿名类的语法可能看起来笨拙且不清楚。在这些情况下，您通常试图将功能作为参数传递给另一种方法，例如，当某人单击按钮时应采取什么措施。Lambda表达式使您能够执行此操作，将功能视为方法参数，或将代码视为数据。\n一个功能接口仅包含一个抽象方法，因此在实现该方法时可以省略该方法的名称。为此，您可以使用lambda表达式（而不是使用匿名类表达式）\nLambda 表达式 lambda表达式类似于一个方法:它提供了一个形式参数列表和一个主体(一个表达式或块)，后者根据这些参数进行表达。\nLambdaExpression:\rLambdaParameters -\u0026gt; LambdaBody Lambda表达式总是poly表达式\n如果lambda表达式出现在程序中的除分配上下文（第5.2节），调用上下文（第5.3节）或强制转换上下文（第5.5 节）之外的其他地方，则是编译时错误。\n分配上下文 赋值上下文 允许将表达式的值赋给变量 // 常量表达式的编译时范围变窄意味着代码如下被允许。\rbyte theAnswer = 42; 调用上下文 调用上下文允许将方法或构造函数调用（第 8.8.7.1节，第 15.9节，第 15.12节）中的参数值分配给相应的形式参数。 // 严格的或宽松的调用上下文都不包含在赋值上下文中允许的整数常量表达式的隐式缩小。Java编程语言的设计人员认为，包括这些隐式变窄的转换会给重载解析规则（第15.22.2节）增加额外的复杂性。\rpublic class Test {\rstatic int m(byte a, int b) { return a+b; }\r// static long m(long a, int b) { return a+b; } // static int m(short a, short b) { return a-b; }\rpublic static void main(String[] args) {\rSystem.out.println(m(12, 2)); // compile-time error\r}\r} 分配上下文 赋值上下文允许将表达式的值赋给变量 对lambda表达式的求值将生成功能接口的实例（第9.8节）。Lambda表达式评估并不会导致表达的身体的执行; 相反，这可能在以后调用功能接口的适当方法时发生。\n() -\u0026gt; {} // No parameters; result is void 没有参数；结果为void () -\u0026gt; 42 // No parameters, expression body 无参数，表达式主体\r() -\u0026gt; null // No parameters, expression body 无参数，表达式主体\r() -\u0026gt; { return 42; } // No parameters, block body with return 没有参数，使用return () -\u0026gt; { System.gc(); } // No parameters, void block body 没有参数，void块主体\r() -\u0026gt; { // Complex block body with returns 复杂的块主体，\rif (true) return 12;\relse {\rint result = 15;\rfor (int i = 1; i \u0026lt; 10; i++)\rresult *= i;\rreturn result;\r}\r} (int x) -\u0026gt; x+1 // Single declared-type parameter 单个声明类型的参数\r(int x) -\u0026gt; { return x+1; } // Single declared-type parameter 单个声明类型的参数\r(x) -\u0026gt; x+1 // Single inferred-type parameter 单个推断类型参数\rx -\u0026gt; x+1 // Parentheses optional for 括号可选 单个推断类型参数\r// single inferred-type parameter\r(String s) -\u0026gt; s.length() // Single declared-type parameter\r(Thread t) -\u0026gt; { t.start(); } // Single declared-type parameter\rs -\u0026gt; s.length() // Single inferred-type parameter\rt -\u0026gt; { t.start(); } // Single inferred-type parameter\r(int x, int y) -\u0026gt; x+y // Multiple declared-type parameters\r(x, y) -\u0026gt; x+y // Multiple inferred-type parameters\r(x, int y) -\u0026gt; x+y // Illegal: can\u0026#39;t mix inferred and declared types\r(x, final y) -\u0026gt; x+y // Illegal: no modifiers with inferred types 此语法的优点是最大程度地减少了简单Lambda表达式周围的括号噪音，这在Lambda表达式是方法的自变量或主体是另一个Lambda表达式时特别有用。它还清楚地区分了其表达形式和声明形式，从而避免了歧义或过度依赖\u0026rsquo; ;\u0026lsquo;标记。当需要一些额外的包围以视觉上区分完整的lambda表达式或其主体表达式时，自然会支持括号（就像在其他运算符优先级不清楚的情况下一样）。\n语法有一些解析挑战。Java编程语言始终要求进行任意先行查找，以区分\u0026rsquo; (\u0026lsquo;标记后的类型和表达式：其后可能是强制转换或带括号的表达式。当泛型重新使用类型中的二进制运算符“ \u0026lt;”和“ \u0026gt;” 时，情况变得更糟。Lambda表达式引入了一种新的可能性：“ (”之后的标记可以描述类型，表达式或Lambda参数列表。有些标记会立即指示参数列表（注释，final）; 在其他情况下，必须将某些模式解释为参数列表（连续两个名称，\u0026rsquo; ,\u0026lsquo;不嵌套在\u0026rsquo; \u0026lt;\u0026lsquo;和\u0026rsquo; \u0026gt;\u0026lsquo;内）；有时，直到在“ -\u0026gt;”之后遇到“ )” 之后才能做出决定。考虑状态解析的最简单方法是使用状态机：每个状态代表可能的解释（类型，表达式或参数）的子集，以及当机器转换为集合为单例的状态时，解析器知道是哪种情况。但是，这不能很好地映射到固定超前语法。\n没有特殊的无效形式：参数为零的lambda表达式表示为。明显的特殊情况语法无效，因为它在参数列表和强制类型转换之间引入了歧义。 () -\u0026gt; \u0026hellip;-\u0026gt; \u0026hellip;(x) -\u0026gt; \u0026hellip;\nLambda表达式无法声明类型参数。尽管这样做从语义上来说是有意义的，但自然语法（在参数列表之前加上类型参数列表）会带来混乱的歧义。例如，考虑：\nfoo( (x) \u0026lt; y , z \u0026gt; (w) -\u0026gt; v ) Lambda 参数 lambda表达式的形式参数（如果有的话）由带括号的逗号分隔参数说明符列表或带括号的逗号分隔标识符列表指定。在参数说明符列表中，每个参数说明符均由可选修饰符组成，然后是类型（或var），然后是指定参数名称的标识符。在标识符列表中，每个标识符都指定参数的名称。\n如果lambda表达式没有形式参数，则在-\u0026gt;和lambda主体之前会出现一对空括号。\n如果lambda表达式仅具有一个形式参数，并且该参数由标识符而不是参数说明符指定，则可以省略标识符周围的括号。\nLambdaParameters:\r( [LambdaParameterList] )\rIdentifier\rLambdaParameterList:\rLambdaParameter {, LambdaParameter}\rIdentifier {, Identifier}\rLambdaParameter:\r{VariableModifier} LambdaParameterType VariableDeclaratorId\rVariableArityParameter\rLambdaParameterType:\rUnannType\rvar The following productions from §8.4.1, §8.3, and §4.3 are shown here for convenience:\nVariableArityParameter:\r{VariableModifier} UnannType {Annotation} ... Identifier\rVariableModifier:\rAnnotation\rfinal\rVariableDeclaratorId:\rIdentifier [Dims]\rDims:\r{Annotation} [ ] {Annotation} [ ]} 仅当由参数说明符指定时，才能 声明或批注lambda表达式的形式参数。如果形式参数由标识符代替，则形式参数不是final，也没有注释。\nLambda表达式的形式参数可以是可变Arity参数，由参数说明符中的类型后面的省略号表示。lambda表达式最多允许使用一个变量arity参数。如果可变说明参数出现在参数说明符列表中除最后位置之外的任何位置，则是编译时错误。\nlambda表达式的每个形式参数都有一个 推断类型或一个声明类型：\n如果形式参数是由使用的参数说明符指定的var，或者由标识符而不是参数说明符指定的，则形式参数具有推断的类型。根据lambda表达式（第15.27.3节）所针对的功能接口类型来推断类型。\n如果不使用的参数说明符指定var了形式参数，则形式参数具有声明的类型。声明的类型确定如下：\n如果形式参数不是可变arity参数，则 如果在UnannType 和VariableDeclaratorId中没有括号对出现，则声明的类型由UnannType表示，否则由§10.2指定 。\n如果形式参数是可变arity参数，则声明的类型是§10.2指定的数组类型 。\n以下lambda参数列表之间没有区别：\n(int... x) -\u0026gt; BODY\r(int[] x) -\u0026gt; BODY 无论功能接口的抽象方法是固定Arity还是可变Arity，都可以使用。（这与方法重写的规则是一致的。）由于从未直接调用lambda表达式int\u0026hellip; ，因此在功能接口使用的形式参数中使用lambda表达式int[]不会影响周围的程序。在lambda主体中，可变arity参数的处理方式与数组类型的参数一样。\n所有形式参数都已声明类型的lambda表达式被称为显式类型。所有形式参数都具有推断类型的lambda表达式被称为隐式类型。没有形式参数的lambda表达式被显式键入。\n如果隐式键入了lambda表达式，则将根据其出现的上下文解释其lambda主体。具体来说，主体中表达式的类型，主体引发的检查异常以及主体中代码的类型正确性均取决于为形式参数推断的类型。这意味着形式参数类型的推断必须在“尝试”检查lambda主体的“之前”进行。\n这是一个编译时错误，如果lambda表达式声明与声明的类型形参和一个正式的参数与推断的类型。\n此规则可防止在形式参数（例如(x, int y) -\u0026gt; BODY 或）中混合使用推断类型和声明类型(var x, int y) -\u0026gt; BODY。请注意，如果所有形式参数都具有推断的类型，则语法会阻止标识符和var参数说明符的混合使用，例如(x, var y) -\u0026gt; BODY或(var x, y) -\u0026gt; BODY。\n§9.7.4和§9.7.5 中指定了形式参数声明上的注释修饰符规则。\n如果final多次出现作为形式参数声明的修饰符，则是编译时错误。\n如果 形式参数的LambdaParameterType为var且 同一形式参数的VariableDeclaratorId具有一个或多个括号对，则是编译时错误。\n§6.3和§6.4中 指定了形式参数声明的范围和阴影。\nlambda表达式声明两个具有相同名称的形式参数是编译时错误。（也就是说，它们的声明提到了相同的标识符。）\nJava SE 8中，_禁止将lambda参数用作名称，并且不建议将其用作其他类型的变量的名称（第4.12.3节）。从Java SE 9开始，它 _是一个关键字（第3.9节），因此在任何上下文中都不能将其用作变量名。\n如果将声明的形式参数final分配给lambda表达式的主体内，则是编译时错误 。\n调用lambda表达式时（通过方法调用表达式（第15.12节）），实际参数表达式的值会在执行lambda主体之前初始化新创建的参数变量，每个变量都是声明的或推断的类型。在LambdaParameter中或直接在 LambdaParameterList或 LambdaParameters中出现 的标识符可以用作lambda主体中的简单名称，以引用形式参数。\nLambda表达式的形式参数类型float始终包含浮点值集的一个元素（第4.2.3节）；同样，lambda表达式的形式参数类型double 始终包含double值集的元素。Lambda表达式的形式参数的类型不允许float 包含float-extended-exponent值集的元素，该元素既不是float值集的元素，也不允许Lambda表达式的形式参数的类型double 包含double-extended-exponent值集的元素，该元素也不是double值集的元素。\nLambda Body Lambda主体可以是单个表达式或块（第14.2节）。像方法主体一样，lambda主体描述了每次调用都会执行的代码。\nLambdaBody:\rExpression\rBlock 与出现在匿名类声明中的代码不同，在lambda正文中出现的名称和thisand super关键字的含义以及引用声明的可访问性与周围环境相同（除了lambda参数引入新名称）。\nlambda表达式主体中（无论是显式的还是隐式的）透明性（即与周围环境相同）将为实现提供更大的灵活性，并防止主体中不合格名称的含义依赖于重载分辨率。\n实际上，lambda表达式需要谈论自己（以递归方式调用其自身或调用其其他方法）是不寻常的，而更常见的情况是希望使用名称来引用封闭类中的内容，否则会被阴影（this，toString()）遮盖。如果有必要让lambda表达式引用自身（如via this），则应改用方法引用或匿名内部类。\n如果该块中的每个return语句都具有形式，则该lambda主体是void兼容的return;。\n块 lambda body 的身体是价值兼容，如果它不能正常（完成§14.21），并在每块return语句的形式return 表达;\n如果块lambda主体既不兼容void也不兼容值，则是编译时错误。\n在值兼容的块lambda主体中，结果表达式是可能产生调用值的任何表达式。具体地，对于形式的每个语句 return 表达 ;由所述主体包含的，该表达式 是一个结果的表达。\n// The following lambda bodies are void-compatible: 以下lambda主体与void兼容：\r() -\u0026gt; {}\r() -\u0026gt; { System.out.println(\u0026#34;done\u0026#34;); }\r// These are value-compatible:这些是价值兼容的：\r() -\u0026gt; { return \u0026#34;done\u0026#34;; }\r() -\u0026gt; { if (...) return 1; else return 0; }\r// These are both: 这些都是：\r() -\u0026gt; { throw new RuntimeException(); }\r() -\u0026gt; { while (true); }\r// This is neither: 这都不是：\r() -\u0026gt; { if (...) return \u0026#34;done\u0026#34;; System.out.println(\u0026#34;done\u0026#34;); } The handling of void/value-compatible and the meaning of names in the body jointly serve to minimize the dependency on a particular target type in the given context, which is useful both for implementations and for programmer comprehension. While expressions can be assigned different types during overload resolution depending on the target type, the meaning of unqualified names and the basic structure of the lambda body do not change. 无效/值兼容的处理和主体中名称的含义共同作用，以最小化给定上下文中对特定目标类型的依赖性，这对于实现和程序员理解都是有用的。尽管可以根据目标类型在重载解析期间为表达式分配不同的类型，但不限定名称的含义和lambda主体的基本结构不会改变。\nNote that the void/value-compatible definition is not a strictly structural property: \u0026ldquo;can complete normally\u0026rdquo; depends on the values of constant expressions, and these may include names that reference constant variables. 请注意，void / value兼容的定义不是严格的结构属性：“可以正常完成”取决于常量表达式的值，并且这些表达式可能包含引用常量变量的名称。\nAny local variable, formal parameter, or exception parameter used but not declared in a lambda expression must either be declared final or be effectively final (§4.12.4), or a compile-time error occurs where the use is attempted. 使用的但未在lambda表达式中声明的任何局部变量，形式参数或异常参数都必须声明final或有效地是最终的（第4.12.4节），否则在尝试使用时会发生编译时错误。\nAny local variable used but not declared in a lambda body must be definitely assigned (§16 (Definite Assignment)) before the lambda body, or a compile-time error occurs. 必须在lambda主体之前明确分配任何已使用但未在lambda主体中声明的局部变量（第16节（Definite Assignment）），否则会发生编译时错误。\nSimilar rules on variable use apply in the body of an inner class (§8.1.3). The restriction to effectively final variables prohibits access to dynamically-changing local variables, whose capture would likely introduce concurrency problems. Compared to the final restriction, it reduces the clerical burden on programmers. 关于变量使用的类似规则也适用于内部类的主体（第8.1.3节）。对有效最终变量的限制禁止访问动态变化的局部变量，其捕获可能会引入并发问题。与final限制相比，它减少了程序员的文书负担。\nThe restriction to effectively final variables includes standard loop variables, but not enhanced-for loop variables, which are treated as distinct for each iteration of the loop (§14.14.2). 对有效最终变量的限制包括标准循环变量，但不包括增强for循环变量，对于循环的每次迭代，它们都被视为不同的变量（第14.14.2节）。\n// The following lambda bodies demonstrate use of effectively final variables. 以下lambda主体演示了有效使用最终变量的方法。\rvoid m1(int x) {\rint y = 1;\rfoo(() -\u0026gt; x+y);\r// Legal: x and y are both effectively final. Legal：x和y都是有效的最终值。\r}\rvoid m2(int x) {\rint y;\ry = 1;\rfoo(() -\u0026gt; x+y);\r// Legal: x and y are both effectively final. Legal：x和y都是有效的最终值。\r}\rvoid m3(int x) {\rint y;\rif (...) y = 1;\rfoo(() -\u0026gt; x+y);\r// Illegal: y is effectively final, but not definitely assigned. 非法：y实际上是最终的，但未明确赋值。\r}\rvoid m4(int x) {\rint y;\rif (...) y = 1; else y = 2;\rfoo(() -\u0026gt; x+y);\r// Legal: x and y are both effectively final. Legal：x和y都是有效的最终值。\r} void m5(int x) {\rint y;\rif (...) y = 1;\ry = 2;\rfoo(() -\u0026gt; x+y);\r// Illegal: y is not effectively final. 非法：y实际上不是最终的。\r}\rvoid m6(int x) {\rfoo(() -\u0026gt; x+1);\rx++;\r// Illegal: x is not effectively final. 非法：x实际上不是最终的。\r}\rvoid m7(int x) {\rfoo(() -\u0026gt; x=1);\r// Illegal: x is not effectively final. 非法：x实际上不是最终的。\r}\rvoid m8() {\rint y;\rfoo(() -\u0026gt; y=1);\r// Illegal: y is not definitely assigned before the lambda. 非法：y不一定在lambda之前赋值。\r}\rvoid m9(String[] arr) {\rfor (String s : arr) {\rfoo(() -\u0026gt; s);\r// Legal: s is effectively final Legal：s实际上是最终的\r// (it is a new variable on each iteration) （这是每次迭代中的新变量）\r}\r}\rvoid m10(String[] arr) {\rfor (int i = 0; i \u0026lt; arr.length; i++) {\rfoo(() -\u0026gt; arr[i]);\r// Illegal: i is not effectively final 非法：i 实际上不是最终的\r// (it is not final, and is incremented) （不是最终值，并且是递增的）\r}\r} Type of a Lambda Expression Lambda表达式的类型 如果T是功能接口类型（第9.8节），并且表达式与从T派生的基础目标类型的功能类型一致，则 Lambda表达式在分配上下文，调用上下文或强制转换上下文中与目标类型T 兼容。\n的地面目标类型源自Ť如下：\n如果T是通配符参数化的功能接口类型，并且显式键入了lambda表达式，则将如§18.5.3中所述推断地面目标类型 。\nIf T is a wildcard-parameterized functional interface type and the lambda expression is implicitly typed, then the ground target type is the non-wildcard parameterization (§9.9) of T. 如果Ť是一个通配符-参数化功能接口类型和lambda表达式隐式类型，则地面目标类型是非通配符的参数（§9.9）的Ť。\nOtherwise, the ground target type is T. 否则，地面目标类型是Ť。\nA lambda expression is congruent with a function type if all of the following are true: 如果满足以下所有条件，则 lambda表达式与函数类型一致：\nThe function type has no type parameters. 函数类型没有类型参数。\nThe number of lambda parameters is the same as the number of parameter types of the function type. lambda参数的数量与函数类型的参数类型的数量相同。\nIf the lambda expression is explicitly typed, its formal parameter types are the same as the parameter types of the function type. 如果lambda表达式是显式类型的，则其形式参数类型与函数类型的参数类型相同。\nIf the lambda parameters are assumed to have the same types as the function type\u0026rsquo;s parameter types, then: 如果假定lambda参数与函数类型的参数类型具有相同的类型，则：\nIf the function type\u0026rsquo;s result is void, the lambda body is either a statement expression (§14.8) or a void-compatible block. 如果函数类型的结果为void，则lambda主体为语句表达式（第14.8节）或void-compatible块。\nIf the function type\u0026rsquo;s result is a (non-void) type R, then either (i) the lambda body is an expression that is compatible with R in an assignment context, or (ii) the lambda body is a value-compatible block, and each result expression (§15.27.2) is compatible with R in an assignment context. 如果函数类型的结果是（非void）类型R，则（i）lambda主体是在赋值上下文中与R兼容的表达式，或者（ii）lambda主体是值兼容的块，并且在赋值上下文中，每个结果表达式（第15.27.2节）与R兼容。\nIf a lambda expression is compatible with a target type T, then the type of the expression, U, is the ground target type derived from T. 如果lambda表达式与目标类型T兼容，则表达式的类型U是从T派生的基础目标类型 。\nIt is a compile-time error if any class or interface mentioned by either U or the function type of U is not accessible (§6.6) from the class or interface in which the lambda expression appears. 它是一个编译时间错误，如果由任一提及的任何类或接口Ù或功能类型ü不可访问（6.6节）从类或接口，其中λ表达式出现。\nFor each non-static member method m of U, if the function type of U has a subsignature of the signature of m, then a notional method whose method type is the function type of U is deemed to override m, and any compile-time error or unchecked warning specified in §8.4.8.3 may occur. 对于每一个非static成员方法m的ü，如果功能类型ü具有的签名的子签名m，则名义方法，其方法类型的功能类型û被认为覆盖m，以及任何编译时错误或警告未检查可能会出现第8.4.8.3节中指定的情况。\nA checked exception that can be thrown in the body of the lambda expression may cause a compile-time error, as specified in §11.2.3. 可能在lambda表达式的主体中引发的已检查异常可能会导致编译时错误，如§11.2.3中所指定 。\nThe parameter types of explicitly typed lambdas are required to exactly match those of the function type. While it would be possible to be more flexible - allow boxing or contravariance, for example - this kind of generality seems unnecessary, and is inconsistent with the way overriding works in class declarations. A programmer ought to know exactly what function type is being targeted when writing a lambda expression, so he should thus know exactly what signature must be overridden. (In contrast, this is not the case for method references, and so more flexibility is allowed when they are used.) In addition, more flexibility with parameter types would add to the complexity of type inference and overload resolution. 显式类型的lambda的参数类型必须与函数类型的参数类型完全匹配。虽然可能会更灵活-例如允许装箱或使用方差-这种通用性似乎是不必要的，并且与在类声明中重写工作的方式不一致。程序员在编写lambda表达式时应该确切地知道目标函数类型，因此他应该确切地知道必须重写哪个签名。（相反，方法引用不是这种情况，因此使用它们时可以提供更大的灵活性。）此外，\nNote that while boxing is not allowed in a strict invocation context, boxing of lambda result expressions is always allowed - that is, the result expression appears in an assignment context, regardless of the context enclosing the lambda expression. However, if an explicitly typed lambda expression is an argument to an overloaded method, a method signature that avoids boxing or unboxing the lambda result is preferred by the most specific check (§15.12.2.5). 请注意，虽然在严格的调用上下文中不允许装箱，但始终允许对lambda结果表达式进行装箱-也就是说，无论包围lambda表达式的上下文如何，结果表达式都会出现在赋值上下文中。但是，如果显式类型的lambda表达式是重载方法的参数，则最具体的检查方法（避免对lambda结果进行装箱或装箱）的方法签名是首选的（第15.12.2.5节）。\nIf the body of a lambda is a statement expression (that is, an expression that would be allowed to stand alone as a statement), it is compatible with a void-producing function type; any result is simply discarded. So, for example, both of the following are legal: 如果lambda的主体是一个语句表达式（即，一个可以作为语句独立出现的表达式），则它与void-production函数类型兼容；任何结果都将被简单丢弃。因此，例如，以下两项都是合法的：\n// Predicate has a boolean result 谓词具有boolean结果\rjava.util.function.Predicate\u0026lt;String\u0026gt; p = s -\u0026gt; list.add(s);\r// Consumer has a void result 消费者有一个void结果\rjava.util.function.Consumer\u0026lt;String\u0026gt; c = s -\u0026gt; list.add(s); Generally speaking, a lambda of the form () -\u0026gt; expr, where expr is a statement expression, is interpreted as either () -\u0026gt; { return expr; } or () -\u0026gt; { expr; }, depending on the target type. 一般而言，() -\u0026gt; expr形式的lambda（ 其中expr是语句表达式）根据目标类型解释为() -\u0026gt; { return expr; }或() -\u0026gt; { expr; }。\nRun-Time Evaluation of Lambda Expressions Lambda表达式的运行时评估 At run time, evaluation of a lambda expression is similar to evaluation of a class instance creation expression, insofar as normal completion produces a reference to an object. Evaluation of a lambda expression is distinct from execution of the lambda body. 在运行时，只要正常完成生成对对象的引用，对lambda表达式的求值就类似于对类实例创建表达式的求值。Lambda表达式的计算与Lambda主体的执行不同。\nEither a new instance of a class with the properties below is allocated and initialized, or an existing instance of a class with the properties below is referenced. If a new instance is to be created, but there is insufficient space to allocate the object, evaluation of the lambda expression completes abruptly by throwing an OutOfMemoryError. 分配并初始化具有以下属性的类的新实例，或者引用具有以下属性的类的现有实例。如果要创建一个新实例，但没有足够的空间分配对象，则通过抛出来突然完成lambda表达式的求值OutOfMemoryError。\nThis implies that the identity of the result of evaluating a lambda expression (or, of serializing and deserializing a lambda expression) is unpredictable, and therefore identity-sensitive operations (such as reference equality (§15.21.3), object locking (§14.19), and the System.identityHashCode method) may produce different results in different implementations of the Java programming language, or even upon different lambda expression evaluations in the same implementation. 这意味着评估lambda表达式（或对lambda表达式进行序列化和反序列化）的结果的身份是不可预测的，因此，身份敏感的操作（如引用相等（第15.21.3节），对象锁定（第14.19节））和 System.identityHashCode方法）可能会在Java编程语言的不同实现中甚至在同一实现中的不同lambda表达式求值时产生不同的结果。\nThe value of a lambda expression is a reference to an instance of a class with the following properties: lambda表达式的值是对具有以下属性的类的实例的引用：\nThe class implements the targeted functional interface type and, if the target type is an intersection type, every other interface type mentioned in the intersection. 该类实现目标功能接口类型，如果目标类型是路口类型，则实现路口中提到的所有其他接口类型。\nWhere the lambda expression has type U, for each non-static member method m of U: 对于每个U的非static 成员方法m， 其中lambda表达式的类型为U：\nIf the function type of U has a subsignature of the signature of m, then the class declares a method that overrides m. The method\u0026rsquo;s body has the effect of evaluating the lambda body, if it is an expression, or of executing the lambda body, if it is a block; if a result is expected, it is returned from the method. 如果U的函数类型具有的签名的子签名m，则该类声明一个重写的方法m。该方法的主体具有评估lambda主体（如果是表达式）或执行lambda主体（如果是块）的作用；如果期望结果，则从方法中返回。\nIf the erasure of the type of a method being overridden differs in its signature from the erasure of the function type of U, then before evaluating or executing the lambda body, the method\u0026rsquo;s body checks that each argument value is an instance of a subclass or subinterface of the erasure of the corresponding parameter type in the function type of U; if not, a ClassCastException is thrown. 如果对要重写的方法类型的擦除在签名上与对U函数类型的擦除不同，则在评估或执行lambda主体之前，该方法的主体将检查每个参数值是否是子类或子接口的实例U的函数类型中对应参数类型的擦除；如果不是，ClassCastException则抛出a。\nThe class overrides no other methods of the targeted functional interface type or other interface types mentioned above, although it may override methods of the Object class. 该类不会覆盖目标功能接口类型或上述其他接口类型的其他方法，尽管它可以覆盖Object该类的方法。\nThese rules are meant to offer flexibility to implementations of the Java programming language, in that: 这些规则旨在通过以下方式为Java编程语言的实现提供灵活性：\nA new object need not be allocated on every evaluation. 不必在每次评估中分配一个新对象。\nObjects produced by different lambda expressions need not belong to different classes (if the bodies are identical, for example). 由不同的lambda表达式产生的对象不必属于不同的类（例如，如果主体相同）。\nEvery object produced by evaluation need not belong to the same class (captured local variables might be inlined, for example). 评估产生的每个对象不必属于同一类（例如，可以内联捕获的局部变量）。\nIf an \u0026ldquo;existing instance\u0026rdquo; is available, it need not have been created at a previous lambda evaluation (it might have been allocated during the enclosing class\u0026rsquo;s initialization, for example). 如果“现有实例”可用，则不必在先前的lambda评估中创建它（例如，可能在封闭类的初始化期间分配了它）。\nIf the targeted functional interface type is a subtype of java.io.Serializable, the resulting object will automatically be an instance of a serializable class. Making an object derived from a lambda expression serializable can have extra run time overhead and security implications, so lambda-derived objects are not required to be serializable \u0026ldquo;by default\u0026rdquo;. 如果目标功能接口类型是的子类型java.io.Serializable，则生成的对象将自动是可序列化类的实例。使从lambda表达式派生的对象可序列化会带来额外的运行时开销和安全隐患，因此，lambda派生的对象不需要“默认情况下”可序列化。\nLambda表达式的语法 注意，lambda表达式看起来很像方法声明。您可以将lambda表达式视为匿名方法，即没有名称的方法。 Lambda表达式包含以下内容：\n用括号括起来的形式参数的逗号分隔列表。\n可以省略lambda表达式中参数的数据类型。 如果只有一个参数，则可以省略括号。 不允许声明一个与局部变量同名的参数或者局部变量。（一个作用域） 箭头标记， -\u0026gt;\n主体，由单个表达式或语句块组成。\n如果指定单个表达式，则Java运行时将评估该表达式，然后返回其值。另外，您可以使用return语句： p -\u0026gt; {\rreturn p.getGender() == Person.Sex.MALE\r\u0026amp;\u0026amp; p.getAge() \u0026gt;= 18\r\u0026amp;\u0026amp; p.getAge() \u0026lt;= 25;\r} return语句不是表达式。在lambda表达式中，必须将语句括在大括号（{}）中。但是，您不必在括号中包含void方法调用。 lambda表达式对封闭范围的局部变量具有相同的访问权。Lambda 表达式具有词法范围。这意味着它们不会从超类型继承任何名称，也不会引入新的作用域级别。解释lambda表达式中的声明就像在封闭环境中一样。\n因为lambda表达式未引入新的作用域范围。因此，您可以直接访问封闭范围的字段，方法和局部变量。 从lambda表达式引用的局部变量，必须是final或实际上是final\n如何确定Lambda表达式的类型：\n当Java运行时调用方法时printPersons，它期望的数据类型为CheckPerson，因此lambda表达式为该类型。但是，当Java运行时调用方法时printPersonsWithPredicate，它期望的数据类型为Predicate，因此lambda表达式就是这种类型。这些方法期望的数据类型称为目标类型。为了确定lambda表达式的类型，Java编译器使用找到lambda表达式的上下文或情况的目标类型。因此，您只能在Java编译器可以确定目标类型的情况下使用lambda表达式： 对于方法参数，Java编译器使用其他两种语言功能确定目标类型：重载解析和类型参数推断。\n"},{"id":237,"href":"/Tech/3Java/Java-Code/Java-List/","title":"Java List","parent":"Java Code","content":" 创建一个空的 不可变 或 不可修改 的列 // Java 9 之前 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;公众号\u0026#34;); list.add(\u0026#34;我没有三颗心脏\u0026#34;); list.add(\u0026#34;关注走起来\u0026#34;); List\u0026lt;String\u0026gt; unmodifiableList = Collections.unmodifiableList(list); // 或者使用 {{}} 的形式 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;() {{ add(\u0026#34;公众号\u0026#34;); add(\u0026#34;我没有三颗心脏\u0026#34;); add(\u0026#34;关注走起来\u0026#34;); }}; List\u0026lt;String\u0026gt; unmodifiableList = Collections.unmodifiableList(list); // Java 9 便捷的工厂方法 List\u0026lt;String\u0026gt; unmodifiableList = List.of(\u0026#34;公众号\u0026#34;, \u0026#34;我没有三颗心脏\u0026#34;, \u0026#34;关注走起来\u0026#34;); "},{"id":238,"href":"/Tech/3Java/Java-Code/Java-Method-References/","title":"Java Method References","parent":"Java Code","content":" Java Method References Java 方法参考 使用 lambda表达式创建匿名方法。但是，有时lambda表达式除了调用现有方法外什么也不做。在这种情况下，通常更容易按名称引用现有方法。方法引用使您可以执行此操作；它们是紧凑，易于阅读的lambda表达式，用于已具有名称的方法。\n再次考虑Lambda表达式Person部分中讨论的 类 ：\npublic class Person {\rpublic enum Sex {\rMALE, FEMALE\r}\rString name;\rLocalDate birthday;\rSex gender;\rString emailAddress;\rpublic int getAge() {\r// ...\r}\rpublic Calendar getBirthday() {\rreturn birthday;\r} public static int compareByAge(Person a, Person b) {\rreturn a.birthday.compareTo(b.birthday);\r}} 假设您的社交网络应用程序的成员包含在一个数组中，并且您想按年龄对数组进行排序。您可以使用以下代码（在示例中找到本节中描述的代码摘录 MethodReferencesTest）：\nPerson[] rosterAsArray = roster.toArray(new Person[roster.size()]);\rclass PersonAgeComparator implements Comparator\u0026lt;Person\u0026gt; {\rpublic int compare(Person a, Person b) {\rreturn a.getBirthday().compareTo(b.getBirthday());\r}\r}\rArrays.sort(rosterAsArray, new PersonAgeComparator()); 此调用的方法签名sort如下：\nstatic \u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c) 请注意，该接口Comparator是功能接口。因此，您可以使用lambda表达式，而不是定义并创建一个实现Comparator以下内容的类的新实例：\nArrays.sort(rosterAsArray,\r(Person a, Person b) -\u0026gt; {\rreturn a.getBirthday().compareTo(b.getBirthday());\r}\r); 但是，这种比较两个Person实例的出生日期的方法已经存在Person.compareByAge。您可以在lambda表达式的主体中调用此方法：\nArrays.sort(rosterAsArray,\r(a, b) -\u0026gt; Person.compareByAge(a, b)\r); 由于此lambda表达式调用现有方法，因此可以使用方法引用代替lambda表达式：\nArrays.sort(rosterAsArray, Person::compareByAge); 方法引用Person::compareByAge在语义上与lambda表达式相同(a, b) -\u0026gt; Person.compareByAge(a, b)。每个都有以下特征：\n它的形式参数列表是从复制Comparator.compare，这是(Person, Person)。 它的主体调用该方法Person.compareByAge。 有四种方法参考：\n类 列 引用静态方法 ContainingClass::staticMethodName 引用特定对象的实例方法 containingObject::instanceMethodName 引用特定类型的任意对象的实例方法 ContainingType::methodName 引用构造函数 ClassName::new 引用静态方法 方法参考Person::compareByAge是对静态方法的参考。\n引用特定对象的实例方法 以下是对特定对象的实例方法的引用示例：\nclass ComparisonProvider {\rpublic int compareByName(Person a, Person b) {\rreturn a.getName().compareTo(b.getName());\r}\rpublic int compareByAge(Person a, Person b) {\rreturn a.getBirthday().compareTo(b.getBirthday());\r}\r}\rComparisonProvider myComparisonProvider = new ComparisonProvider();\rArrays.sort(rosterAsArray, myComparisonProvider::compareByName); 方法引用myComparisonProvider::compareByName调用compareByName作为对象一部分的方法myComparisonProvider。JRE推断方法类型参数，在这种情况下为(Person, Person)。\n引用特定类型的任意对象的实例方法 以下是对特定类型的任意对象的实例方法的引用示例：\nString[] stringArray = { \u0026#34;Barbara\u0026#34;, \u0026#34;James\u0026#34;, \u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;,\r\u0026#34;Patricia\u0026#34;, \u0026#34;Robert\u0026#34;, \u0026#34;Michael\u0026#34;, \u0026#34;Linda\u0026#34; };\rArrays.sort(stringArray, String::compareToIgnoreCase); 方法参考的等效lambda表达式String::compareToIgnoreCase将具有形式参数列表(String a, String b)，其中a和b是用于更好地描述此示例的任意名称。方法引用将调用该方法a.compareToIgnoreCase(b)。\n引用构造函数 您可以使用name以与静态方法相同的方式引用构造函数new。以下方法将元素从一个集合复制到另一个：\npublic static \u0026lt;T, SOURCE extends Collection\u0026lt;T\u0026gt;, DEST extends Collection\u0026lt;T\u0026gt;\u0026gt;\rDEST transferElements(\rSOURCE sourceCollection,\rSupplier\u0026lt;DEST\u0026gt; collectionFactory) {\rDEST result = collectionFactory.get();\rfor (T t : sourceCollection) {\rresult.add(t);\r}\rreturn result;\r} 功能接口Supplier包含一个get不带任何参数并返回一个对象的方法。因此，您可以transferElements使用lambda表达式来调用该方法，如下所示：\nSet\u0026lt;Person\u0026gt; rosterSetLambda =\rtransferElements(roster, () -\u0026gt; { return new HashSet\u0026lt;\u0026gt;(); });\r} 您可以使用构造函数引用代替lambda表达式，如下所示：\nSet\u0026lt;Person\u0026gt; rosterSet = transferElements(roster, HashSet::new); Java编译器推断您要创建一个HashSet包含type元素的集合Person。另外，您可以指定如下：\nSet\u0026lt;Person\u0026gt; rosterSet = transferElements(roster, HashSet\u0026lt;Person\u0026gt;::new); "},{"id":239,"href":"/Tech/3Java/Java-Code/Java-%E4%B8%AD-Stream-%E7%9A%84%E7%94%A8%E6%B3%95/","title":"Java 中 Stream 的用法","parent":"Java Code","content":" Java 中 Stream 的用法 1、操作符 Stream的操作符大体上分为两种：中间操作符和终止操作符\n1.1、中间操作符 对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。\n中间操作符包含8种(排除了parallel,sequential,这两个操作并不涉及到对数据流的加工操作)\nmap(mapToInt,mapToLong,mapToDouble) 转换操作符，把比如A-\u0026gt;B，这里默认提供了转int，long，double的操作符。 flatmap(flatmapToInt,flatmapToLong,flatmapToDouble) 拍平操作比如把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。 limit 限流操作，比如数据流中有10个 我只要出前3个就可以使用。 distint 去重操作，对重复元素去重，底层使用了equals方法。 filter 过滤操作，把不想要的数据过滤。 peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。 skip 跳过操作，跳过某些元素。 sorted(unordered) 排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。 1.2、终止操作符 数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。\ncollect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors。 count 统计操作，统计最终的数据个数。 findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。 noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。 min、max 最值操作，需要自定义比较器，返回数据流中最大最小的值。 reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。 forEach、forEachOrdered 遍历操作，这里就是对最终的数据进行消费了。 toArray 数组操作，将数据流的元素转换成数组。 这里只介绍了Stream，并没有涉及到IntStream、LongStream、DoubleStream，这三个流实现了一些特有的操作符，我将在后续文章中介绍到。\n2、Example 2.1、stream public class Test { public static void main(String[] args) { // 1、对象属性 to Map Map\u0026lt;String, Integer\u0026gt; collect = detailList.stream() .collect(Collectors.toMap(InboundDetail::getGoodsSku, Collectors.summingInt(InboundDetail::getFactGoodsQty))); // 1.1、对象属性 to Map Map\u0026lt;String, String\u0026gt; optionsMap = options.stream() .collect( Collectors.toMap( optionItem -\u0026gt; String.valueOf(optionItem.getId()), optionItem -\u0026gt; optionItem.getReflectValue() ) ); // 2、对象属性 to List List\u0026lt;Long\u0026gt; warehouseIdList = allocateLocationDtoList.stream() .map(AllocateLocationDto::getWarehouseId) .distinct() .collect(Collectors.toList()); // 3、根据 属性 分组 Map\u0026lt;String, List\u0026lt;SendTradeInfoVO\u0026gt;\u0026gt; map = sendTradeInfoList.stream() .collect(Collectors.groupingBy(SendTradeInfoVO::getLogisticNo)); // 3、根据 属性 分组 Map\u0026lt;String, Map\u0026lt;String, Set\u0026lt;String\u0026gt;\u0026gt;\u0026gt; checkApplicationType = detailList .stream() .collect( Collectors.groupingBy( e -\u0026gt; { String descByValue = OutboundApplicationTypeEnum.getDescByValue(byPrimaryKey.getApplicationType()); return StringUtils.isEmpty(descByValue) ? \u0026#34;null\u0026#34; : descByValue; } , Collectors.groupingBy( WmsOutboundApplicationDetail::getCustomerCode , Collectors.mapping(WmsOutboundApplicationDetail::getApplicationNo, Collectors.toSet()) ) ) ); // 4、根据 属性 计数、求和 long skuCount = detailList.stream() .map(OriginalOrderDetailVO::getGoodsSku) .count(); Map\u0026lt;Long, Integer\u0026gt; canSaleQtyMap = warehouseStockDtos.stream().collect(Collectors.groupingBy(WarehouseStockDto::getGoodsId, Collectors.summingInt(WarehouseStockDto::getCanSale))); int goodsQty = detailList.stream() .mapToInt(orderDetail -\u0026gt; NumberUtil.getInt(orderDetail.getGoodsQty())) .sum(); // 5、reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce BigDecimal platFormProductBearAmount = platFormAllBearInfoList.stream() .map(amount -\u0026gt; {return new BigDecimal(amount.getBearAmount() == null ? \u0026#34;0.00\u0026#34; : amount.getBearAmount());}) .reduce(BigDecimal.ZERO, BigDecimal::add) .divide(HUNDRED) .setScale(2,RoundingMode.HALF_UP); // 5、根据 属性 排序 List\u0026lt;TradeInfo\u0026gt; collect = goodInfos.stream() .filter(p -\u0026gt; new BigDecimal(p.getTotalFee()).compareTo(BigDecimal.ZERO) \u0026gt; 0) .sorted(Comparator.comparing(o -\u0026gt; new BigDecimal(o.getTotalFee()))) .collect(Collectors.toList()); List\u0026lt;AllotDetailVO\u0026gt; allotDetailVOList =result.getAllotDetailVOList().stream().sorted(Comparator.comparing(AllotDetailVO::getCreateTime).thenComparing(AllotDetailVO::getGoodsId)).collect(Collectors.toList()); } } 2.2、HttpServletRequest public class Test { public static void main(String[] args) { HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder .getRequestAttributes()).getRequest(); String responseCharset = WebUtils.getResponseCharset(request.getContentType()); } } 2.3、 "},{"id":240,"href":"/Tech/3Java/Java-Code/Java-%E6%B3%9B%E5%9E%8BGenerics-/","title":"Java 泛型( Generics )","parent":"Java Code","content":" Java 泛型(Generics ) 1. 概述 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？\n顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），\n然后在使用/调用时传入具体的类型（类型实参）。\n泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，\n操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。\n2. 泛型的使用 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法\n2.1. 泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。\n泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：\nclass 类名称 \u0026lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型\u0026gt;{\rprivate 泛型标识 /*（成员变量类型）*/ var; .....\r}\r} 2.1.1 一个最普通的泛型类： 例子：\n//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\r//在实例化泛型类时，必须指定T的具体类型\rpublic class Generic\u0026lt;T\u0026gt;{ //key这个成员变量的类型为T,T的类型由外部指定 private T key;\rpublic Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定\rthis.key = key;\r}\rpublic T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定\rreturn key;\r}\r} 使用：\n//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型\r//传入的实参类型需与泛型的类型参数类型相同，即为Integer.\rGeneric\u0026lt;Integer\u0026gt; genericInteger = new Generic\u0026lt;Integer\u0026gt;(123456);\r//传入的实参类型需与泛型的类型参数类型相同，即为String.\rGeneric\u0026lt;String\u0026gt; genericString = new Generic\u0026lt;String\u0026gt;(\u0026#34;key_vlaue\u0026#34;);\rLog.d(\u0026#34;泛型测试\u0026#34;,\u0026#34;key is \u0026#34; + genericInteger.getKey());\rLog.d(\u0026#34;泛型测试\u0026#34;,\u0026#34;key is \u0026#34; + genericString.getKey()); 2.1.2 泛型变量定义及字母规范 2.1.2.1 泛型变量定义 上在我们只定义了一个泛型变量T，那如果我们需要传进去多个泛型要怎么办呢？ 只需要在类似下面这样就可以了：\nclass MorePoint\u0026lt;T,U\u0026gt;{ } 也就是在原来的T后面用逗号隔开，写上其它的任意大写字母即可。想加几个就加几个，比如我们想加五个泛型变量，那应该是这样的：\nclass MorePoint\u0026lt;T,U,A,B,C\u0026gt;{ } 例子：\nclass MorePoint\u0026lt;T,U\u0026gt; { private T x; private T y; private U name; public void setX(T x) { this.x = x; } public T getX() { return this.x; } ………… public void setName(U name){ this.name = name; } public U getName() { return this.name; } } 使用：\nMorePoint\u0026lt;Integer,String\u0026gt; morePoint = new MorePoint\u0026lt;Integer, String\u0026gt;(); morePoint.setName(\u0026#34;harvic\u0026#34;); Log.d(TAG, \u0026#34;morPont.getName:\u0026#34; + morePoint.getName()); 2.1.2.2 字母规范 任意一个大写字母都可以 为了提高可读性，大家还是用有意义的字母比较好，一般来讲，在不同的情境下使用的字母意义如下： E — Element，常用在java Collection里，如：List,Iterator,Set K,V — Key，Value，代表Map的键值对 N — Number，数字 T — Type，类型，如String，Integer等等 注意：\n定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。\n注意：\n泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic){ }\n2.2 泛型接口 泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：\n//定义一个泛型接口\rpublic interface Generator\u0026lt;T\u0026gt; {\rpublic T next();\r} 当实现泛型接口的类，未传入泛型实参时：\n/**\r* 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中\r* 即：class FruitGenerator\u0026lt;T\u0026gt; implements Generator\u0026lt;T\u0026gt;{\r* 如果不声明泛型，如：class FruitGenerator implements Generator\u0026lt;T\u0026gt;，编译器会报错：\u0026#34;Unknown class\u0026#34;\r*/\rclass FruitGenerator\u0026lt;T\u0026gt; implements Generator\u0026lt;T\u0026gt;{\r@Override\rpublic T next() {\rreturn null;\r}\r} 当实现泛型接口的类，传入泛型实参时：\n/**\r* 传入泛型实参时：\r* 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator\u0026lt;T\u0026gt;\r* 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。\r* 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型\r* 即：Generator\u0026lt;T\u0026gt;，public T next();中的的T都要替换成传入的String类型。\r*/\rpublic class FruitGenerator implements Generator\u0026lt;String\u0026gt; {\rprivate String[] fruits = new String[]{\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Pear\u0026#34;};\r@Override\rpublic String next() {\rRandom rand = new Random();\rreturn fruits[rand.nextInt(3)];\r}\r} 2.3 泛型方法 在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。\n尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。\n泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。\n/**\r* 泛型方法的基本介绍\r* @param tClass 传入的泛型实参\r* @return T 返回值为T类型\r* 说明：\r* 1）public 与 返回值中间\u0026lt;T\u0026gt;非常重要，可以理解为声明此方法为泛型方法。\r* 2）只有声明了\u0026lt;T\u0026gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。\r* 3）\u0026lt;T\u0026gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。\r* 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。\r*/\rpublic \u0026lt;T\u0026gt; T genericMethod(Class\u0026lt;T\u0026gt; tClass)throws InstantiationException ,\rIllegalAccessException{\rT instance = tClass.newInstance();\rreturn instance;\r} Object obj = genericMethod(Class.forName(\u0026#34;com.test.test\u0026#34;)); 2.3.1 泛型方法的基本用法 public class GenericTest {\r//这个类是个泛型类，在上面已经介绍过\rpublic class Generic\u0026lt;T\u0026gt;{ private T key;\rpublic Generic(T key) {\rthis.key = key;\r}\r//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。\r//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。\r//所以在这个方法中才可以继续使用 T 这个泛型。\rpublic T getKey(){\rreturn key;\r}\r/**\r* 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息\u0026#34;cannot reslove symbol E\u0026#34;\r* 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。\rpublic E setKey(E key){\rthis.key = keu\r}\r*/\r}\r/** * 这才是一个真正的泛型方法。\r* 首先在public与返回值之间的\u0026lt;T\u0026gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T\r* 这个T可以出现在这个泛型方法的任意位置.\r* 泛型的数量也可以为任意多个 * 如：public \u0026lt;T,K\u0026gt; K showKeyName(Generic\u0026lt;T\u0026gt; container){\r* ...\r* }\r*/\rpublic \u0026lt;T\u0026gt; T showKeyName(Generic\u0026lt;T\u0026gt; container){\rSystem.out.println(\u0026#34;container key :\u0026#34; + container.getKey());\r//当然这个例子举的不太合适，只是为了说明泛型方法的特性。\rT test = container.getKey();\rreturn test;\r}\r//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic\u0026lt;Number\u0026gt;这个泛型类做形参而已。\rpublic void showKeyValue1(Generic\u0026lt;Number\u0026gt; obj){\rLog.d(\u0026#34;泛型测试\u0026#34;,\u0026#34;key value is \u0026#34; + obj.getKey());\r}\r//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?\r//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类\rpublic void showKeyValue2(Generic\u0026lt;?\u0026gt; obj){\rLog.d(\u0026#34;泛型测试\u0026#34;,\u0026#34;key value is \u0026#34; + obj.getKey());\r}\r/**\r* 这个方法是有问题的，编译器会为我们提示错误信息：\u0026#34;UnKnown class \u0026#39;E\u0026#39; \u0026#34;\r* 虽然我们声明了\u0026lt;T\u0026gt;,也表明了这是一个可以处理泛型的类型的泛型方法。\r* 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。\rpublic \u0026lt;T\u0026gt; T showKeyName(Generic\u0026lt;E\u0026gt; container){\r...\r} */\r/**\r* 这个方法也是有问题的，编译器会为我们提示错误信息：\u0026#34;UnKnown class \u0026#39;T\u0026#39; \u0026#34;\r* 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。\r* 所以这也不是一个正确的泛型方法声明。\rpublic void showkey(T genericObj){\r}\r*/\rpublic static void main(String[] args) {\r}\r} 2.3.2 泛型类中的泛型方法 当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下\npublic class GenericFruit {\rclass Fruit{\r@Override\rpublic String toString() {\rreturn \u0026#34;fruit\u0026#34;;\r}\r}\rclass Apple extends Fruit{\r@Override\rpublic String toString() {\rreturn \u0026#34;apple\u0026#34;;\r}\r}\rclass Person{\r@Override\rpublic String toString() {\rreturn \u0026#34;Person\u0026#34;;\r}\r}\rclass GenerateTest\u0026lt;T\u0026gt;{\rpublic void show_1(T t){\rSystem.out.println(t.toString());\r}\r//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。\r//由于泛型方法在声明的时候会声明泛型\u0026lt;E\u0026gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。\rpublic \u0026lt;E\u0026gt; void show_3(E t){\rSystem.out.println(t.toString());\r}\r//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。\rpublic \u0026lt;T\u0026gt; void show_2(T t){\rSystem.out.println(t.toString());\r}\r}\rpublic static void main(String[] args) {\rApple apple = new Apple();\rPerson person = new Person();\rGenerateTest\u0026lt;Fruit\u0026gt; generateTest = new GenerateTest\u0026lt;Fruit\u0026gt;();\r//apple是Fruit的子类，所以这里可以\rgenerateTest.show_1(apple);\r//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person\r//generateTest.show_1(person);\r//使用这两个方法都可以成功\rgenerateTest.show_2(apple);\rgenerateTest.show_2(person);\r//使用这两个方法也都可以成功\rgenerateTest.show_3(apple);\rgenerateTest.show_3(person);\r}\r} 2.3.3 泛型方法与可变参数 public \u0026lt;T\u0026gt; void printMsg( T... args){\rfor(T t : args){\rLog.d(\u0026#34;泛型测试\u0026#34;,\u0026#34;t is \u0026#34; + t);\r}\r} 2.3.4 静态方法与泛型 静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。\n即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。\npublic class StaticGenerator\u0026lt;T\u0026gt; {\r....\r....\r/**\r* 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）\r* 即使静态方法要使用泛型类中已经声明过的泛型也不可以。\r* 如：public static void show(T t){..},此时编译器会提示错误信息：\r\u0026#34;StaticGenerator cannot be refrenced from static context\u0026#34;\r*/\rpublic static \u0026lt;T\u0026gt; void show(T t){\r}\r} 2.3.5 泛型方法总结 泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：\n无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，\n那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。\n所以如果static方法要使用泛型能力，就必须使其成为泛型方法。\n2.5 泛型上下边界 在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。\n\u0026lt;T extends B1 \u0026amp; B2 \u0026amp; B3\u0026gt; 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型\npublic void showKeyValue1(Generic\u0026lt;? extends Number\u0026gt; obj){\rLog.d(\u0026#34;泛型测试\u0026#34;,\u0026#34;key value is \u0026#34; + obj.getKey());\r} 泛型方法的例子：\n//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的\u0026lt;T\u0026gt;上添加上下边界，即在泛型声明的时候添加\r//public \u0026lt;T\u0026gt; T showKeyName(Generic\u0026lt;T extends Number\u0026gt; container)，编译器会报错：\u0026#34;Unexpected bound\u0026#34;\rpublic \u0026lt;T extends Number\u0026gt; T showKeyName(Generic\u0026lt;T\u0026gt; container){\rSystem.out.println(\u0026#34;container key :\u0026#34; + container.getKey());\rT test = container.getKey();\rreturn test;\r} 通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。\n2.5 泛型通配符 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。\n可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。\n2.6 泛型数组 看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。\n也就是说下面的这个例子是不可以的：\nList\u0026lt;String\u0026gt;[] ls = new ArrayList\u0026lt;String\u0026gt;[10]; 而使用通配符创建泛型数组是可以的，如下面这个例子：\nList\u0026lt;?\u0026gt;[] ls = new ArrayList\u0026lt;?\u0026gt;[10]; 这样也是可以的：\nList\u0026lt;String\u0026gt;[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题：\nList\u0026lt;String\u0026gt;[] lsa = new List\u0026lt;String\u0026gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List\u0026lt;Integer\u0026gt; li = new ArrayList\u0026lt;Integer\u0026gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，\r但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，\r上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。\r而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 3、泛型的实现原理 一、Java泛型的实现方法：类型擦除 前面已经说了，Java的泛型是伪泛型。为什么说Java的泛型是伪泛型呢？因为，在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。\nJava中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。\n如在代码中定义的List和List等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方法与C++模版机制实现方式之间的重要区别。\n类型擦除 Java语言引入了泛型，以在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java编译器将类型擦除应用于：\n如果类型参数不受限制，则将通用类型中的所有类型参数替换为其边界或对象。因此，产生的字节码仅包含普通的类，接口和方法。 必要时插入类型转换，以保持类型安全。 生成桥接方法以在扩展的泛型类型中保留多态。 类型擦除可确保不会为参数化类型创建新的类；因此，泛型不会产生运行时开销。\n二、类型擦除后保留的原始类型\n在上面，两次提到了原始类型，什么是原始类型？原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。\n4、泛型限制 为了有效地使用Java泛型，必须考虑以下限制：\n无法实例化具有原始类型的泛型类型 无法创建类型参数的实例 无法声明类型为类型参数的静态字段 无法将Casts或instanceof与参数化类型一起使用 无法创建参数化类型的数组 无法创建，捕获或引发参数化类型的对象 无法重载将每个重载的形式参数类型擦除为相同原始类型的方法 无法重载将每个重载的形式参数类型擦除为相同原始类型的方法 一个类不能有两个重载的方法，这些方法在类型擦除后将具有相同的签名。\npublic class Example {\rpublic void print(Set\u0026lt;String\u0026gt; strSet) { }\rpublic void print(Set\u0026lt;Integer\u0026gt; intSet) { }\r} 重载将共享相同的类文件表示形式，并且将生成编译时错误。\n无法声明类型为类型参数的静态字段 类的静态字段是该类的所有非静态对象共享的类级别变量。因此，不允许使用类型参数的静态字段。考虑以下类别：\npublic class MobileDevice\u0026lt;T\u0026gt; {\rprivate static T os;\r// ...\r} 如果允许使用类型参数的静态字段，那么以下代码将被混淆：\nMobileDevice\u0026lt;Smartphone\u0026gt; phone = new MobileDevice\u0026lt;\u0026gt;();\rMobileDevice\u0026lt;Pager\u0026gt; pager = new MobileDevice\u0026lt;\u0026gt;();\rMobileDevice\u0026lt;TabletPC\u0026gt; pc = new MobileDevice\u0026lt;\u0026gt;(); 因为静态字段os由phone，pager和pc共享，所以os的实际类型是什么？它不能同时是Smartphone，Pager和TabletPC。因此，您无法创建类型参数的静态字段。\n"},{"id":241,"href":"/Tech/3Java/Java-Code/Java8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/","title":"Java8 方法引用，构造器引用","parent":"Java Code","content":" Java8 方法引用，构造器引用 1. 前言 Lambda 表达式是可以简化函数式接口的变量或形参赋值的语法。\n而方法引用和构造器引用是为了简化 Lambda 表达式的。\n2. 方法引用 方法引用可以看做是 Lambda 表达式深层次的表达。换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是 Lambda 表达式的一个语法糖。\n2.1 方法引用语法格式 格式：使用方法引用操作符 “::” 将类(或对象) 与 方法名分隔开来。 两个:中间不能有空格，而且必须英文状态下半角输入 如下三种主要使用情况： 情况1：对象 :: 实例方法名 情况2：类 :: 静态方法名 情况3：类 :: 实例方法名 理解：类（或对象） :: 要调用的类（或对象）中的方法\n2.2 方法引用使用前提 要求1：\nLambda 体只有一句语句，并且是通过调用一个对象的/类现有的方法来完成的 要求2：\n针对情况1：函数式接口中的抽象方法 a 在被重写时使用了某一个对象的方法 b。如果方法 a 的形参列表、返回值类型与方法 b 的形参列表、返回值类型都相同，则我们可以使用方法 b 实现对方法 a 的重写、替换。 注意： 此方法是实例方法，需要对象调用！\n针对情况2：函数式接口中的抽象方法a在被重写时使用了某一个类的静态方法b。如果方法a的形参列表、返回值类型与方法b的形参列表、返回值类型都相同，则我们可以使用方法b实现对方法a的重写、替换。 注意： 此方法是静态方法，需要类调用！\n针对情况3：函数式接口中的抽象方法a在被重写时使用了某一个对象的方法b。如果方法a的返回值类型与方法b的返回值类型相同，同时方法a的形参列表中有n个参数，方法b的形参列表有n-1个参数，且方法a的第1个参数作为方法b的调用者，且方法a的后n-1参数与方法b的n-1参数匹配（类型相同或满足多态场景也可以） 注意： 此方法b是非静态方法，需要对象调用。但是形式上，写成对象a所属的类调用\n3. 构造器引用、数组引用 理解了方法引用，构造器引用、数组引用就很好理解了。\n构造器引用格式：\n接口\u0026lt;泛型\u0026gt; 引用 = 类名 :: new ，调用的构造器由泛型参数决定。\n数组引用格式：\n接口\u0026lt;泛型\u0026gt; 引用 = 数组名[] :: new，数组的初始化容量由泛型参数决定。\n"},{"id":242,"href":"/Tech/3Java/Java-Code/JDK-1.8-4%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","title":"Jdk 1.8 4大函数式接口","parent":"Java Code","content":" 4 大函数式接口 JDK 1.8 主要在 java.util.function 包中\n1、Supplier 接口 java.util.function Interface Supplier\u0026lt;T\u0026gt; 接口中包含了一个抽象方法T get()。用来获取一个泛型参数指定类型的对象数据。\n该接口被称为生产型接口，指定接口是什么类型，那么接口中的get方法就会产生什么类型的数据。\npublic class SupplierTest { public static String getString(Supplier\u0026lt;String\u0026gt; sup){ return sup.get(); } public static int getInt(Supplier\u0026lt;Integer\u0026gt; sup){ return sup.get(); } public static void main(String[] args) { String str = getString(() -\u0026gt; \u0026#34;heroC\u0026#34;); /*getString(new Supplier\u0026lt;String\u0026gt;() { @Override public String get() { return \u0026#34;heroC\u0026#34;; } });*/ System.out.println(str); int strInt = getInt(() -\u0026gt; 1130); System.out.println(strInt); } } 2、Consumer 接口 java.util.function Interface Consumer\u0026lt;T\u0026gt; 接口正好与Supplier接口相反，它不是生产一个数据，而是消费（使用）一个数据，其数据类型由泛型决定。\n抽象方法：void accept(T t) ，意为消费一个数据类型。\n"},{"id":243,"href":"/Tech/3Java/Java-FX/JavaFX-Canvas/","title":"Java Fx Canvas","parent":"Java FX","content":" 使用 Canvas 画布 总览 JavaFX Canvas API提供了可以写入的自定义纹理。它是由类中定义Canvas并GraphicsContext在javafx.scene.canvas包中。使用此API涉及创建一个Canvas对象，获取其对象，GraphicsContext并调用绘图操作以在屏幕上呈现您的自定义形状。因为Canvas是Node子类，所以可以在JavaFX scene （场景图）中使用它。\nCanvas Canvas 是可以使用GraphicsContext。提供的图形命令集绘制的图像。\n一个 Canvas节点被构造成具有宽度和高度，指定到其中的画布绘图命令被描绘的图像的大小。所有绘图操作都被裁剪到该图像的边界。\nGraphicsContext Canvas canvas = new Canvas(300, 250); GraphicsContext gc = canvas.getGraphicsContext2D(); This class is used to issue draw calls to a Canvas using a buffer. 此类用于使用缓冲区向画布发出绘制调用。 Each call pushes the necessary parameters onto the buffer where they will be later rendered onto the image of the Canvas node by the rendering thread at the end of a pulse. 每次调用都会将必要的参数推送到缓冲区，然后在脉冲结束时由渲染线程将它们渲染到画布节点的图像上。 A Canvas only contains one GraphicsContext, and only one buffer. If it is not attached to any scene, then it can be modified by any thread, as long as it is only used from one thread at a time. Once a Canvas node is attached to a scene, it must be modified on the JavaFX Application Thread. 画布只包含一个GraphicsContext和一个缓冲区。如果它没有附加到任何场景，那么它可以被任何线程修改，只要它一次只能从一个线程使用。将画布节点附加到场景后，必须在JavaFX应用程序线程上对其进行修改。 Calling any method on the GraphicsContext is considered modifying its corresponding Canvas and is subject to the same threading rules. 在GraphicsContext上调用任何方法都将被视为修改其相应的画布，并受相同的线程规则的约束。 A GraphicsContext also manages a stack of state objects that can be saved or restored at anytime. GraphicsContext还管理一堆可以随时保存或恢复的状态对象堆栈。 "},{"id":244,"href":"/Tech/3Java/Java-FX/JavaFx-Cheat-Sheets-JavaFx-%E9%80%9F%E6%9F%A5%E8%A1%A8/","title":"Java Fx Cheat Sheets （ Java Fx 速查表)","parent":"Java FX","content":" JavaFx Cheat Sheets （JavaFx 速查表) 1、舞台(Stage)，场景(Scene)，容器(Container)，布局(Layout )和控件(Controls)之间的关系：\n在JavaFX中，Stage是应用程序窗口，其中包含称为Scene的空间。 Scene包含界面的组件，如Button，Text，…或容器。\n"},{"id":245,"href":"/Tech/3Java/Java-FX/JavaFX-Scene/","title":"Java Fx Scene","parent":"Java FX","content":" Scene Graph 总览 Scene Graph (场景图)是一种类似树的数据结构，其中树中的每个项目都有零个或一个父级和零个或多个子级。\n此软件包中的两个主要类是：\nScene–定义要渲染的场景。它包含一个fill变量，指定场景的背景，width并height指定场景的大小的变量，以及content包含的“root”的列表序列Nodes将被渲染到场景上。此序列Nodes是为此的场景图Scene。将A Scene呈现到Stage，这是JavaFX内容的顶级容器。 Node–场景图中所有节点的抽象基类。每个节点要么是不具有子节点的“叶”节点，要么是具有零个或多个子节点的“分支”节点。树中的每个节点都有零个或一个父节点。场景图中每个树中只有一个节点将没有父节点，这通常称为“根”节点。场景图中可能有几棵树。有些树可能是的一部分Scene，在这种情况下，它们有资格显示。其他树木可能不属于任何树木Scene。 分支节点是其类型Parent或子类。\n叶节点的类，如 Rectangle，Text， ImageView，MediaView，或其他这样的叶类，其不能具有子。\n一个节点最多可以在场景图中的任何位置出现一次。具体来说，一个节点在a的子代列表中Parent或作为a的剪辑 必须出现不超过一次Node。有关Node这些限制的更多详细信息，请参见该类。\nJavaFX Scene Graph提供了使用CSS（级联样式表）对节点进行样式设置的功能。\nScene JavaFX Scene类是场景图中所有内容的容器。场景的背景按照fill属性指定的方式填充。 应用程序必须Node通过设置root属性来指定场景图的根。如果将a Group用作根，则场景图的内容将被场景的宽度和高度限制，并且更改场景的大小（如果用户调整舞台的大小）将不会更改场景图的布局。如果将可调整大小的节点（布局Region或 Control）设置为根，则根的大小将跟踪场景的大小，从而根据需要中继内容。\n场景的大小可以在构建过程中由应用程序初始化。如果未指定大小，则场景将根据其内容的首选大小自动计算其初始大小。如果仅指定一个维度，则考虑到根的内容偏差，使用指定的维度来计算另一个维度。\n应用程序可以在创建时请求深度缓冲区支持或场景抗锯齿支持Scene。仅具有2D形状且没有任何3D变换的场景不需要深度缓冲区，也不需要场景抗锯齿支持。包含3D形状或具有3D变换的2D形状的场景可以使用深度缓冲区支持来进行适当的深度排序渲染。为了避免进行深度战斗（也称为Z战斗），请对没有3D变换的2D形状禁用深度测试。请参阅 depthTest以获取更多信息。具有3D形状的场景可以启用场景抗锯齿功能以提高其渲染质量。\ndepthBuffer和antiAliasing标志是条件功能。分别具有默认值：false和SceneAntialiasing.DISABLED。请参阅ConditionalFeature.SCENE3D 以获取更多信息。\n默认的头灯将添加到包含一个或多个Shape3D节点但不包含任何灯光节点的场景中 。该光源 Color.WHITE PointLight放置在相机位置。\nScene可以在任何线程上创建和修改 A ，直到将其附加到Window上showing。之后，必须仅在JavaFX Application Thread上对其进行修改。注意这Scene不是线程安全的。同时修改Scene多个线程上的a 会导致无法预料的结果，因此必须避免。\nJavaFX应用程序线程是在JavaFX运行时启动过程中创建的。有关更多信息，请参见Application类和Platform.startup(Runnable)方法。\nGroup 一个Group节点包含一个ObservableList的子节点，每当渲染该节点时，这些子节点就会按顺序渲染。 A Group将承担其子代的集体责任，并且不能直接调整其大小。\n应用于的任何变换，效果或状态Group都将应用于该组的所有子级。此类变换和效果将不包括在该组的布局范围内，但是，如果直接在该组的子级上设置变换和效果，则这些变换和效果将包括在该组的布局范围内。\n默认情况下，a Group将在布局遍历期间将其可调整大小的子控件“自动调整大小”到其首选大小，以确保在区域和控件状态改变时调整其大小。如果应用程序需要禁用此自动调整大小行为，则应将其设置 autoSizeChildren为false并了解，如果子级的首选大小发生更改，则它们将不会自动调整大小（因此请当心！）。\n"},{"id":246,"href":"/Tech/3Java/Java-FX/JavaFX-Stage/","title":"Java Fx Stage","parent":"Java FX","content":" JavaFX Stage 舞台 总览 JavaFX Stage .类是顶级JavaFX容器。初级阶段由平台构建。Application 可以构造Stage对象。\nStage 对象必须在JavaFX Application Thread上构造和修改。\nThe JavaFX Application Thread is created as part of the startup process for the JavaFX runtime.\nJavaFX Application Thread 是在JavaFX运行时启动过程中创建的。\n许多 Stage 属性是只读的，因为它们可以由基础平台在外部进行更改，因此不能绑定。\n样式 Stage 具有以下样式之一：\nStageStyle.DECORATED -具有纯白色背景和平台装饰的舞台。 StageStyle.UNDECORATED -具有纯白色背景且没有装饰的舞台。 StageStyle.TRANSPARENT -具有透明背景且没有装饰的舞台。 StageStyle.UTILITY -具有纯白色背景和最少平台装饰的舞台。 必须先初始化样式，然后才能使舞台可见。\n在某些平台上，装饰可能不可用。例如，在某些移动或嵌入式设备上。在这些情况下，将接受对DECORATED或UTILITY窗口的请求，但不会显示任何装饰。\n所有者 A stage can optionally have an owner Window. When a window is a stage\u0026rsquo;s owner, it is said to be the parent of that stage. stage 可以有一个所有者 Window。当一个 Window 是一个 stage 所有者时，它被称为该 stage 的父级。\n拥有的舞台绑定到父窗口。拥有的舞台将始终位于其父窗口的顶部。当父窗口关闭或图标化时，所有拥有的窗口也会受到影响。拥有的舞台不能被独立地标识。\n必须先初始化所有者，然后才能使该舞台可见。\n"},{"id":247,"href":"/Tech/3Java/Java-FX/JavaFX-Transformations-Animations-and-Visual-Effects/","title":"Java Fx Transformations, Animations, and Visual Effects","parent":"Java FX","content":" JavaFX: Transformations, Animations, and Visual Effects JavaFX：转换，动画和视觉效果\n1、转换概述 所有转换都位于javafx.scene.transform 包中，并且是Transform该类的子类。\nIntroducing Transformations 变换 介绍 转换会根据某些参数更改图形对象在坐标系中的位置。JavaFX支持以下类型的转换：\nTranslation 转换 Rotation 回转 Scaling 缩放比例 Shearing 剪力 These transformations can be applied to either a standalone node or to groups of nodes. You can apply one transformation at a time or you can combine transformations and apply several transformations to one node. 这些变换可以应用于独立节点或节点组。您可以一次应用一个变换，也可以组合转换并将多个变换应用于一个节点。\nThe Transform class implements the concepts of affine transformations. The Affine class extends the Transform class and acts as a superclass to all transformations. Affine transformations are based on euclidean algebra, and perform a linear mapping (through the use of matrixes) from initial coordinates to other coordinates while preserving the straightness and parallelism of lines. Affine transformations can be constructed using observableArrayLists rotations, translations, scales, and shears. 在Transform类实现仿射变换的概念。本Affine类扩展Transform类，并作为一个超类中的所有变换。仿射变换基于欧几里德代数，并执行线性映射（通过使用矩阵），从初始坐标到其他坐标，同时保留直线的直线性和平行性。可以使用observableArrayLists旋转，平移，缩放和剪切来构造仿射变换。\nNote: 注意：\nUsually, do not use the Affine class directly, but instead, use the specific Translate, Scale, Rotate, or Shear transformations. 通常，不要Affine直接使用该类，而应使用特定的“平移”，“缩放”，“旋转”或“剪切”变换。\nTransformations in JavaFX can be performed along three coordinates, thus enabling users to create three-dimensional (3-D) objects and effects. To manage the display of objects with depth in 3-D graphics, JavaFX implements z-buffering. Z-buffering ensures that the perspective is the same in the virtual world as it is in the real one: a solid object in the foreground blocks the view of one behind it. Z-buffering can be enabled by using the setDepthTest class. You can try to disable z-buffering (setDepthTest(DepthTest.DISABLE)) in the sample application to see the effect of the z-buffer. JavaFX中的变换可以沿着三个坐标执行，从而使用户能够创建三维(3-D)对象和效果。为了在3-D图形中管理具有深度的对象的显示，JavaFX实现了z-buffering。Z-buffering确保虚拟世界中的透视图与现实世界中的透视图相同:前台的实体对象会阻塞后面的视图。可以通过使用setDepthTest类启用z缓冲。您可以尝试在样例应用程序中禁用z-buffering (setDepthTest(DepthTest.DISABLE))，以查看z-buffer的效果。\nTo simplify transformation usage, JavaFX implements transformation constructors with the x-axis and y-axis along with the x, y, and z axes. If you want to create a two-dimensional (2-D) effect, you can specify only the x and y coordinates. If you want to create a 3-D effect, specify all three coordinates. 为了简化转换的使用，JavaFX使用x轴和y轴以及x、y和z轴实现转换构造函数。如果要创建二维(2d)效果，可以只指定x和y坐标。如果您想要创建一个3d效果，请指定所有三个坐标。\nTo be able to see 3-D objects and transformation effects in JavaFX, users must enable the perspective camera. 为了能够在JavaFX中查看3-D对象和转换效果，用户必须启用透视相机。\nThough knowing the underlying concepts can help you use JavaFX more effectively, you can start using transformations by studying the example provided with this document and trying different transformation parameters. For more information about particular classes, methods, or additional features, see the API documentation. 尽管了解基本概念可以帮助您更有效地使用JavaFX，但是可以通过研究本文档提供的示例并尝试不同的转换参数来开始使用转换。有关特定类，方法或其他功能的更多信息，请参阅API文档。\nIn this document, a Xylophone application is used as a sample to illustrate all the available transformations. You can download its source code by clicking the transformations.zip link. 在本文档中，木琴应用程序用作示例来说明所有可用的转换。您可以通过单击transformations.zip链接下载其源代码。\n2、Transformation Types and Examples 转换类型和示例 This document describes specific transformations and provides code examples. 本文档描述了特定的转换并提供了代码示例。\nTranslation 平移 The translation transformation shifts a node from one place to another along one of the axes relative to its initial position. The initial position of the xylophone bar is defined by x, y, and z coordinates. In Example 2-1, the initial position values are specified by the xStart, yPos, and zPos variables. Some other variables are added to simplify the calculations when applying different transformations. Each bar of the xylophone is based on one of the base bars. The example then translates the base bars with different shifts along the three axes to correctly locate them in space. 平移变换将一个节点相对于其初始位置沿一个轴从一个位置移动到另一个位置。木琴横条的初始位置由x，y和z坐标定义。在实施例2-1中，初始位置值由指定的xStart，yPos和zPos变量。应用其他转换时，添加了一些其他变量以简化计算。木琴的每个条都基于基础条之一。然后，该示例将沿三个轴平移的基杆平移，以正确地将其定位在空间中。\nExample 2-1 shows a code snippet from the sample application with the translation transformation. 例2-1显示了带有转换转换的示例应用程序中的代码片段。\nGroup rectangleGroup = new Group();\rrectangleGroup.setDepthTest(DepthTest.ENABLE);\rdouble xStart = 260.0;\rdouble xOffset = 30.0;\rdouble yPos = 300.0;\rdouble zPos = 0.0;\rdouble barWidth = 22.0;\rdouble barDepth = 7.0;\r// Base1\rCube base1Cube = new Cube(1.0, new Color(0.2, 0.12, 0.1, 1.0), 1.0);\rbase1Cube.setTranslateX(xStart + 135);\rbase1Cube.setTranslateZ(yPos+20.0);\rbase1Cube.setTranslateY(11.0); Rotation 回转 The rotation transformation moves the node around a specified pivot point of the scene. You can use the rotate method of the Transform class to perform the rotation. 旋转变换将节点围绕场景的指定枢轴点移动。您可以使用类的rotate方法Transform执行旋转。\nTo rotate the camera around the xylophone in the sample application, the rotation transformation is used, although technically, it is the xylophone itself that is moving when the mouse rotates the camera. 在示例应用程序中，为了使照相机围绕木琴旋转，使用了旋转变换，尽管从技术上讲，当鼠标旋转照相机时，木琴本身才在移动。\nExample 2-2 shows the code for the rotation transformation. 例2-2显示了旋转变换的代码。\nclass Cam extends Group {\rTranslate t = new Translate();\rTranslate p = new Translate();\rTranslate ip = new Translate();\rRotate rx = new Rotate();\r{ rx.setAxis(Rotate.X_AXIS); }\rRotate ry = new Rotate();\r{ ry.setAxis(Rotate.Y_AXIS); }\rRotate rz = new Rotate();\r{ rz.setAxis(Rotate.Z_AXIS); }\rScale s = new Scale();\rpublic Cam() { super(); getTransforms().addAll(t, p, rx, rz, ry, s, ip); }\r}\r...\rscene.setOnMouseDragged(new EventHandler\u0026lt;MouseEvent\u0026gt;() {\rpublic void handle(MouseEvent me) {\rmouseOldX = mousePosX;\rmouseOldY = mousePosY;\rmousePosX = me.getX();\rmousePosY = me.getY();\rmouseDeltaX = mousePosX - mouseOldX;\rmouseDeltaY = mousePosY - mouseOldY;\rif (me.isAltDown() \u0026amp;\u0026amp; me.isShiftDown() \u0026amp;\u0026amp; me.isPrimaryButtonDown()) {\rcam.rz.setAngle(cam.rz.getAngle() - mouseDeltaX);\r}\relse if (me.isAltDown() \u0026amp;\u0026amp; me.isPrimaryButtonDown()) {\rcam.ry.setAngle(cam.ry.getAngle() - mouseDeltaX);\rcam.rx.setAngle(cam.rx.getAngle() + mouseDeltaY);\r}\relse if (me.isAltDown() \u0026amp;\u0026amp; me.isSecondaryButtonDown()) {\rdouble scale = cam.s.getX();\rdouble newScale = scale + mouseDeltaX*0.01;\rcam.s.setX(newScale); cam.s.setY(newScale); cam.s.setZ(newScale);\r}\relse if (me.isAltDown() \u0026amp;\u0026amp; me.isMiddleButtonDown()) {\rcam.t.setX(cam.t.getX() + mouseDeltaX);\rcam.t.setY(cam.t.getY() + mouseDeltaY);\r}\r}\r}); Note that the pivot point and the angle define the destination point the image is moved to. Carefully calculate values when specifying the pivot point. Otherwise, the image might appear where it is not intended to be. For more information, see the API documentation 请注意，枢轴点和角度定义了图像要移动到的目标点。指定枢轴点时，请仔细计算值。否则，图像可能会出现在原本不希望出现的位置。有关更多信息，请参见API文档。\nScaling 缩放比例 The scaling transformation causes a node to either appear larger or smaller, depending on the scaling factor. Scaling changes the node so that the dimensions along its axes are multiplied by the scale factor. Similar to the rotation transformations, scaling transformations are applied at a pivot point. This pivot point is considered the point around which scaling occurs. 缩放变换导致节点根据缩放因子而显得更大或更小。缩放会更改节点，以便沿其轴的尺寸乘以比例因子。与旋转变换类似，缩放变换应用于枢轴点。该枢轴点被认为是发生缩放的点。\nTo scale, use the Scale class and the scale method of the Transform class. 要缩放，请使用Scale类和该类的scale方法Transform。\nIn the Xylophone application, you can scale the xylophone using the mouse while pressing Alt and the right mouse button. The scale transformation is used to see the scaling. 在木琴应用程序中，您可以在按住Alt键和鼠标右键的同时，使用鼠标缩放木琴。比例变换用于查看比例。\nExample 2-3 shows the code for the scale transformation. 例2-3显示了比例变换的代码。\nelse if (me.isAltDown() \u0026amp;\u0026amp; me.isSecondaryButtonDown()) {\rdouble scale = cam.s.getX();\rdouble newScale = scale + mouseDeltaX*0.01;\rcam.s.setX(newScale); cam.s.setY(newScale); cam.s.setZ(newScale);\r}\r... Shearing 剪力 剪切 A shearing transformation rotates one axis so that the x-axis and y-axis are no longer perpendicular. The coordinates of the node are shifted by the specified multipliers. 剪切变换使一个轴旋转，以使x轴和y轴不再垂直。节点的坐标移动指定的乘数。\nTo shear, use the Shear class or the shear method of the Transform class. 要剪切，请使用Shear该类或该类的shear方法Transform。\nIn the Xylophone application, you can shear the xylophone by dragging the mouse while holding Shift and pressing the left mouse button. 在木琴应用程序中，可以通过按住Shift并按鼠标左键的同时拖动鼠标来剪切木琴。\nExample 2-4 shows the code snippet for the shear transformation. 图2-1剪切转换\nelse if (me.isShiftDown() \u0026amp;\u0026amp; me.isPrimaryButtonDown()) {\rdouble yShear = shear.getY();\rshear.setY(yShear + mouseDeltaY/1000.0);\rdouble xShear = shear.getX();\rshear.setX(xShear + mouseDeltaX/1000.0);\r} Multiple Transformations 多重转换 You can construct multiple transformations by specifying an ordered chain of transformations. For example, you can scale an object and then apply a shearing transformation to it, or you can translate an object and then scale it. 您可以通过指定转换的有序链来构造多个转换。例如，您可以缩放对象，然后对其应用剪切变换，也可以平移对象然后对其进行缩放。\nExample 2-5 shows multiple transformations applied to an object to create a xylophone bar. 例2-5显示了应用于对象以创建木琴条的多个转换。\nExample 2-5 Multiple Transformations 示例2-5多重转换\nCube base1Cube = new Cube(1.0, new Color(0.2, 0.12, 0.1, 1.0), 1.0);\rbase1Cube.setTranslateX(xStart + 135);\rbase1Cube.setTranslateZ(yPos+20.0);\rbase1Cube.setTranslateY(11.0);\rbase1Cube.setScaleX(barWidth*11.5);\rbase1Cube.setScaleZ(10.0);\rbase1Cube.setScaleY(barDepth*2.0); 3、Animation Basics 转换类型和示例 Animation in JavaFX can be divided into timeline animation and transitions. This chapter provides examples of each animation type.\nTimeline and Transition are subclasses of the javafx.animation.Animation class. For more information about particular classes, methods, or additional features, see the API documentation.\nTransitions Transitions in JavaFX provide the means to incorporate animations in an internal timeline. Transitions can be composed to create multiple animations that are executed in parallel or sequentially. See the Parallel Transition and Sequential Transition sections for details. The following sections provide some transition animation examples.\nFade Transition A fade transition changes the opacity of a node over a given time.\nExample 3-1 shows a code snippet for a fade transition that is applied to a rectangle. First a rectangle with rounded corners is created, and then a fade transition is applied to it.\nExample 3-1 Fade Transition\nfinal Rectangle rect1 = new Rectangle(10, 10, 100, 100);\rrect1.setArcHeight(20);\rrect1.setArcWidth(20);\rrect1.setFill(Color.RED);\r...\rFadeTransition ft = new FadeTransition(Duration.millis(3000), rect1);\rft.setFromValue(1.0);\rft.setToValue(0.1);\rft.setCycleCount(Timeline.INDEFINITE);\rft.setAutoReverse(true);\rft.play(); Path Transition A path transition moves a node along a path from one end to the other over a given time.\nFigure 3-1 Path Transition Example 3-2 shows a code snippet for a path transition that is applied to a rectangle. The animation is reversed when the rectangle reaches the end of the path. In code, first a rectangle with rounded corners is created, and then a new path animation is created and applied to the rectangle.\nExample 3-2 Path Transition\nfinal Rectangle rectPath = new Rectangle (0, 0, 40, 40);\rrectPath.setArcHeight(10);\rrectPath.setArcWidth(10);\rrectPath.setFill(Color.ORANGE);\r...\rPath path = new Path();\rpath.getElements().add(new MoveTo(20,20));\rpath.getElements().add(new CubicCurveTo(380, 0, 380, 120, 200, 120));\rpath.getElements().add(new CubicCurveTo(0, 120, 0, 240, 380, 240));\rPathTransition pathTransition = new PathTransition();\rpathTransition.setDuration(Duration.millis(4000));\rpathTransition.setPath(path);\rpathTransition.setNode(rectPath);\rpathTransition.setOrientation(PathTransition.OrientationType.ORTHOGONAL_TO_TANGENT);\rpathTransition.setCycleCount(Timeline.INDEFINITE);\rpathTransition.setAutoReverse(true);\rpathTransition.play(); Parallel Transition A parallel transition executes several transitions simultaneously.\nExample 3-3 shows the code snippet for the parallel transition that executes fade, translate, rotate, and scale transitions applied to a rectangle.\nFigure 3-2 Parallel Transition Example 3-3 Parallel Transition\nRectangle rectParallel = new Rectangle(10,200,50, 50);\rrectParallel.setArcHeight(15);\rrectParallel.setArcWidth(15);\rrectParallel.setFill(Color.DARKBLUE);\rrectParallel.setTranslateX(50);\rrectParallel.setTranslateY(75);\r...\rFadeTransition fadeTransition = new FadeTransition(Duration.millis(3000), rectParallel);\rfadeTransition.setFromValue(1.0f);\rfadeTransition.setToValue(0.3f);\rfadeTransition.setCycleCount(2);\rfadeTransition.setAutoReverse(true);\rTranslateTransition translateTransition =\rnew TranslateTransition(Duration.millis(2000), rectParallel);\rtranslateTransition.setFromX(50);\rtranslateTransition.setToX(350);\rtranslateTransition.setCycleCount(2);\rtranslateTransition.setAutoReverse(true);\rRotateTransition rotateTransition = new RotateTransition(Duration.millis(3000), rectParallel);\rrotateTransition.setByAngle(180f);\rrotateTransition.setCycleCount(4);\rrotateTransition.setAutoReverse(true);\rScaleTransition scaleTransition = new ScaleTransition(Duration.millis(2000), rectParallel);\rscaleTransition.setToX(2f);\rscaleTransition.setToY(2f);\rscaleTransition.setCycleCount(2);\rscaleTransition.setAutoReverse(true);\rparallelTransition = new ParallelTransition();\rparallelTransition.getChildren().addAll(\rfadeTransition,\rtranslateTransition,\rrotateTransition,\rscaleTransition\r);\rparallelTransition.setCycleCount(Timeline.INDEFINITE);\rparallelTransition.play(); Sequential Transition A sequential transition executes several transitions one after another.\nExample 3-4 shows the code for the sequential transition that executes one after another. Fade, translate, rotate, and scale transitions that are applied to a rectangle.\nExample 3-4 Sequential Transition\nRectangle rectSeq = new Rectangle(25,25,50,50);\rrectSeq.setArcHeight(15);\rrectSeq.setArcWidth(15);\rrectSeq.setFill(Color.CRIMSON);\rrectSeq.setTranslateX(50);\rrectSeq.setTranslateY(50);\r...\rFadeTransition fadeTransition = new FadeTransition(Duration.millis(1000), rectSeq);\rfadeTransition.setFromValue(1.0f);\rfadeTransition.setToValue(0.3f);\rfadeTransition.setCycleCount(1);\rfadeTransition.setAutoReverse(true);\rTranslateTransition translateTransition =\rnew TranslateTransition(Duration.millis(2000), rectSeq);\rtranslateTransition.setFromX(50);\rtranslateTransition.setToX(375);\rtranslateTransition.setCycleCount(1);\rtranslateTransition.setAutoReverse(true);\rRotateTransition rotateTransition = new RotateTransition(Duration.millis(2000), rectSeq);\rrotateTransition.setByAngle(180f);\rrotateTransition.setCycleCount(4);\rrotateTransition.setAutoReverse(true);\rScaleTransition scaleTransition = new ScaleTransition(Duration.millis(2000), rectSeq);\rscaleTransition.setFromX(1);\rscaleTransition.setFromY(1);\rscaleTransition.setToX(2);\rscaleTransition.setToY(2);\rscaleTransition.setCycleCount(1);\rscaleTransition.setAutoReverse(true);\rsequentialTransition = new SequentialTransition();\rsequentialTransition.getChildren().addAll(\rfadeTransition,\rtranslateTransition,\rrotateTransition,\rscaleTransition);\rsequentialTransition.setCycleCount(Timeline.INDEFINITE);\rsequentialTransition.setAutoReverse(true);\rsequentialTransition.play(); For more information about animation and transitions, see the API documentation and the Animation section in the Ensemble project in the SDK.\nTimeline Animation An animation is driven by its associated properties, such as size, location, and color etc. Timeline provides the capability to update the property values along the progression of time. JavaFX supports key frame animation. In key frame animation, the animated state transitions of the graphical scene are declared by start and end snapshots (key frames) of the state of the scene at certain times. The system can automatically perform the animation. It can stop, pause, resume, reverse, or repeat movement when requested.\nBasic Timeline Animation The code in Example 3-5 animates a rectangle horizontally and moves it from its original position X=100 to X=300 in 500 ms. To animate an object horizontally, alter the x-coordinates and leave the y-coordinates unchanged.\nFigure 3-3 Horizontal Movement Example 3-5 shows the code snippet for the basic timeline animation.\nExample 3-5 Timeline Animation\nfinal Rectangle rectBasicTimeline = new Rectangle(100, 50, 100, 50);\rrectBasicTimeline.setFill(Color.RED);\r...\rfinal Timeline timeline = new Timeline();\rtimeline.setCycleCount(Timeline.INDEFINITE);\rtimeline.setAutoReverse(true);\rfinal KeyValue kv = new KeyValue(rectBasicTimeline.xProperty(), 300);\rfinal KeyFrame kf = new KeyFrame(Duration.millis(500), kv);\rtimeline.getKeyFrames().add(kf);\rtimeline.play(); Timeline Events JavaFX provides the means to incorporate events that can be triggered during the timeline play. The code in Example 3-6 changes the radius of the circle in the specified range, and KeyFrame triggers the random transition of the circle in the x-coordinate of the scene.\nExample 3-6 Timeline Events\nimport javafx.application.Application;\rimport javafx.stage.Stage;\rimport javafx.animation.AnimationTimer;\rimport javafx.animation.KeyFrame;\rimport javafx.animation.KeyValue;\rimport javafx.animation.Timeline;\rimport javafx.event.ActionEvent;\rimport javafx.event.EventHandler;\rimport javafx.scene.Group;\rimport javafx.scene.Scene;\rimport javafx.scene.effect.Lighting;\rimport javafx.scene.layout.StackPane;\rimport javafx.scene.paint.Color;\rimport javafx.scene.shape.Circle;\rimport javafx.scene.text.Text;\rimport javafx.util.Duration;\rpublic class TimelineEvents extends Application {\r//main timeline\rprivate Timeline timeline;\rprivate AnimationTimer timer;\r//variable for storing actual frame\rprivate Integer i=0;\r@Override public void start(Stage stage) {\rGroup p = new Group();\rScene scene = new Scene(p);\rstage.setScene(scene);\rstage.setWidth(500);\rstage.setHeight(500);\rp.setTranslateX(80);\rp.setTranslateY(80);\r//create a circle with effect\rfinal Circle circle = new Circle(20, Color.rgb(156,216,255));\rcircle.setEffect(new Lighting());\r//create a text inside a circle\rfinal Text text = new Text (i.toString());\rtext.setStroke(Color.BLACK);\r//create a layout for circle with text inside\rfinal StackPane stack = new StackPane();\rstack.getChildren().addAll(circle, text);\rstack.setLayoutX(30);\rstack.setLayoutY(30);\rp.getChildren().add(stack);\rstage.show();\r//create a timeline for moving the circle\rtimeline = new Timeline();\rtimeline.setCycleCount(Timeline.INDEFINITE);\rtimeline.setAutoReverse(true);\r//You can add a specific action when each frame is started.\rtimer = new AnimationTimer() {\r@Override\rpublic void handle(long l) {\rtext.setText(i.toString());\ri++;\r}\r};\r//create a keyValue with factory: scaling the circle 2times\rKeyValue keyValueX = new KeyValue(stack.scaleXProperty(), 2);\rKeyValue keyValueY = new KeyValue(stack.scaleYProperty(), 2);\r//create a keyFrame, the keyValue is reached at time 2s\rDuration duration = Duration.millis(2000);\r//one can add a specific action when the keyframe is reached\rEventHandler onFinished = new EventHandler\u0026lt;ActionEvent\u0026gt;() {\rpublic void handle(ActionEvent t) {\rstack.setTranslateX(java.lang.Math.random()*200-100);\r//reset counter\ri = 0;\r}\r};\rKeyFrame keyFrame = new KeyFrame(duration, onFinished , keyValueX, keyValueY);\r//add the keyframe to the timeline\rtimeline.getKeyFrames().add(keyFrame);\rtimeline.play();\rtimer.start();\r}\rpublic static void main(String[] args) {\rApplication.launch(args);\r}\r} Interpolators Interpolation defines positions of the object between the start and end points of the movement. You can use various built-in implementations of the Interpolator class or you can implement your own Interpolator to achieve custom interpolation behavior.\nBuilt-in Interpolators JavaFX provides several built-in interpolators that you can use to create different effects in your animation. By default, JavaFX uses linear interpolation to calculate the coordinates.\nExample 3-7 shows a code snippet where the EASE_BOTH interpolator instance is added to the KeyValue in the basic timeline animation. This interpolator creates a spring effect when the object reaches its start point and its end point.\nExample 3-7 Built-in Interpolator\nfinal Rectangle rectBasicTimeline = new Rectangle(100, 50, 100, 50);\rrectBasicTimeline.setFill(Color.BROWN);\r...\rfinal Timeline timeline = new Timeline();\rtimeline.setCycleCount(Timeline.INDEFINITE);\rtimeline.setAutoReverse(true);\rfinal KeyValue kv = new KeyValue(rectBasicTimeline.xProperty(), 300,\rInterpolator.EASE_BOTH);\rfinal KeyFrame kf = new KeyFrame(Duration.millis(500), kv);\rtimeline.getKeyFrames().add(kf);\rtimeline.play(); Custom Interpolators Apart from built-in interpolators, you can implement your own interpolator to achieve custom interpolation behavior. A custom interpolator example consists of two java files. Example 3-8 shows a custom interpolator that is used to calculate the y-coordinate for the animation. Example 3-9 shows the code snippet of the animation where the AnimationBooleanInterpolator is used.\nExample 3-8 Custom Interpolator\npublic class AnimationBooleanInterpolator extends Interpolator {\r@Override\rprotected double curve(double t) {\rreturn Math.abs(0.5-t)*2 ;\r}\r} Example 3-9 Animation with Custom Interpolator\nfinal KeyValue keyValue1 = new KeyValue(rect.xProperty(), 300);\rAnimationBooleanInterpolator yInterp = new AnimationBooleanInterpolator();\rfinal KeyValue keyValue2 = new KeyValue(rect.yProperty(), 0., yInterp); "},{"id":248,"href":"/Tech/3Java/Java-FX/JavaFx/","title":"Java Fx","parent":"Java FX","content":" JavaFX架构 JavaFX公共API下方是运行JavaFX代码的引擎。它由子组件组成，这些子组件包括JavaFX高性能图形引擎Prism；一个小型高效的窗口系统，称为Glass；媒体引擎和Web引擎。尽管这些组件没有公开公开，但是它们的描述可以帮助您更好地了解运行JavaFX应用程序的组件。\nScene Graph 场景图 Java Public APIs for JavaFX Features 用于JavaFX功能的Java公共API Graphics System 图形系统 Glass Windowing Toolkit 玻璃窗工具包 Media and Images 媒体和图片 Web Component Web组件 CSS CSS引擎 UI Controls UI控件 Layout 布局 2-D and 3-D Transformations 2D和3D转换 Visual Effects 视觉效果 JavaFX体系结构图 JavaFX体系结构图显示了堆栈。顶层显示在一个圆形的栗色框中，表示JavaFX公共API和JavaFX场景图。下一层是圆形的蓝色框中的Quantum Toolkit。第三层在一个圆形的蓝色框中具有称为Prism的图形管道，在一个方形的豌豆绿色框中具有一个玻璃窗口工具包（Glass），在一个方形的鲜绿色框中具有媒体引擎，在一个方形的棕色框中具有Web引擎。第四层由圆形的蓝色框中的Java 2D，OpenGL和Direct3D（D3D）组成。均以圆形蓝色框显示的Quantum Toolkit，Prism，Java 2D，OpenGL和D3D组成了JavaFX图形系统。最低层（以浅紫色显示）是Java虚拟机。Java虚拟机位于JavaFX图形系统，Glass Windowing Toolkit，媒体引擎和Web引擎的下面。\nScene Graph 场景图 如图2-1的顶层所示，JavaFX场景图是构建JavaFX应用程序的起点。它是节点的分层树，代表应用程序用户界面的所有可视元素。它可以处理输入并可以呈现。\n场景图中的单个元素称为节点。每个节点都有一个ID，样式类和边界量。除了场景图的根节点之外，场景图中的每个节点都有一个父级和零个或多个子级。它还可以具有以下内容：\n效果，例如模糊和阴影 不透明度 变身 事件处理程序（例如鼠标，键和输入法） 特定于应用程序的状态 与Swing和Abstract Window Toolkit（AWT）不同，JavaFX场景图除了具有控件，布局容器，图像和媒体之外，还包括图形基元，例如矩形和文本。\n对于大多数用途，场景图简化了使用UI的工作，尤其是在使用丰富的UI时。使用javafx.animation API可以快速完成对场景图中的各种图形进行动画处理，并且声明性方法（例如XML doc）也可以很好地工作。\n该javafx.scene API允许创建和指定多种类型的内容，例如：\n节点：形状（2-D和3-D），图像，媒体，嵌入式Web浏览器，文本，UI控件，图表，组和容器 状态：内容的变换（节点的位置和方向），视觉效果以及其他视觉状态 效果：更改场景图节点外观的简单对象，例如模糊，阴影和颜色调整 有关更多信息，请参见使用JavaFX场景图文档。\nSubScene 场景图 SubScene节点是场景图中内容的容器。它是用于场景分离的特殊节点。它可以用于使用其他相机渲染场景的一部分。如果要在布局中使3D对象的Y向上和2D UI对象的Y向下，则可以使用SubScene节点。\nSubScene的一些可能用例是：\nUI控件的叠加层（需要静态相机） 背景参考底图（静态或更新频率较低） “抬头”显示 3D对象为Y向上，而2D UI为Y向下。 Light 光 现在，光线也被定义为场景图中的一个节点。如果场景中包含的一组活动光源为空，则提供默认光源。每盏灯都包含一组受影响的节点。如果一组节点为空，则将影响场景（或子场景）上的所有节点。如果父节点位于该节点集中，则其所有子节点也会受到影响。\n灯光与Shape3D对象的几何形状及其材质相互作用以提供渲染结果。当前，有两种类型的光源：\nAmbientLight -似乎来自各个方向的光源。 PointLight -在空间中具有固定点并在远离自身的所有方向上均等地辐射光的光源。 类层次结构：\njavafx.scene.Node\rjavafx.scene.LightBase (abstract)\rjavafx.scene.AmbientLight\rjavafx.scene.PointLight 用于JavaFX功能的Java公共API 图2-1中所示的JavaFX体系结构的顶层提供了一组完整的Java公共API，它们支持富客户端应用程序开发。这些API为构建富客户端应用程序提供了无与伦比的自由度和灵活性。JavaFX平台将Java平台的最佳功能与全面的沉浸式媒体功能相结合，形成了直观，全面的一站式开发环境。这些用于JavaFX的Java API功能：\n允许使用强大的Java功能，例如泛型，注释，多线程和Lamda表达式（在Java SE 8中引入）。 使Web开发人员更容易使用其他基于JVM的动态语言（例如Groovy和JavaScript）中的JavaFX。 允许Java开发人员使用其他系统语言（例如Groovy）来编写大型或复杂的JavaFX应用程序。 允许使用包括对高性能延迟绑定，绑定表达式，绑定序列表达式和部分绑定重新评估的支持的绑定。替代语言（例如Groovy）可以使用此绑定库来引入类似于JavaFX Script的绑定语法。 扩展Java集合库以包括可观察的列表和映射，这使应用程序可以将用户界面连接到数据模型，观察那些数据模型中的更改并相应地更新相应的UI控件。 JavaFX API和编程模型是JavaFX 1.x产品线的延续。大多数JavaFX API已直接移植到Java。根据从JavaFX 1.x版本的用户收到的反馈，对一些API（例如Layout和Media）以及许多其他详细信息进行了改进和简化。JavaFX更加依赖于Web标准，例如CSS用于样式控制，而ARIA用于可访问性规范。其他网络标准的使用也正在审查中。\n图形系统 图2-1中以蓝色显示的JavaFX图形系统是JavaFX场景图形层下面的实现细节。它支持2-D和3-D场景图。当系统上的图形硬件不足以支持硬件加速渲染时，它将提供软件渲染。\nJavaFX平台上实现了两个图形加速管道：\nPrism提供了流程渲染工作,它可以在包括3-D在内的硬件和软件渲染器上运行。它负责JavaFX场景的栅格化和渲染。根据所使用的设备，以下多个渲染路径是可能的：\nWindows XP和Windows Vista上的DirectX 9 Windows 7上的DirectX 11 Mac，Linux，嵌入式上的OpenGL 无法进行硬件加速时的软件渲染 尽可能使用完全硬件加速的路径，但是当不可用时，将使用软件渲染路径，因为软件渲染路径已经在所有Java运行时环境（JRE）中分发。在处理3D场景时，这一点尤其重要。但是，使用硬件渲染路径时，性能会更好。\nQuantum Toolkit将Prism和Glass Windowing Toolkit捆绑在一起，并使它们可用于堆栈中位于其上方的JavaFX层。它还管理与渲染与事件处理相关的线程规则。\n玻璃窗工具包 Glass Windowing Toolkit（图2-1中部以米色显示）是JavaFX图形堆栈中的最低级别。它的主要职责是提供本机操作服务，例如管理窗口，计时器和表面。它用作将JavaFX平台连接到本机操作系统的平台相关层。\nGlass工具包还负责管理事件队列。与管理自己的事件队列的抽象窗口工具包（AWT）不同，Glass工具包使用本机操作系统的事件队列功能来调度线程使用。另外，与AWT不同，Glass工具箱与JavaFX应用程序在同一线程上运行。在AWT中，AWT的本机部分在一个线程上运行，而Java级别在另一个线程上运行。这引入了很多问题，其中许多问题是通过使用单一JavaFX应用程序线程方法在JavaFX中解决的。\nThreads 线程数 系统在任何给定时间运行两个或多个以下线程\nJavaFX应用程序线程 这是JavaFX应用程序开发人员使用的主要线程。必须从此线程访问任何“实时”场景，该场景是窗口的一部分。可以在后台线程中创建和操作场景图，但是当其根节点连接到场景中的任何活动对象时，必须从JavaFX应用程序线程访问该场景图。这使开发人员可以在后台线程上创建复杂的场景图，同时保持“实时”场景上的动画流畅，快速。JavaFX应用程序线程是与Swing和AWT事件调度线程（EDT）不同的线程，因此在将JavaFX代码嵌入到Swing应用程序中时必须小心。 Prism渲染线程 此线程与事件分发程序分开处理渲染。它允许在处理帧N +1时渲染帧N。执行并发处理的能力是一个很大的优势，特别是在具有多个处理器的现代系统上。Prism渲染线程可能还具有多个栅格化线程，这些线程可帮助卸载渲染​​中需要完成的工作。 媒体线程 此线程在后台运行，并使用JavaFX应用程序线程通过场景图同步最新帧。 Pulse 脉冲 脉冲是一个事件，向JavaFX场景图指示是时候将该场景图上的元素的状态与Prism同步了。最多以每秒60帧（fps）的速度调节脉冲，并在场景图上运行动画时将其触发。即使动画没有运行，当场景图中的某些内容发生更改时，也会安排一个脉冲。例如，如果按钮的位置改变，则调度脉冲。\n当发射脉冲时，场景图上元素的状态向下同步到渲染层。脉冲使应用程序开发人员可以异步处理事件。这一重要功能使系统可以批量处理和执行脉冲事件。\n布局和CSS也与脉冲事件相关。场景图中的许多更改都可能导致多个布局或CSS更新，从而可能严重降低性能。系统每个脉冲自动执行一次CSS和布局遍历，以避免性能下降。应用程序开发人员还可以根据需要手动触发布局遍历，以便在脉冲之前进行测量。\nGlass Windowing Toolkit 负责执行脉冲事件。它使用高分辨率的本地计时器进行执行。\n媒体和图片 JavaFX媒体功能可通过javafx.scene.mediaAPI获得。JavaFX同时支持视觉和音频媒体。提供了对MP3，AIFF和WAV音频文件以及FLV视频文件的支持。JavaFX媒体功能是作为三个独立的组件提供的：Media对象代表媒体文件，MediaPlayer播放媒体文件，MediaView是显示媒体的节点。\nMedia Engine组件（在图2-1中以绿色显示）在设计时充分考虑了性能和稳定性，并提供跨平台的一致行为。有关更多信息，请阅读将媒体资产合并到JavaFX Applications文档中。\nWeb Component Web组件 Web组件是基于Webkit的JavaFX UI控件，它通过其API提供Web查看器和完整的浏览功能。该Web引擎组件（基于图2-1中的橙色所示）基于WebKit，WebKit是一个开源Web浏览器引擎，支持HTML5，CSS，JavaScript，DOM和SVG。它使开发人员能够在其Java应用程序中实现以下功能：\n从本地或远程URL呈现HTML内容 支持历史记录并提供前进和后退导航 重新加载内容 将效果应用于Web组件 编辑HTML内容 执行JavaScript命令 处理事件 该嵌入式浏览器组件由以下类组成：\nWebEngine 提供基本的网页浏览功能。 WebView封装WebEngine对象，将HTML内容合并到应用程序的场景中，并提供用于应用效果和转换的字段和方法。它是Node类的扩展。 此外，可以通过JavaScript控制Java调用，反之亦然，以允许开发人员充分利用这两种环境。有关JavaFX嵌入式浏览器的更详细的概述，请参阅向JavaFX应用程序中添加HTML内容文档。 CSS JavaFX级联样式表（CSS）能够将自定义样式应用于JavaFX应用程序的用户界面，而无需更改该应用程序的任何源代码。CSS可以应用于JavaFX场景图中的任何节点，并且可以异步地应用于节点。JavaFX CSS样式也可以在运行时轻松地分配给场景，从而允许应用程序的外观动态变化。\nJavaFX CSS基于W3C CSS版本2.1规范，并且在当前版本3的基础上进行了一些补充。JavaFXCSS支持和扩展旨在允许任何兼容的CSS解析器（甚至是那些兼容的CSS解析器）对JavaFX CSS样式表进行干净的解析。不支持JavaFX扩展。这样可以将用于JavaFX和其他目的（例如HTML页面）的CSS样式混合到一个样式表中。所有JavaFX属性名称都以“ -fx-” 供应商扩展名作为前缀，包括那些似乎与标准HTML CSS兼容的名称，因为某些JavaFX值的语义略有不同。\n有关JavaFX CSS的更多详细信息，请参阅使用CSS设置JavaFX应用程序的外观文档。\nUI Controls UI控件 通过JavaFX API可用的JavaFX UI控件是通过使用场景图中的节点来构建的。它们可以充分利用JavaFX平台的视觉丰富功能，并且可以跨不同平台移植。JavaFX CSS允许UI控件的主题化和外观化。\n图2-3显示了当前支持的一些UI控件。这些控件位于javafx.scene.control程序包中。\n有关所有可用JavaFX UI控件的更多详细信息，请参阅使用JavaFX UI控件 和该包的API文档 javafx.scene.control。\nLayout 布局 布局容器或窗格可用于允许在JavaFX应用程序的场景图中灵活，动态地布置UI控件。JavaFX Layout API包含以下容器类，这些容器类可自动执行常见的布局模型：\n本BorderPane类勾画出其内容节点上，下，左，右，或中心区域。 该HBox级水平排列其内容节点在单行。 所述VBox类垂直排列其内容节点在单个列中。 该StackPane班将它的内容节点在后到前的单堆。 本GridPane类允许开发人员创建的行和列的灵活的网格中，奠定了内容节点。 的FlowPane类排列在水平或垂直它的内容节点“流”，包裹在指定的宽度（对于水平）或高度（对于垂直）的边界。 该TilePane班将它的内容节点，大小均匀的布局单元格或瓷砖 在AnchorPane类允许开发人员创建锚节点的顶部，底部，左侧，或中心的布局。 为了实现所需的布局结构，可以在JavaFX应用程序中嵌套不同的容器。\n要了解有关如何使用布局的更多信息，请参见 在JavaFX中使用布局。 有关JavaFX布局API的更多信息，请参阅该javafx.scene.layout包的API文档。\n2-D and 3-D Transformations 2D和3D转换 可以使用以下javafx.scene.tranform类在xy坐标中转换JavaFX场景图中的每个节点：\ntranslate –相对于其初始位置，沿着x，y，z平面将节点从一个位置移动到另一个位置。 scale –根据缩放比例，调整节点的大小以使其在x，y，z平面中显示更大或更小。 shear–旋转一个轴，以使x轴和y轴不再垂直。节点的坐标将移动指定的乘数。 rotate –围绕场景的指定枢轴点旋转节点。 affine–执行从2-D / 3-D坐标到其他2-D / 3-D坐标的线性映射，同时保留直线的“直线”和“平行”属性。此类应用使用Translate，Scale，Rotate，或Shear变换，而不是直接使用的类。 要了解有关使用转换的更多信息，请参阅 《在JavaFX中应用转换》 文档。有关javafx.scene.transformAPI类的更多信息，请参阅 API文档。\nVisual Effects 视觉效果 JavaFX场景图中富客户端接口的开发涉及使用Visual Effects或Effects来实时增强JavaFX应用程序的外观。JavaFX效果主要基于图像像素，因此，它们采用场景图中的节点集，将其渲染为图像，并对其应用指定的效果。\nJavaFX中可用的某些视觉效果包括以下类的使用：\nDrop Shadow –在要应用效果的内容后面渲染给定内容的阴影。 Reflection –在实际内容下方呈现内容的反射版本。 Lighting –模拟照在给定内容上的光源，并且可以使平面对象具有更逼真的三维外观。 有关如何使用某些可用视觉效果的示例，请参见 创建视觉效果 文档。有关所有可用视觉效果类的更多信息，请参见该包的API文档javafx.scene.effect。\n"},{"id":249,"href":"/Tech/3Java/Java-FX/JavaFX%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%B5%85%E8%B0%88/","title":"Java Fx游戏开发效率浅谈","parent":"Java FX","content":" JavaFX游戏开发效率浅谈 这一段时间没事的时候把基于JavaFX的游戏引擎WJFXGameEngine的效率进行优化了一下(个人博客的示例并未重新上传)，简单的2D游戏，在我PC上运行最快可以达到750-800FPS。下面来简单谈谈JavaFX游戏开发上的一些基本问题。\n看过JavaFX官方游戏示例BrickBreak的人都可以发现，这个游戏的绘制和逻辑是在Timeline中进行的。JavaFX中的Timeline根据我使用的经验来看，效率不是很高，而且如果数量过多，会很卡。在我游戏引擎中目前的简单的动画是用Timeline实现的，未来会做大改动。\n而且之前的教程中，JavaFX简单的游戏框架中讲的也是是用的Timeline。这实际是个很严重的问题。被JavaFX官方示例误导了。\n目前我的改动是，使用双线程，一个线程处理绘制，一个线程处理更新操作(这也是很多游戏引擎常用的做法，例如Android游戏引擎AndEngine)。当然，绘制处理必须要在JavaFX MainThread中运行，所以我们使用Platform.runLater来调用绘制操作。虽然它还是在主线程执行，但更新绘制的速度明显更快。之前做的JavaFX游戏示例中，经常出现子弹卡顿等现场，现在不会出现了。\ndrawThread = new Thread(new Runnable() {\r@Override\rpublic void run() {\rwhile (isRunning) {\rtry {\rThread.sleep(waitTime);\r} catch (Exception e) {\r}\rPlatform.runLater(new Runnable() {\r@Override\rpublic void run() {\rdraw(getGraphicsContext2D());\r}\r});\rif (fpsMaker != null) {\rfpsMaker.makeFPS();\r}\r}\r}\r});\rupdateThread = new Thread(new Runnable() {\r@Override\rpublic void run() {\rwhile (isRunning) {\rtry {\rThread.sleep(waitTime);\r} catch (Exception e) {\r}\rupdate();\r}\r}\r}); 这个是我的WScreen类里的代码。\n线程等待时间waitTime越低的时候，FPS会越快。\nFPS快了之后，就有另外一个问题。由于更新操作频繁，如果这样时候你在update等操作里面还依然使用move(4)这样的方法的话，你会发现速度非常的快。\n而且由于FPS又不是稳定的，所以我们会发现在不同配置的电脑上运行的情况差别很大，这样，我们就要用到另外一个概念了DeltaTime。\nDeltaTime记录的是距离上次Update的时间。我们每次移动的速度* DeltaTime，就可以让我们以不受帧率影响的速率移动了。\n当然DeltaTime几乎在所有的游戏引擎或框架中都有这个概念，像我以前用的微软的XNA游戏框架，现在工作的Unity3D开发等。\n"},{"id":250,"href":"/Tech/3Java/Java-Regular-Expression/","title":"Java Regular Expression","parent":"3、Java","content":" Java Regular Expression 一些简单的就不写了\n否定式前瞻 否定式向前查找，对于正则表达式引擎来说，因为它是从文本头部向尾部开始解析的（可以通过正则选项控制解析方向），因此对于文本尾部方向，称为“前”。\n解决的问题： 正则表达式匹配不包含某些字符串的技巧\n前瞻的语法是：： (?!匹配模式) 表达式如下： ((?!hede).)* 解释一下几个部分： 在正则表达式里， ?! 是否定式向前查找，它帮我们解决了字符串“不包含”匹配的问题。 表达式(?!hede).会往前查找，看看前面是不是没有“hede”字串，如果没有(是其它字符)，那么.(点号)就会匹配这些其它字符。这种正则表达式的“查找”也叫做“zero-width-assertions”(零宽度断言)，因为它不会捕获任何的字符，只是判断。 在上面的例子里，每个空字符都会检查其前面的字符串是否不是‘hede\u0026rsquo;，如果不是，这.(点号)就是匹配捕捉这个字符。表达式(?!hede).只执行一次，所以，我们将这个表达式用括号包裹成组(group)，然后用*(星号)修饰——匹配0次或多次： 以下是一些补充： // 1、多个 否定式前瞻配合 ((?!\\})(?!\u0026#34;)(?!,\u0026#34;).)* // 2、多个 否定式前瞻配合，捕获 json 指定 key 的值。\r\u0026#34;sub_msg\u0026#34;:\\s?\\\u0026#34;?((?!\\})(?!\u0026#34;)(?!,\u0026#34;).)* "},{"id":251,"href":"/Tech/3Java/Java-Tags/","title":"Java Tags","parent":"3、Java","content":" Java Tags 标签：Java Tags 时间：2018年11月1日14:37:44 连接：https://www.saveload.cn/html/mood/2018/Java Tags.mk equals与==的区别 ==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。equals()方法最重要的一点是，能够根据业务要求去重写，按照自定义规则去判断两个对象是否相等。重写equals()方法的时候，要注意一下hashCode是否会因为对象的属性改变而改变，否则在使用散列集合储存该对象的时候会碰到坑！！理解equals()方法的存在是很重要的。\nstatic： 接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。 static修饰就表示它属于类的，随的类的加载而存在的，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了。 如果是非static的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为static。\nfinal： 接口中不可以定义变量即定义的变量前都要加上final修饰，使之成为常量(没有final修饰的是变量，加上final修饰就会变成常量)。 所以接口的属性默认是public static final 常量，且必须赋初值。（ final修饰就是保证接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意去修改的话，接口建立这个常量就没有意义了。\nthis： this 这个关键字的最大作用就是让类中的一个方法，访问该类里的另一个方法或变量，\n实体类别： Entity接近原始数据，Model接近业务对象～ Entity：是专用于EF的对数据库表的操作， Model：是为页面提供数据和数据校验的，所以两者可以并存 POJO：POJO是Plain OrdinaryJava Object的缩写不错，但是它通指没有使用Entity Beans的普通java对象，可以把POJO作为支持业务逻辑的协助类。\n面向对象\n面向对象设计：易于扩展、可复用、易维护、易构建复杂系统 （继承 支持了 复用，多态 支持了 扩展，封装 支持了 构建维护复用） “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。” 面向对象的一个主要特性就是隐藏实现（不去暴露非必要暴露的对象成员），即一个对象的成员的可访问范围是必须要进行控制的，而公开的通常是方法，通常的做法是将对象属性私有，通过 get、set 方法来获得对象的属性。 面向对象设计一条基本的准则是“为状态的变化使用数据成员，为行为的变化使用多性形”。（例如用属性记录图形的长宽高或直径，用多形性来指定画圆形还是画方形） 记住多形性只能通过方法调用才能表现出来 “多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。 “Upcasting”（上溯造型） 我们将从一个 衍生类 句柄转换成一个 基础类 句柄的行为叫作“上溯造型” 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。 “下溯造型”（Downcasting） 继承、重载(overloaded )、重写、动态绑定 泛型 复用约束 示例：集合的泛型方法 论合成与继承 如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”或者“类似”关系是用继承来表达的，而“包含”关系是用合成来表达的。 继承 用来表达同一个系列不同种对象的行为间的差异。 句柄在运行期间可以重新与一个不同的对象绑定或结合起来,这样一来，我们在运行期间 通过改变句柄绑定的子类类型 就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。 Logger 大家不要再在方法里写：System.out.println(\u0026ldquo;查询到的储位列表数据：\u0026rdquo; + list); 这个很耗费系统性能，且不易维护。 可以用如下方式代替：\n1）、可以在类里声明一个 Logger 对象： Logger logger = LoggerFactory.getLogger(WmsStorageController.class);\n2）、在需要控制台进行输出处： logger.info(\u0026ldquo;查询到的储位列表数据1: {}\u0026quot;,list); logger.error(\u0026ldquo;查询到的储位列表数据2: {}\u0026rdquo; , list); logger.debug(\u0026ldquo;查询到的储位列表数据3: {}\u0026quot;,list); info、error、debug 表示不同的日志输出等级\n这样我们就可以通过 logback-spring 、application.yml 配置文件来统一设定维护输出信息\nCode Review\nCI 持续集成（Continuous Integration）\n持续集成（CI）是在源代码变更后自动检测、拉取、构建和（在大多数情况下）进行单元测试的过程。持续集成是启动管道的环节（尽管某些预验证 —— 通常称为上线前检查pre-flight checks —— 有时会被归在持续集成之前）。 持续集成的目标是快速确保开发人员新提交的变更是好的，并且适合在代码库中进一步使用。 持续集成是如何工作的：持续集成的基本思想是让一个自动化过程监测一个或多个源代码仓库是否有变更。当变更被推送到仓库时，它会监测到更改、下载副本、构建并运行任何相关的单元测试。 目前，监测程序通常是像 Jenkins 这样的应用程序，它还协调管道中运行的所有（或大多数）进程，监视变更是其功能之一。监测程序可以以几种不同方式监测变更。这些包括： 轮询：监测程序反复询问代码管理系统，“代码仓库里有什么我感兴趣的新东西吗？”当代码管理系统有新的变更时，监测程序会“唤醒”并完成其工作以获取新代码并构建/测试它。 定期：监测程序配置为定期启动构建，无论源码是否有变更。理想情况下，如果没有变更，则不会构建任何新内容，因此这不会增加额外的成本。 推送：这与用于代码管理系统检查的监测程序相反。在这种情况下，代码管理系统被配置为提交变更到仓库时将“推送”一个通知到监测程序。最常见的是，这可以以 webhook 的形式完成 —— 在新代码被推送时一个挂勾hook的程序通过互联网向监测程序发送通知。为此，监测程序必须具有可以通过网络接收 webhook 信息的开放端口。 CD 持续交付（Continuous Delivery）\n持续交付（CD）通常是指整个流程链（管道），它自动监测源代码变更并通过构建、测试、打包和相关操作运行它们以生成可部署的版本，基本上没有任何人为干预。 持续交付在软件开发过程中的目标是自动化、效率、可靠性、可重复性和质量保障（通过持续测试）。 持续交付包含持续集成（自动检测源代码变更、执行构建过程、运行单元测试以验证变更），持续测试（对代码运行各种测试以保障代码质量），和（可选）持续部署（通过管道发布版本自动提供给用户）。 Java 注解（Annotation） 为对象增加一些元信息\n微服务\n根据微服务治理，即使现在 订单、商品 在同一个数据库，假如你当前是订单服务，想查询商品，也要用商品服务提供1的接口，而不是自己直接去查库，用户也是一样， 而且接口啥意思？隐藏的实现！是隐藏实现细节！接口啥意思？是将“是什么”与“怎样做”两个模块的分离。 作为某个服务对外提供的 工具，你的工具更应该倾向于简单的接口，尽量的轻，尽量的是告知能提供什么信息，尽量的不在工具提供切实实现。（你工具类是作为某个服务的抽象工具，而不是真的像瑞士军刀一样的真实的扳手工具集合） Java 目标\nJava最终的目标是减轻程序员的负担。 OOP允许我们根据问题来描述问题。 为了方案的重复使用，我们使用：“继承”、“组织”\n利用旧有类的方式有两种，一种是通过“继承”，另一种是通过：“组织”（即通过把旧有的类作为属性引入），可以明确的一点是：轻易的使用“继承”，设计将是非常笨拙的，会大大的增加程序的复杂度，利用“组织”则更显简单灵活。 到底选择合成还是继承\n如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”关系是用继承来表达的，而“包含”关系是用合成来表达的。 为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。在下一章里（多形性），会向大家介绍必须进行上溯造型的一种场合。但只要记住经常问自己“我真的需要上溯造型吗”，对于合成还是继承的选择就不应该是个太大的问题。 关于第3点：“是否必须上溯造型” 的意思是：是否有要把新类当作现有类看的必要！！！\n一、语言基础： 1、Java语言基础(Java 关键字及其特性，Java语法、java.lang 包)、jvm、多线程编程、网络编程 1.1、语言框架： netty、shrio、RabbitMQ、Quartz、dubbo、mybaitc、spring、springmvc、springboot、springcloud 2、数据结构和算法、操作系统、计算机网络、设计模式 3、Java语言基础 1、关键字及其作用特性 2、面向对象的理解 4、Java多线程 1、虚拟机的内存模型 2、java.util.concurrent、Future 5、jvm 1、《深入理解Java虚拟机》\n1、设计模式：《设计模式》，Gang Of Four。四杆老枪的设计模式，教会你一些固定招式应付各种经典场景。\r2、JVM：《深入理解 Java 虚拟机》。在早些年，如果你说你懂 JVM 原理，那你就是国内Java顶尖人才了，现如今 JVM 知识已经烂大街，成为面试必备八股文。你需要了解 JVM 如何使用内存，如何 GC，如何调整启动参数，如何查看 dump 文件。\r3、网络编程：需要搞懂 HTTP、TCP/IP 协议，了解一根网线如何串起整个网络。\r4、分布式系统各种中间件\r（1）Dubbo，这是国内最知名的开源项目之一，找一本阿里出的 dubbo 书读。无中心化分布式架构的核心取代了 IBM 的 SOA 产品（中心化架构容易造成性能瓶颈）。\r（2）ZooKeeper，推荐读 ZooKeeper 小红书。ZK 是分布式系统数据一致性协调工具。在单机进程中代码执行被认为是完全可靠的，要么执行成功要么执行失败，而到了分布式系统，进程之间网络调用经常会出现超时，出现超时就麻烦了，到底是成功了还是失败了没法简单判断。理解 CAP 理解分布式系统数据的一致性是分布式系统不出错的保障。\r（3）Kafka，推荐《Kafka 权威指南》。要理解其为什么那么快又那么可靠又那么大存储空间。这同时也是理解幂等性最方便的系统。\r（4）MySQL，假装也是中间件了，推荐《MySQL高性能》，《MySQL 技术内幕：InnoDB 存储引擎》。要了解红黑树和索引的实现方式，了解 InnoDB 存储引擎的工作原理，你才能更好的理解 explain sql 后出来的各种回显结果，从而帮助你更好的调优 SQL。顺便说一句 MyISAM 被废弃了，你可以少看一本书了，偷着乐吧。\r（5）nginx。之所以能有多个幂等存在就全靠它了。学习一下它的单线程技术，明明是单线程却能做到高性能。nginx：我就是看不上你多线程，咋啦？唯有真正理解计算机原理才能返璞归真。\r（6）Netty，推荐《Netty 权威指南》。在2002之前很多系统都是阻塞 IO，随后的几年中计算机网络突然提速了，这是为什么？2002发布 JDK1.4，2004年出现 Netty，之前大量的计算机网络性能都被阻塞在 IO 上没有被释放，NIO 出现后大幅度提升了 IO 效率。我猜测，在 JDK 支持了 NIO 之后，Tomcat 等 web 容器很快跟进升级，于是全世界在硬件资源没变的情况下网络站点的并发响应能力却大福提升了。\r（7）Flume，一个日志收集传输系统。\r（8）Protobuf，序列化也是性能中需要重点关注的地方。\r（9）Tomcat，太有名了，学学其 classloader 设计思想。\r5、JavaEE，一个名存实亡的企业级开发标准，大部分已经被业界抛弃，依然有用的知识，如 servlet，JMX 等。一个时代的落幕，唉。\r6、编译原理和操作系统：我假设你上大学的时候学过了，如果没有学过，操作系统至少要读一下，推荐清华大学的本科教材。\r7、分布式数据库体系架构，需要掌握分库分表、异构索引、数据库主备等。推荐读一下阿里的 OceanBase，《大规模分布式存储系统：原理解析与架构实战》。另外推荐一本《数据密集型系统设计》，堪称存储设计的通史。\r8、Spring 和 Mybatis，掌握使用，能读懂源码更好了。\r9、UML 建模，推荐《UML 用户指南》。 SELLER\t卖家 BUYER\t买家 OTHER\t其它 BOX\t箱子\nPAY\t支付 SEND_GOODS\t发货 CONFIRM_GOODS\t收货 RETURN_GOODS\t退货 refund\t退款 FEEDBACK\t反馈 CHECK\t审核\nWAIT\t等待 PENDING\t待确认 PART\t部分\nOPEN\t打开 FINISHED\t成功 CLOSED\t关闭 CONFIRM 确认 AGREE\t同意 REFUSE\t拒绝 SUCCESS\t成功 CANCEL\t取消 FORBID 禁止 ban 禁止\nDAMAGED\t残损 EXPIRED\t过期\nreview renew logo slogan Subject 主题 Observer 观察者 勿cue SSG（静态站点生成）\nNFT SNS(Social Networking Services)——社会性网络服务\nDeveloper Reference Documentation\n"},{"id":252,"href":"/Tech/3Java/Java-Util-Concurrent/","title":"Java Util Concurrent","parent":"3、Java","content":" Java Util Concurrent "},{"id":253,"href":"/Tech/3Java/Java-Version/Java-%E5%90%84%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7%E6%9B%B4%E6%96%B0%E5%88%B0Java20/","title":"Java 各版本新特性(更新到 Java20)","parent":"Java Version","content":"JDK各版本新特性(更新到Java20) 发行说明:https://openjdk.org/projects/jdk/\nJDK 1.0 1996-01-23 Oak(橡树)\nJDK 1.1 1997-02-19\nJDK 1.2 1998-12-08 Playground(操场)\nJDK 1.3 2000-05-08 Kestrel(红隼)\nJDK 1.4 2004-02-06 Merlin(隼)\nJDK 1.5新特性 2004-9-30(Tiger)老虎\nJDK 1.6 2006-12-11 Mustang(野马)\nJDK 7新特性: 2011-07-28 Dolphin(海豚)\nJDK 1.8 2014-03-18\nJDK 1.0 1996-01-23 Oak(橡树) 初代版本,伟大的一个里程碑,但是是纯解释运行,使用外挂JIT,\r性能比较差,运行速度慢\rJDK 1.1 1997-02-19 JDBC(Java DataBase Connectivity)\r支持内部类\rRMI(Remote Method Invocation)\r反射\rJava Bean\rJDK 1.2 1998-12-08 Playground(操场) 集合框架\rJIT(Just In Time)编译器\r对打包的Java文件进行数字签名\rJFC(Java Foundation Classes)包括Swing1.0,拖放和Java2D类库\rJava插件\rJDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型\rApplet中添加声音支持\rJDK 1.3 2000-05-08 Kestrel(红隼) Java Sound API Jar文件索引 对Java的各个方面都做了大量优化和增强\nJDK 1.4 2004-02-06 Merlin(隼) XML处理 Java打印服务 Logging API Java Web Start JDBC 3.0API 断言 Preferences API 链式异常处理 支持IPV6 支持正则表达式 引入Image I/O API\nJDK 1.5新特性 2004-9-30(Tiger)老虎 泛型 增强循环,可以使用迭代方式 自动装箱与自动拆箱 类型安全的枚举 可变参数 底层就是一个数组,根据参数个数不同,会创建不同长度的数组 在传递时可以直接传递数组(传递数组后就不能再传递其余可变参数) 静态引入 元数据(注解) Instrumentation\nJDK 1.6 2006-12-11 Mustang(野马) 支持脚本语言 JDBC 4.0API Java Compiler API 可插拔注解 增加对Native PKI(Public Key Infrastructure),Java GSS(Generic Security Service) Kerberos和LDAP(Lightweight Directory Access Protocol)支持 继承Web Services\nJDK 7新特性: 2011-07-28 Dolphin(海豚) 1.switch支持字符串变量 2.泛型实例化类型自动推断 ArrayList list = new ArrayList\u0026lt;\u0026gt;();\n3.新的整数字面表达方式 \u0026ldquo;ob\u0026quot;前缀 和 \u0026ldquo;_\u0026ldquo;连接符 1.表示二进制字面值的前缀ob 以下三个值相同 byte b1 = ob00100001; byte b2 = 0x21; byte b3 = 33;\n2.字面常量数字的下划线.用下划线连接整数提升其可读性,自身无含义,不可用在数字的起始和末尾\rJava编码语言对给数值型的字面值加下划线有严格的规定。如上所述，你只能在数字之间用下划线。你不能用把一个数字用下划线开头，或者已下划线结尾。这里有一些其它的不能在数值型字面值上用下划线的地方：\r在数字的开始或结尾\r对浮点型数字的小数点附件\rF或L下标的前面\r该数值型字面值是字符串类型的时候 float pi1 = 3_.1415F; // 无效的; 不能在小数点之前有下划线\rfloat pi2 = 3._1415F; // 无效的; 不能在小数点之后有下划线\rlong socialSecurityNumber1=999_99_9999_L;//无效的，不能在L下标之前加下划线\rint a1 = _52; // 这是一个下划线开头的标识符，不是个数字\rint a2 = 5_2; // 有效\rint a3 = 52_; // 无效的，不能以下划线结尾\rint a4 = 5_______2; // 有效的\rint a5 = 0_x52; // 无效，不能在0x之间有下划线\rint a6 = 0x_52; // 无效的，不能在数字开头有下划线\rint a7 = 0x5_2; // 有效的 (16进制数字)\rint a8 = 0x52_; // 无效的，不能以下划线结尾\rint a9 = 0_52; // 有效的（8进制数）\rint a10 = 05_2; // 有效的（8进制数）\rint a11 = 052_; // 无效的，不能以下划线结尾\r4.在单个catch块中捕获多个异常,以及用升级版的类型检查重新抛出异常\ncatch代码块得到了升级,用以在单个catch块中处理多个异常,如果你要捕获多个异常并且它们包含相似的代码,使用这一特性会减少代码重复\rcatch(IOException | SQLException | Exception ex) {\r}\r这种情况下ex变量是final的\r5.try-with-resources语句\ntry-with-resources语句是一个声明一个或多个资源的try语句,一个资源作为一个对象,必须在程序结束后关闭\rtry-with-resources语句确保在语句的最后每个资源都被关闭,任何实现了Java.lang.AutoCloseable和java.io.Closeable的对象都可以使用try-with-resource来实现异常处理和关闭资源\rtry-with-resource可以声明多个资源(声明语句之间用分好分割,最后一个可忽略分号)\rtry (流创建等需要关闭的资源打开操作,多个之间用;隔开) {操作} catch(Exception 这里可加catch可不加) {}\r普通 try\nBufferedWriter writer = null;\rtry {\rwriter = new BufferedWriter(new FileWriter(fileName));\rwriter.write(str); // do something with the file we\u0026#39;ve opened\r} catch (IOException e) {\r// handle the exception\r} finally {\rtry {\rif (writer != null)\rwriter.close();\r} catch (IOException e) {\r// handle the exception\r}\r} try-with-resource try\ntry(BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))){\rwriter.write(str); // do something with the file we\u0026#39;ve opened\r}\rcatch(IOException e){\r// handle the exception\r} 注意：从Java 9开始，没有必要在try-with-resources语句中声明资源。\n可以这样做：\nBufferedWriter writer = new BufferedWriter(new FileWriter(fileName));\rtry (writer) {\rwriter.write(str); // do something with the file we\u0026#39;ve opened\r}\rcatch(IOException e) {\r// handle the exception\r} 引入JavaNIO.2开发包\nnull值的自动处理\nJDK 1.8 2014-03-18 Lambda 表达式\nLambda允许把函数作为一个方法的参数(函数作为参数传递进方法中)\r方法引用 方法引用提供了非常有用的语法,可以直接引用已有的Java类或对象(实例)的方法或构造器.\r与lambda联合使用,方法引用可以使语言的构造更紧凑简洁,减少冗余代码\r默认方法\r默认方法就是一个在接口里面有了一个实现的方法\r新工具\r新的编译工具 如:Nashorn引擎 jjs 类依赖分析器jdeps\rStream API\r新添加的Stream API(java.utils.stream)把真正的函数式编程风格引入到Java中\rData Time API\r加强对日期与时间的处理\rOptional类\rOptional类已经成为Java8类库的一部分,可用来解决空指针异常\rNashorn,JavaScript引擎\rJava8提供了一个新的Nashorn JavaScript引擎,它允许我们在JVM上运行特定的JavaScript应用\rJDK 9新特性: 2017-9-22 https://openjdk.org/projects/jdk9/ 模块系统\n模块是一个包的容器,Java9最大的变化之一是引入了模块系统(Jigsaw项目)\rREPL(JShell)\r交互式编程环境\r在cmd中输入JShell 可以帮你自动创建类\r以及运行一些简单的方法\rHTTP2客户端\rHTTP/2标准是HTTP协议的最新版本,新的HTTPClient API支持WebSocket和HTTP2流以及服务器推送特性\r改进的Javadoc\rJavadoc现在支持在API文档中的进行搜索,另外Javadoc的输出现在符合兼容HTML5标准\r多版本兼容Jar包\r多版本兼容Jar功能能让你创建仅在特定版本的Java环境中运行库程序时选择使用的class版本\r集合工厂方法\rList,Set和Map接口中,新的静态工厂方法可以创建这些集合的不可变实例\r私有接口方法\r在接口中使用private私有方法.我们可以使用private访问修饰符在接口中编写私有方法\r进程API\r改进的API来控制和管理操作系统进程.改进java.lang.ProcessHandle及其嵌套接口info来让开发者逃离时常因为要获取一个本地进程的PID而不得不适用本地代码的窘境\r改进的Stream API\r改进的Stream API添加了一些便利的方法,使流处理更容易,并使用收集器编写复杂的查询\r改进 try-with-resources\r如果你已经有一个资源是final或等效于final变量,您可以在try-with-resources语句中使用该变量,而无需再try-with-resources语句中声明一个新变量\r改进的弃用注解@Deprecated\r可以标记Java API的状态 可以表示被标记的API将会被移除,或者已被破坏\r改进钻石操作符(Diamond Operator)\r匿名类可以使用钻石操作符(Diamond Operator)\r改进Optional类\rjava.util.Optional添加了很多新的有用方法,Optional可以直接转为stream\r多分辨率图像API\r定义多分辨率图像API,开发者可以很容易的操作和展示不同分辨率的图像了\r改进的CompletableFuture API\rCompletableFuture类的异步机制可以在ProcessHandle.onExit方法退出时执行操作\r轻量级的JSON API\r内置了一个轻量级的JSON API\r响应式流(Reactive Streams)API\rJava9中引入了新的响应式流API来支持Java9中的响应式编程\r模块化\r可定制JRE:更小的运行时镜像\r更确定的模块依赖关系:避免Jar Hell问题\r与 OSGI 的比较\r模块的定义:\r模块是一个命名的,自我描述的代码和数据的集合\r模块的代码被组织成多个包,每个包中包含Java类和接口\r模块的数据则包括资源文件和其他静态信息\r模块声明文件\r模块声明文件:module-info.java\r新的关键字:module 声明一个模块\r模块名称的规则 与Java包的命名规则相似\rJava 10 2018-3-21\nJEP286,var局部变量类型推断\rJEP296,将原来用 Mercurial 管理的众多JDK仓库代码,合并到一个仓库中,简化开发和管理过程\rJEP304,统一的垃圾回收接口\rJEP307,G1垃圾回收器的并行完整垃圾回收,实现并行性来改善最坏情况下的延迟\rJEP310,应用程序类数据(AppCDS)共享,通过跨进共享通用类元数据来减少内存占用空间,和减少启动时间\rJEP312,ThreadLocal握手交互.在不进入到全局JVM安全点(Safepoint)的情况下,对线程执行回调,优化可以只停止单个线程,而不是停全部线程或一个都不停\rJEP313,移除JDK中附带的javah工具,可以使用javac -h代替\rJEP314,使用附加的Unicode语言标记扩展\rJEP317,能将堆内存占用分配给用户指定的备用内存设备\rJEP317,使用Graal基于Java的编译器,可以预先把Java代码编译成本地代码来提升效能\rJEP318,在OpenJDK中提供一组默认的根证书颁发机构证书,开源目前Oracle提供的JavaSE的根证书,这样OpenJDK对开发人员使用起来更方便\rJEP322,基于时间定义的发布版本,即上述提到的发布周期,版本号为...分别是大版本,中间版本,升级包和补丁版本\rJava 11 2018-09-25\n181:Nest_Based访问控制\n309:动态类文件常量\r315:改善Aarch64 intrinsic\r318:无操作垃圾收集器ZGC\r320:消除Java EE和CORBA模块\r321:HTTP客户端(标准)\r323:局部变量的语法?参数\r324:Curve25519和Curve448关键协议\r327:Unicode 10\r328:飞行记录器\r329:ChaCha20和Poly1305加密算法\r330:发射一列纵队源代码程序\r331:低开销堆分析\r332:传输层安全性(Transport Layer Security,TLS)1.3\r333:动作,一个可伸缩的低延迟垃圾收集器(实验)\r335:反对Nashorn JavaScript引擎\r336:反对Pack200工具和API\rJava12 2019-3-19\n在Java12中,switch可以有返回值 并且使用-\u0026gt;直接\rbreak 可以携带返回值,如果需要 break 返回值,则需每一个 case 后都有返回值或者抛出一个异常\rint num = switch(value) {\rcase 1 -\u0026gt;1;\rcase 2 -\u0026gt;2;\rcase 3,4 -\u0026gt;3;\rcase 5: break 5;\rcase 6 -\u0026gt; {System.out.println(\u0026quot;hello world\u0026quot;);//没有返回则抛出异常}\r}\rJava13 2019-9-17\nJava13中,switch支持如下写法\rint date = switch (day) {\rcase MONDAY, FRIDAY, SUNDAY : yield 6;\rcase TUESDAY : yield 7;\rcase THURSDAY, SATURDAY : yield 8;\rcase WEDNESDAY : yield 9;\rdefault : yield 1; // default条件是必须的\r};\r支持文本块 使用三个\u0026quot;\u0026quot;\u0026quot;\r起始的\u0026quot;\u0026quot;\u0026quot;结尾必须换行\rString text = \u0026quot;\u0026quot;\u0026quot;\rhello world\r! \u0026quot;\u0026quot;\u0026quot;\r文本块是在13中是预览功能,使用前需要先启用\r手动编译:\rjavac --release 13 --enable-preview ...\r手动运行\rjava --enable-preview ...\rJava14 2020-3-17\n改进的switch表达式在14中获得了完全的支持\rinstanceof 支持模式匹配(语言特性 预览特性)\r使用 instanceof 和 instanceof 里的对象不用强转了\rNullPointerException(JVM特性)\r14的这个异常更加详细,精确到某个属性\rRecord(预览功能)\rjava14提供了解决get,set,toString等代码冗余,\rRecord 会提供 equals,hashCode,toString方法的实体,可以重构如下\rpublic record Clazz(int a,double b,String c) {}\r通过 record,可以自动地得到equals,hashCode,toString的实现,还有构造器和 getter 方法\r文本块中加入 \\ 可以不换行\rJava15 2020-9-15\n文本块转正\rZGC垃圾回收器转正\rShenandoah转正\r移除 Nashorn JavaScript Engine(JDK脚本执行引擎)\r在JDK11标记过期,15完全移除\rCharSequence新增isEmpty默认方法\rJava16 2021-3-16\n向量API（孵化）\r提供了jdk.incubator.vector来用于矢量计算\r启用c++ 14 语言特性\r从 Mercurial 迁移到Git\r迁移到 GitHub（将OpenJDK源码的版本控制迁移到github上）\rZGC 并发线程堆栈处理\rUnix-Domain 套接字通道\r为socket channel和server-socket channel api增加Unix-domain(AF_UNIX)套接字支持。\rAlpine Linux Port\rElastic Metaspace\rWindows/AArch64 Port\rForeign Linker API（孵化）\r提供jdk.incubator.foreign来简化native code的调用\r基于值的类的警告\r提供注解 @jdk.internal.ValueBased 来用于标注作为value-based的类\r将原始包装类指定为基于值的类，并弃用它们的构造函数以便删除，并提示新的弃用警告。提供关于在Java平台中任何基于值类的实例上进行同步的警告。\r打包工具\r在JDK 16中转正，从 jdk.incubator.jpackage 转为 jdk.jpackage\r用于打包自包含的Java应用程序\r外部内存访问API（第三次孵化）\r引入一个API，允许Java程序安全有效地访问Java堆之外的外部内存\r为 instanceof 进行模式匹配\r在JDK 16中转正，可以如下使用\rObject o = new String(\u0026quot;\u0026quot;);\rif (o instanceof String str) {\rSystem.out.println(str.concat(\u0026quot;模式匹配\u0026quot;));\r}\rRecords\r在JDK 16中转正\r对内部API进行更多封装，鼓励开发者从使用内部的方法迁移到标准API\rSealed Classes\rJava17(LTS) 2021-9-14 发行说明: https://www.oracle.com/java/technologies/javase/17-relnote-issues.html\nSealed Classes(密封类) 已将密封类添加到Java语言中。密封类和接口限制其他类或接口可以扩展或实现它们。 密封类由JEP360提出，并在JDK15中作为预览特性提供。JEP 397再次提出了这些建议，并进行了改进 Pattern Matching for switch (Preview) 使用开关表达式和语句的模式匹配以及模式语言的扩展来增强Java编程语言。 通过将模式匹配扩展到switch，可以针对多个模式对表达式进行测试，每个模式都有一个特定的操作，因此可以简洁而安全地表达复杂的面向数据的查询。 New macOS Rendering Pipeline(新的MacOS渲染管道) Swing API用于渲染的Java 2D API现在可以使用新的Apple Metal加速渲染API for macOS。 这在默认情况下目前是禁用的，因此渲染仍然使用OpenGL API，虽然Apple不推荐使用这些API，但它们仍然可用并受支持。 要启用Metal，应用程序应通过设置系统属性指定其用途：-Dsun.java2d.metal=true Metal或OpenGL的使用对应用程序是透明的，因为这是内部实现的差异，对JavaAPI没有影响。 金属管道需要macOS 10.14.x或更高版本。在早期版本上设置它的尝试将被忽略。 New API for Accessing Large Icons JDK 17中提供了一种新方法 javax.swing.filechooser.FileSystemView.getSystemIcon（File，int，int） 它可以在可能的情况下访问更高质量的图标。 它在Windows平台上完全实现；但是，在其他平台上的结果可能会有所不同，稍后将进行增强。例如，通过使用以下代码： FileSystemView fsy = FileSystemView.getFileSystemView(); Icon icon = fsv.getSystemIcon(new File(\u0026ldquo;application.exe\u0026rdquo;), 64, 64); JLabel label = new JLabel (icon); 用户可以为“application.exe”文件获取更高质量的图标。 此图标适用于创建可在高DPI环境中更好缩放的标签。 DatagramSocket Can Be Used Directly to Join Multicast Groups 在此版本中，java.net.DatagramSocket已更新，以添加对加入多播组的支持。 它现在定义了joinGroup和leaveGroup方法来加入和离开多播组。 java.net.DatagramSocket的类级API文档已经更新，以解释如何配置普通DatagramSocket并使用它加入和退出多播组。 此更改意味着DatagramSocket API可以用于多播应用程序，而无需使用传统的java.net.MulticastSocket API。 MulticastSocket API与以前一样工作，尽管它的大多数方法都不推荐使用。 有关这一变化的基本原理的更多信息，请参见CSR JDK-8260667。 Add support for UserDefinedFileAttributeView on macOS(在macOS上添加对UserDefinedFileAttributeView的支持) macOS上的文件系统提供程序实现已在此版本中更新，以支持扩展属性。 现在可以使用java.nio.file.attribute.UserDefinedFileAttributeView API获取文件扩展属性的视图。 以前的JDK版本不支持此（可选）视图。 Enhanced Pseudo-Random Number Generators(增强型伪随机数发生器) Provide new interface types and implementations for pseudorandom number generators (PRNGs), including jumpable PRNGs and an additional class of splittable PRNG algorithms (LXM). 为伪随机数生成器（PRNG）提供新的接口类型和实现，包括可跳线PRNG和附加的可拆分PRNG算法（LXM）。 Modernization of Ideal Graph Visualizer(理想图形可视化仪的现代化) Source Details in Error Messages(错误消息中的源详细信息) New Page for \u0026ldquo;New API\u0026rdquo; and Improved \u0026ldquo;Deprecated\u0026rdquo; Page(“新API”的新页面和改进的“弃用”页面) Foreign Function \u0026amp; Memory API (Incubator)(外部函数和内存API（孵化器）) Console Charset API(控制台字符集API) 已更新java.io.Console以定义一个新方法，该方法返回控制台的字符集。 返回的字符集可能不同于从Charset.defaultCharset（）方法返回的字符集。 例如，它返回IBM437，而Charset.defaultCharset（）在windows上返回windows-1252（en-US）。有关更多详细信息，请参阅CSR。 Flight Recorder Event for Deserialization(用于反序列化的飞行记录器事件) Implement Context-Specific Deserialization Filters(实现特定于上下文的反序列化过滤器) 弃用 Applet API 以进行删除 它基本上无关紧要，因为所有 Web 浏览器供应商都已取消对 Java 浏览器插件的支持或宣布了这样做的计划。 Java 9 中的JEP 289先前已弃用 Applet API，但并未将其删除。 弃用安全管理器以进行删除 安全管理器和与其相关的 API 已被弃用，并将在未来版本中删除。 为确保开发人员和用户知道安全管理器已被弃用，如果通过java -Djava.security.manager. 如果通过System::setSecurityManagerAPI动态启用安全管理器，Java 运行时还会在运行时发出警告。无法禁用这些警告。 弃用 Kerberos 中的 3DES 和 RC4 弃用套接字实现工厂机制 static void ServerSocket.setSocketFactory? (SocketImplFactory fac) static void Socket.setSocketImplFactory?(SocketImplFactory fac) static void DatagramSocket.setDatagramSocketImplFactory?(DatagramSocketImplFactory fac) 以下用于设置系统范围套接字实现工厂的静态方法已被弃用： 弃用 JVM TI 堆函数 1.0 Java18 2022-03-22 发行说明：https://www.oracle.com/java/technologies/javase/18-relnote-issues.html\n[用于核心库改进和更新] 默认编码UTF-8(java.nio.charsets) 从 JDK 18 开始，UTF-8 是 Java SE API 的默认字符集. 依赖于默认字符集的 API 现在在所有 JDK 实现中表现一致，并且独立于用户的操作系统、语言环境和配置\n简单的 Web 服务器(java.net) jwebserver, 一个用于启动最小静态 Web 服务器的命令行工具, 已经被引入. 该工具和随附的 API 位于 jdk.httpserver 模块的 com.sun.net.httpserver 包中，旨在用于原型设计、临时编码和测试，尤其是在教育环境中。\n使用方法句柄重新实现核心反射(java.lang:reflect) 使用方法句柄重新实现核心反射。依赖于现有实现的高度实现特定和未记录方面的代码可能会受到影响。可能出现的问题包括：\n检查内部生成的反射类（例如 的子类MagicAccessorImpl）的代码不再有效，必须更新。\r尝试破坏封装并将 的私有 finalmodifiers字段Method的值更改为Field与Constructor基础成员不同的类的代码可能会导致运行时错误。必须更新此类代码。\r为了减轻这种兼容性风险，您可以启用旧实现作为解决方法\n方法是使用 -Djdk.reflect.useDirectMethodHandle=false.\n我们将在未来的版本中删除旧的核心反射实现。-Djdk.reflect.useDirectMethodHandle=false解决方法将在此时停止工作。\n互联网地址解析 SPI(java.net) 为主机名和地址解析引入服务提供者接口 (SPI)，以便 java.net.InetAddress 可以使用平台内置解析器以外的解析器。这个新的 SPI 允许替换操作系统的本地解析器，该解析器通常配置为使用本地主机文件和域名系统 (DNS) 的组合。\n[用于工具改进] Java API文档中的代码片段(javadoc) 为 JavaDoc 的标准 Doclet 添加了一个 @snippet 标记，以简化在 API 文档中包含示例源代码。 [用于预览和孵化器] Vector API（第三个孵化器）(核心库) 引入一个 API 来表达向量计算，该计算可以在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能。\n外部函数和内存 API（第二个孵化器）(核心库) 引入一个 API，Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过有效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），API 使 Java 程序能够调用本机库并处理本机数据，而不会出现脆弱性和危险。 JNI。\n[规范/语言] switch 的模式匹配（第二次预览） 通过对 switch 表达式和语句的模式匹配以及对模式语言的扩展来增强 Java 编程语言。将模式匹配扩展到 switch 允许针对多个模式测试表达式，每个模式都有特定的操作，因此可以简洁安全地表达复杂的面向数据的查询。 Java19 2022-09-20\n发行说明：https://www.oracle.com/java/technologies/javase/19-relnote-issues.html\n[主要新功能] [并发模型更新预览] JEP 425虚拟线程（预览） 将虚拟线程引入Java平台。虚拟线程是轻量级线程，可以大大减少编写、维护和观察高吞吐量并发应用程序的工作量。这是一个预览API。\nJEP 428结构化并发（孵化器） 通过引入结构化并发API简化多线程编程。结构化并发将在不同线程中运行的多个任务视为单个工作单元，从而简化错误处理和消除，提高可靠性，增强可观察性。这是一个孵化API。\n[语言功能预览] JEP 405 Recoord模式（预览） 使用Record模式增强Java编程语言，以解构记录值。可以嵌套Record模式和类型模式，以实现强大、声明性和可组合的数据导航和处理形式。这是一个预览语言功能。\nJEP 427 switch模式匹配（第三次预览） 使用switch表达式和语句的模式匹配增强Java编程语言。将模式匹配扩展到switch允许根据多个模式对表达式进行测试，每个模式都有一个特定的操作，从而可以简洁、安全地表达复杂的面向数据的查询。这是一个预览语言功能。\n[Libraries 预览/孵化器] JEP 424外部函数和内存API（预览） 引入一个API，通过该API，Java程序可以与Java运行时之外的代码和数据进行互操作。通过有效地调用外部函数（即JVM外部的代码），并通过安全地访问外部内存（即不由JVM管理的内存），API使Java程序能够调用本机库并处理本机数据，而不会出现JNI的脆弱性和危险性。这是一个预览API。\nJEP 426 Vector API（第四培养箱） 引入一个API来表示向量计算，该API在运行时可靠地编译为支持的CPU架构上的最优向量指令，从而实现优于等效标量计算的性能。\n[新功能]-增强功能 [core-libs/java.lang] 支持Unicode 14.0 java.lang.Character类支持14.0级的Unicode字符数据库，该数据库增加了838个字符，总共144697个字符。这些新增内容包括5个新脚本，总共159个脚本，以及37个新表情符号字符。\n新的System.properties, System.out和System.err 这些系统属性的值是标准输出和标准错误流（system.out和system.err）使用的编码。\n[core-libs/java.net] 对Java GSS/Kerberos的HTTPS通道绑定支持 [core-libs/java.time] 增加 Date-Time 格式 java.time.format中引入了 java.time.format.DateTimeFormatter/DateTimeFormatterBuilder 类 [core-libs/java.util:collections] 创建预分配哈希映射和哈希集的新方法 引入了新的静态工厂方法，允许创建预先分配的HashMap和相关实例，以容纳预期数量的映射或元素。 [security-libs/java.security] Windows KeyStore更新为包括对本地计算机位置的访问 在X509Certificate:：getSubjectAlternativeNames和X509Certificate：：getIssuerAlternationalNames中分解序列 [security-libs/javax.net.ssl] TLS签名方案 [security-libs/jdk.security] 向jarsigner添加-providerPath选项 [hotspot/compiler] 支持Linux/AArch64上的PAC-RET保护 [hotspot/runtime] CDS档案的自动生成 …… [删除的功能和选项] 删除诊断标志GCParallelVerificationEnabled 删除SSLSocketImpl中的终结器实现 删除Subject:：current和Subject::callAs API的替代线程本地实现 [不推荐的功能和选项] java.lang.ThreadGroup已降级 Locale 类构造函数的弃用 PSSParameterSpec（int）构造函数和DEFAULT静态常量已弃用 OAEPParameterSpec类DEFAULT静态常量已弃用 Java20 2023-03-21\n发行说明：https://jdk.java.net/20/release-notes\n除了数千次性能、稳定性和安全性更新外，Java 20还提供了数十项新功能和增强功能，其中七项增强功能的重要性足以保证他们自己的JDK增强建议（JEP），包括四项预览功能和三项孵化器功能。\n[新功能] [TLS Key Exchange Named Groups] [security-libs/javax.net.ssl] 新的API javax.net.ssl.SSLParameters.getNamedGroups() 和 javax.net.ssl.SSLParameters.setNamedGroups() [如果检测到错误的java.io.tmpdir设置，则打印标准错误警告] [core-libs/java.lang] [支持Unicode 15.0] [core-libs/java.lang] [Add GarbageCollectorMXBean for Remark and Cleanup Pause Time in G1] [hotspot/gc] 一个名为“G1并发GC”的新GarbageCollectorMXBean已添加到G1垃圾收集器中。 [新JFR事件：jdk.InitialSecurityProperty、jdk.SecurityProviderService] [Provide Poly1305 Intrinsic on x86_64 platforms with AVX512 instructions] [在x86_64和aarch64平台上提供ChaCha20 Intrinsics] [新的“jmod\u0026ndash;compression”命令行选项]\njmod 工具中添加了一个新的\u0026ndash;compression命令行选项，用于在创建jmod归档时指定压缩级别。可接受的值是zip-[0-9]，其中zip-0不提供压缩，而zip-9提供最佳压缩。默认为zip-6。\n[Javac警告复合赋值中的类型转换可能有误] javac中添加了新的lint选项有损转换，以警告可能有损转换的复合赋值中的类型转换。如果复合赋值的右侧操作数的类型与变量的类型不兼容，则隐含强制转换，并且可能发生有损转换。\n可以使用 @SuppressWarnings(\u0026ldquo;lossy-conversions\u0026rdquo;) 来抑制新的警告。\n[删除的功能和选项] [Thread.shupend()、Thread.resume()、Thread.stop()更改为抛出UnsupportedOperationException异常]\n[G1并发细化线程的控制已被完全取代]\n[删除对javac-source/-target/-版本7的支持]\n[弃用的功能和选项] [java.net.URL构造函数已弃用]\n[弃用用于删除的JMX Management Applets]\n[其他注意事项] [HTTP响应的读取流在中断时抛出IOException]\n[HttpClient默认保持活动时间为30秒]\n[添加了HTTP/2的空闲连接超时]\n"},{"id":254,"href":"/Tech/3Java/Java-Version/Java8-%E6%96%B0%E6%8F%90%E4%BE%9B%E6%97%B6%E9%97%B4API/","title":"Java8 新提供时间 API","parent":"Java Version","content":" Java8新提供时间API Java8新的日期和时间API的设计原则 Java8中新的日期和时间是基于JSR-310实现的,参考了绝大多数的joda-timeApi。\n不变性：新的日期/时间API中，所有的类都是不可变的，实现了线程安全； 关注点分离：新的API中将人可读的日期时间和机器时间(unix timestamp)明确分离，它为日期(Date)、时间(Time)、日期时间(DateTime)、时间戳(unix timestamp)以及时区定义了不同的类； 清晰明了：新的API中，方法都被明确定义用以完成相同的行为，例如，想要拿到当前实例，可以用new()方法，在所有的类方法中都实现了 formate()和parse()方法，不再是之前用单独一个类去解决，而且新的API中所有的类都使用了工厂模式和策略模式； 实用性：所有新的日期和时间API类都实现了一系列方法用以完成通用的需求，例如：加、减、格式化、解析、从日期或时间中提取单独部分等等； 可扩展性：新的日期/时间API是基于国际标准ISO 8601,其实我们也是可以将其用于非IOS的日历上 Java8中的日期和时间API包含以下包 java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是该包的一部分，例如：LocalDate、LocalTime、LocalDateTime、Instant、Period、Duration等类。这些类都是线程安全的 java.time.chrono包：这个包为非ISO的日历标准定义了一些泛化的API，我们可以拓展AbstractChronology来创建自己的日历标准 java.time.formate包：这个包包含能够格式化和解析日期时间对象的类，在绝大数情况下，我们不应该直接使用它，因为java.time包中相应的类已经提供了格式化和解析的方法 java.time.temporal包：这个包包含一些时态对象，可以用其找出关于某个日期/时间对象的某个特定日期或时间，比如说找到某个月的第一天或最后一天，可以根据withXXX的格式进行区分 java.time.zone包：这个包支持不同的时区以及相关规则的类 时间相关类 介绍 LocalDate 时间处理类，最高精确到天，没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime 时间处理类，最高精确到分秒，没有时区的日期, LocalDate是不可变并且线程安全的 LocalDateTime 时间处理类，最高精确到纳秒, LocalDate是不可变并且线程安全的 DateTimeFormatter 时间格式化 ZoneId 时区设置类 Instant 用来表示时间线上的一个点（瞬时） Clock 时钟,用于访问当前时刻、日期、时间，用到时区 Duration 用秒和纳秒表示时间的数量（长短），用于计算两个日期的“时间”间隔 Period 用于计算两个“日期”间隔 获取当前日期、时间 //now LocalDateTime now = LocalDateTime.now(); System.out.println(now); //2020-10-23T19:29:08.064 //localDate LocalDate localDate = now.toLocalDate(); System.out.println(\u0026#34;localDate:\u0026#34;+localDate);//2020-10-23 //localTime LocalTime localTime = now.toLocalTime(); System.out.println(\u0026#34;localTime:\u0026#34; + localTime); //19:29:08.064 //year int year = now.getYear(); System.out.println(\u0026#34;year:\u0026#34; + year); //2020 获取时间戳 Instant timestamp = Instant.now(); 格式化时间、指定时间日期创建对应的对象 时间格式化字符串 计算两个时间点的间隔 日历计算 "},{"id":255,"href":"/Tech/3Java/Java-Version/Java9-%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/","title":"Java9 版本新特性","parent":"Java Version","content":"Java9 版本新特性 发行说明:https://openjdk.org/projects/jdk9/\n特性总览 以下是 Java 9 中的引入的部分新特性。关于 Java 9 新特性更详细的介绍可参考这里。\nREPL（JShell） 不可变集合的工厂方法 模块系统 接口支持私有化 钻石操作符升级 Optional 改进 Stream API 改进 反应式流（Reactive Streams） 进程 API 升级的 Try-With-Resources HTTP / 2 多版本兼容 Jar 包 其他 改进应用安全性能 统一 JVM 日志 G1 设为默认垃圾回收器 String 底层存储结构更改 CompletableFuture API 改进 I/O 流新特性 JavaScript 引擎 Nashorn 改进 标识符增加限制 改进的 Javadoc 改进的 @Deprectaed 注解 多分辨率图像 API 变量句柄 改进方法句柄（Method Handle） 提前编译 AOT "},{"id":256,"href":"/Tech/3Java/Java-Version/Java9-%E7%89%B9%E6%80%A7-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%B5%81Reactive-Stream/","title":"Java9 特性 响应式流( Reactive Stream)","parent":"Java Version","content":" Java9 特性-响应式流(Reactive Stream) 转自：Java9 特性-响应式流(Reactive Stream)\n作者：蜜糖的代码注释\n链接：https://www.jianshu.com/p/eddea056e38a\n来源：简书\n什么是流 形象的比喻来说就是如同水一样绵绵不绝的数据形式。而抽象点来说，是有一个生产者（source）产生，由一个或者多个消费者（sink）消费的数据元素（item）序列。那从这个抽象的描述就可以看出，使用流来承担数据交互的模式就是咱们经常说的生产者/消费者模型，而这种模型也可以称之为发布者/订阅者模型（后文将使用这个名字，因为JDK中使用的是这个名字）。\n对于流数据来说，一般有两种的数据流转方式：\n拉（pull）数据模式：订阅者向发布者索要数据。 推（push）数据模式：发布者向订阅者推送数据（push）。 这两种模式都是描述的单次信息传递的方式。如果发布者产生信息的速度和订阅者消费信息的速度一致的话，那这两种方法都将是十分有效的数据流转方式。\n流有什么问题 流的问题在于当两端的速度不匹配的时候（考虑一下各种mq主要处理的问题削峰平谷）。而速度的不匹配自然存在以下两种情况：\n订阅者消费速度快 这种情况的时候会出现订阅者有处理能力了，但是订阅者无信息可以处理的情况。如果这种时候是同步的调用模式，则订阅者将会阻塞，直到有新的信息可以进行处理。而如果这时候是异步的信息处理模式，则订阅者可以在无消息处理的时候挂起，直接切换到其他的任务处理中（对于多核CPU的多线程来说）。也就是说，对于这种情况，比较理想的是异步推模式。\n发布者发布速度快 当发布者发布速度快的时候，会发生订阅者来不及处理数据的情况。如果是同步的情况下发布者会一直阻塞，而如果是异步模式则对于订阅者来说有两种处理方式（可以类比一下线程池设计）可以处理:\n损失数据：丢弃数据（在有限的队列缓存已经满了的情况下） 不损失数据：加入队列缓存数据（订阅者需要有拥有无限的缓冲队列暂存数据，以确保不会溢出） 而还有另一种需要发布者加入的处理方式叫做背压（backpressure）。背压的实现方式是：由订阅者发出信号，让发布者降低信息的发布速度，从而让信息速度之间匹配。背压的优点是同样可以处理信息流速不一致问题。而更有意思的是，这时候信息的处理策略可以由发布者来选择：\n损失数据：丢弃数据（在有限的队列缓存已经满了的情况下） 不损失数据：加入队列缓存数据（订阅者需要有拥有无限的缓冲队列暂存数据，以确保不会溢出） 没错，这两种情况是和订阅者一致的，不过选择权则由订阅者变成了发布者。\n也就是说，在发布者发布速度快的时候，要么发布者直接同步阻塞，要么可以先根据消息的主要关心方（是发布者还是订阅者）来确定是否使用背压，然后再根据数据的类型判断是否接受数据丢弃（不丢弃可能会导致系统崩溃）。往往我们的发布者可以由上层的mq或者程序的应答机制保护消息的可用性。\n那么结论是什么，我们需要异步非阻塞(订阅者消费快)、以及背压（发布者发布快）。\n什么是响应式流 Reactive Streams 是一项非阻塞背压的异步流处理标准的倡议，当然，如果我这个翻译看的不清楚的话就还是看原文吧（http://www.reactive-streams.org/）。\nReactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.\n响应式流（Reactive Streams）概念被提出是在2013年，旨在处理上一小节中由于流速问题而产生的几种问题：订阅者订阅者的阻塞、由订阅者（数据下游）来选择是依赖无限队列（数据不丢）或直接丢弃数据。\n而对于一项标准而言，它的目是自然是用更少的协议来描述交互。而响应式流的模型也是十分简单:\n订阅者异步的向发布者请求N个元素。 发布者一步的向订阅者发送M（0\u0026lt;M\u0026lt;=N）个元素。 基于这个模型，响应式流可以做到pull模型和push模型流处理机制之间动态切换。当订阅者较慢时，发送者没有新数量的请求则发布者进入等待请求信息的状态，相当于pull模型；当订阅者更快时，相当于发布者没有新的信息，订阅者进入到等待消息发送的状态相当于push模型。\nJava中的响应式流 对于响应式流，在2015年的时候确定了关于其Java API，具体的详情也也可以参考上面的链接。其中定义了4个API，具体为：\nPublisher Subscriber Subscription Processor\u0026lt;T,R\u0026gt; 对他们的定义为:\nPublisher(发布者) 是一个假定上游会产生无限数据的信息发布者。他们会向有发送请求的订阅者推送元素\nSubscriber(订阅者) 订阅者会从发布者那里领取令牌，然后根据令牌向发布者发送“获取请求”。同时当发布者部分准备好元素的时候，会通过令牌对订阅者进行调用，进行数据消费。\nSubscription(令牌) 发布者和订阅者通过令牌来进行信息通信的约定。主要有：开始订阅、信息获取、信息推送、异常、结束、取消订阅。\nProcessor(处理器) 可以通过处理器连接发布者、订阅者以及其他处理器。Processor本身同时继承了Publisher与Subscriber接口，所以可以对元素进行处理转发。主要用于让数据从T转换为R。同时，由于Processor本身也可以接入Processor，所以Processor可以组成链来对数据进行处理。\n一次完整的调用流程大概可以描述为：\n订阅者向发布者发送订阅请求。 发布者根据订阅请求生成令牌发送给订阅者。 订阅者根据令牌向发布者发送请求N个数据。 发送者根据订阅者的请求数量返回M(M\u0026lt;=N)个数据 重复3，4 数据发送完毕后由发布者发送给订阅者结束信号 而Java API中的接口如下所示，其中所有的方法都是void，因为所有的方法都是异步执行的。\npublic interface Publisher\u0026lt;T\u0026gt; { //用于1.中订阅请求 public void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { //用于2.中回调发送令牌 public void onSubscribe(Subscription s); //用于3.用于接受4中发送过来的数据 public void onNext(T t); //用于3，4，5接收中间异常了之后的调用 public void onError(Throwable t); //用于6.中结束信号的回调 public void onComplete(); } public interface Subscription { //用于3.的发送请求N个数据 public void request(long n); //用于3，4，5订阅者异步的向 public void cancel(); } public interface Processor\u0026lt;T,R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } JDK中的响应式流 Java API中的流程使用方式看起来比较简单，但API背后的具体实现由于是全异步交互以及涉及具体背压处理而很困难。而JDK9中为用户提供了 Publisher 接口的简单实现，让开发人员可以基于此来扩展出自己的实际需求。\nJDK 9中的响应式流功能提供在 java.util.concurrent 包下，全响应式流的 API 接口被封装到 Flow 接口中，其中包括需要使用的接口以及静态方法，关于上一小节中接口方法的详细描述也可以参见该接口上的方法描述。其中的静态接口为:\nFlow.Processor\u0026lt;T,R\u0026gt;\rFlow.Publisher\u0026lt;T\u0026gt;\rFlow.Subscriber\u0026lt;T\u0026gt;\rFlow.Subscription 除去上一小节说的4个接口外，Flow中还包含了一个默认方法defaultBufferSize()，用于返回默认的令牌中的缓冲区大小，而默认的值为： DEFAULT_BUFFER_SIZE = 256。\n除去 Flow 外，其中还有一个刚刚说到的 Publisher 的简单实现类SubmissionPublisher。该接口在实现了 publisher 之外还实现了 AutoCloseable 接口，所以可以直接用 try 块来进行资源的管理。\n尽管JDK 9中没有提供 Subscriber 的简单实现，但是在 SubmissionPublisher 中提供了一个 consume(Consumer\u0026lt;? super T\u0026gt; consumer) 方法，用于让开发人员可以直接消费消息发布者的所有元素。实际上是在内部实现了简单的 Subscriber 为 ConsumerSubscriber，但是并不是 public 的，所以不能直接使用\n简单的例子 根据JDK 9中提供的SubmissionPublisher\u0026lt;T\u0026gt;咱们来写一个小例子。\npublic static void main(String[] args) { // 用于承接返回值的任务 CompletableFuture\u0026lt;Void\u0026gt; task; // try-with-resource来控制资源 try (SubmissionPublisher\u0026lt;Integer\u0026gt; publisher = new SubmissionPublisher\u0026lt;\u0026gt;()) { System.out.println(\u0026#34;默认缓冲容量: \u0026#34; + publisher.getMaxBufferCapacity()); // 传入打印方法来处理元素 task = publisher.consume(System.out::println); // 打印数字，调用发布者进行信息处理 IntStream.range(1, 6) .forEach(publisher::submit); } if (task != null) { try { // 当所有订阅者处理完毕后调用 task.get(); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } 在这个例子里面进行了以下几件事。\n声明一个CompletableFuture用于捕获后续的处理事件。 开启资源用于进行流消息订阅 设置流的订阅方法（订阅者） 进行发布者的信息发送 阻塞主方法等待处理完毕后结束 其中 pub.getMaxBufferCapacity() 会打印默认的缓存空间256。在调用 publisher.consume 的时候，是奖传入的 Consumer 在内部封装成一个 Subscribr 的简单实现类，用于订阅信息的发送，实时上后续数据的订阅者就是在这步创建的。\n当 publisher 进行调用的时候，调用 submit 发送数据，publisher 有两个方法用于发送数据，一个是 submit，一个是 offer。两个方法下面实际都是调用的 doOffer 方法，所以，offer 方法提供了置顶延迟时间后丢弃的策略，而 submit 是 offer 的简单实现，是一致阻塞不丢弃。\n最后 不得不说响应式流是 java 中响应式编程的基础，而 JDK 9 中也提供了 Reactive Streams 的“简单”实现。之所示简单是打引号的是因为实际上还有点绕的，有兴趣的同学可以追一下 SubmissionPublisher 的实现，有一些思想的经典实现，比如用整数中的 7 位来作为状态机。在下一篇中我们再聊一下 JDK 9 中的数据交互顺序。\n"},{"id":257,"href":"/Tech/3Java/Java-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/","title":"Java 分布式唯一 Id生成方案","parent":"3、Java","content":" 分布式唯一ID生成方案 整个系统ID唯一 ID是数字类型，而且是趋势递增的 ID简短，查询效率快\n1、UUID 优点：\n代码实现简单。 本机生成，没有性能问题 因为是全球唯一的ID，所以迁移数据容易 缺点：\n每次生成的ID是无序的，无法保证趋势递增 UUID的字符串存储，查询效率慢 存储空间大 ID本事无业务含义，不可读 应用场景：\n类似生成token令牌的场景 不适用一些要求有趋势递增的ID场景 2、MySQL主键自增 这个方案就是利用了MySQL的主键自增auto_increment，默认每次ID加1。\n优点：\n数字化，id递增 查询效率高 具有一定的业务可读 缺点：\n存在单点问题，如果mysql挂了，就没法生成iD了 数据库压力大，高并发抗不住 3、MySQL多实例主键自增 这个方案就是解决mysql的单点问题，在auto_increment基本上面，设置step步长 每台的初始值分别为1,2,3\u0026hellip;N，步长为N（这个案例步长为4）\n优点：\n解决了单点问题 缺点：\n一旦把步长定好后，就无法扩容；而且单个数据库的压力大，数据库自身性能无法满足高并发 应用场景：\n数据不需要扩容的场景 4、雪花 snowflake 算法 这个算法网上介绍了很多。雪花算法生成64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 优点：\n此方案每秒能够产生409.6万个ID，性能快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点：\n依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 -在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。 5、Redis生成方案 利用redis的incr原子性操作自增，一般算法为：\n年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增\n优点：\n有序递增，可读性强 缺点：\n占用带宽，每次要向redis进行请求 性能还可以，如果对性能要求不是太高的话，这个方案基本符合要求。\n但不完全符合希望id从 1 开始趋势递增。（当然算法可以调整为 就一个 redis自增，不需要什么年份，多少天等）。\n6、小结 以上介绍了常见的几种分布式ID生成方案。一线大厂的分布式ID方案绝没有这个简单，他们对高并发，高可用的要求很高。\n如Redis方案中，每次都要去Redis去请求，有网络请求耗时，并发强依赖了Redis。这个设计是有风险的，一旦Redis挂了，整个系统不可用。\n而且一线大厂也会考虑到ID安全性的问题，如：Redis方案中，用户是可以预测下一个ID号是多少，因为算法是递增的。\n这样的话竞争对手第一天中午12点下个订单，就可以看到平台的订单ID是多少，第二天中午12点再下一单，又平台订单ID到多少。这样就可以猜到平台1天能产生多少订单了，这个是绝对不允许的，公司绝密啊。\n"},{"id":258,"href":"/Tech/3Java/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"Java 动态代理","parent":"3、Java","content":" Java 动态代理（Dynamic Proxy） 一、什么是代理？ 代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。\n简单结构示意图： 为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。\n二、Java 动态代理类 Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：\n(1)Interface InvocationHandler：该接口中仅定义了一个方法： public object invoke(Object obj,Method method, Object[] args) 在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，args为该方法的参数数组。这个抽象方法在代理类中动态实现。\n(2)Proxy：该类即为动态代理类，其中主要包含以下内容： protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。\rstatic Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。\rstatic Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类（DynamicProxy）可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法) 所谓代理类 DynamicProxy 是这样一种class：它是在运行时生成的 class，在生成它时你必须提供一组 interface 给它，然后该 class 就宣称它实现了这些 interface。你当然可以把该 class 的实例当作这些 interface 中的任何一个来用。当然，这 DynamicProxy 其实就是一个 Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个 handler ，由它接管实际的工作。\n在使用动态代理类时，我们必须实现InvocationHandler接口\n通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。\n动态代理步骤： 创建一个实现接口InvocationHandler的类，它必须实现invoke方法 创建被代理的类以及接口 通过Proxy的静态方法 newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理 通过代理调用方法 三、JDK的动态代理怎么使用？ 1、需要动态代理的接口： /**\r* 需要动态代理的接口\r*/\rpublic interface Subject\r{\r/**\r* 你好\r*\r* @param name\r* @return\r*/\rpublic String SayHello(String name);\r/**\r* 再见\r*\r* @return\r*/\rpublic String SayGoodBye();\r} 2、需要代理的实际对象： /**\r* 实际对象\r*/\rpublic class RealSubject implements Subject\r{\r/**\r* 你好\r*\r* @param name\r* @return\r*/\rpublic String SayHello(String name)\r{\rreturn \u0026#34;hello \u0026#34; + name;\r}\r/**\r* 再见\r*\r* @return\r*/\rpublic String SayGoodBye()\r{\rreturn \u0026#34; good bye \u0026#34;;\r}\r} 3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊） /**\r* 调用处理器实现类\r* 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象\r*/\rpublic class InvocationHandlerImpl implements InvocationHandler\r{\r/**\r* 这个就是我们要代理的真实对象\r*/\rprivate Object subject;\r/**\r* 构造方法，给我们要代理的真实对象赋初值\r*\r* @param subject\r*/\rpublic InvocationHandlerImpl(Object subject)\r{\rthis.subject = subject;\r}\r/**\r* 该方法负责集中处理动态代理类上的所有方法调用。\r* 调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行\r*\r* @param proxy 代理类实例\r* @param method 被调用的方法对象\r* @param args 调用参数\r* @return\r* @throws Throwable\r*/\rpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable\r{\r//在代理真实对象前我们可以添加一些自己的操作\rSystem.out.println(\u0026#34;在调用之前，我要干点啥呢？\u0026#34;);\rSystem.out.println(\u0026#34;Method:\u0026#34; + method);\r//当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用\rObject returnValue = method.invoke(subject, args);\r//在代理真实对象后我们也可以添加一些自己的操作\rSystem.out.println(\u0026#34;在调用之后，我要干点啥呢？\u0026#34;);\rreturn returnValue;\r}\r} 4、测试 /**\r* 动态代理演示\r*/\rpublic class DynamicProxyDemonstration\r{\rpublic static void main(String[] args)\r{\r//代理的真实对象\rSubject realSubject = new RealSubject();\r/**\r* InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发\r* 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用.\r* 即：要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法\r*/\rInvocationHandler handler = new InvocationHandlerImpl(realSubject);\rClassLoader loader = realSubject.getClass().getClassLoader();\rClass[] interfaces = realSubject.getClass().getInterfaces();\r/**\r* 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例\r*/\rSubject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);\rSystem.out.println(\u0026#34;动态代理对象的类型：\u0026#34;+subject.getClass().getName());\rString hello = subject.SayHello(\u0026#34;jiankunking\u0026#34;);\rSystem.out.println(hello);\r// String goodbye = subject.SayGoodBye();\r// System.out.println(goodbye);\r}\r} 四、动态代理怎么实现的？ 五、结论 因为JDK生成的最终真正的代理类，它继承自Proxy并实现了我们定义的Subject接口， 在实现Subject接口方法的内部，通过反射调用了InvocationHandlerImpl的invoke方法。\n通过分析代码可以看出Java 动态代理，具体有如下四步骤：\n通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 常用的代理方式可以粗分为：静态代理和动态代理。\n静态代理的实现比较简单：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加前拦截，后拦截等所需的业务功能。\n自己手动写一个类并实现接口实在太麻烦了。仔细一想，我们其实想要的并不是代理类，而是代理对象！那么，能否让JVM根据接口自动生成代理对象呢？\n比如，有没有一个方法，我传入接口，它就给我自动返回代理对象呢？\n需求：在项目现有所有类的方法前后打印日志。\n你如何在不修改已有代码的前提下，完成这个需求？\n静态代理\n具体做法如下：\n为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有）\n在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，代理对象 = 增强代码 + 目标对象（原对象），有了代理对象后，就不用原对象了\n静态代理的缺陷\n程序员要手动为每一个目标类，编写对应的代理类。如果当前系统已经有成百上千个类，工作量太大了。所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？\n接口创建对象的可行性分析\n复习对象的创建过程\n首先，在很多初学者的印象中，类和对象的关系是这样的： 虽然知道源代码经过javac命令编译后会在磁盘中得到字节码文件（.class文件），也知道java命令会启动JVM将字节码文件加载进内存，但也仅仅止步于此了。至于从字节码文件加载进内存到堆中产生对象，期间具体发生了什么，他们并不清楚。\n所谓“万物皆对象”，字节码文件也难逃“被对象”的命运。它被加载进内存后，JVM为其创建了一个对象，以后所有该类的实例，皆以它为模板。这个对象叫Class对象，它是Class类的实例。\n大家想想，Class类是用来描述所有类的，比如Person类，Student类\u0026hellip;那我如何通过Class类创建Person类的Class对象呢？这样吗：\nClass clazz = new Class(); 好像不对吧，我说这是Student类的Class对象也行啊。有点晕了\u0026hellip;\n其实，程序员是无法自己new一个Class对象的，它仅由JVM创建。\nClass类的构造器是private的，杜绝了外界通过new创建Class对象的可能。当程序需要某个类时，JVM自己会调用这个构造器，并传入ClassLoader（类加载器），让它去加载字节码文件到内存，然后JVM为其创建对应的Class对象 为了方便区分，Class对象的表示法为：Class，Class 所以借此机会，我们不妨换种方式看待类和对象：\n也就是说，要得到一个类的实例，关键是先得到该类的Class对象！只不过new这个关键字实在太方便，为我们隐藏了底层很多细节，我在刚开始学习Java时甚至没意识到Class对象的存在。\n接口Class和类Class的区别\n来分析一下接口Class和类Class的区别。以Calculator接口的Class对象和CalculatorImpl实现类的Class对象为例：\npublic class ProxyTest {\rpublic static void main(String[] args) {\r/*Calculator接口的Class对象\r得到Class对象的三种方式：1.Class.forName(xxx) 2.xxx.class 3.xxx.getClass()\r注意，这并不是我们new了一个Class对象，而是让虚拟机加载并创建Class对象 */\rClass\u0026lt;Calculator\u0026gt; calculatorClazz = Calculator.class;\r//Calculator接口的构造器信息\rConstructor[] calculatorClazzConstructors = calculatorClazz.getConstructors();\r//Calculator接口的方法信息\rMethod[] calculatorClazzMethods = calculatorClazz.getMethods();\r//打印\rSystem.out.println(\u0026#34;------接口Class的构造器信息------\u0026#34;);\rprintClassInfo(calculatorClazzConstructors);\rSystem.out.println(\u0026#34;------接口Class的方法信息------\u0026#34;);\rprintClassInfo(calculatorClazzMethods);\r//Calculator实现类的Class对象\rClass\u0026lt;CalculatorImpl\u0026gt; calculatorImplClazz = CalculatorImpl.class;\r//Calculator实现类的构造器信息\rConstructor\u0026lt;?\u0026gt;[] calculatorImplClazzConstructors = calculatorImplClazz.getConstructors();\r//Calculator实现类的方法信息\rMethod[] calculatorImplClazzMethods = calculatorImplClazz.getMethods();\r//打印\rSystem.out.println(\u0026#34;------实现类Class的构造器信息------\u0026#34;);\rprintClassInfo(calculatorImplClazzConstructors);\rSystem.out.println(\u0026#34;------实现类Class的方法信息------\u0026#34;);\rprintClassInfo(calculatorImplClazzMethods);\r}\rpublic static void printClassInfo(Executable[] targets){\rfor (Executable target : targets) {\r// 构造器/方法名称\rString name = target.getName();\rStringBuilder sBuilder = new StringBuilder(name);\r// 拼接左括号\rsBuilder.append(\u0026#39;(\u0026#39;);\rClass[] clazzParams = target.getParameterTypes();\r// 拼接参数\rfor(Class clazzParam : clazzParams){\rsBuilder.append(clazzParam.getName()).append(\u0026#39;,\u0026#39;);\r}\r//删除最后一个参数的逗号\rif(clazzParams!=null \u0026amp;\u0026amp; clazzParams.length != 0) {\rsBuilder.deleteCharAt(sBuilder.length()-1);\r}\r//拼接右括号\rsBuilder.append(\u0026#39;)\u0026#39;);\r//打印 构造器/方法\rSystem.out.println(sBuilder.toString());\r}\r}\r} 接口Class对象没有构造方法，所以Calculator接口不能直接new对象 实现类Class对象有构造方法，所以CalculatorImpl实现类可以new对象 接口Class对象有两个方法add()、subtract() 实现类Class对象除了add()、subtract()，还有从Object继承的方法 也就是说，接口和实现类的 Class 信息除了构造器，基本相似。\n既然我们希望通过接口创建实例，就无法避开下面两个问题：\n接口方法体缺失问题 首先，接口的Class对象已经得到，它描述了方法信息。\n但它没方法体。\n没关系，反正代理对象的方法是个空壳，只要调用目标对象的方法即可。\nJVM可以在创建代理对象时，随便糊弄一个空的方法体，反正后期我们会想办法把目标对象塞进去调用。\n所以这个问题，勉强算是解决。\n动态代理\njava.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类的支持。Proxy后面会用到InvocationHandler，因此我打算以Proxy为切入点。首先，再次明确我们的思路：\nProxy类有一个静态方法:Proxy.getProxyClass()：返回代理类的Class对象。\n也就说，只要传入目标类实现的接口的Class对象，getProxyClass()方法即可返回代理Class对象，而不用实际编写代理类。这相当于什么概念？\npublic class ProxyTest {\rpublic static void main(String[] args) {\r/*\r* 参数1：Calculator的类加载器（当初把Calculator加载进内存的类加载器）\r* 参数2：代理对象需要和目标对象实现相同接口Calculator\r* */\rClass calculatorProxyClazz = Proxy.getProxyClass(Calculator.class.getClassLoader(), Calculator.class);\r//以Calculator实现类的Class对象作对比，看看代理Class是什么类型\rSystem.out.println(CalculatorImpl.class.getName());\rSystem.out.println(calculatorProxyClazz.getName());\r//打印代理Class对象的构造器\rConstructor[] constructors = calculatorProxyClazz.getConstructors();\rSystem.out.println(\u0026#34;----构造器----\u0026#34;);\rprintClassInfo(constructors);\r//打印代理Class对象的方法\rMethod[] methods = calculatorProxyClazz.getMethods();\rSystem.out.println(\u0026#34;----方法----\u0026#34;);\rprintClassInfo(methods);\r}\rpublic static void printClassInfo(Executable[] targets) {\rfor (Executable target : targets) {\r// 构造器/方法名称\rString name = target.getName();\rStringBuilder sBuilder = new StringBuilder(name);\r// 拼接左括号\rsBuilder.append(\u0026#39;(\u0026#39;);\rClass[] clazzParams = target.getParameterTypes();\r// 拼接参数\rfor (Class clazzParam : clazzParams) {\rsBuilder.append(clazzParam.getName()).append(\u0026#39;,\u0026#39;);\r}\r//删除最后一个参数的逗号\rif (clazzParams != null \u0026amp;\u0026amp; clazzParams.length != 0) {\rsBuilder.deleteCharAt(sBuilder.length() - 1);\r}\r//拼接右括号\rsBuilder.append(\u0026#39;)\u0026#39;);\r//打印 构造器/方法\rSystem.out.println(sBuilder.toString());\r}\r}\r} 输出结果：\ncom.nostyling.wcms.test.DynamicProxy.test3.CalculatorImpl\rcom.sun.proxy.$Proxy0\r----构造器----\rcom.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)\r----方法----\radd(int,int)\requals(java.lang.Object)\rtoString()\rhashCode()\rsubtract(int,int)\risProxyClass(java.lang.Class)\rgetProxyClass(java.lang.ClassLoader,[Ljava.lang.Class;)\rnewProxyInstance(java.lang.ClassLoader,[Ljava.lang.Class;,java.lang.reflect.InvocationHandler)\rgetInvocationHandler(java.lang.Object)\rwait(long)\rwait(long,int)\rwait()\rgetClass()\rnotify()\rnotifyAll() 也就是说，通过给Proxy.getProxyClass()传入类加载器和接口Class对象，我们得到了一个加强版的Class：即包含接口的方法信息add()、subtract()，又包含了构造器$Proxy0(InvocationHandler)，还有一些自己特有的方法以及从Object继承的方法。\n梳理一下：\n原先我们本打算直接根据接口Class得到代理对象，无奈接口Class只有方法信息，没有构造器\n于是，我们想，有没有办法创建一个Class对象，既有接口Class的方法信息，同时又包含构造器方便创建代理实例呢？\n利用Proxy类的静态方法getProxyClass()方法，给它传一个接口Class对象，它能返回一个加强版Class对象。也就是说getProxyClass()的本质是：用Class，造Class。\nProxy类和JVM，让我们不写代理类却直接得到代理Class对象，进而得到代理对象。\n静态代理：\n动态代理：\n既然Class\u0026lt;$Proxy0\u0026gt;有方法信息，又有构造器，我们试着用它得到代理实例吧：\ninvocationHandler的作用，倒像是把“方法”和“方法体”分离。JVM只造一个空的代理对象给你，后面想怎么玩，由你自己组装。反正代理对象中有个成员变量invocationHandler，每一个方法里只有一句话：handler.invoke()。所以调任何一个代理方法，最终都会跑去调用invoke()方法。\n设法在invoke()方法得到目标对象，并调用目标对象的同名方法。\n不编写实现类，直接在运行期创建某个interface的实例.\nJava标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface 的实例。\n先定义了接口:\ninterface Hello {\rvoid morning(String name);\r} 通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。\npublic class Main {\rpublic static void main(String[] args) {\rInvocationHandler handler = new InvocationHandler() {\r@Override\rpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\rSystem.out.println(method);\rif (method.getName().equals(\u0026#34;morning\u0026#34;)) {\rSystem.out.println(\u0026#34;Good morning, \u0026#34; + args[0]);\r}\rreturn null;\r}\r};\rHello hello = (Hello) Proxy.newProxyInstance(\rHello.class.getClassLoader(), // 传入ClassLoader\rnew Class[] { Hello.class }, // 传入要实现的接口\rhandler); // 传入处理调用方法的InvocationHandler\rhello.morning(\u0026#34;Bob\u0026#34;);\r}\r}\rinterface Hello {\rvoid morning(String name);\r} "},{"id":259,"href":"/Tech/3Java/Java-%E5%91%BD%E4%BB%A4/Java-%E5%91%BD%E4%BB%A4/","title":"Java 命令","parent":"Java 命令","content":" Java 命令 转自：Java 官网\n链接：https://docs.oracle.com/en/java/javase/19/docs/specs/man/java.html\n查看当前使用的是哪种垃圾回收器\njava -XX:+PrintCommandLineFlags -version "},{"id":260,"href":"/Tech/3Java/Java-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/","title":"Java 存储机制","parent":"3、Java","content":"\r一、java的六种存储地址及解释\r1） 寄存器(register)：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。\r2） 堆栈(stack)：位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其中。 3）堆(heap)：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。 4）静态存储(static storage)：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。 5） 常量存储(constant storage)：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中。\r6） 非RAM存储：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。\r二、栈、堆、方法区存储的内容\r堆区: 1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。\r栈区: 1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用\r2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 方法区: 1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 三、在Java语言里堆(heap)和栈(stack)里的区别 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 3. Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义 int a = 3; int b = 3； 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 4.每个JVM的线程都有自己的私有的栈空间，随线程创建而创建，java的stack存放的是frames ，java的stack和c的不同，只是存放本地变量，返回值和调用方法，不允许直接push和pop frames ，因为frames 可能是有heap分配的，所以j为ava的stack分配的内存不需要是连续的。java的heap是所有线程共享的，堆存放所有 runtime data ，里面是所有的对象实例和数组，heap是JVM启动时创建。 5. String是一个特殊的包装类数据。即可以用String str = new String(\u0026#34;abc\u0026#34;);的形式来创建，也可以用String str = \u0026#34;abc\u0026#34;；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java 中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = \u0026#34;abc\u0026#34;；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。 四、 关于String str = \u0026#34;abc\u0026#34;的内部工作。Java内部将此语句转化为以下几个步骤： (1)先定义一个名为str的对String类的对象引用变量：String str； (2)在栈中查找有没有存放值为\u0026#34;abc\u0026#34;的地址，如果没有，则开辟一个存放字面值为\u0026#34;abc\u0026#34;的地址，接着创建一个新的String类的对象o，并将o 的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为\u0026#34;abc\u0026#34;的地址，则查找对象o，并返回o的地址。 (3)将str指向对象o的地址。 值得注意的是，一般String类中字符串值都是直接存值的。但像String str = \u0026#34;abc\u0026#34;；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！ 为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。 String str1 = \u0026#34;abc\u0026#34;; String str2 = \u0026#34;abc\u0026#34;; System.out.println(str1==str2); //true 注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的值是否相等。==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。 结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。 我们再来更进一步，将以上代码改成： String str1 = \u0026#34;abc\u0026#34;; String str2 = \u0026#34;abc\u0026#34;; str1 = \u0026#34;bcd\u0026#34;; System.out.println(str1 + \u0026#34;,\u0026#34; + str2); //bcd, abc System.out.println(str1==str2); //false 这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为\u0026#34;bcd\u0026#34;时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。 再修改原来代码： String str1 = \u0026#34;abc\u0026#34;; String str2 = \u0026#34;abc\u0026#34;; str1 = \u0026#34;bcd\u0026#34;; String str3 = str1; System.out.println(str3); //bcd String str4 = \u0026#34;bcd\u0026#34;; System.out.println(str1 == str4); //true str3 这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。 我们再接着看以下的代码。 String str1 = new String(\u0026#34;abc\u0026#34;); String str2 = \u0026#34;abc\u0026#34;; System.out.println(str1==str2); //false 创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 String str1 = \u0026#34;abc\u0026#34;; String str2 = new String(\u0026#34;abc\u0026#34;); System.out.println(str1==str2); //false 创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。 以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。 (4) 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。 (5)结论与建议： 1)我们在使用诸如String str = \u0026#34;abc\u0026#34;；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为\u0026#34;abc\u0026#34;的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。 2)使用String str = \u0026#34;abc\u0026#34;；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(\u0026#34;abc\u0026#34;)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 4)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。 如果java不能成功分配heap的空间，将抛出OutOfMemoryError "},{"id":261,"href":"/Tech/3Java/Java-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AE%B0%E5%BD%95/","title":"Java 属性的内存结构记录","parent":"3、Java","content":" 1、对象的内存布局 转载于知乎 刘缙 的回答\n1、对象的内存布局： C/C++的内存布局： struct Point {\rfloat x;\rfloat y;\rfloat z;\r}; bytes field 4 x 4 y 4 z Java 的内存布局： bytes field 12 object header 4 x 4 y 4 z 2、嵌套对象的内存布局： C/C++的内存布局： struct Line {\rstruct Point begin;\rstruct Point end;\r}; bytes field 4 begin.x 4 begin.y 4 begin.z 4 end.x 4 end.y 4 end.z Java 的内存布局： 3、数组对象的内存布局： C/C++的内存布局： struct Point v[100]; bytes field 4 v[0].x 4 v[0].y 4 v[0].z 4 v[1].x 4 v[1].y 4 v[1].z \u0026hellip; \u0026hellip; Java 的内存布局： 2、Java 属性的内存空间分配： int e;\rint f = 3;\rString a;\rString b = new String();\rString c = \u0026#34;xxx\u0026#34;; 可以看到只有b、c、f 属性分配了内存空间。以此可以确认声明变量时（无论引用类型还是基本类型），都不在内存分配空间，只有声明的变量触发了初始化后（initialized），才会被分配内存空间，例如变量作为类静态（static）属性，类加载后就会初始化，或者作为方法的形参也会被初始化。\n注意\u0026quot;引用\u0026quot;也是占用空间的，基本类型的引用就是“数据”本身，引用类型的引用是“数据”所在内存空间的首地址\n这里要特殊考虑String，以及Integer、Double等几个基本类型包装类，它们都是immutable类型，因为没有提供自身修改的函数，每次操作都是新生成一个对象，并把该空间的首地址赋给引用。\n"},{"id":262,"href":"/Tech/3Java/Java-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/","title":"Java 引用的四种方式","parent":"3、Java","content":" Java 引用的是四种方式 java内存管理分为内存分配和内存回收，都不需要程序员负责，垃圾回收的机制主要是看对象是否有引用指向该对象。\njava对象的引用包括 强引用，软引用，弱引用，虚引用\nJava中提供这四种引用类型主要有两个目的：\n第一是可以让程序员通过代码的方式决定某些对象的生命周期；\n第二是有利于JVM进行垃圾回收。\n下面来阐述一下这四种类型引用的概念：\n１．强引用\n是指创建一个对象并把这个对象赋给一个引用变量。\n比如：\nObject object =new Object();\rString str =\u0026#34;hello\u0026#34;; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。\n2.软引用（SoftReference）\n如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；\n如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。\nSoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。\n也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。\n另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。\n举个栗子：\nMyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。\n随即，我们可以结束aReference对这个MyObject实例的强引用:\naRef = null; 此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。\nJava虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。\n也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:\nMyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。 使用ReferenceQueue清除失去了软引用对象的SoftReference：\n使用ReferenceQueue清除失去了软引用对象的SoftReference：\n作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:\nReferenceQueue queue = new ReferenceQueue(); SoftReference ref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。\n在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:\nSoftReference ref = null; while ((ref = (EmployeeRef) q.poll()) != null) { // 清除ref } 3.弱引用（WeakReference）\n弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：\npublic class test { public static void main(String[] args) { WeakReference\u0026lt;People\u0026gt;reference=new WeakReference\u0026lt;People\u0026gt;(new People(\u0026#34;zhouqian\u0026#34;,20)); System.out.println(reference.get()); System.gc();//通知GVM回收资源 System.out.println(reference.get()); } } class People{ public String name; public int age; public People(String name,int age) { this.name=name; this.age=age; } @Override public String toString() { return \u0026#34;[name:\u0026#34;+name+\u0026#34;,age:\u0026#34;+age+\u0026#34;]\u0026#34;; } } 输出结果：\n[name:zhouqian,age:20]\rnull 第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。\n比如：将代码做一点小更改：\npublic class test { public static void main(String[] args) { People people=new People(\u0026#34;zhouqian\u0026#34;,20); //关联强引用\rWeakReference\u0026lt;People\u0026gt;reference=new WeakReference\u0026lt;People\u0026gt;(people); System.out.println(reference.get()); System.gc(); System.out.println(reference.get()); } } class People{ public String name; public int age; public People(String name,int age) { this.name=name; this.age=age; } @Override public String toString() { return \u0026#34;[name:\u0026#34;+name+\u0026#34;,age:\u0026#34;+age+\u0026#34;]\u0026#34;; } } 输出结果：\n[name:zhouqian,age:20] [name:zhouqian,age:20] 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。\n4.虚引用（PhantomReference）\n虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。\n要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\npublic class Main { public static void main(String[] args) { ReferenceQueue\u0026lt;String\u0026gt; queue = new ReferenceQueue\u0026lt;String\u0026gt;(); PhantomReference\u0026lt;String\u0026gt; pr = new PhantomReference\u0026lt;String\u0026gt;(new String(\u0026#34;hello\u0026#34;), queue); System.out.println(pr.get()); } } 软引用和弱引用 对于强引用，我们平时在编写代码时经常会用到。而对于其他三种类型的引用，使用得最多的就是软引用和弱引用，这2种既有相似之处又有区别。它们都是用来描述非必需对象的，但是被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。 在SoftReference类中，有三个方法，两个构造方法和一个get方法（WekReference类似）：\n两个构造方法：\npublic SoftReference(T referent) { super(referent); this.timestamp = clock; } public SoftReference(T referent, ReferenceQueue\u0026lt;? super T\u0026gt; q) { super(referent, q); this.timestamp = clock; } get方法用来获取与软引用关联的对象的引用，如果该对象被回收了，则返回null。\n在使用软引用和弱引用的时候，我们可以显示地通过System.gc()来通知JVM进行垃圾回收，但是要注意的是，虽然发出了通知，JVM不一定会立刻执行，也就是说这句是无法确保此时JVM一定会进行垃圾回收的。\n对象可及性的判断\n在很多时候，一个对象并不是从根集直接引用的，而是一个对象被其他对象引用，甚至同时被几个对象所引用，从而构成一个以根集为顶的树形结构。\n◆单条引用路径可及性判断:在这条路径中，最弱的一个引用决定对象的可及性。 ◆多条引用路径可及性判断:几条路径中，最强的一条的引用决定对象的可及性。\n如何利用软引用和弱引用解决OOM问题\n前面讲了关于软引用和弱引用相关的基础知识，那么到底如何利用它们来优化程序性能，从而避免OOM的问题呢？\n下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。\n设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到。\n3．使用软引用构建敏感数据的缓存\n3.1 为什么需要使用软引用\n首先，我们看一个雇员信息查询系统的实例。我们将使用一个Java语言实现的雇员信息查询系统查询存储在磁盘文件或者数据库中的雇员人事档案信息。作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。这时我们通常会有两种程序实现方式:一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得垃圾收集线程可以回收其所占用的内存空间，当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。很显然，第一种实现方法将造成大量的内存浪费，而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，应用程序也要重新构建一个对象。我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。\n3.2 如果使用软引用\nSoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。\n看下面代码:\nMyObject aRef = new MyObject();\rSoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。 随即，我们可以结束aReference对这个MyObject实例的强引用:\naRef = null; 此后，这个MyObject对象成为了软可及对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:\nMyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。\n3.3 使用ReferenceQueue清除失去了软引用对象的SoftReference\n作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:\nReferenceQueue queue = new ReferenceQueue();\rSoftReference ref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。 在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:\nSoftReference ref = null;\rwhile ((ref = (EmployeeRef) q.poll()) != null) {\r// 清除ref\r} 理解了ReferenceQueue的工作机制之后，我们就可以开始构造一个Java对象的高速缓存器了。\n3.4通过软可及对象重获方法实现Java对象的高速缓存 利用Java2平台垃圾收集机制的特性以及前述的垃圾对象重获方法，我们通过一个雇员信息查询系统的小例子来说明如何构建一种高速缓存器来避免重复构建同一个对象带来的性能损失。我们将一个雇员的档案信息定义为一个Employee类:\npublicclass Employee {\rprivate String id;// 雇员的标识号码\rprivate String name;// 雇员姓名\rprivate String department;// 该雇员所在部门\rprivate String Phone;// 该雇员联系电话\rprivateintsalary;// 该雇员薪资\rprivate String origin;// 该雇员信息的来源\r// 构造方法\rpublic Employee(String id) {\rthis.id = id;\rgetDataFromlnfoCenter();\r}\r// 到数据库中取得雇员信息\rprivatevoid getDataFromlnfoCenter() {\r// 和数据库建立连接井查询该雇员的信息，将查询结果赋值\r// 给name，department，plone，salary等变量\r// 同时将origin赋值为\u0026#34;From DataBase\u0026#34;\r}\r…… 这个Employee类的构造方法中我们可以预见，如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这是需要消耗很多时间的。下面是一个对Employee对象进行缓存的缓存器的定义:\npublicclass EmployeeCache {\rstaticprivate EmployeeCache cache;// 一个Cache实例\rprivate Hashtable\u0026lt;String,EmployeeRef\u0026gt; employeeRefs;// 用于Chche内容的存储\rprivate ReferenceQueue\u0026lt;Employee\u0026gt; q;// 垃圾Reference的队列\r// 继承SoftReference，使得每一个实例都具有可识别的标识。\r// 并且该标识与其在HashMap内的key相同。\rprivateclass EmployeeRef extends SoftReference\u0026lt;Employee\u0026gt; {\rprivate String _key = \u0026#34;\u0026#34;;\rpublic EmployeeRef(Employee em, ReferenceQueue\u0026lt;Employee\u0026gt; q) {\rsuper(em, q);\r_key = em.getID();\r}\r}\r// 构建一个缓存器实例\rprivate EmployeeCache() {\remployeeRefs = new Hashtable\u0026lt;String,EmployeeRef\u0026gt;();\rq = new ReferenceQueue\u0026lt;Employee\u0026gt;();\r}\r// 取得缓存器实例\rpublicstatic EmployeeCache getInstance() {\rif (cache == null) {\rcache = new EmployeeCache();\r}\rreturncache;\r}\r// 以软引用的方式对一个Employee对象的实例进行引用并保存该引用\rprivatevoid cacheEmployee(Employee em) {\rcleanCache();// 清除垃圾引用\rEmployeeRef ref = new EmployeeRef(em, q);\remployeeRefs.put(em.getID(), ref);\r}\r// 依据所指定的ID号，重新获取相应Employee对象的实例\rpublic Employee getEmployee(String ID) {\rEmployee em = null;\r// 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。\rif (employeeRefs.containsKey(ID)) {\rEmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);\rem = (Employee) ref.get();\r}\r// 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，\r// 并保存对这个新建实例的软引用\rif (em == null) {\rem = new Employee(ID);\rSystem.out.println(\u0026#34;Retrieve From EmployeeInfoCenter. ID=\u0026#34; + ID);\rthis.cacheEmployee(em);\r}\rreturn em;\r}\r// 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象\rprivatevoid cleanCache() {\rEmployeeRef ref = null;\rwhile ((ref = (EmployeeRef) q.poll()) != null) {\remployeeRefs.remove(ref._key);\r}\r}\r// 清除Cache内的全部内容\rpublicvoid clearCache() {\rcleanCache();\remployeeRefs.clear();\rSystem.gc();\rSystem.runFinalization();\r}\r} 4．使用弱引用构建非敏感数据的缓存\n4.1全局 Map 造成的内存泄漏\n无意识对象保留最常见的原因是使用Map将元数据与临时对象（transient object）相关联。假定一个对象具有中等生命周期，比分配它的那个方法调用的生命周期长，但是比应用程序的生命周期短，如客户机的套接字连接。需要将一些元数据与这个套接字关联，如生成连接的用户的标识。在创建Socket时是不知道这些信息的，并且不能将数据添加到Socket对象上，因为不能控制 Socket 类或者它的子类。这时，典型的方法就是在一个全局 Map 中存储这些信息，如下面的 SocketManager 类所示：使用一个全局 Map 将元数据关联到一个对象。\npublicclass SocketManager {\rprivate Map\u0026lt;Socket, User\u0026gt; m = new HashMap\u0026lt;Socket, User\u0026gt;();\rpublicvoid setUser(Socket s, User u) {\rm.put(s, u);\r}\rpublic User getUser(Socket s) {\rreturnm.get(s);\r}\rpublicvoid removeUser(Socket s) {\rm.remove(s);\r}\r} 这种方法的问题是元数据的生命周期需要与套接字的生命周期挂钩，但是除非准确地知道什么时候程序不再需要这个套接字，并记住从 Map 中删除相应的映射，否则，Socket 和 User 对象将会永远留在 Map 中，远远超过响应了请求和关闭套接字的时间。这会阻止 Socket 和 User 对象被垃圾收集，即使应用程序不会再使用它们。这些对象留下来不受控制，很容易造成程序在长时间运行后内存爆满。除了最简单的情况，在几乎所有情况下找出什么时候 Socket 不再被程序使用是一件很烦人和容易出错的任务，需要人工对内存进行管理。\n4.2如何使用WeakHashMap 在Java集合中有一种特殊的Map类型—WeakHashMap，在这种Map中存放了键对象的弱引用，当一个键对象被垃圾回收器回收时，那么相应的值对象的引用会从Map中删除。WeakHashMap能够节约存储空间，可用来缓存那些非必须存在的数据。关于Map接口的一般用法。 下面示例中MapCache类的main()方法创建了一个WeakHashMap对象，它存放了一组Key对象的弱引用，此外main()方法还创建了一个数组对象，它存放了部分Key对象的强引用。\nclass Element {\rprivate String ident;\rpublic Element(String id) {\rident = id;\r}\rpublic String toString() {\rreturnident;\r}\rpublicint hashCode() {\rreturnident.hashCode();\r}\rpublicboolean equals(Object obj) {\rreturn obj instanceof Element \u0026amp;\u0026amp; ident.equals(((Element) obj).ident);\r}\rprotectedvoid finalize(){\rSystem.out.println(\u0026#34;Finalizing \u0026#34;+getClass().getSimpleName()+\u0026#34; \u0026#34;+ident);\r}\r}\rclass Key extends Element{\rpublic Key(String id){\rsuper(id);\r}\r}\rclass Value extends Element{\rpublic Value (String id){\rsuper(id);\r}\r}\rpublicclass CanonicalMapping {\rpublicstaticvoid main(String[] args){\rint size=1000;\rKey[] keys=new Key[size];\rWeakHashMap\u0026lt;Key,Value\u0026gt; map=new WeakHashMap\u0026lt;Key,Value\u0026gt;();\rfor(int i=0;i\u0026lt;size;i++){\rKey k=new Key(Integer.toString(i));\rValue v=new Value(Integer.toString(i));\rif(i%3==0)\rkeys[i]=k;\rmap.put(k, v);\r}\rSystem.gc();\r}\r} 从打印结果可以看出，当执行System.gc()方法后，垃圾回收器只会回收那些仅仅持有弱引用的Key对象。id可以被3整除的Key对象持有强引用，因此不会被回收。\n4.3用 WeakHashMap 堵住泄漏 在 SocketManager 中防止泄漏很容易，只要用 WeakHashMap 代替 HashMap 就行了。（这里假定SocketManager不需要线程安全）。当映射的生命周期必须与键的生命周期联系在一起时，可以使用这种方法。用WeakHashMap修复 SocketManager。\npublicclass SocketManager {\rprivate Map\u0026lt;Socket,User\u0026gt; m = new WeakHashMap\u0026lt;Socket,User\u0026gt;();\rpublicvoid setUser(Socket s, User u) {\rm.put(s, u);\r}\rpublic User getUser(Socket s) {\rreturnm.get(s);\r}\r} 4.4配合使用引用队列 WeakHashMap 用弱引用承载映射键，这使得应用程序不再使用键对象时它们可以被垃圾收集，get() 实现可以根据 WeakReference.get() 是否返回 null 来区分死的映射和活的映射。但是这只是防止 Map 的内存消耗在应用程序的生命周期中不断增加所需要做的工作的一半，还需要做一些工作以便在键对象被收集后从 Map 中删除死项。否则，Map 会充满对应于死键的项。虽然这对于应用程序是不可见的，但是它仍然会造成应用程序耗尽内存。 引用队列是垃圾收集器向应用程序返回关于对象生命周期的信息的主要方法。弱引用有个构造函数取引用队列作为参数。如果用关联的引用队列创建弱引用，在弱引用对象成为 GC 候选对象时，这个引用对象就在引用清除后加入到引用队列中（具体参考上文软引用示例）。 WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，大多数 Map 操作中会调用它，它去掉引用队列中所有失效的引用，并删除关联的映射。 5．UML:使用关联类指明特定形式的引用 关联类能够用来指明特定形式的引用，如弱（weak）、软（soft）或虚 （phantom）引用。\n也可以如下的构造型方式。\n"},{"id":263,"href":"/Tech/3Java/Java-%E6%8A%80%E6%9C%AF%E5%85%B3%E9%94%AE%E5%AD%97/","title":"Java 技术关键字","parent":"3、Java","content":"线程相关： 锁(sync和Lock) 、线程池 、异步计算、 一些相关概念： 重入锁 、轻量级锁 、重量级锁、 KClass对象头、 悲观锁 、乐观锁、 AQS原理和相关实现(并发集合/Lock) NIO相关(通信方面一定要了解[IO/NIO/AIO]) ：NIO模型 、NIO选择器、 xxxx 高并发的解决方案、 数据静态化 、缓存、 数据库集群 、负载均衡 、CDN加速、 设计模式和设计原则 、工厂模式、 代理模式 、组合模式、 开闭原则、\n相关的分布式框架以及中间件 分布式任务调度框架 消息中间件(各种MQ) 分布式通信 常见的分布式框架 数据结构以及算法相关 没啥好说的，看看JCF就能应付一般的 基本的排序算法(冒泡，快排，归并) 二分查找/Top10/and so on 树的性质和相关操作 Spring相关\n《数据结构和算法》：基础的知识\n《深入java虚拟机》：同上。\n《Java并发编程的艺术》：这本书对并发编程的常用知识点进行了系统的讲解，将的深度还可以，没有具体的案例。\n《架构探险》：同上，这本书上对于我们理解Spring中的实现原理，还是有一定的帮助的。书中模仿Spring框架，写的 配置文件加载、类加载器、IOC的实现、AOP的实现还是有参考价值的。\n《Redis实战》：现在用的越来越多了，不管用没用过，都可以学习一下。\n《大型分布式网站架构设计与实践》：这本书从总体上讲解了大型网站架构常用的技术，不深入，对于从整体上认识 大型分布式网站还是很有参考价值的。如果我们想要在哪一方面深入学习，可以有针对性的进行深入学习。\n《大型网站技术架构：核心原理与案例分析》：同上。\n《Java程序员面试笔试宝典》：买这本书主要是找工作时，做一些题目，对于笔试来说，有针对性的学习复习一下。\n"},{"id":264,"href":"/Tech/3Java/Java-%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/","title":"Java 日志体系","parent":"3、Java","content":" Java日志体系 转自： Alben\n链接：https://albenw.github.io/posts/854fc091/\n概要 本文的目的是搞清楚Java中各种日志Log之间是怎么的关系，如何作用、依赖，好让我们平时在工作中如果遇到“日志打不出”或者“日志jar包冲突”等之类的问题知道该如何入手解决，以及在各种场景下如何调整项目中的各个框架的日志输出，使得输出统一。\nLog日志体系 在日常工作中我们可能看到项目中依赖的跟日志相关的jar包有很多，commons-logging.jar、log4j.jar、sl4j-api.jar、logback.jar等等，眼花缭乱。我们要正确的配置，使得jar包相互作用生效之前，就先要理清它们之间的关系。\n背景/发展史 那就要从Java Log的发展历程开始说起。\nlog4j（作者Ceki Gülcü）出来时就等到了广泛的应用（注意这里是直接使用），是Java日志事实上的标准，并成为了Apache的项目 Apache要求把log4j并入到JDK，SUN拒绝，并在jdk1.4版本后增加了 JUL（java.util.logging） 毕竟是JDK自带的，JUL也有很多人用。同时还有其他日志组件，如SimpleLog等。这时如果有人想换成其他日志组件，如log4j换成JUL，因为api完全不同，就需要改动代码。 Apache见此，开发了 JCL（Jakarta Commons Logging），即commons-logging-xx.jar。它只提供一套通用的日志接口api，并不提供日志的实现。很好的设计原则嘛，依赖抽象而非实现。这样应用程序可以在运行时选择自己想要的日志实现组件。 这样看上去也挺美好的，但是log4j的作者觉得JCL不好用，自己开发出 slf4j，它跟JCL类似，本身不替供日志具体实现，只对外提供接口或门面。目的就是为了替代JCL。同时，还开发出 logback，一个比log4j拥有更高性能的组件，目的是为了替代log4j。 Apache参考了logback,并做了一系列优化，推出了 log4j2 关系/依赖 大概了解心路历程后，再详细看看它们之间的关系、依赖。\nJCL commons-logging 已经停止更新，最后的状态如下所示：\nJCL支持日志组件不多，不过也有很人用的，例如Spring 现在用的也越来越少了，也不多讲了\nSLF4J 因为当时Java的日志组件比较混乱繁杂，Ceki Gülcü推出slf4j后，也相应为行业中各个主流日志组件推出了slf4j的适配\n图来源于官方文档\n图的意思为如果你想用slf4j作为日志门面的话，你如何去配合使用其他日志实现组件，这里说明一下（注意jar包名缺少了版本号，在找版本时也要注意版本之间是否兼容）\nslf4j + logback slf4j-api.jar + logback-classic.jar + logback-core.jar slf4j + log4j slf4j-api.jar + slf4j-log4j12.jar + log4j.jar slf4j + jul slf4j-api.jar + slf4j-jdk14.jar 也可以只用slf4j无日志实现 slf4j-api.jar + slf4j-nop.jar SLF4J的适配 slf4j支持各种适配，无论你现在是用哪种日志组件，你都可以通过slf4j的适配器来使用上slf4j。 只要你切换到了slf4j，那么再通过slf4j用上实现组件，即上面说的。\n图来源于官方文档\n其实总的来说，无论就是以下几种情况\n你在用JCL 使用jcl-over-slf4j.jar适配 你在用log4j 使用log4j-over-slf4j.jar适配 你在用JUL 使用jul-to-slf4j.jar适配 入下图所示： 让Spring统一输出 这就是为了对slf4j的适配做一个例子说明。 Spring是用JCL作为日志门面的，那我们的应用是 slf4j + logback，怎么让Spring也用到logback作为日志输出呢？这样的好处就是我们可以统一项目内的其他模块、框架的日志输出（日志格式，日志文件，存放路径等，以及其他 slf4j 支持的功能） 很简单，就是加入jcl-over-slf4j.jar就好了。\n我又盗了一个图来说明\n适配思路 其实很简单\n你首先确认需要统一日志的模块、框架是使用哪个日志组件的，然后再找到sfl4j的适配器。 记得去掉无用的日志实现组件，只保留你要用的。 常见问题 slf4j的日志加载会在程序启动时把日志打出来，所以一定要注意，它会说明加载是否成功，加载了那个日志实现。 slf4j已经对错误作了说明官网说明 下面讲一下可能经常遇到的问题 Failed to load class org.slf4j.impl.StaticLoggerBinder 没找到日志实现，如果你觉得你已经写上了对应的日志实现依赖了，那你要检查一下了，一般来说极有可能是版本不兼容。\nMultiple bindings 找到多个日志实现，slf4j会找其中一个作为日志实现。\n"},{"id":265,"href":"/Tech/3Java/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/","title":"Java 类加载机制详解","parent":"3、Java","content":" Java 类加载机制详解 转自：JAVA系列之类加载机制详解\n链接：https://www.cnblogs.com/myshare/p/16892361.html\n类的加载机制 ？ 双亲委派机制 ？ 什么是类加载器 ？ 自定义类加载器有哪些应用场景 ？ 通常，在关于Java的类加载部分会遇到以上疑问，本文将对类加载重要部分做详细介绍，包括重要的基础概念和应用场景，在编写过程中也帮助作者重新熟悉并加固了知识点，希望在看完后对读者能有所帮助。\n"},{"id":266,"href":"/Tech/3Java/Java-%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/","title":"Java 过滤器与 Spring Mvc拦截器","parent":"3、Java","content":" Java过滤器与SpringMVC拦截器 "},{"id":267,"href":"/Tech/3Java/Json/","title":"JSON","parent":"3、Java","content":" FastJson 1、序列化时过滤字段(属性)\n@JSONField(serialize = false)\rprivate String name; @JSONField(name = \u0026#34;AGE\u0026#34;)\rprivate transient String age; 在实体字段前面，使用transient关键字，表示该字段不参与序列化，转JSON字符串时就可以忽略掉该字段。因为是JAVA关键字所以也会影响该字段其他序列化操作。\nSimplePropertyPreFilter filter = new SimplePropertyPreFilter(); filter.getExcludes().add(\u0026#34;PHONE\u0026#34;); System.out.println(JSONObject.toJSONString(u, filter)); FastJson的属性名过滤器\n2、序列化时过滤字段(属性)\n@JSONField(serialize = false)\rprivate String name; 3、\nSystem.out.println(\u0026#34;RefundCollection 的 json: \u0026#34; + JSON.toJSONString(logisticsAddress.getLogisticsAddressDTOList(), SerializerFeature.WriteMapNullValue)); 4、\n// 序列化配置对象\rSerializeConfig config = new SerializeConfig();\r/**\r* CamelCase 策略，Java对象属性：personId，序列化后属性：persionId\r* PascalCase 策略，Java对象属性：personId，序列化后属性：PersonId\r* SnakeCase 策略，Java对象属性：personId，序列化后属性：person_id\r* KebabCase 策略，Java对象属性：personId，序列化后属性：person-id\r*/\rconfig.propertyNamingStrategy = PropertyNamingStrategy.CamelCase;;\r// 序列化对象\rString json = JSON.toJSONString(object,config);\rSystem.out.println(\u0026#34;反序列 person json -\u0026gt; \u0026#34;); Gson @SerializedName(\u0026#34;app_key\u0026#34;)\rprivate String appKey = null; List\u0026lt;String\u0026gt; name = new Gson().fromJson(json, new TypeToken\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {}.getType()); Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\rDouDianResponseDTO\u0026lt;NewCreateOrderResponseDTO\u0026gt; dtoDouDianResponseDTO = gson.fromJson(returns.getBody(), new TypeToken\u0026lt;DouDianResponseDTO\u0026lt;NewCreateOrderResponseDTO\u0026gt;\u0026gt;() {\r}.getType()); Json的序列化与反序列化，分别对应不同的名称，那么只需要设置@SerializedName(value=\u0026#34;序列化、反序列化默认名称\u0026#34;,alternate={\u0026#34;反序列化名称备选\u0026#34;}) "},{"id":268,"href":"/Tech/3Java/jvm/jvm/","title":"Jvm","parent":"jvm","content":" JVM 1、PermGen Space (永久带) 1、在jdk1.7之前，字符串常量存储在方法区的 PermGen Space 2、常量池 常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = \u0026ldquo;java\u0026quot;这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。 java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间，常量池存在于方法区中。 String类也是java中用得多的类，同样为了创建String对象的方便，也实现了常量池的技术。 在Java语言中不是这样，一切都是动态的。编译时，如果发现对其它类方法的调用或者对其它类字段的引用的语句，记录进class文件中的只能是一个文本形式的符号引用，在连接过程中，虚拟机根据这个文本信息去查找对应的方法或字段。 Java是一种动态链接的语言，常量池的作用非常重要，常量池中除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值外，还包含一些以文本形式出现的符号引用，比如： 类和接口的全限定名； 字段的名称和描述符； 方法的名称和描述符。 "},{"id":269,"href":"/Tech/3Java/jvm/%E4%BB%8E%E8%A1%A8%E5%88%B0%E9%87%8C%E5%AD%A6%E4%B9%A0JVM%E5%AE%9E%E7%8E%B0/","title":"从表到里学习 Jvm实现","parent":"jvm","content":" 从表到里学习JVM实现 转载自：RednaxelaFX\r链接：https://www.douban.com/doulist/2545443/\r来源：豆瓣 在社会化分工、软件行业细分专业化的趋势下，会真的参与到底层系统实现的人肯定是越来越少（比例上说）。真的会参与到JVM实现的人肯定是少数。 但如果您对JVM是如何实现的有兴趣、充满好奇，却苦于没有足够系统的知识去深入，那么这个豆列就是为您打好基础而准备的。\n如果只想用用Java用用JVM，对深入到实现细节无甚兴趣的话，这个豆列就请不必参考了，免得浪费钱浪费时间精力，呵呵 :-)\n本豆列的脉络是：\nJVM与Java语言规范 要了解JVM是如何实现的，首先必须要知道JVM到底是什么、不是什么，表面上应该提供怎样的功能。为此，JVM规范必读，而且应该时常放在手边参考。 而JVM的主要服务对象是Java编程语言。虽然JVM也可以支持众多其它语言，但JVM里的“J”仍然最重要，Java的语言特性影响了JVM的原始设计，所以Java语言规范也应该阅读。特别是，JVM关于线程和同步相关的规定都是交由Java语言规范的相关章节定义的。\n虚拟机概论 这里选取《Virtual Machines: Versatile Platforms for Systems and Processes》，帮助您了解“虚拟机”一词到底指代什么，有什么不同类型，大概有哪些实现方法，等等。读完这本书有助获得一个清晰的大局观。\n为Java程序员从用户的角度介绍JVM的使用经验的几本书 虽然这几本并没有深入到JVM实现的非常细节的角落，但对已经习惯用Java语言编程的程序员来说，有这么几本书带领自己从熟悉的领域进入不熟悉的领域总是件好事。 这几本书中，最深入JVM内部的是《Oracle JRockit: The Definitive Guide》；有丰富调优建议的是《Java Performance》；结合实现大概介绍JVM的抽象概念的是周志明的《深入理解Java虚拟机》。\n虚拟机的入门级实现 先通过《Language Implementation Patterns》了解编程语言的一些入门级实现方式，把高级语言编译器与虚拟机两个概念联系起来。\n然后通过《プログラミング言語を作る》了解非常简易的、用树遍历式以及字节码式解释器实现虚拟机大概是个怎么回事。虽然这本书没有实现JVM，但它介绍的Diksam与早期JVM的实现颇有相似之处，可参考。\n接下来《深入嵌入式Java虚拟机》介绍了一种实际的JVM——KVM的实现细节。KVM是CLDC的参考实现（RI）里的JVM，结构简单，资源消耗小，适合入门阅读。\n陈涛的《HotSpot实战》主要介绍了HotSpot VM的核心VM的实现。第一版的内容还不算深，介绍runtime的部分比较多，而介绍GC与动态编译器的具体实现的部分比较少。想对HotSpot VM的实现有初步了解，但担心GC与编译原理的知识太难的同学可以从这本书入手。 （不过请注意自己对着代码确实把知识消化掉，因为这个第一版的内容有不少小错误嗯…）\n这部分最后是《The School of Niklaus Wirth》，里面有一章介绍了HotSpot Client Compiler (C1)的原始设计思路。这是个非常简单、但相对来说性能还不错的JIT编译器，可用于对JIT编译器的基本了解。这本书本身就很赞，不为学习虚拟机也可以一读。\n需要注意的是从“简易的JVM实现”到“高性能、复杂的JVM实现”跨度非常大；前者的许多部分的实现方式与后者相当不同。先从简易的实现开始入手主要是为了对JVM里大概都有些什么组件有所了解。但如果目标是了解高性能JVM的实现，那就必须在GC、编译原理方面打下更好的基础，重新洗一次脑。\nC++基础书 下面要开始逐渐深入JVM的内部实现，如果没有良好的C或（与？）C++基础会比较吃力。虽然也有几乎完全用Java语言实现的高性能JVM，例如Maxine VM与Jikes RVM，但它们都是研究性质的；商用JVM实现仍然是C与C++的天下。\n这里我先推荐C++之父自己写的那本书来入门。虽然BS巨巨后来还出过本新书，而近来也渐渐开始有介绍C++11的入门书，但实际上现在多数JVM实现用的还是C99或非常古老的C++（连C++03都不一定用到了），所以用这本老书应该就够了。 然后通过《深度探索C++对象模型》来学习C++对象模型的常见实现方式。这对后面理解Java对象模型的实现很有帮助。\nGC与编译原理的入门书 GC书总共就那么几本，倒也没啥可挑的。《The Garbage Collection Handbook》是绝对必读。\n编译原理的书就稍微尴尬些。现有的编译原理书大都针对静态编译器、针对像C或C++那样的偏静态、偏native的语言。我还没读到过什么编译原理书是专门介绍JIT编译器或者说动态编译器的。《The Compiler Design Handbook》（http://book.douban.com/subject/2333166/）算是有一章专门讲动态编译，不过也只是很入门的介绍。 静态与动态编译器会有些取舍上、实现策略上的差异，不过还好其核心的原理都是一样的，所以还是可以推荐几本书。龙书用来最初入门，鲸书用来补充一些优化相关的知识，EAC第二版用来学习编译器一种比较良好的逻辑组织方式，最后学一下针对现代机器的优化。《Optimizing Compilers for Modern Architectures》（http://book.douban.com/subject/2126867/）是我比较喜欢的一本。\n介绍计算机体系结构的书 实际JVM实现里，如果有JIT编译器或者动态编译器那它们的编译目标多半是底层机器的机器码。这就涉及到计算机体系结构了。 如果您只对Java语言和抽象的JVM有一定了解，那可以用《计算机组成及汇编语言原理》来入门。这本书比较奇葩，用JVM的字节码指令集来当作真实机器介绍体系结构的概念。我并不太喜欢这本书，但感觉它对有Java背景的初学者来说应该有点用。要注意的是千万别只读这本书来入门，请结合CSAPP来重新洗一次脑。 如果对C或C++已经有所了解，那《深入理解计算机系统》（CSAPP）是计算机体系结构入门的最适合的书了。\n进一步阅读 到此为止各种抽象概念应该都了解得差不多了。那么要在真实的机器上实现高性能JVM，就必须要对真实机器的指令集细节有所了解。x86/x86-64、SPARC、ARM、MIPS，要在哪个平台上做高性能实现就要学习哪个平台的指令集及指令级别优化技巧。这里就不具体推荐书了。\n操作系统层面的知识同样重要。像是说JVM要实现线程、内存分配啥的，都可能要跟系统调用或CRT对系统调用的包装打交道。这部分也需要另外找书来读。我回头再考虑下要不要加几本道这个豆列里来。\n另外，从80年代开始高级语言虚拟机的实现技术有了突飞猛进的发展，但却没有专门的书对这个领域做综述和导读。多数有用的资料其实还是在论文里。光靠读书是远远不够用的，论文这块也请关注。\n顺便广告一下：我的博客里关于虚拟机的文章也推荐给大家阅读：http://rednaxelafx.iteye.com/blog/362738\n=====================================\n这个豆列没有漏掉《Inside the Java Virtual Machine, Second Edition》（ http://book.douban.com/subject/1788390/ ，中文版《深入Java虚拟机(原书第2版)》，http://book.douban.com/subject/1138768/） ，只是我现在已经不再推荐它了。这本书刚出版的时候确实引起了一番学习Java虚拟机的热潮，但其部分内容从现在的角度看已经过时，特别是涉及JVM实现的部分。像火车算法什么的现在已经没有JVM实现使用。不过话说回来，了解了解这些过时的信息也没什么不好，前提是能自己分辨清楚哪些信息是适用于现在的JVM的，而哪些已经成为了历史。\n另外有一本清华大学出版社出的《解析Java虚拟机开发——权衡优化.高效和安全的最优方案》（http://book.douban.com/subject/24757135/），这本纯粹是对周志明的《深入理解Java虚拟机》一书的抄袭；周志明与出版社对清华大学出版社的侵权行为提起的诉讼已经胜诉。然而抄袭也抄得很不给力，印刷、排版都不如原版。建议不要购买。\n"},{"id":270,"href":"/Tech/3Java/maven/Maven-3-pom/","title":"Maven 3 Pom","parent":"maven","content":" Maven POM POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。\n执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\nPOM 中可以指定以下配置：\n项目依赖 插件 执行目标 项目构建 profile 项目版本 项目开发者列表 相关邮件列表信息 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。\nproject 工程的根标签。\nmodelVersion 模型版本 属性，指定 POM 的版本。模型版本需要设置为 4.0。\ngroupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。\nartifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。\nversion 是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。\nname 此元素指示用于项目的显示名称\nurl 此元素指示可以在何处找到项目的网站\n\u0026lt;project xmlns = \u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34;\rxmlns:xsi = \u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation = \u0026#34;http://maven.apache.org/POM/4.0.0\rhttp://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;!-- 模型版本 --\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --\u0026gt;\r\u0026lt;groupId\u0026gt;com.companyname.project-group\u0026lt;/groupId\u0026gt;\r\u0026lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --\u0026gt;\r\u0026lt;artifactId\u0026gt;project\u0026lt;/artifactId\u0026gt;\r\u0026lt;!-- 版本号 --\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;!-- 此元素指示用于项目的显示名称。这通常用于Maven生成的文档中。 --\u0026gt;\r\u0026lt;name\u0026gt;my-app\u0026lt;/name\u0026gt;\r\u0026lt;!-- 此元素指示可以在何处找到项目的网站。这通常用于Maven生成的文档中 --\u0026gt;\r\u0026lt;url\u0026gt;http://www.example.com\u0026lt;\u0026lt;/url\u0026gt;\r\u0026lt;/project\u0026gt; 父（Super）POM\n父（Super）POM 是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 http://repo1.maven.org/maven2 去下载。\nMaven 使用 effective pom（Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 pom.xml 中做尽可能少的配置，当然这些配置可以被重写。\n使用以下命令来查看 Super POM 默认配置：\nmvn help:effective-pom Maven 将会开始处理并显示 effective-pom。\nEffective POM 的结果就像在控制台中显示的一样，经过继承、插值之后，使配置生效。\n在上面命令行输出的 pom.xml 中，你可以看到 Maven 在执行目标时需要用到的默认工程源码目录结构、输出目录、需要的插件、仓库和报表目录。\nMaven 的 pom.xml 文件也不需要手工编写。\nMaven 提供了大量的原型插件来创建工程，包括工程结构和 pom.xml。\nPOM 标签大全详解\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\u0026#34;\u0026gt; \u0026lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;!--被继承的父项目的构件标识符 --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被继承的父项目的全球唯一标识符 --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--被继承的父项目的版本 --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --\u0026gt; \u0026lt;relativePath /\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --\u0026gt; \u0026lt;groupId\u0026gt;asia.banseon\u0026lt;/groupId\u0026gt; \u0026lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --\u0026gt; \u0026lt;artifactId\u0026gt;banseon-maven2\u0026lt;/artifactId\u0026gt; \u0026lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--项目的名称, Maven产生的文档用 --\u0026gt; \u0026lt;name\u0026gt;banseon-maven\u0026lt;/name\u0026gt; \u0026lt;!--项目主页的URL, Maven产生的文档用 --\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --\u0026gt; \u0026lt;description\u0026gt;A maven project to study maven.\u0026lt;/description\u0026gt; \u0026lt;!--描述了这个项目构建环境中的前提条件。 --\u0026gt; \u0026lt;prerequisites\u0026gt; \u0026amp;lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --\u0026amp;gt; \u0026amp;lt;maven /\u0026amp;gt; \u0026lt;/prerequisites\u0026gt; \u0026lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --\u0026gt; \u0026lt;issueManagement\u0026gt; \u0026lt;!--问题管理系统（例如jira）的名字， --\u0026gt; \u0026lt;system\u0026gt;jira\u0026lt;/system\u0026gt; \u0026lt;!--该项目使用的问题管理系统的URL --\u0026gt; \u0026lt;url\u0026gt;http://jira.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/issueManagement\u0026gt; \u0026lt;!--项目持续集成信息 --\u0026gt; \u0026lt;ciManagement\u0026gt; \u0026lt;!--持续集成系统的名字，例如continuum --\u0026gt; \u0026lt;system /\u0026gt; \u0026lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --\u0026gt; \u0026lt;notifiers\u0026gt; \u0026lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --\u0026gt; \u0026lt;notifier\u0026gt; \u0026lt;!--传送通知的途径 --\u0026gt; \u0026lt;type /\u0026gt; \u0026lt;!--发生错误时是否通知 --\u0026gt; \u0026lt;sendOnError /\u0026gt; \u0026lt;!--构建失败时是否通知 --\u0026gt; \u0026lt;sendOnFailure /\u0026gt; \u0026lt;!--构建成功时是否通知 --\u0026gt; \u0026lt;sendOnSuccess /\u0026gt; \u0026lt;!--发生警告时是否通知 --\u0026gt; \u0026lt;sendOnWarning /\u0026gt; \u0026lt;!--不赞成使用。通知发送到哪里 --\u0026gt; \u0026lt;address /\u0026gt; \u0026lt;!--扩展配置项 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/notifier\u0026gt; \u0026lt;/notifiers\u0026gt; \u0026lt;/ciManagement\u0026gt; \u0026lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --\u0026gt; \u0026lt;inceptionYear /\u0026gt; \u0026lt;!--项目相关邮件列表信息 --\u0026gt; \u0026lt;mailingLists\u0026gt; \u0026lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --\u0026gt; \u0026lt;mailingList\u0026gt; \u0026lt;!--邮件的名称 --\u0026gt; \u0026lt;name\u0026gt;Demo\u0026lt;/name\u0026gt; \u0026lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\u0026gt; \u0026lt;post\u0026gt;banseon@126.com\u0026lt;/post\u0026gt; \u0026lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\u0026gt; \u0026lt;subscribe\u0026gt;banseon@126.com\u0026lt;/subscribe\u0026gt; \u0026lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\u0026gt; \u0026lt;unsubscribe\u0026gt;banseon@126.com\u0026lt;/unsubscribe\u0026gt; \u0026lt;!--你可以浏览邮件信息的URL --\u0026gt; \u0026lt;archive\u0026gt;http:/hi.baidu.com/banseon/demo/dev/\u0026lt;/archive\u0026gt; \u0026lt;/mailingList\u0026gt; \u0026lt;/mailingLists\u0026gt; \u0026lt;!--项目开发者列表 --\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;!--某个项目开发者的信息 --\u0026gt; \u0026lt;developer\u0026gt; \u0026lt;!--SCM里项目开发者的唯一标识符 --\u0026gt; \u0026lt;id\u0026gt;HELLO WORLD\u0026lt;/id\u0026gt; \u0026lt;!--项目开发者的全名 --\u0026gt; \u0026lt;name\u0026gt;banseon\u0026lt;/name\u0026gt; \u0026lt;!--项目开发者的email --\u0026gt; \u0026lt;email\u0026gt;banseon@126.com\u0026lt;/email\u0026gt; \u0026lt;!--项目开发者的主页的URL --\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --\u0026gt; \u0026lt;roles\u0026gt; \u0026lt;role\u0026gt;Project Manager\u0026lt;/role\u0026gt; \u0026lt;role\u0026gt;Architect\u0026lt;/role\u0026gt; \u0026lt;/roles\u0026gt; \u0026lt;!--项目开发者所属组织 --\u0026gt; \u0026lt;organization\u0026gt;demo\u0026lt;/organization\u0026gt; \u0026lt;!--项目开发者所属组织的URL --\u0026gt; \u0026lt;organizationUrl\u0026gt;http://hi.baidu.com/banseon\u0026lt;/organizationUrl\u0026gt; \u0026lt;!--项目开发者属性，如即时消息如何处理等 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;dept\u0026gt;No\u0026lt;/dept\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!--项目开发者所在时区， -11到12范围内的整数。 --\u0026gt; \u0026lt;timezone\u0026gt;-5\u0026lt;/timezone\u0026gt; \u0026lt;/developer\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;!--项目的其他贡献者列表 --\u0026gt; \u0026lt;contributors\u0026gt; \u0026lt;!--项目的其他贡献者。参见developers/developer元素 --\u0026gt; \u0026lt;contributor\u0026gt; \u0026lt;name /\u0026gt; \u0026lt;email /\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;organization /\u0026gt; \u0026lt;organizationUrl /\u0026gt; \u0026lt;roles /\u0026gt; \u0026lt;timezone /\u0026gt; \u0026lt;properties /\u0026gt; \u0026lt;/contributor\u0026gt; \u0026lt;/contributors\u0026gt; \u0026lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --\u0026gt; \u0026lt;license\u0026gt; \u0026lt;!--license用于法律上的名称 --\u0026gt; \u0026lt;name\u0026gt;Apache 2\u0026lt;/name\u0026gt; \u0026lt;!--官方的license正文页面的URL --\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon/LICENSE-2.0.txt\u0026lt;/url\u0026gt; \u0026lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --\u0026gt; \u0026lt;distribution\u0026gt;repo\u0026lt;/distribution\u0026gt; \u0026lt;!--关于license的补充信息 --\u0026gt; \u0026lt;comments\u0026gt;A business-friendly OSS license\u0026lt;/comments\u0026gt; \u0026lt;/license\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --\u0026gt; \u0026lt;connection\u0026gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) \u0026lt;/connection\u0026gt; \u0026lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --\u0026gt; \u0026lt;developerConnection\u0026gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk \u0026lt;/developerConnection\u0026gt; \u0026lt;!--当前代码的标签，在开发阶段默认为HEAD --\u0026gt; \u0026lt;tag /\u0026gt; \u0026lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --\u0026gt; \u0026lt;url\u0026gt;http://svn.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --\u0026gt; \u0026lt;organization\u0026gt; \u0026lt;!--组织的全名 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;!--组织主页的URL --\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/organization\u0026gt; \u0026lt;!--构建项目需要的信息 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --\u0026gt; \u0026lt;sourceDirectory /\u0026gt; \u0026lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --\u0026gt; \u0026lt;scriptSourceDirectory /\u0026gt; \u0026lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --\u0026gt; \u0026lt;testSourceDirectory /\u0026gt; \u0026lt;!--被编译过的应用程序class文件存放的目录。 --\u0026gt; \u0026lt;outputDirectory /\u0026gt; \u0026lt;!--被编译过的测试class文件存放的目录。 --\u0026gt; \u0026lt;testOutputDirectory /\u0026gt; \u0026lt;!--使用来自该项目的一系列构建扩展 --\u0026gt; \u0026lt;extensions\u0026gt; \u0026lt;!--描述使用到的构建扩展。 --\u0026gt; \u0026lt;extension\u0026gt; \u0026lt;!--构建扩展的groupId --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--构建扩展的artifactId --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--构建扩展的版本 --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/extensions\u0026gt; \u0026lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --\u0026gt; \u0026lt;defaultGoal /\u0026gt; \u0026lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;!--描述存放资源的目录，该路径相对POM路径 --\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;!--包含的模式列表，例如**/*.xml. --\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;!--排除的模式列表，例如**/*.xml --\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;!--构建产生的所有文件存放的目录 --\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --\u0026gt; \u0026lt;finalName /\u0026gt; \u0026lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --\u0026gt; \u0026lt;filters /\u0026gt; \u0026lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;!--使用的插件列表 。 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述插件所需要的信息。 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--插件在仓库里的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--插件在仓库里的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被使用的插件的版本（或版本范围） --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;!--execution元素包含了插件执行需要的信息 --\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;!--配置的执行目标 --\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;!--配置是否被传播到子POM --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;!--项目引入插件所需要的额外依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--任何配置是否被传播到子项目 --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;!--使用的插件列表 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;!--根据环境参数或命令行参数激活某个构建处理 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!--profile默认是否激活的标志 --\u0026gt; \u0026lt;activeByDefault /\u0026gt; \u0026lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --\u0026gt; \u0026lt;jdk /\u0026gt; \u0026lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\u0026gt; \u0026lt;os\u0026gt; \u0026lt;!--激活profile的操作系统的名字 --\u0026gt; \u0026lt;name\u0026gt;Windows XP\u0026lt;/name\u0026gt; \u0026lt;!--激活profile的操作系统所属家族(如 \u0026#39;windows\u0026#39;) --\u0026gt; \u0026lt;family\u0026gt;Windows\u0026lt;/family\u0026gt; \u0026lt;!--激活profile的操作系统体系结构 --\u0026gt; \u0026lt;arch\u0026gt;x86\u0026lt;/arch\u0026gt; \u0026lt;!--激活profile的操作系统版本 --\u0026gt; \u0026lt;version\u0026gt;5.1.2600\u0026lt;/version\u0026gt; \u0026lt;/os\u0026gt; \u0026lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --\u0026gt; \u0026lt;property\u0026gt; \u0026lt;!--激活profile的属性的名称 --\u0026gt; \u0026lt;name\u0026gt;mavenVersion\u0026lt;/name\u0026gt; \u0026lt;!--激活profile的属性的值 --\u0026gt; \u0026lt;value\u0026gt;2.0.3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\u0026gt; \u0026lt;file\u0026gt; \u0026lt;!--如果指定的文件存在，则激活profile。 --\u0026gt; \u0026lt;exists\u0026gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ \u0026lt;/exists\u0026gt; \u0026lt;!--如果指定的文件不存在，则激活profile。 --\u0026gt; \u0026lt;missing\u0026gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ \u0026lt;/missing\u0026gt; \u0026lt;/file\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;!--构建项目所需要的信息。参见build元素 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;defaultGoal /\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;finalName /\u0026gt; \u0026lt;filters /\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\u0026gt; \u0026lt;modules /\u0026gt; \u0026lt;!--发现依赖和扩展的远程仓库列表。 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;!--参见repositories/repository元素 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;name /\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;name /\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--不赞成使用. 现在Maven忽略该元素. --\u0026gt; \u0026lt;reports /\u0026gt; \u0026lt;!--该元素包括使用报表插件产生报表的规范。当用户执行\u0026#34;mvn site\u0026#34;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --\u0026gt; \u0026lt;reporting\u0026gt; ...... \u0026lt;/reporting\u0026gt; \u0026lt;!--参见dependencyManagement元素 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;!--参见distributionManagement元素 --\u0026gt; \u0026lt;distributionManagement\u0026gt; ...... \u0026lt;/distributionManagement\u0026gt; \u0026lt;!--参见properties元素 --\u0026gt; \u0026lt;properties /\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\u0026gt; \u0026lt;modules /\u0026gt; \u0026lt;!--发现依赖和扩展的远程仓库列表。 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;!--包含需要连接到远程仓库的信息 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!--如何处理远程仓库里发布版本的下载 --\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --\u0026gt; \u0026lt;id\u0026gt;banseon-repository-proxy\u0026lt;/id\u0026gt; \u0026lt;!--远程仓库名称 --\u0026gt; \u0026lt;name\u0026gt;banseon-repository-proxy\u0026lt;/name\u0026gt; \u0026lt;!--远程仓库URL，按protocol://hostname/path形式 --\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.169:9999/repository/\u0026lt;/url\u0026gt; \u0026lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\u0026gt; \u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\u0026gt; \u0026lt;pluginRepository\u0026gt; ...... \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!--依赖的group ID --\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt; \u0026lt;!--依赖的artifact ID --\u0026gt; \u0026lt;artifactId\u0026gt;maven-artifact\u0026lt;/artifactId\u0026gt; \u0026lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --\u0026gt; \u0026lt;type\u0026gt;jar\u0026lt;/type\u0026gt; \u0026lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --\u0026gt; \u0026lt;classifier\u0026gt;\u0026lt;/classifier\u0026gt; \u0026lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --\u0026gt; \u0026lt;systemPath\u0026gt;\u0026lt;/systemPath\u0026gt; \u0026lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--不赞成使用. 现在Maven忽略该元素. --\u0026gt; \u0026lt;reports\u0026gt;\u0026lt;/reports\u0026gt; \u0026lt;!--该元素描述使用报表插件产生报表的规范。当用户执行\u0026#34;mvn site\u0026#34;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --\u0026gt; \u0026lt;reporting\u0026gt; \u0026lt;!--true，则，网站不包括默认的报表。这包括\u0026#34;项目信息\u0026#34;菜单中的报表。 --\u0026gt; \u0026lt;excludeDefaults /\u0026gt; \u0026lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --\u0026gt; \u0026lt;outputDirectory /\u0026gt; \u0026lt;!--使用的报表插件和他们的配置。 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述报表插件需要的信息 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--报表插件在仓库里的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--报表插件在仓库里的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被使用的报表插件的版本（或版本范围） --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--任何配置是否被传播到子项目 --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--报表插件的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --\u0026gt; \u0026lt;reportSets\u0026gt; \u0026lt;!--表示报表的一个集合，以及产生该集合的配置 --\u0026gt; \u0026lt;reportSet\u0026gt; \u0026lt;!--报表集合的唯一标识符，POM继承时用到 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--产生报表集合时，被使用的报表的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;!--配置是否被继承到子POMs --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--这个集合里使用到哪些报表 --\u0026gt; \u0026lt;reports /\u0026gt; \u0026lt;/reportSet\u0026gt; \u0026lt;/reportSets\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/reporting\u0026gt; \u0026lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --\u0026gt; \u0026lt;distributionManagement\u0026gt; \u0026lt;!--部署项目产生的构件到远程仓库需要的信息 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --\u0026gt; \u0026lt;uniqueVersion /\u0026gt; \u0026lt;id\u0026gt;banseon-maven2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;banseon maven2\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;file://${basedir}/target/deploy\u0026lt;/url\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;uniqueVersion /\u0026gt; \u0026lt;id\u0026gt;banseon-maven2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Banseon-maven2 Snapshot Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot\u0026lt;/url\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;!--部署项目的网站需要的信息 --\u0026gt; \u0026lt;site\u0026gt; \u0026lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --\u0026gt; \u0026lt;id\u0026gt;banseon-site\u0026lt;/id\u0026gt; \u0026lt;!--部署位置的名称 --\u0026gt; \u0026lt;name\u0026gt;business api website\u0026lt;/name\u0026gt; \u0026lt;!--部署位置的URL，按protocol://hostname/path形式 --\u0026gt; \u0026lt;url\u0026gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web \u0026lt;/url\u0026gt; \u0026lt;/site\u0026gt; \u0026lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --\u0026gt; \u0026lt;downloadUrl /\u0026gt; \u0026lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --\u0026gt; \u0026lt;relocation\u0026gt; \u0026lt;!--构件新的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--构件新的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--构件新的版本号 --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--显示给用户的，关于移动的额外信息，例如原因。 --\u0026gt; \u0026lt;message /\u0026gt; \u0026lt;/relocation\u0026gt; \u0026lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --\u0026gt; \u0026lt;status /\u0026gt; \u0026lt;/distributionManagement\u0026gt; \u0026lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是\u0026lt;name\u0026gt;value\u0026lt;/name\u0026gt;。 --\u0026gt; \u0026lt;properties /\u0026gt; \u0026lt;/project\u0026gt; "},{"id":271,"href":"/Tech/3Java/maven/Maven-4-settings/","title":"Maven 4 Settings","parent":"maven","content":" Maven settings.xml 作者：静默星空\n链接：https://www.cnblogs.com/jingmoxukong/p/6050172.html?utm_source=gold_browser_extension\n来源：博客园\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1、settings.xml的作用 它是用来设置 Maven 参数的配置文件。并且，settings.xml是Maven的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。\n二、settings.xml元素详解 \u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\rhttps://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;localRepository/\u0026gt;\r\u0026lt;interactiveMode/\u0026gt;\r\u0026lt;usePluginRegistry/\u0026gt;\r\u0026lt;offline/\u0026gt;\r\u0026lt;pluginGroups/\u0026gt;\r\u0026lt;servers/\u0026gt;\r\u0026lt;mirrors/\u0026gt;\r\u0026lt;proxies/\u0026gt;\r\u0026lt;profiles/\u0026gt;\r\u0026lt;activeProfiles/\u0026gt;\r\u0026lt;/settings\u0026gt; 1.1、LocalRepository 作用：该值表示构建系统本地仓库的路径。 其默认值：~/.m2/repository。\n\u0026lt;localRepository\u0026gt;${user.home}/.m2/repository\u0026lt;/localRepository\u0026gt; 1.2、InteractiveMode 作用：表示maven是否需要和用户交互以获得输入。 如果maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。\n\u0026lt;interactiveMode\u0026gt;true\u0026lt;/interactiveMode\u0026gt; 1.3、UsePluginRegistry 作用：maven是否需要使用plugin-registry.xml文件来管理插件版本。 如果需要让maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。\n\u0026lt;usePluginRegistry\u0026gt;false\u0026lt;/usePluginRegistry\u0026gt; 1.4、Offline 作用：这个属性表示在Maven进行项目编译和部署等操作时是否允许Maven进行联网来下载所需要的信息。 如果构建系统需要在离线模式下运行，则为true，默认为false。 当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。\n\u0026lt;offline\u0026gt;false\u0026lt;/offline\u0026gt; 1.5、PluginGroups 作用：在pluginGroups元素下面可以定义一系列的pluginGroup元素。表示当通过plugin的前缀来解析plugin的时候到哪里寻找。pluginGroup元素指定的是plugin的groupId。默认情况下，Maven会自动把 org.apache.maven.plugins 和 org.codehaus.mojo 添加到pluginGroups下。\n\u0026lt;pluginGroups\u0026gt;\r\u0026lt;!--plugin的组织Id（groupId） --\u0026gt;\r\u0026lt;pluginGroup\u0026gt;org.codehaus.mojo\u0026lt;/pluginGroup\u0026gt;\r\u0026lt;/pluginGroups\u0026gt; 1.6、Servers 作用：一般，仓库的下载和部署是在pom.xml文件中的 repositories 和 distributionManagement 元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，这些信息可以配置在 settings.xml 中。\n\u0026lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --\u0026gt;\r\u0026lt;servers\u0026gt;\r\u0026lt;!--服务器元素包含配置服务器时需要的信息 --\u0026gt;\r\u0026lt;server\u0026gt;\r\u0026lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --\u0026gt;\r\u0026lt;id\u0026gt;server001\u0026lt;/id\u0026gt;\r\u0026lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --\u0026gt;\r\u0026lt;username\u0026gt;my_login\u0026lt;/username\u0026gt;\r\u0026lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。密码加密功能已被添加到2.1.0 +。详情请访问密码加密页面 --\u0026gt;\r\u0026lt;password\u0026gt;my_password\u0026lt;/password\u0026gt;\r\u0026lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是${user.home}/.ssh/id_dsa）以及如果需要的话，一个密语。将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。 --\u0026gt;\r\u0026lt;privateKey\u0026gt;${usr.home}/.ssh/id_dsa\u0026lt;/privateKey\u0026gt;\r\u0026lt;!--鉴权时使用的私钥密码。 --\u0026gt;\r\u0026lt;passphrase\u0026gt;some_passphrase\u0026lt;/passphrase\u0026gt;\r\u0026lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --\u0026gt;\r\u0026lt;filePermissions\u0026gt;664\u0026lt;/filePermissions\u0026gt;\r\u0026lt;!--目录被创建时的权限。 --\u0026gt;\r\u0026lt;directoryPermissions\u0026gt;775\u0026lt;/directoryPermissions\u0026gt;\r\u0026lt;/server\u0026gt;\r\u0026lt;/servers\u0026gt; 1.7、Mirrors 作用：用于定义一系列的远程仓库的镜像。我们可以在 pom 中定义一个下载工件的时候所使用的远程仓库。但是有时候这个远程仓库会比较忙，所以这个时候人们就想着给它创建镜像以缓解远程仓库的压力，也就是说会把对远程仓库的请求转换到对其镜像地址的请求。每个远程仓库都会有一个 id，这样我们就可以创建自己的 mirror 来关联到该仓库，那么以后需要从远程仓库下载工件的时候 Maven 就可以从我们定义好的 mirror 站点来下载，这可以很好的缓解我们远程仓库的压力。在我们定义的 mirror 中每个远程仓库都只能有一个 mirro r与它关联，也就是说你不能同时配置多个 mirror 的 mirrorOf 指向同一个 repositoryId。\n\u0026lt;mirrors\u0026gt;\r\u0026lt;!-- 给定仓库的下载镜像。 --\u0026gt;\r\u0026lt;mirror\u0026gt;\r\u0026lt;!-- 该镜像的唯一标识符。id用来区分不同的mirror元素。 --\u0026gt;\r\u0026lt;id\u0026gt;mirrorId\u0026lt;/id\u0026gt;\r\u0026lt;!-- 镜像名称 --\u0026gt;\r\u0026lt;name\u0026gt;PlanetMirror Australia\u0026lt;/name\u0026gt;\r\u0026lt;!-- 该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --\u0026gt;\r\u0026lt;url\u0026gt;http://downloads.planetmirror.com/pub/maven2\u0026lt;/url\u0026gt;\r\u0026lt;!-- 被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo.maven.apache.org/maven2/）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --\u0026gt;\r\u0026lt;mirrorOf\u0026gt;repositoryId\u0026lt;/mirrorOf\u0026gt;\r\u0026lt;/mirror\u0026gt;\r\u0026lt;/mirrors\u0026gt; 1.8、Proxies 作用：用来配置不同的代理。\n\u0026lt;proxies\u0026gt;\r\u0026lt;!--代理元素包含配置代理时需要的信息 --\u0026gt;\r\u0026lt;proxy\u0026gt;\r\u0026lt;!--代理的唯一定义符，用来区分不同的代理元素。 --\u0026gt;\r\u0026lt;id\u0026gt;myproxy\u0026lt;/id\u0026gt;\r\u0026lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。 --\u0026gt;\r\u0026lt;active\u0026gt;true\u0026lt;/active\u0026gt;\r\u0026lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --\u0026gt;\r\u0026lt;protocol\u0026gt;http\u0026lt;/protocol\u0026gt;\r\u0026lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --\u0026gt;\r\u0026lt;host\u0026gt;proxy.somewhere.com\u0026lt;/host\u0026gt;\r\u0026lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --\u0026gt;\r\u0026lt;port\u0026gt;8080\u0026lt;/port\u0026gt;\r\u0026lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --\u0026gt;\r\u0026lt;username\u0026gt;proxyuser\u0026lt;/username\u0026gt;\r\u0026lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --\u0026gt;\r\u0026lt;password\u0026gt;somepassword\u0026lt;/password\u0026gt;\r\u0026lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --\u0026gt;\r\u0026lt;nonProxyHosts\u0026gt;*.google.com|ibiblio.org\u0026lt;/nonProxyHosts\u0026gt;\r\u0026lt;/proxy\u0026gt;\r\u0026lt;/proxies\u0026gt; 1.9、Profiles 作用：根据环境参数来调整构建配置的列表。 settings.xml 中的 profile 元素是 pom.xml 中 profile 元素的裁剪版本。它包含了 id、activation、repositories、pluginRepositories 和 properties 元素。这里的 profile 元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。如果一个 settings.xml中的 profile 被激活，它的值会覆盖任何其它定义在 pom.xml 中带有相同id的 profile。当所有的约束条件都满足的时候就会激活这个 profile。\n\u0026lt;profiles\u0026gt;\r\u0026lt;profile\u0026gt;\r\u0026lt;!-- profile的唯一标识 --\u0026gt;\r\u0026lt;id\u0026gt;test\u0026lt;/id\u0026gt; \u0026lt;!-- 自动触发profile的条件逻辑 --\u0026gt;\r\u0026lt;activation\u0026gt;\r\u0026lt;activeByDefault\u0026gt;false\u0026lt;/activeByDefault\u0026gt;\r\u0026lt;jdk\u0026gt;1.6\u0026lt;/jdk\u0026gt;\r\u0026lt;os\u0026gt;\r\u0026lt;name\u0026gt;Windows 7\u0026lt;/name\u0026gt;\r\u0026lt;family\u0026gt;Windows\u0026lt;/family\u0026gt;\r\u0026lt;arch\u0026gt;x86\u0026lt;/arch\u0026gt;\r\u0026lt;version\u0026gt;5.1.2600\u0026lt;/version\u0026gt;\r\u0026lt;/os\u0026gt;\r\u0026lt;property\u0026gt;\r\u0026lt;name\u0026gt;mavenVersion\u0026lt;/name\u0026gt;\r\u0026lt;value\u0026gt;2.0.3\u0026lt;/value\u0026gt;\r\u0026lt;/property\u0026gt;\r\u0026lt;file\u0026gt;\r\u0026lt;exists\u0026gt;${basedir}/file2.properties\u0026lt;/exists\u0026gt;\r\u0026lt;missing\u0026gt;${basedir}/file1.properties\u0026lt;/missing\u0026gt;\r\u0026lt;/file\u0026gt;\r\u0026lt;/activation\u0026gt;\r\u0026lt;!-- 扩展属性列表 --\u0026gt;\r\u0026lt;properties /\u0026gt;\r\u0026lt;!-- 远程仓库列表 --\u0026gt;\r\u0026lt;repositories /\u0026gt;\r\u0026lt;!-- 插件仓库列表 --\u0026gt;\r\u0026lt;pluginRepositories /\u0026gt;\r...\r\u0026lt;/profile\u0026gt;\r\u0026lt;/profiles\u0026gt; 1.9.1、Activation 作用：自动触发profile的条件逻辑。这是profile中最重要的元素。跟pom.xml中的profile一样，settings.xml中的profile也可以在特定环境下改变一些值，而这些环境是通过activation元素来指定的。activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 jdk：表示当jdk的版本满足条件的时候激活，在这里是1.6。这里的版本还可以用一个范围来表示，如 [1.4,1.7) 表示1.4、1.5和1.6满足； [1.4,1.7] 表示1.4、1.5、1.6和1.7满足； os：表示当操作系统满足条件的时候激活。 property：property是键值对的形式，表示当Maven检测到了这样一个键值对的时候就激活该profile。 (1)下面的示例表示当存在属性hello的时候激活该profile。\n\u0026lt;property\u0026gt;\r\u0026lt;name\u0026gt;hello\u0026lt;/name\u0026gt;\r\u0026lt;/property\u0026gt; (2)下面的示例表示当属性hello的值为world的时候激活该profile。\n\u0026lt;property\u0026gt;\r\u0026lt;name\u0026gt;hello\u0026lt;/name\u0026gt;\r\u0026lt;value\u0026gt;world\u0026lt;/value\u0026gt;\r\u0026lt;/property\u0026gt; 这个时候如果要激活该 profile的话，可以在调用Maven指令的时候加上参数hello并指定其值为world，如： mvn compile –D hello=world file：表示当文件存在或不存在的时候激活，exists表示存在，missing表示不存在。如下面例子表示当文件hello/world不存在的时候激活该profile。\n\u0026lt;profile\u0026gt;\r\u0026lt;activation\u0026gt;\r\u0026lt;file\u0026gt;\r\u0026lt;missing\u0026gt;hello/world\u0026lt;/missing\u0026gt;\r\u0026lt;/file\u0026gt;\r\u0026lt;/activation\u0026gt;\r\u0026lt;/profile\u0026gt; activeByDefault：当其值为true的时候表示如果没有其他的profile处于激活状态的时候，该profile将自动被激活。 properties：用于定义属性键值对的。当该profile是激活状态的时候，properties下面指定的属性都可以在pom.xml中使用。对应profile的扩展属性列表。 maven属性和ant中的属性一样，可以用来存放一些值。这些值可以在pom.xml中的任何地方使用标记${X}来使用，这里X是指属性的名称。属性有五种不同的形式，并且都能在settings.xml文件中访问。\n\u0026lt;!-- 1. env.X: 在一个变量前加上\u0026#34;env.\u0026#34;的前缀，会返回一个shell环境变量。例如,\u0026#34;env.PATH\u0026#34;指代了$path环境变量（在Windows上是%PATH%）。 2. project.x：指代了POM中对应的元素值。例如: \u0026lt;project\u0026gt;\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\u0026lt;/project\u0026gt;通过${project.version}获得version的值。 3. settings.x: 指代了settings.xml中对应元素的值。例如：\u0026lt;settings\u0026gt;\u0026lt;offline\u0026gt;false\u0026lt;/offline\u0026gt;\u0026lt;/settings\u0026gt;通过 ${settings.offline}获得offline的值。 4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，例如 ${java.home}。 5. x: 在\u0026lt;properties/\u0026gt;元素中，或者外部文件中设置，以${someVar}的形式使用。\r--\u0026gt;\r\u0026lt;properties\u0026gt;\r\u0026lt;user.install\u0026gt;${user.home}/our-project\u0026lt;/user.install\u0026gt;\r\u0026lt;/properties\u0026gt; 注：如果该profile被激活，则可以在pom.xml中使用 ${user.install} 。\nrepositories：用于定义远程仓库的，当该profile是激活状态的时候，这里面定义的远程仓库将作为当前pom的远程仓库。它是maven用来填充构建系统本地仓库所使用的一组远程仓库。\n\u0026lt;repositories\u0026gt;\r\u0026lt;!--包含需要连接到远程仓库的信息 --\u0026gt;\r\u0026lt;repository\u0026gt;\r\u0026lt;!--远程仓库唯一标识 --\u0026gt;\r\u0026lt;id\u0026gt;codehausSnapshots\u0026lt;/id\u0026gt;\r\u0026lt;!--远程仓库名称 --\u0026gt;\r\u0026lt;name\u0026gt;Codehaus Snapshots\u0026lt;/name\u0026gt;\r\u0026lt;!--如何处理远程仓库里发布版本的下载 --\u0026gt;\r\u0026lt;releases\u0026gt;\r\u0026lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\u0026gt;\r\u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt;\r\u0026lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\u0026gt;\r\u0026lt;updatePolicy\u0026gt;always\u0026lt;/updatePolicy\u0026gt;\r\u0026lt;!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 --\u0026gt;\r\u0026lt;checksumPolicy\u0026gt;warn\u0026lt;/checksumPolicy\u0026gt;\r\u0026lt;/releases\u0026gt;\r\u0026lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\u0026gt;\r\u0026lt;snapshots\u0026gt;\r\u0026lt;enabled /\u0026gt;\r\u0026lt;updatePolicy /\u0026gt;\r\u0026lt;checksumPolicy /\u0026gt;\r\u0026lt;/snapshots\u0026gt;\r\u0026lt;!--远程仓库URL，按protocol://hostname/path形式 --\u0026gt;\r\u0026lt;url\u0026gt;http://snapshots.maven.codehaus.org/maven2\u0026lt;/url\u0026gt;\r\u0026lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\u0026gt;\r\u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt;\r\u0026lt;/repository\u0026gt;\r\u0026lt;/repositories\u0026gt; (1) releases、snapshots：这是对于工件的类型的限制。 (2) enabled：表示这个仓库是否允许这种类型的工件 (3) updatePolicy：表示多久尝试更新一次。可选值有always、daily、interval:minutes（表示每多久更新一次）和never。 (4) checksumPolicy：当Maven在部署项目到仓库的时候会连同校验文件一起提交，checksumPolicy表示当这个校验文件缺失或不正确的时候该如何处理，可选项有ignore、fail和warn。\npluginRepositories：在Maven中有两种类型的仓库，一种是存储工件的仓库，另一种就是存储plugin插件的仓库。pluginRepositories的定义和repositories的定义类似，它表示Maven在哪些地方可以找到所需要的插件。和repository类似，只是repository是管理jar包依赖的仓库，pluginRepositories则是管理插件的仓库。maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。\n\u0026lt;pluginRepositories\u0026gt;\r\u0026lt;!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --\u0026gt;\r\u0026lt;pluginRepository\u0026gt;\r\u0026lt;releases\u0026gt;\r\u0026lt;enabled /\u0026gt;\r\u0026lt;updatePolicy /\u0026gt;\r\u0026lt;checksumPolicy /\u0026gt;\r\u0026lt;/releases\u0026gt;\r\u0026lt;snapshots\u0026gt;\r\u0026lt;enabled /\u0026gt;\r\u0026lt;updatePolicy /\u0026gt;\r\u0026lt;checksumPolicy /\u0026gt;\r\u0026lt;/snapshots\u0026gt;\r\u0026lt;id /\u0026gt;\r\u0026lt;name /\u0026gt;\r\u0026lt;url /\u0026gt;\r\u0026lt;layout /\u0026gt;\r\u0026lt;/pluginRepository\u0026gt;\r\u0026lt;/pluginRepositories\u0026gt; 示例：\n\u0026lt;activation\u0026gt;\r\u0026lt;!--profile默认是否激活的标识 --\u0026gt;\r\u0026lt;activeByDefault\u0026gt;false\u0026lt;/activeByDefault\u0026gt;\r\u0026lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --\u0026gt;\r\u0026lt;jdk\u0026gt;1.5\u0026lt;/jdk\u0026gt;\r\u0026lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\u0026gt;\r\u0026lt;os\u0026gt;\r\u0026lt;!--激活profile的操作系统的名字 --\u0026gt;\r\u0026lt;name\u0026gt;Windows XP\u0026lt;/name\u0026gt;\r\u0026lt;!--激活profile的操作系统所属家族(如 \u0026#39;windows\u0026#39;) --\u0026gt;\r\u0026lt;family\u0026gt;Windows\u0026lt;/family\u0026gt;\r\u0026lt;!--激活profile的操作系统体系结构 --\u0026gt;\r\u0026lt;arch\u0026gt;x86\u0026lt;/arch\u0026gt;\r\u0026lt;!--激活profile的操作系统版本 --\u0026gt;\r\u0026lt;version\u0026gt;5.1.2600\u0026lt;/version\u0026gt;\r\u0026lt;/os\u0026gt;\r\u0026lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = 值，Profile就会被激活。如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --\u0026gt;\r\u0026lt;property\u0026gt;\r\u0026lt;!--激活profile的属性的名称 --\u0026gt;\r\u0026lt;name\u0026gt;mavenVersion\u0026lt;/name\u0026gt;\r\u0026lt;!--激活profile的属性的值 --\u0026gt;\r\u0026lt;value\u0026gt;2.0.3\u0026lt;/value\u0026gt;\r\u0026lt;/property\u0026gt;\r\u0026lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\u0026gt;\r\u0026lt;file\u0026gt;\r\u0026lt;!--如果指定的文件存在，则激活profile。 --\u0026gt;\r\u0026lt;exists\u0026gt;${basedir}/file2.properties\u0026lt;/exists\u0026gt;\r\u0026lt;!--如果指定的文件不存在，则激活profile。 --\u0026gt;\r\u0026lt;missing\u0026gt;${basedir}/file1.properties\u0026lt;/missing\u0026gt;\r\u0026lt;/file\u0026gt;\r\u0026lt;/activation\u0026gt; 1.10、ActiveProfiles 作用：手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。如果没有匹配的profile，则什么都不会发生。 例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。\n\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\rhttps://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt;\r...\r\u0026lt;activeProfiles\u0026gt;\r\u0026lt;!-- 要激活的profile id --\u0026gt;\r\u0026lt;activeProfile\u0026gt;env-test\u0026lt;/activeProfile\u0026gt;\r\u0026lt;/activeProfiles\u0026gt;\r...\r\u0026lt;/settings\u0026gt; settings模板：\r\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;!--本地仓库--\u0026gt;\r\u0026lt;localRepository\u0026gt;~/.m2/repository\u0026lt;/localRepository\u0026gt;\r\u0026lt;!--Maven是否与用户交互,默认值为true--\u0026gt;\r\u0026lt;interactiveMode\u0026gt;true\u0026lt;/interactiveMode\u0026gt;\r\u0026lt;!--离线模式,默认值为false--\u0026gt;\r\u0026lt;offline\u0026gt;false\u0026lt;/offline\u0026gt;\r\u0026lt;!--插件组--\u0026gt;\r\u0026lt;pluginGroups\u0026gt;\u0026lt;/pluginGroups\u0026gt;\r\u0026lt;!--代理--\u0026gt;\r\u0026lt;proxies\u0026gt;\u0026lt;/proxies\u0026gt;\r\u0026lt;!--下载与部署仓库的认证信息--\u0026gt;\r\u0026lt;servers\u0026gt;\u0026lt;/servers\u0026gt;\r\u0026lt;!--仓库镜像--\u0026gt;\r\u0026lt;mirrors\u0026gt;\r\u0026lt;mirror\u0026gt;\r\u0026lt;id\u0026gt;bluebozRepo\u0026lt;/id\u0026gt;\r\u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt;\r\u0026lt;name\u0026gt;Blueboz\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;http://bluebozpc:8081/repository/maven-public/\u0026lt;/url\u0026gt;\r\u0026lt;/mirror\u0026gt;\r\u0026lt;/mirrors\u0026gt;\r\u0026lt;!--Settings Profile--\u0026gt;s\r\u0026lt;profiles\u0026gt;\u0026lt;/profiles\u0026gt;\r\u0026lt;!--激活Profile--\u0026gt;\r\u0026lt;activeProfiles\u0026gt;\u0026lt;/activeProfile\u0026gt;\r\u0026lt;/settings\u0026gt; Could not find artifact org.springframework.boot:spring-boot-maven-plugin:jar: in central (https://repo.maven.apache.org/maven2)\n"},{"id":272,"href":"/Tech/3Java/maven/Maven-5-%E4%BB%93%E5%BA%93/","title":"Maven 5 仓库","parent":"maven","content":" Maven 仓库 在 Maven 的术语中，仓库是一个位置（place）。\nMaven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。\n在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。\nMaven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。\nMaven 仓库有三种类型：\n本地（local） 中央（central） 远程（remote） 本地仓库 Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。\n运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。\n默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。\nMaven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\\conf 目录中的 Maven 的 settings.xml 文件中 localRepository 定义另一个路径。\n\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;localRepository\u0026gt;C:/MyLocalRepository\u0026lt;/localRepository\u0026gt;\r\u0026lt;/settings\u0026gt; 当你运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。\n中央仓库 Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。\n中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。\n中央仓库的关键概念：\n这个仓库由 Maven 社区管理。 不需要配置。 需要通过网络才能访问。\n远程仓库 如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。\n举例说明，使用下面的 pom.xml，Maven 将从远程仓库中下载该 pom.xml 中声明的所依赖的（在中央仓库中获取不到的）文件。\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34;\rxmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0\rhttp://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;com.companyname.projectgroup\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;project\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;com.companyname.common-lib\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;common-lib\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;repositories\u0026gt;\r\u0026lt;repository\u0026gt;\r\u0026lt;id\u0026gt;companyname.lib1\u0026lt;/id\u0026gt;\r\u0026lt;url\u0026gt;http://download.companyname.org/maven2/lib1\u0026lt;/url\u0026gt;\r\u0026lt;/repository\u0026gt;\r\u0026lt;repository\u0026gt;\r\u0026lt;id\u0026gt;companyname.lib2\u0026lt;/id\u0026gt;\r\u0026lt;url\u0026gt;http://download.companyname.org/maven2/lib2\u0026lt;/url\u0026gt;\r\u0026lt;/repository\u0026gt;\r\u0026lt;/repositories\u0026gt;\r\u0026lt;/project\u0026gt; Maven 依赖搜索顺序 当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：\n步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。 步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。 步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。 步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。 Maven 阿里云(Aliyun)仓库 Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。\n修改 maven 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：\n\u0026lt;mirror\u0026gt;\r\u0026lt;id\u0026gt;aliyunmaven\u0026lt;/id\u0026gt;\r\u0026lt;mirrorOf\u0026gt;*\u0026lt;/mirrorOf\u0026gt;\r\u0026lt;name\u0026gt;阿里云公共仓库\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;https://maven.aliyun.com/repository/public\u0026lt;/url\u0026gt;\r\u0026lt;/mirror\u0026gt; 如果想使用其它代理仓库，可在 节点中加入对应的仓库使用地址。以使用 spring 代理仓为例：\n\u0026lt;repository\u0026gt;\r\u0026lt;id\u0026gt;spring\u0026lt;/id\u0026gt;\r\u0026lt;url\u0026gt;https://maven.aliyun.com/repository/spring\u0026lt;/url\u0026gt;\r\u0026lt;releases\u0026gt;\r\u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt;\r\u0026lt;/releases\u0026gt;\r\u0026lt;snapshots\u0026gt;\r\u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt;\r\u0026lt;/snapshots\u0026gt;\r\u0026lt;/repository\u0026gt; 在你的 pom.xml 文件 节点中加入你要引用的文件信息：\n\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;[GROUP_ID]\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;[ARTIFACT_ID]\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;[VERSION]\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt; "},{"id":273,"href":"/Tech/3Java/maven/Maven-6-%E6%8F%92%E4%BB%B6/","title":"Maven 6 插件","parent":"maven","content":" Maven 插件 Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：\n创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告 关键概念： 插件是在 pom.xml 中使用 plugins 元素定义的。 每个插件可以有多个目标。 你可以定义阶段，插件会使用它的 phase 元素开始处理。我们已经使用了 clean 阶段。 你可以通过绑定到插件的目标的方式来配置要执行的任务。我们已经绑定了 echo 任务到 maven-antrun-plugin 的 run 目标。 就是这样，Maven 将处理剩下的事情。它将下载本地仓库中获取不到的插件，并开始处理。 "},{"id":274,"href":"/Tech/3Java/maven/Maven-7-%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0jar/","title":"Maven 7 引入本地jar","parent":"maven","content":" Maven 引入本地 jar pom.xml 的 dependencies 列表列出了我们的项目需要构建的所有外部依赖项。\n要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。\n然后添加以下依赖到 pom.xml 文件中：\n\u0026lt;dependencies\u0026gt;\r\u0026lt;!-- 在这里添加你的依赖 --\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;ldapjdk\u0026lt;/groupId\u0026gt; \u0026lt;!-- 库名称，也可以自定义 --\u0026gt;\r\u0026lt;artifactId\u0026gt;ldapjdk\u0026lt;/artifactId\u0026gt; \u0026lt;!--库名称，也可以自定义--\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;!--版本号--\u0026gt;\r\u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;!--作用域--\u0026gt;\r\u0026lt;systemPath\u0026gt;${basedir}\\src\\lib\\ldapjdk.jar\u0026lt;/systemPath\u0026gt; \u0026lt;!--项目根目录下的lib文件夹下--\u0026gt;\r\u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; pom.xml 文件完整代码如下：\n\u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\rxsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\u0026#34;\u0026gt;\r\u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\r\u0026lt;groupId\u0026gt;com.companyname.bank\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;consumerBanking\u0026lt;/artifactId\u0026gt;\r\u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;\r\u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt;\r\u0026lt;name\u0026gt;consumerBanking\u0026lt;/name\u0026gt;\r\u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt;\r\u0026lt;dependencies\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt;\r\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;ldapjdk\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;ldapjdk\u0026lt;/artifactId\u0026gt;\r\u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt;\r\u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt;\r\u0026lt;systemPath\u0026gt;${basedir}\\src\\lib\\ldapjdk.jar\u0026lt;/systemPath\u0026gt;\r\u0026lt;/dependency\u0026gt;\r\u0026lt;/dependencies\u0026gt;\r\u0026lt;/project\u0026gt; "},{"id":275,"href":"/Tech/3Java/maven/Maven-8-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/","title":"Maven 8 项目模板","parent":"maven","content":""},{"id":276,"href":"/Tech/3Java/maven/Maven-9-%E5%BF%AB%E7%85%A7SNAPSHOT/","title":"Maven 9 快照( SNA Pshot)","parent":"maven","content":" Maven 快照(SNAPSHOT) 什么是快照? 快照是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。 现在 data-service 团队会每次发布更新代码的快照到仓库中，比如说 data-service:1.0-SNAPSHOT 来替代旧的快照 jar 包。\n项目快照 vs 版本 对于版本，如果 Maven 以前下载过指定的版本文件，比如说 data-service:1.0，Maven 将不会再从仓库下载新的可用的 1.0 文件。若要下载更新的代码，data-service 的版本需要升到1.1。\n快照的情况下，每次 app-ui 团队构建他们的项目时，Maven 将自动获取最新的快照(data-service:1.0-SNAPSHOT)。\nSNAPSHOT作用： 标识这个jar是一个不稳定的jar，是一个标识版本的作用。\n使用了SNAPSHOT之后，maven会经常去私服或是中央仓库中拉取最新 的这个jar的版本；而没有SNAPSHOT的jar，则会从本地仓库中查找，本地不存在，才去中央仓库中拉取。\n更新频率：需要在pom.xml文件中进行配置。 updatePolicy: always代表经常性的去拉取最新的jar， daily代表每天拉取一次，interval： 分钟； nerver： 和正式版本一致，不会去拉取最新的jar。\n\u0026lt;repositorys\u0026gt;\r\u0026lt;repository\u0026gt;\r\u0026lt;id\u0026gt;****\u0026lt;/id\u0026gt;\r\u0026lt;url\u0026gt;***\u0026lt;/url\u0026gt;\r\u0026lt;snapshots\u0026gt;\r\u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt;\r\u0026lt;updatePolicy\u0026gt;(always/ daliy/ interval/ nrever)\u0026lt;/updatePolicy\u0026gt;\r\u0026lt;/snapshot\u0026gt;\r\u0026lt;/repository\u0026gt;\r\u0026lt;/repository\u0026gt; Maven 中的仓库分为两种，snapshot 快照仓库和 release 发布仓库。 snapshot 快照仓库用于保存开发过程中的不稳定版本， release 正式仓库则是用来保存稳定的发行版本。 定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写) maven2 会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本。如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。\n在java开发过程中，我们经常会看到代码仓库中的某些项目版本以release或snapshots结尾,现在说说这两个版本之间有什么区别.\n一般来说 snapshots 版本代表正在开发中的版本,release 代表比较稳定的发布版本.\n-SNAPSHOT 表示该版本是快照版本,一般处于开发阶段,0.0.1版本还有功能没有完成,或还有bug还要修复,所以这个阶段一般代码更新比较频繁,开发人员写完代码会直接提交到代码仓库,这样之前依赖0.0.1-SNAPSHOT版本的开发人员也可以马上更新代码. -Release 表示是稳定版的,这次迭代的所有功能都已经完成,并且通过了测试之后,就可以发布为0.0.1-Release版本,Release版的一旦发布，就不要再改变代码了,所以如果之后在0.0.1-Release这个版本上发现了bug,需要修复,那么我们应该将0.0.1-Release版本改为0.0.2-SNAPSHOT,然后再修改bug并测试,没问题之后将0.0.2-SNAPSHOT改为0.0.2-Release发布. 使用maven的时候maven会根据pom文件中的version中是否带有-SNAPSHOT来判断是否是快照版本。如果是快照版本，在maven deploy时会发布到快照版本库中,依赖该版本的项目在编译打包时，maven会自动从maven仓库下载新的快照版本。如果是正式发布版本,deploy时会自动发布到正式版本库中，依赖该版本的项目在编译打包时如果本地已经存在该版本的工程默认不会从maven仓库下载新的版本.\n所以如果现在开发的项目依赖了另外一个项目,如果不希望出现本来运行的好好地,过了一会儿因为依赖项目的更新突然不能运行了,那么可以选择依赖一个 Release 版本(如果有的话).\n"},{"id":277,"href":"/Tech/3Java/maven/Maven/","title":"Maven","parent":"maven","content":" Maven 转自：Apache Maven\n链接：https://maven.apache.org/index.html\nMaven 生命周期\n1、clean ：清理上一次构建生成的所有文件；\r2、validate\r3、compile ：编译项目的源代码；\r4、test ：运行测试代码；\r5、package ：打包成jar或者war或者其他格式的分发包；\r6、verify\r7、install ：将打好的包安装到本地仓库，供其他项目使用；\r8、site ：生成项目的站点文档；\r9、deploy ：将打好的包安装到远程仓库，供其他项目使用； Maven 目录分析\n1:Maven 目录分析\rbin：含有mvn运行的脚本\rboot：含有plexus-classworlds类加载器框架\rconf：含有settings.xml配置文件\rlib：含有Maven运行时所需要的java类库\rSettings.xml 中默认的用户库: ${user.home}/.m2/repository[通过maven下载的jar包都会存储到指定的个人仓库中]\rMaven默认仓库下载地址在: maven的lib目录下maven-model-builder-3.0.4.jar的pom.xml中 IDEA 自带 Maven 配置\n标签： Java\r环境变量\r在环境变量的系统变量中添加\rMAVEN_HOME：F:\\IntelliJ IDEA 2019.2.3\\plugins\\maven\\lib\\maven3（你的maven所在位置）\rMAVEN_OPTS：-Xms128m -Xmx1024m\r在环境变量的用户变量中的Path中添加：%MAVEN_HOME%\\bin Maven 创建项目目录结构\nmy-app\r|-- pom.xml\r`-- src\r|-- main\r| `-- java\r| `-- com\r| `-- mycompany\r| `-- app\r| `-- App.java\r`-- test\r`-- java\r`-- com\r`-- mycompany\r`-- app\r`-- AppTest.java 2：创建目录结构：\rHello\r--src -----main\r----------java --用来存放Java文件\r----------resources --用来存放资源文件\r----------webapp/WEB-INF --web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面\r-----test\r---------java --用来存放测试的Java文件\r---------resources\r--target --项目输出位置,编译完毕后自动生成\r-----classes --编译输出目录\r-----test-classes --测试编译输出目录\r--pom.xml -- 项目对象模型的描述 ，它是maven配置的核心 Maven 核心概念\n5:Maven核心概念：\r5.1：Maven插件\rMaven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的每个插件都能实现多个功能，每个功能就是一个插件目标\rMaven的生命周期与插件目标相互绑定，以完成某个具体的构建任务, Maven的插件在: .m2\\org\\apache\\maven\\plugins\r5.2：Maven坐标\r类似在平面几何中坐标（x,y）可以标识平面中唯一的一点, Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范\r拥有了统一规范，就可以把查找工作交给机器\rgroupId：定义当前Maven项目隶属项目 (实际对应JAVA的包的结构, 是main目录里java的目录结构)\rartifactId：定义实际项目中的一个模块(项目的唯一的标识符,实际对应项目的名称,就是项目根目录的名称)\rversion：定义当前项目的当前版本\r5.3：Maven仓库\r何为Maven仓库：用来统一存储所有Maven共享构建的位置就是仓库\rMaven配置jar包的路径为：groupId/artifactId/version/artifactId-version\r本地仓库(~/.m2/repository/)：每个用户只有一个本地仓库\r中央仓库(Maven默认的远程仓库)：Maven默认的远程仓库下载地址为：http://repo1.maven.org/maven2\r私服：是一种特殊的远程仓库, 它是架设在局域网内的仓库, 主要是为了团队协作开发\r镜像：用来替代中央仓库, 速度一般比中央仓库快\r5.4：软件构建生命周期,maven软件构建的生命周期\r清除--\u0026gt; 编译--\u0026gt;测试--\u0026gt;报告--\u0026gt;打包（jar\\war）--\u0026gt;安装--\u0026gt;部署。\rmaven生命周期命令插件（命令：mvn clean）：clean--compile--test--package--install-deploy。\rmaven坐标：maven通过坐标的概念来唯一标识jar包或者war包 maven 仓库类型 我们在 nexus 私服或其他 maven 库看仓库类型有hosted、proxy、group\n项目 具体说明 hosted 本地存储。像官方仓库一样提供本地私库功能 proxy 提供代理其它仓库的类型 group 组类型，能够组合多个仓库为一个地址提供服务 "},{"id":278,"href":"/Tech/3Java/maven/%E6%B8%85%E9%99%A4lastUpdated%E6%96%87%E4%BB%B6/","title":"清除last Updated文件","parent":"maven","content":" maven:清除lastUpdated文件 项目使用maven管理jar包，很容易因为各种原因(网速慢、断网)导致jar包下载不下来，出现很多.lastUpdated文件。这些文件一个一个删除太麻烦。下面是全部删除的方法\nwindows系统\ncd %userprofile%\\.m2\\repository\rfor /r %i in (*.lastUpdated) do del %i linux系统\nfind /app/maven/localRepository -name \u0026#34;*.lastUpdated\u0026#34; -exec grep -q \u0026#34;Could not transfer\u0026#34; {} \\; -print -exec rm {} \\; 删除 Maven 下载的半成品\ncd %userprofile%\\.m2\\repository for /r %i in (*.lastUpdated) do del %i 唉，大数据本意是能有效处理巨量信息，比如一个几万人的小区水电煤气、蔬菜、粮食、医药资源、如果被封控了怎么进行资源、运力、人力、调配补给，在哪些地点设置核酸检测点能有效的减少时间资源浪费（几千几万人去检测，他们利用这些时间无论是工作还是休闲娱乐，都比在排队上面有价值），比如卖家通过分析过去一年中的几百万订单货品，在全国各地分配分仓货品设置\n"},{"id":279,"href":"/Tech/3Java/MQ/RabbitMQ-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"Rabbit Mq 1 基本概念","parent":"MQ","content":""},{"id":280,"href":"/Tech/3Java/MQ/RabbitMQ-2-%E5%AE%89%E8%A3%85/","title":"Rabbit Mq 2 安装","parent":"MQ","content":" 安装在基于 RPM 的 Linux 上（RedHat Enterprise Linux、CentOS、Fedora、openSUSE） 使用 Docker 映像，安装 RabbitMQ 服务器 转自：官方教程\n链接：https://registry.hub.docker.com/_/rabbitmq/\nHow to use this image Running the daemon 关于 RabbitMQ 需要注意的重要事项之一是，它根据所谓的“节点名称”存储数据，该名称默认为主机名。对于 Docker 中的使用，这意味着我们应该为每个守护进程指定 / 显式，这样我们就不会获得随机主机名并可以跟踪我们的数据：-h--hostname\n$ docker run -d --hostname my-rabbit --name some-rabbit rabbitmq:3 这将启动侦听默认端口 5672 的 RabbitMQ 容器。如果你给它一分钟，然后做，你会在输出中看到一个类似于：docker logs some-rabbit\n=INFO REPORT==== 6-Jul-2015::20:47:02 ===\rnode : rabbit@my-rabbit\rhome dir : /var/lib/rabbitmq\rconfig file(s) : /etc/rabbitmq/rabbitmq.config\rcookie hash : UoNOcDhfxW9uoZ92wh6BjA==\rlog : tty\rsasl log : tty\rdatabase dir : /var/lib/rabbitmq/mnesia/rabbit@my-rabbit 请注意那里，特别是它将我的“节点名称”附加到文件存储的末尾。默认情况下，此映像使所有卷全部生效。database dir/var/lib/rabbitmq\n环境变量 有关 RabbitMQ 本身支持的环境变量列表，请参阅 rabbitmq.com/configure\n警告：从 RabbitMQ 3.9 开始，下面列出的所有特定于 docker 的变量都已弃用，不再使用。请改用配置文件;请访问 rabbitmq.com/configure 以了解有关配置文件的更多信息。首先，3.8 映像将打印出它从提供的环境变量生成的配置文件。\n# Unavailable in 3.9 and up\rRABBITMQ_DEFAULT_PASS_FILE\rRABBITMQ_DEFAULT_USER_FILE\rRABBITMQ_MANAGEMENT_SSL_CACERTFILE\rRABBITMQ_MANAGEMENT_SSL_CERTFILE\rRABBITMQ_MANAGEMENT_SSL_DEPTH\rRABBITMQ_MANAGEMENT_SSL_FAIL_IF_NO_PEER_CERT\rRABBITMQ_MANAGEMENT_SSL_KEYFILE\rRABBITMQ_MANAGEMENT_SSL_VERIFY\rRABBITMQ_SSL_CACERTFILE\rRABBITMQ_SSL_CERTFILE\rRABBITMQ_SSL_DEPTH\rRABBITMQ_SSL_FAIL_IF_NO_PEER_CERT\rRABBITMQ_SSL_KEYFILE\rRABBITMQ_SSL_VERIFY\rRABBITMQ_VM_MEMORY_HIGH_WATERMARK 设置默认用户和密码 如果要更改 / 的默认用户名和密码，可以使用 和 环境变量执行此操作。这些变量以前在特定于 docker 的入口点 shell 脚本中可用，但现在可以直接在 RabbitMQ 中使用。guest guest RABBITMQ_DEFAULT_USER RABBITMQ_DEFAULT_PASS\n$ docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-management $ docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=adm1n@Dl7w4r rabbitmq:3-management 然后，您可以转到或在浏览器中使用 / 访问管理控制台 http://localhost:8080 http://host-ip:8080 user password\n注意①： 上面的 docker run 没有指定 -p，最好是删除 Containers ，重新从 Images 启动时设置好 端口映射\n注意②： 上面的 docker run 指定的账号密码未生效（待确认原因），实际观察日志可以看到 账号是：guest，密码是：guest。\n设置默认虚拟主机 如果要更改默认虚拟主机，可以使用环境变量执行此操作：RABBITMQ_DEFAULT_VHOST\n$ docker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost rabbitmq:3-management "},{"id":281,"href":"/Tech/3Java/MQ/RabbitMQ-3-Java-client-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","title":"Rabbit Mq 3 Java Client 源码分析","parent":"MQ","content":""},{"id":282,"href":"/Tech/3Java/MQ/RabbitMQ-4-%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/","title":"Rabbit Mq 4 应用、工具及二次开发","parent":"MQ","content":""},{"id":283,"href":"/Tech/3Java/MQ/RabbitMQ-5-%E5%85%B6%E5%AE%83/","title":"Rabbit Mq 5 其它","parent":"MQ","content":""},{"id":284,"href":"/Tech/3Java/MQ/RabbitMQ/","title":"Rabbit Mq","parent":"MQ","content":" RabbitMQ 标签：RabbitMQ、基础、RabbitMQ、源码解读、进阶、Java开源框架\r时间：2018年11月12日18:43:58 以下这些教程介绍了使用 RabbitMQ 创建消息传递应用程序的基础知识。您需要安装RabbitMQ服务器才能完成教程，请参阅安装指南部分。\rMQ概述\rMQ的使用场景大概包括解耦，异步消息，提高峰值处理能力，送达和排序保证，缓冲等。\rRabbitMQ是一个消息代理：它接受和转发消息。消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。\r涉及名称、\r竞争消费者：\r在单个渠道上创建多个竞争消费者，以便消费者可以同时处理多个消息。竞争消费者是多个消费者，他们都是为了从单个点对点频道接收消息而创建的。当频道传递消息时，任何消费者都可能接收消息。消息传递系统的实现确定哪个消费者实际接收消息，但实际上消费者彼此竞争成为接收者。消费者收到消息后，可以委托其应用程序的其余部分来帮助处理消息。（此解决方案仅适用于点对点通道 ; 发布 - 订阅通道上的多个使用者只需为每条消息创建更多副本。）\r工作队列：（又称：任务队列）背后的主要思想是避免立即执行资源密集型任务，并且必须等待它完成。相反，我们安排任务稍后完成。我们将任务封装 为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当您运行许多工作程序时，它们之间将共享任务。\r生产者：消息发送者，在MQ中被称为生产者（producer），一个发送消息的应用也被叫做生产者，用P表示。\r消费者：生产者“生产”出消息后，最终由谁消费呢？等待接受消息的应用程序，我们称之为消费者（Consuming ），用C表示。\r算了！ 算了！直接再读开发文档吧，也花不了多少时间。\rhttp://www.rabbitmq.com/getstarted.html\rhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html\r一个 非常重要！！！ 的经验总结：\r生产者：在 信道 basicPublish 中 需指定 交换器（exchange）和 路由键（routingKey）；\r消费者：在 信道 basicConsume 中 需指定 队列（queue），所以 消费者 在 basicConsume 之前 要通过 queueBind 绑定： 队列（queue）、交换器（exchange）和 路由键（routingKey）。\r"},{"id":285,"href":"/Tech/3Java/MyBatis/Mybatis-%E6%8F%92%E4%BB%B6/","title":"Mybatis 插件","parent":"MyBatis","content":" Mybatis 插件 Mybatis 插件可以在 DAO 层进行拦截，如打印执行的 SQL 语句日志，做一些权限控制，分页等功能；\nMybatis 插件典型适用场景 分页功能 mybatis 的分页默认是基于内存分页的（查出所有，再截取），数据量大的情况下效率较低，不过使用mybatis插件可以改变该行为，只需要拦截 StatementHandler 类的 prepare方法，改变要执行的SQL语句为分页语句即可；\n公共字段统一赋值 一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在DAO层统一拦截处理，可以用mybatis插件拦截Executor类的update方法，对相关参数进行统一赋值即可；\n性能监控 对于SQL语句执行的性能监控，可以通过拦截 Executor 类的 update, query 等方法，用日志记录每个方法执行的时间；\nMybatis 插件介绍 什么是Mybatis插件 与其称为Mybatis插件，不如叫Mybatis拦截器，更加符合其功能定位，实际上它就是一个拦截器，应用代理模式，在方法级别上进行拦截\n支持拦截的方法 执行器Executor（update、query、commit、rollback等方法）； 参数处理器ParameterHandler（getParameterObject、setParameters方法）； 结果集处理器ResultSetHandler（handleResultSets、handleOutputParameters等方法）； SQL语法构建器StatementHandler（prepare、parameterize、batch、update、query等方法）； 拦截阶段 那么这些类上的方法都是在什么阶段被拦截的呢？为理解这个问题，我们先看段简单的代码（摘自 mybatis 源码中的单元测试 SqlSessionTest 类），来了解下典型的 mybatis 执行流程，如下代码所示：\n以上代码主要完成以下功能：\n读取mybatis的xml配置文件信息 通过SqlSessionFactoryBuilder创建SqlSessionFactory对象 通过SqlSessionFactory获取SqlSession对象 执行SqlSession对象的selectList方法，查询结果 关闭SqlSession 如下是时序图，在整个时序图中，涉及到mybatis插件部分已标红，基本上就是体现在上文中提到的四个类上，对这些类上的方法进行拦截。\nMybatis 插件实现机制 先来看下mybatis是如何加载插件配置的，对应的xml配置信息如下：\n对应的解析代码如下，主要做以下工作：\n根据解析到的类信息创建 Interceptor 对象； 调用 setProperties 方法设置属性变量； 添加到 Configuration 的 interceptorChain 拦截器链中； 以上逻辑对应的时序图如下：\n代理对象的生成 Mybatis 插件的实现机制主要是基于动态代理实现的，其中最为关键的就是代理对象的生成，所以有必要来了解下这些代理对象是如何生成的。\nExecutor 代理对象 ParameterHandler代理对象 ResultSetHandler代理对象 StatementHandler代理对象 观察源码，发现这些可拦截的类对应的对象生成都是通过InterceptorChain的pluginAll方法来创建的，进一步观察pluginAll方法，如下：\n遍历所有拦截器，调用拦截器的plugin方法生成代理对象，注意生成代理对象重新赋值给target，所以如果有多个拦截器的话，生成的代理对象会被另一个代理对象代理，从而形成一个代理链条，执行的时候，依次执行所有拦截器的拦截逻辑代码；\n接下来看一下我们在编写拦截器的时候，一个典型的plugin方法实现方式，如下：\n再进一步查看wrap方法，如下：\n典型的动态代理实现，调用的是Proxy.newProxyInstance方法来生成代理对象。\n以上逻辑对应的时序图如下，这里我们假设声明了两个拦截器，那么在创建target代理对象的时候，最终返回的代理对象proxy2，实际上代理了proxy1，而proxy1又代理了target，：\n拦截逻辑的执行 由于真正去执行 Executor、ParameterHandler、ResultSetHandler和StatementHandler 类中的方法的对象是代理对象（建议将代理对象转为 class 文件，反编译查看其结构，帮助理解），所以在执行方法时，首先调用的是 Plugin 类（实现了InvocationHandler 接口）的 invoke 方法，如下： 首先根据执行方法所属类获取拦截器中声明需要拦截的方法集合； 判断当前方法需不需要执行拦截逻辑，需要的话，执行拦截逻辑方法（即 Interceptor 接口的 intercept 方法实现），不需要则直接执行原方法。\n可以关注下Interceptor接口的intercept方法实现，一般需要用户自定义实现逻辑，其中有一个重要参数，即Invocation类，通过改参数我们可以获取执行对象，执行方法，以及执行方法上的参数，从而进行各种业务逻辑实现，一般在该方法的最后一句代码都是invocation.proceed()（内部执行method.invoke方法），否则将无法执行下一个拦截器的intercept方法。\n以上逻辑对应的时序图如下，这里我们以执行executor对象的query方法为例，且假设有两个拦截器存在：\nMybatis 插件开发例子 这里以分页插件为例，来了解下一般mybatis插件的编写规则，如下所示：\n主要需要实现三个方法\nintercept:在此实现自己的拦截逻辑，可从 Invocation 参数中拿到执行方法的对象，方法，方法参数，从而实现各种业务逻辑, 如下代码所示，从 invocation 中获取的 statementHandler 对象即为被代理对象，基于该对象，我们获取到了执行的原始SQL语句，以及 prepare 方法上的分页参数，并更改SQL语句为新的分页语句，最后调用 invocation.proceed()返回结果。 plugin：生成代理对象； setProperties：设置一些属性变量； 小结 简单的说，mybatis 插件就是对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，先去执行代理对象的方法，从而执行自己编写的拦截逻辑，所以真正要用好 mybatis 插件，主要还是要熟悉这四个接口的方法以及这些方法上的参数的含义；\n另外，如果配置了多个拦截器的话，会出现层层代理的情况，即代理对象代理了另外一个代理对象，形成一个代理链条，执行的时候，也是层层执行；\n关于mybatis插件涉及到的设计模式和软件思想如下：\n设计模式：代理模式、责任链模式； 软件思想：AOP编程思想，降低模块间的耦合度，使业务模块更加独立； 一些注意事项：\n不要定义过多的插件，代理嵌套过多，执行方法的时候，比较耗性能； 拦截器实现类的 intercept 方法里最后不要忘了执行 invocation.proceed() 方法，否则多个拦截器情况下，执行链条会断掉； 番外：本地实践 import com.yestae.framework.search.aop.core.CoreMapperAnnotationProcessor; import org.aopalliance.intercept.Interceptor; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.EnableAspectJAutoProxy; import org.springframework.core.Ordered; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; /** * 拦截@Mapper注解的接口的所有方法 * * @author: xiexindong * @date: 2020-08-13 20:41 */ @Aspect @Component @Order(CoreMapperMethodInterceptor.ORDER) @EnableAspectJAutoProxy(proxyTargetClass = true) public class CoreMapperMethodInterceptor implements Interceptor, Ordered { public static final int ORDER = 0; @Autowired private CoreMapperAnnotationProcessor coreMapperAnnotationProcessor; @Override public int getOrder() { return CoreMapperMethodInterceptor.ORDER; } /** * 拦截处理所有mapper方法 * * @param proceedingJoinPoint * @return * @throws Throwable */ @Around(\u0026#34;@within(org.apache.ibatis.annotations.Mapper)\u0026#34;) public Object invokeMapperAllMethod(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { return coreMapperAnnotationProcessor.process(proceedingJoinPoint); } } "},{"id":286,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-%E6%95%99%E7%A8%8B1/","title":"My Batis 教程1","parent":"MyBatis 教程","content":" MyBatis 教程1.md 学习自：\nhttp://www.mybatis.cn/mybatis/28.html\nMyBatis 基本功能 1、建立数据库连接，获得 Connection 对象。 2、根据用户的输入组装查询 SQL 语句。 3、根据 SQL 语句建立 Statement 对象 或者 PreparedStatement 对象。 4、用 Connection 对象执行 SQL语句，获得结果集 ResultSet 对象。 5、然后一条一条读取结果集 ResultSet 对象中的数据。 6、根据读取到的数据，按特定的业务逻辑进行计算。 7、根据计算得到的结果再组装更新 SQL 语句。 8、再使用 Connection 对象执行更新 SQL 语句，以更新数据库中的数据。 7、最后依次关闭各个 Statement 对象和 Connection 对象。 MyBatis 工作原理 对JDBC进行了封装\nMyBatis 的核心组件 1、SQLSessionFactoryBuilder(构造器):它会根据配置信息或者代码生成SqlSessionFactory。 2、SqlSessionFactory(工厂接口)：依靠工厂生成SqlSession。 3、SqlSession(会话)：是一个既可以发送SQL去执行并且返回结果，也可以获取Mapper接口。 4、SQL Mapper:是由一个JAVA接口和XML文件(或注解)构成，需要给出对应的SQL和映射规则。SQL是由Mapper发送出去，并且返回结果。 "},{"id":287,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-1-select-%E6%A0%87%E7%AD%BE/","title":"My Batis 1 Select 标签","parent":"MyBatis 教程","content":"在MyBatis中实现SQL映射的常见标签有：\nselect标签（映射查询语句）、 insert标签（映射插入语句）、 update标签（映射更新语句）、 delete标签（映射删除语句）、 sql标签（可被其他语句引用的可重用语句块） select标签的属性介绍 \u0026lt;select\rid=\u0026#34;selectUser\u0026#34;\rparameterType=\u0026#34;int\u0026#34;\rresultType=\u0026#34;hashmap\u0026#34;\rresultMap=\u0026#34;userResultMap\u0026#34;\rflushCache=\u0026#34;false\u0026#34;\ruseCache=\u0026#34;true\u0026#34;\rtimeout=\u0026#34;10000\u0026#34;\rfetchsize=\u0026#34;256\u0026#34;\rstatementType=\u0026#34;PREPARED\u0026#34;\rresultsetType=\u0026#34;FORMARD ONLY\u0026#34;\u0026gt; id：命名空间中唯一的标识符，可以被用来引用这条语句。\nparameterType：将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为MyBatis可以通过TypeHandler推断出具体传入语句的参数，默认值为unset。\nresultType：从这条语句中返回的期望类型的类的完全限定名或别名。\n注意：如果返回值是集合类型，那应该是集合可以包含的类型，而不能是集合本身的类型。返回时可以使用resultType或resultMap，但不能同时使用。\nresultMap：外部resultMap的命名引用。结果集的映射是MyBatis最强大的特性，许多复杂映射的情形都能通过resultMap迎刃而解。返回时可以使用resultMap 或resultType，但不能同时使用。\nflushCache：如果设置为true，则任何时候只要语句被调用，都会导致本地缓存和二级缓存都被清空，默认值为false。\nuseCache：如果设置为true，将会导致本条语句的结果被二级缓存，在select标签当中默认值为true。\ntimeout：驱动程序等待数据库返回请求结果的等待秒数，超时则抛出异常。默认值为unset (依赖驱动)。\nfetchSize：驱动程序每次批量返回的结果行数。默认值为unset (依赖驱动)。\nstatementType：值为STATEMENT、PREPARED 或CALLABLE。这会让MyBatis分别使用JDBC中的Statement、PreparedStatement或CallableStatement，默认值为PREPARED。\nresultSetType：结果集的类型，值为FORWARD_ONLY、SCROLL_SENSITIVE 或SCROLLINSENSITIVE，默认值为unset (依赖驱动)。\ndatabaseId：如果配置了databaseIdProvider，MyBatis会加载所有的不带databaseId或匹配当前databaseId的语句。如果带或者不带的语句都有，则不带的会被忽略。\nresultOrdered：这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。\nresultSets：这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。\n"},{"id":288,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-2-sql-%E6%A0%87%E7%AD%BE/","title":"My Batis 2 SQL 标签","parent":"MyBatis 教程","content":" MyBatis-2-sql 标签 sql元素可以被用来定义可重用的SQL代码段，可以包含在其他语句中。它可以被静态地(在加载参数时) 参数化。不同的属性值通过包含的实例发生变化。例如:\n\u0026lt;sql id=\u0026#34;userColumns\u0026#34;\u0026gt; ${alias}.id,${alias}.username,${alias}.password \u0026lt;/sql\u0026gt; 取值的正确方式是${prop},而不是#{prop}\n这个SQL片段可以被包含在其他语句中，例如:\n\u0026lt;select id=\u0026#34;selectUsers\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt;\rselect\r\u0026lt;include refid=\u0026#34;userColumns\u0026#34; \u0026gt;\u0026lt;property name=\u0026#34;alias\u0026#34; value=\u0026#34;t1\u0026#34; /\u0026gt;\u0026lt;/include\u0026gt;\rfrom some_table tl\r\u0026lt;/select\u0026gt; 注意观察在include 标签内引用时，通过property标签动态给alias赋值\n属性值可以用于包含的refid属性或者包含的字句里面的属性，例如:\n\u0026lt;sql id=\u0026#34;sometable\u0026#34;\u0026gt;\r${prefix}Table\r\u0026lt;/sql\u0026gt;\r\u0026lt;sql id=\u0026#34;someinclude\u0026#34;\u0026gt;\rfrom\r\u0026lt;include refid=\u0026#34;${include_target}\u0026#34;/\u0026gt;\r\u0026lt;/sql\u0026gt;\r\u0026lt;select id=\u0026#34;select\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt;\rselect\rfieldl,field2,field3\r\u0026lt;include refid=\u0026#34;someinclude\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;some\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34; include_target \u0026#34;value=\u0026#34;sometable\u0026#34; /\u0026gt;\r\u0026lt;/include\u0026gt;\r\u0026lt;/select\u0026gt; "},{"id":289,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-3-Transaction-%E4%BA%8B%E5%8A%A1%E6%8E%A5%E5%8F%A3/","title":"My Batis 3 Transaction 事务接口","parent":"MyBatis 教程","content":" MyBatis Transaction 事务接口 Mybatis提供了一个事务接口Transaction以及两个实现类jdbcTransaction和ManagedTransaction。\nJdbcTransaction：单独使用Mybatis时，默认的事务管理实现类，就和它的名字一样，它就是我们常说的JDBC事务的极简封装，和编程使用mysql-connector-java-5.1.38-bin.jar事务驱动没啥差别。其极简封装，仅是让connection支持连接池而已。\nManagedTransaction：含义为托管事务，空壳事务管理器，皮包公司。仅是提醒用户，在其它环境中应用时，把事务托管给其它框架，比如托管给Spring，让Spring去管理事务。\n事务工厂 TransactionFactory SpringManagedTransaction 当Spring与Mybatis一起使用时，Spring提供了一个实现类 SpringManagedTransaction。它其实也是通过使用JDBC来进行事务管理的，当Spring的事务管理有效时，不需要操作commit、rollback、close，Spring事务管理会自动帮我们完成。\n配置事务管理方式 mybatis-config.xml 配置文件内，可配置事务管理类型。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt;\r\u0026lt;!--配置事务的管理方式--\u0026gt;\r\u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34; /\u0026gt;\r\u0026lt;!-- 配置数据库连接信息 --\u0026gt;\r\u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34; /\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34; /\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34; /\u0026gt;\r\u0026lt;/dataSource\u0026gt;\r\u0026lt;/environment\u0026gt;\r\u0026lt;/environments\u0026gt; \u0026lt;/configuration\u0026gt; "},{"id":290,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-4-SqlSessionFactory/","title":"My Batis 4 SQL Session Factory","parent":"MyBatis 教程","content":" MyBatis SqlSessionFactory 1、SqlSessionFactory 简介 SqlSessionFactory是MyBatis中的一个重要的对象，它是用来创建SqlSession对象的，而SqlSession用来操作数据库的。\n2、SqlSessionFactory 生成 SqlSessionFactory对象可以通过SqlSessionFactoryBuilder来获得，而SqlSessionFactoryBuildr则可以从XML配置文件或预先定制的Configuration实例构建出SqlSessionFactory的实例。\nSqlSessionFactory是线程安全的，它一旦被创建，应该在应用执行期间都存在。在应用运行期间不要重复创建多次，建议使用单例模式。\n关于SqlSessionFactory和SqlSession两个对象给一个具体的使用过程:\nimport java.io.IOException; import java.io.InputStream; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.cn.entity.User; public class MyBatisTest { public static void main(String[] args) { try { //读取mybatis-config.xml文件 InputStream resourceAsStream = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); //初始化mybatis,创建SqlSessionFactory类的实例 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //创建session实例 SqlSession session = sqlSessionFactory.openSession(); /* * 接下来在这里做很多事情,到目前为止,目的已经达到得到了SqlSession对象.通过调用SqlSession里面的方法, * 可以测试MyBatis和Dao层接口方法之间的正确性,当然也可以做别的很多事情,在这里就不列举了 */ //插入数据 User user = new User(); user.setC_password(\u0026#34;123\u0026#34;); user.setC_username(\u0026#34;123\u0026#34;); user.setC_salt(\u0026#34;123\u0026#34;); //第一个参数为方法的完全限定名:位置信息+映射文件当中的id session.insert(\u0026#34;com.cn.dao.UserMapping.insertUserInformation\u0026#34;, user); //提交事务 session.commit(); //关闭session session.close(); } catch (IOException e) { e.printStackTrace(); } } } "},{"id":291,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-5-SqlSession/","title":"My Batis 5 SQL Session","parent":"MyBatis 教程","content":" MyBatis SqlSession SqlSession 是 MyBatis 的关键对象，通过这个接口可以操作命令，管理事务等。\n注意：虽然SqlSession提供select/insert/update/delete方法，在旧版本中使用使用SqlSession接口的这些方法，但是新版的Mybatis中就会建议使用Mapper接口的方法。\n1.1、SqlSession旧版本用法： Person p = session.selectOne(\u0026#34;cn.mybatis.mydemo.mapper.PersonMapper.selectPersonById\u0026#34;, 1); 1.2、SqlSession新版本用法（推荐用法）： // 获得mapper接口的代理对象\rPersonMapper pm = session.getMapper(PersonMapper.class);\r// 直接调用接口的方法，查询id为1的Peson数据\rPerson p = pm.selectPersonById(1); 2、MyBatis的SqlSession与JDBC的Connection对比 SqlSession对象，该对象中包含了执行SQL语句的所有方法，类似于JDBC里面的Connection。这种“类似”体现在以下几个方面：\n（1）在JDBC中，Connection不直接执行SQL方法，而是生成Statement或者PrepareStatement对象，利用Statement或者PrepareStatement来执行增删改查方法。 （2）在MyBatis中，SqlSession可以直接执行增删改查方法，例如： T selectOne(String statement);int insert(String statement, Object parameter);等，也可以获取映射器Mapper： T getMapper(Class type);然后通过映射器来执行增删改查操作。如下代码所示： // 获得mapper接口的代理对象\rPersonMapper pm = session.getMapper(PersonMapper.class);\r// 直接调用接口的方法，查询id为1的Peson数据\rPerson p = pm.selectPersonById(1); 3、SqlSession 线程安全性分析 SqlSession 是应用程序与持久存储层之间执行交互操作的一个单线程对象，也是MyBatis执行持久化操作的关键对象。\nSqlSession 对象完全包含以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用 SqlSession 实例来直接执行已映射的SQL语句。\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。\n可以考虑使用 ThreadLocal 来封装 SqlSession，关于 ThreadLocal 的用法，请参考：ThreadLocal 的使用场景：Web容器、Spring容器、日志打印\n4、SqlSession 的常用方法如下: SqlSession是应用程序与持久存储层之间执行交互操作的一个单线程对象，也是MyBatis执行持久化操作的关键对象。\nSqlSession对象完全包含以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用SqlSession实例来直接执行已映射的SQL语句。\nSqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。\n可以考虑使用ThreadLocal来封装SqlSession，关于ThreadLocal的用法，请参考：ThreadLocal的使用场景：Web容器、Spring容器、日志打印\n4、SqlSession 的常用方法如下: （1）int insert(String statement)。插入方法，参数statement是在配置文件中定义的\u0026lt;insert\u0026hellip;/\u0026gt;元素的id，返回执行SQL语句所影响的行数。 （2）int insert(String statement，Object parameter)。插入方法，参数statement是在配置文件中定义的\u0026lt;insert\u0026hellip;/\u0026gt;元素的id，parameter是插入所需的参数，通常是对象或者Map，返回执行SQL语句所影响的行数。 （3）int update(String statement) 。更新方法，参数statement是在配置文件中定义的\u0026lt;update\u0026hellip;/\u0026gt;元素的id，返回执行SQL语句所影响的行数。 （4）int update(String statement，Object parameter)。更新方法，参数statement是在配置文件中定义的\u0026lt;update\u0026hellip;/\u0026gt;元素的id，parameter是插入所需的参数，通常是对象或者Map，返回执行SQL语句所影响的行数。 （5）int delete(String statement) 。删除方法，参数statement是在配置文件中定义的\u0026lt;delete\u0026hellip;/\u0026gt;元素的id。返回执行SQL语句所影响的行数。 （6）int delete(String statement，Object parameter)。删除方法，参数statement 是在配置文件中定义的\u0026lt;delete\u0026hellip;/\u0026gt;元素的id，parameter是插入所需的参数，通常是对象或者Map，返回执行SQL语句所影响的行数。 （7） T selectOne(String slatement)。查询方法，参数statement是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，返回执行SQL语句查询结果的泛型对象，通常查询结果只有一条数据时才使用。 （8） T selectOne(String statement，Object parameter)。查询方法，参数statement是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，parameter是查询所需的参数，通常是对象或者Map，返回执行SQL语句查询结果的泛型对象，通常查询结具只有一条数据时才使用。 （9） List selectList(String statemenl)。查询方法，参数是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;素的id，返回执行SQL话句查询结果的泛型对象的集合。 （10） List selectList(String statement，Object parameter)。查询方法，参数statement是在配置文件中定义的\u0026lt;select../\u0026gt;元素的id，parameter是查询所需的参数，通常是对象或者Map，返回执行SQL语句查询结果的泛型对象的集合。 （11） List selectList(String statement，Object parameter，RowBounds rowBounds)。查询方法，参数statement是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，parameter是查询所需的参数，通常是对象或者Map，RowBounds对象用于分页，它的两个属性: offset指查询的当前页数; limit指当前页显示多少条数据。返回执行SQL语句查询结果的泛型对象的集合。 （12）\u0026lt;K，V\u0026gt; Map\u0026lt;K，V\u0026gt; selectMap(String statement，String mapKey) 。查询方法，参数statement是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，mapKey是返回数据的其中一个列名，执行SQL语句查询结果将会被封装成一个Map集合返回，key就是参数mapKey传入的列名，value是封装的对象。 （13）\u0026lt;K，V\u0026gt; Map\u0026lt;K，V\u0026gt; selectMap(String statement，0bject parameler，Sting mapKey)。查询方法，参数statement是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，parameter是查询所需的参数，通常是对象或者Map，mapKey 是返回数据的其中一个列名，执行SQL语句查询结果将会被封装成一个Map集合返回，key就是参数mapKey传入的列名，value是封装的对象。 （14）\u0026lt;K，V\u0026gt; Map\u0026lt;K，V\u0026gt;selectMap(Sting statement，Object parameter，Sting mapKey，RowBounds rowBounds)。查询方法，参数statement 是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，parameter 是否询所需的参数，通常是对象或者Map，mapKey 是返回数据的其中一个列名，RowBounds 对象用于分页。执行SQL 语句查询结果将会被封装成一个Map集合返回，key就是参数mapKey传入的列名，value是封装的对象。 （15）void select(String statement，ResultHandler handler)。查询方法，参数statement是在配置文件中定义的\u0026lt;select../\u0026gt;元素的id，ResultHandler对象用来处理查询返回的复杂结果集，通常用于多表查询。 （16）void select(String statement，Object parameter，ResultHander handler)。查询方法，参数statement是在配置文件中定义的\u0026lt;select../\u0026gt;元素的id，parameter 是查询所需的参数，通常是对象或者Map， ResultHandler对象用来处理查询返回的复杂结果集，通常用于多表查询。 （17）void select(String statement，Object parameter，RowBounds rowBounds，ResultHandr handler)。查询方法，参数statement是在配置文件中定义的\u0026lt;select\u0026hellip;/\u0026gt;元素的id，是查询所需的参数，通常是对象或者Map，RowBounds 对象用于分页，ResultHandr对象用来处理查询返回的复杂结果集，通常用于多表查询。 （18）void commit()。提交事务。 （19）void rollback()。回滚事务。 （20）void close()。关闭SqlSession对象。 （21）Connection getConnection()。获得JDBC的数据库连接对象。 （22） T getMapper(Class type)。返回mapper接口的代理对象，该对象关联了SqlSession对象，开发者可以通过该对象直接调用方法操作数据库，参数type是Mapper的接口类型。Mybatis官方手册建议通过mapper对象访问MyBatis。 5、SqlSession.getMapper方法详解 SqlSession有一个重要的方法getMapper，顾名思义，这个方式是用来获取Mapper映射器的。\n6、SqlSession与Executor SqlSession 只是一个前台客服，真正发挥作用的是 Executor，对SqlSession方法的访问最终都会落到 Executor 的相应方法上去。Executor分成两大类：一类是CachingExecutor，另一类是普通的Executor。\n（1）CachingExecutor有一个重要属性delegate，它保存的是某类普通的Executor，在构造函数时候传入。执行数据库update操作时，它直接调用delegate的update方法，执行query方法时先尝试从cache中取值，取不到再调用delegate的查询方法，并将查询结果存入cache中。\n（2）普通Executor分三类：SimpleExecutor、ReuseExecutor和BatchExecutor。它们都继承于BaseExecutor，BatchExecutor专门用于执行批量sql操作，ReuseExecutor会重用Statement执行sql操作，SimpleExecutor只是简单执行sql。\nSimpleExecutor 是一种常规执行器，每次执行都会创建一个Statement，用完后关闭。\nReuseExecutor 是可重用执行器，将Statement存入map中，操作map中的Statement而不会重复创建Statement。\nBatchExecutor 是批处理型执行器，doUpdate预处理存储过程或批处理操作，doQuery提交并执行过程。\n总之，Executor最终是通过JDBC的java.sql.Statement来执行数据库操作。\n"},{"id":292,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-6-MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%9B%E5%BB%BASession-%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"My Batis 6 My Batis初始化过程：创建 Session 实例的过程","parent":"MyBatis 教程","content":" MyBatis初始化过程：创建Session 实例的过程 我们知道MyBatis的持久化操作离不开SqlSessionFactory对象，该对象由SqlSessionFactoryBuilde加载MyBatis的配置文件产生。SqlSessionFactory对象的openSession方法可以打开SqlSession对象。具体代码如下所示:\n// 读取mybatis-config.xml 文件\rInputstream inputStream= Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;);\r// 初始化mybatis\r// 创建SqlSessionFactory 类的实例\rSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r// 创建Session 实例\rSqlSession session= sqlSessionFactory.openSession(); 上述代码的功能是根据配置文件mybatis-config.xml，创建SqlSessionFactory 对象，然后产生SqlSession，执行SQL语句。而MyBatis的初始化就发生在第三句:\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n现在就让我们看看第三句到底发生了什么。\nMyBatis初始化基本过程: SqlSessionFactoryBuilder 根据传入的数据流生成 Configuration 对象，然后根据 Configuration 对象创建默认的 SqlSessionFactory 实例。\n初始化的基本过程如下图所示： 由上图所示，我们可以得知MyBatis初始化要经过以下几步：\n（1）调用SqlSessionFactoryBuilder 对象的 build(inputStream)方法。 （2）SqlSessionFactoryBuilder 会根据输入流 inputStream 等信息创建XMLConfigBuilder 对象。 （3）SqlSessionFactoryBuilder 调用 XMLConfigBuilder 对象的parse()方法。 （4）XMLConfigBuilder 对象解析 XML 配置文件返回 Configuration 对象。 （5）SqlSessionFactoryBuilder 根据 Configuration 对象创建一个DefaultSessionFactory 对象，供客户端使用。 （6）SqlSessionFactoryBuilder 返回 DefaultSessionFactory 对象给客户端，由此可见，SqlSessionFactory 是根据 MyBatis 的配置文件 mybatis-config.xml 创建的。 "},{"id":293,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-7-MyBatis-ObjectFactory-%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82/","title":"My Batis 7 My Batis Object Factory 对象工厂","parent":"MyBatis 教程","content":" MyBatis ObjectFactory 对象工厂 ObjectFactory 简介 MyBatis每次创建结果对象的新实例时，它都会使用一个对象工厂(ObjectFactory) 实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。\n// 自定义对象工厂\rpublic class ExampleObjectFactory extends DefaultObjectFactory {\rpublic Object create(Class type) {\rreturn super.create (type) ;\r}\rpublic object create (Class type,List\u0026lt;Class\u0026gt; constructorArgTypes,List\u0026lt;Object\u0026gt; constructorArgs) {\rreturn super.create (type,constructorargTypes,constructorArgs) ;\r}\rpublic void setProperties (Properties properties) {\rsuper.setProperties(properties) ;\r}\rpublic \u0026lt;T\u0026gt; boolean isCollection (Class\u0026lt;T\u0026gt; type)\r{\rreturn Collection.class.isAssignableFrom(type);\r} 在MyBatis配置文件中配置自定义对象工厂，如下所示：\n\u0026lt;objectFactory type=\u0026#34;cn.mybatis.factory.ExampleObjectFactory\r\u0026lt;Property names=\u0026#34;someProperty\u0026#34; value=\u0026#34;100\u0026#34; /\u0026gt;\r\u0026lt;/objectFactory\u0026gt; ObjectFactory接口很简单，它包含两个创建对象的方法：一个是默认构造方法的；另外一个是处理带参数的构造方法的。setProperties方法可以被用来配置ObjctFactory，在初始化 ObjectFactory 实例后，ObjectFactory 元素体中定义的属性会被传递给 setProperties 方法。\n"},{"id":294,"href":"/Tech/3Java/MyBatis/MyBatis3/","title":"My Batis3","parent":"MyBatis","content":"标题：MyBatis3\n标签：Java、基础、MyBatis、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：https://www.saveload.cn/html/technology/MyBatis3.txt\n"},{"id":295,"href":"/Tech/3Java/MyBatis/MyBatis%E5%9B%9B%E5%A4%A7%E6%8E%A5%E5%8F%A3%E4%B9%8B-Executor/","title":"My Batis四大接口之 Executor","parent":"MyBatis","content":" MyBatis四大接口之 Executor "},{"id":296,"href":"/Tech/3Java/MyBatis/%E4%B8%80%E4%BA%9BMyBatis%E5%8F%8ASQL%E7%9A%84%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/","title":"一些 My Batis及 Sql的应用技巧","parent":"MyBatis","content":" 1、test 属性的值可以转义为Java代码 例如：可以.size、可以.toString() 传入参数是 list 在 mapper.xml 中 2、自定义排序 通过 order by instr (a,b) 方法对 b 字段按 a 展示顺序排序 3、复杂对象在 mapper.xml 文件中取值、 传入参数是 List\u0026lt;Map\u0026lt;String,String\u0026raquo; 在mapper.xml 文件中通过get方法取值、（另可以 item.sourecSysid 形式通过属性取值。） 在 mapper.xml 文件中通过 orderBys 对象自定义排序 "},{"id":297,"href":"/Tech/3Java/Spring/Base64/","title":"Base64","parent":"Spring","content":"final Base64.Decoder decoder = Base64.getDecoder();\rfinal Base64.Encoder encoder = Base64.getEncoder();\rfinal String text = \u0026#34;字串文字\u0026#34;;\rfinal byte[] textByte = text.getBytes(\u0026#34;UTF-8\u0026#34;);\r//编码\rfinal String encodedText = encoder.encodeToString(textByte);\rSystem.out.println(encodedText);\r//解码\rSystem.out.println(new String(decoder.decode(encodedText), \u0026#34;UTF-8\u0026#34;));\rfinal Base64.Decoder decoder = Base64.getDecoder();\rfinal Base64.Encoder encoder = Base64.getEncoder();\rfinal String text = \u0026#34;字串文字\u0026#34;;\rfinal byte[] textByte = text.getBytes(\u0026#34;UTF-8\u0026#34;);\r//编码\rfinal String encodedText = encoder.encodeToString(textByte);\rSystem.out.println(encodedText);\r//解码\rSystem.out.println(new String(decoder.decode(encodedText), \u0026#34;UTF-8\u0026#34;)); "},{"id":298,"href":"/Tech/3Java/Spring/logback-spring-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/","title":"Logback Spring 基本配置说明","parent":"Spring","content":" logback-spring 基本配置说明 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;!-- 此xml在spring-boot-1.5.3.RELEASE.jar里 --\u0026gt;\r\u0026lt;include resource=\u0026#34;org/springframework/boot/logging/logback/defaults.xml\u0026#34; /\u0026gt;\r\u0026lt;include resource=\u0026#34;org/springframework/boot/logging/logback/console-appender.xml\u0026#34; /\u0026gt;\r\u0026lt;!-- 开启后可以通过jmx动态控制日志级别(springboot Admin的功能) --\u0026gt;\r\u0026lt;!--\u0026lt;jmxConfigurator/\u0026gt;--\u0026gt;\r\u0026lt;!-- RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --\u0026gt;\r\u0026lt;!-- 以下的大概意思是：1.先按日期存日志，日期变了，将前一天的日志文件名重命名为XXX%日期%索引，新的日志仍然是demo.log --\u0026gt;\r\u0026lt;!-- 2.如果日期没有发生变化，但是当前日志的文件大小超过10MB时，对当前日志进行分割 重命名--\u0026gt;\r\u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt;\r\u0026lt;File\u0026gt;${LOG_PATH}${LOG_FILE}\u0026lt;/File\u0026gt;\r\u0026lt;encoder\u0026gt;\r\u0026lt;!-- pattern节点，用来设置日志的输入格式 --\u0026gt;\r\u0026lt;pattern\u0026gt;%date [%level] [%thread] %logger{60} [%file : %line] %msg%n\u0026lt;/pattern\u0026gt;\r\u0026lt;!-- 记录日志的编码:此处设置字符集 - --\u0026gt;\r\u0026lt;charset\u0026gt;UTF-8\u0026lt;/charset\u0026gt;\r\u0026lt;/encoder\u0026gt;\r\u0026lt;!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 --\u0026gt;\r\u0026lt;!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 --\u0026gt;\r\u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026#34;\u0026gt;\r\u0026lt;!-- 添加.gz 历史日志会启用压缩 大大缩小日志文件所占空间 --\u0026gt;\r\u0026lt;!-- 文件名：logs/daily/guns.log.2017-12-05.0.gz --\u0026gt;\r\u0026lt;fileNamePattern\u0026gt;${LOG_PATH}daily/${LOG_FILE}.%d{yyyy-MM-dd}%i.gz\u0026lt;/fileNamePattern\u0026gt;\r\u0026lt;maxHistory\u0026gt;30\u0026lt;/maxHistory\u0026gt;\u0026lt;!-- 保留30天日志 --\u0026gt;\r\u0026lt;!--日志文件最大的大小--\u0026gt; \u0026lt;timeBasedFileNamingAndTriggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\u0026#34;\u0026gt;\r\u0026lt;maxFileSize\u0026gt;10MB\u0026lt;/maxFileSize\u0026gt;\r\u0026lt;/timeBasedFileNamingAndTriggeringPolicy\u0026gt;\r\u0026lt;/rollingPolicy\u0026gt;\r\u0026lt;/appender\u0026gt;\r\u0026lt;!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 --\u0026gt;\r\u0026lt;!-- com.liyan为根包，也就是只要是发生在这个根包下面的所有日志操作行为的权限都是DEBUG --\u0026gt;\r\u0026lt;!--\u0026lt;logger name=\u0026#34;com.liyan\u0026#34; level=\u0026#34;DEBUG\u0026#34;\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;appender-ref ref=\u0026#34;demolog\u0026#34; /\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;/logger\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;logger name=\u0026#34;org.springframework\u0026#34; level=\u0026#34;error\u0026#34;/\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;logger name=\u0026#34;jdbc.connection\u0026#34; level=\u0026#34;OFF\u0026#34;/\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;logger name=\u0026#34;org.apache\u0026#34; level=\u0026#34;error\u0026#34;/\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;logger name=\u0026#34;com.alibaba\u0026#34; level=\u0026#34;error\u0026#34;/\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;logger name=\u0026#34;org.apache.kafka.clients.producer.ProducerConfig\u0026#34; level=\u0026#34;warn\u0026#34;/\u0026gt;--\u0026gt;\r\u0026lt;!-- 控制台输出日志级别 --\u0026gt;\r\u0026lt;!-- 级别依次为【从高到低】：FATAL \u0026gt; ERROR \u0026gt; WARN \u0026gt; INFO \u0026gt; DEBUG \u0026gt; TRACE --\u0026gt;\r\u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt;\u0026lt;!-- 控制台输出日志级别 --\u0026gt;\r\u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt;\r\u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34;/\u0026gt;\u0026lt;!-- 根logger的设置--\u0026gt;\r\u0026lt;/root\u0026gt;\r\u0026lt;/configuration\u0026gt; "},{"id":299,"href":"/Tech/3Java/Spring/Spring-Boot-Security/","title":"Spring Boot Security","parent":"Spring","content":" Hello World Spring Boot Security 创建Spring Security 配置：\nconfigureGlobal方法的名称并不重要。然而，仅在与任何注释的类配置AuthenticationManagerBuilder是很重要的@EnableWebSecurity，@EnableGlobalMethodSecurity或@EnableGlobalAuthentication。否则会产生不可预测的结果。\n自定义身份验证管理器：AuthenticationManagerBuilder 非常适合设置内存，JDBC或LDAP用户详细信息，或用于添加自定义UserDetailsService。以下是配置全局（父）的应用程序示例AuthenticationManager：\n认证\n身份验证的主要策略接口 AuthenticationManager 只有一个方法：authenticate\n@EnableWebSecurity\rpublic class SecurityConfig extends WebSecurityConfigurerAdapter {\r@Override\rprotected void configure(HttpSecurity http) throws Exception {\rhttp\r.authorizeRequests()\r.antMatchers(\u0026#34;/css/**\u0026#34;, \u0026#34;/index\u0026#34;).permitAll()\t.antMatchers(\u0026#34;/user/**\u0026#34;).hasRole(\u0026#34;USER\u0026#34;)\t.and()\r.formLogin()\r.loginPage(\u0026#34;/login\u0026#34;).failureUrl(\u0026#34;/login-error\u0026#34;);\t}\r@Autowired\rpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\rauth\r.inMemoryAuthentication()\r.withUser(\u0026#34;user\u0026#34;).password(\u0026#34;password\u0026#34;).roles(\u0026#34;USER\u0026#34;);\r}\r} 请注意，它AuthenticationManagerBuilder是@Autowired一个方法@Bean- 这是使它构建全局（父）的方法AuthenticationManager。相反，如果我们这样做：\n@Configuration\rpublic class ApplicationSecurity extends WebSecurityConfigurerAdapter {\r@Autowired\rDataSource dataSource;\r... // web stuff here\r@Override\rpublic configure(AuthenticationManagerBuilder builder) {\rbuilder.jdbcAuthentication().dataSource(dataSource).withUser(\u0026#34;dave\u0026#34;)\r.password(\u0026#34;secret\u0026#34;).roles(\u0026#34;USER\u0026#34;);\r}\r} 使用@Override配置器中的方法）然后AuthenticationManagerBuilder仅用于构建“本地” AuthenticationManager，它是全局的子节点。在Spring Boot应用程序中，您可以@Autowired将全局应用程序转换为另一个bean，但除非您自己明确地公开它，否则不能使用本地bean。\nSpring Boot提供了一个默认的全局AuthenticationManager（只有一个用户），除非你通过提供自己的bean类型来抢占它AuthenticationManager。除非您主动需要自定义全局，否则默认设置足够安全，您不必担心它AuthenticationManager。如果您执行任何构建的配置，AuthenticationManager您通常可以在本地执行您正在保护的资源，而不必担心全局默认值。\n授权或访问控制\n一旦身份验证成功，我们就可以继续授权，这里的核心策略是AccessDecisionManager。框架提供了三个实现，并且所有三个委托给一个链AccessDecisionVoter，有点像ProviderManager委托AuthenticationProviders。\n一个AccessDecisionVoter考虑的Authentication（表示主体）和一个安全的Object，其作为装饰有ConfigAttributes：\nboolean supports(ConfigAttribute attribute);\rboolean supports(Class\u0026lt;?\u0026gt; clazz);\rint vote(Authentication authentication, S object,\rCollection\u0026lt;ConfigAttribute\u0026gt; attributes); 该Object是的签名完全通用的，AccessDecisionManager并且AccessDecisionVoter-它代表什么，用户可能要访问（网络资源或在一个Java类中的方法是两种最常见的情况）。该ConfigAttributes也相当一般，较安全的装修Object用一些确定的权限来访问它所需的水平的元数据。ConfigAttribute是一个接口，但它只有一个非常通用的方法并返回一个String，所以这些字符串以某种方式编码资源所有者的意图，表达允许谁访问它的规则。典型的ConfigAttribute是用户角色的名称（如ROLE_ADMIN或ROLE_AUDIT），它们通常具有特殊格式（如ROLE_ 前缀）或表示需要评估的表达式。\n网络安全\nSpring Security 作为 Filter 链中的单个安装，其概念类型是 FilterChainProxy 由于很快就会显现的原因。在Spring Boot 应用程序中，安全过滤器@Bean位于ApplicationContext，并且默认安装它，以便它应用于每个请求。它安装在一个定义的位置SecurityProperties.DEFAULT_FILTER_ORDER，该位置依次锚定FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER（Spring Boot应用程序期望过滤器在包装请求时修改其行为的最大顺序）。除此之外还有更多：从容器的角度来看，Spring Security是一个单独的过滤器，但在其中有一些额外的过滤器，每个过滤器都扮演着特殊的角色。这是一张图片：\n创建和自定义筛选链 Spring Boot应用程序（带有/**请求匹配器的应用程序）中的默认回退过滤器链具有预定义的顺序SecurityProperties.BASIC_AUTH_ORDER。您可以通过设置完全关闭它security.basic.enabled=false，或者您可以将其用作后备，只需使用较低的顺序定义其他规则。要做到这一点，只需添加一个@Bean类型WebSecurityConfigurerAdapter（或WebSecurityConfigurer）并用它来装饰类@Order。例：\n@Configuration\r@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)\rpublic class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {\r@Override\rprotected void configure(HttpSecurity http) throws Exception {\rhttp.antMatcher(\u0026#34;/foo/**\u0026#34;)\r...;\r}\r} 此bean将导致Spring Security添加新的过滤器链并在回退之前对其进行排序。 与另一组资源相比，许多应用程序对一组资源具有完全不同的访问规则。例如，承载UI和支持API的应用程序可能支持基于cookie的身份验证，其中重定向到UI部件的登录页面，而基于令牌的身份验证具有401响应未经身份验证的API部件请求。每组资源都有自己WebSecurityConfigurerAdapter的独特订单和自己的请求匹配器。如果匹配规则重叠，则最早的有序过滤器链将获胜。\n方法安全\n除了支持保护Web应用程序外，Spring Security还支持将访问规则应用于Java方法执行。\n启用方法安全性\n@SpringBootApplication\r@EnableGlobalMethodSecurity(securedEnabled = true)\rpublic class SampleSecureApplication {\r} 装饰方法资源\n@Service\rpublic class MyService {\r@Secured(\u0026#34;ROLE_USER\u0026#34;)\rpublic String secure() {\rreturn \u0026#34;Hello Security\u0026#34;;\r}\r} 此示例是具有安全方法的服务。如果Spring创建了@Bean这种类型，那么它将被代理，并且调用者必须在实际执行该方法之前通过安全拦截器。如果访问被拒绝，则调用者将获得AccessDeniedException而不是实际的方法结果。\n有可以在方法中使用以执行安全性约束，特别是其他注释@PreAuthorize和@PostAuthorize，它允许你写含有以分别方法参数和返回值引用的表达式。\n经过身份验证的主体\nSpring Security基本上是线程绑定的，因为它需要使当前经过身份验证的主体可供各种下游消费者使用。\nSecurityContext context = SecurityContextHolder.getContext();\rAuthentication authentication = context.getAuthentication();\rUser = (User) authentication.getPrincipal();\rassert(authentication.isAuthenticated); HttpServletRequest 类\ngetRemoteUser 方法：如果用户已经过身份验证，或者null用户未经过身份验证，则返回发出此请求的用户的登录名。与CGI变量REMOTE_USER的值相同。\nisUserInRole 方法：返回一个布尔值，指示经过身份验证的用户是否包含在指定的逻辑“角色”中。可以使用部署描述符定义角色和角色成员身份。如果用户尚未通过身份验证，则返回该方法false。\ngetUserPrincipal 方法：返回java.security.Principal包含当前经过身份验证的用户的名称的对象。如果用户尚未通过身份验证，则返回该方法null。\nlogin 方法：在为其配置的Web容器登录机制使用的密码验证域中验证提供的用户名和密码\nlogout 方法：建立null作为值返回时 getUserPrincipal，getRemoteUser和getAuthType被称为该请求。\nHttpSecurity 类\nA HttpSecurity类似于命名空间配置中的Spring Security的XML 元素。它允许为特定的http请求配置基于Web的安全性。默认情况下，它将应用于所有请求，但可以使用requestMatcher(RequestMatcher)或其他类似方法进行限制 。\nauthorizeRequests()：允许根据 HttpServletRequest 使用 限制访问。\ncsrf()：添加CSRF支持。\nhttpBasic()：配置HTTP基本身份验证。\nrememberMe()：允许配置Remember Me身份验证。允许基于令牌的记住我的身份验证。在验证是否存在名为“remember-me”的HTTP参数时，即使用户HttpSession过期，也会记住该用户 。\nformLogin() ：指定支持基于表单的身份验证。\n如果 FormLoginConfigurer.loginPage(String)未指定，则将生成默认登录页面。 .failureForwardUrl()转发认证失败处理程序。 .successForwardUrl()转发认证成功处理程序 .passwordParameter(String)执行身份验证时查找密码的HTTP参数。默认为“password”。 .usernameParameter(String)执行身份验证时查找用户名的HTTP参数。默认为“username”。\nlogout（）：提供注销支持。\n.logoutUrl()触发注销的URL（默认为“/ logout”）。\n.logoutSuccessUrl(“” )注销后重定向到的URL。\n.deleteCookies(\u0026ldquo;cookieNamesToClear\u0026rdquo;)允许指定在注销成功时删除的cookie的名称。\nsessionManagement()：允许配置会话管理。例：.sessionManagement().maximumSessions(1).expiredUrl(\u0026quot;/login?expired\u0026quot;)强制一次只验证用户的单个实例。如果用户使用用户名“user”进行身份验证而未注销，并且尝试使用“user”进行身份验证，则第一个会话将被强制终止并发送到“/ login？expired”URL。\nservletApi（）：将HttpServletRequest方法与在上面找到的值 集成SecurityContext。\nSecurityContext 接口\n定义与当前执行线程关联的最小安全信息的接口\ngetAuthentication() ：获取当前经过身份验证的主体或身份验证请求令牌。\nsetAuthentication(Authentication authentication)：更改当前已验证的主体，或删除身份验证信息。\nAuthenticationManagerBuilder 类\nauthenticationProvider：根据AuthenticationProvider传入的自定义添加身份验证。\nAuthentication 接口\n当前经过身份验证的主体或身份验证请求令牌。\n一旦请求被方法处理，表示身份验证请求或经过身份验证的主体的令牌 AuthenticationManager.authenticate(Authentication)。\n一旦请求被认证，认证通常将存储在由正在使用的认证机制管理 的线程本地SecurityContext中SecurityContextHolder。通过创建Authentication实例并使用代码，可以实现显式身份验证，而无需使用Spring Security的身份验证机制之一：\nSecurityContextHolder.getContext（）setAuthentication（anAuthentication）。\ngetAuthorities（）：授予委托人的权限，或者如果令牌未经过身份验证，则为空集合。永远不会。\ngetDetails（）：存储有关身份验证请求的其他详细信息 这些可能是IP地址，证书序列号等。\ngetPrincipal（）：被验证的委托人的身份。对于使用用户名和密码的身份验证请求，这将是用户名。呼叫者应填充身份验证请求的主体。 该AuthenticationManager会执行通常会返回一个 验证含有作为主要供应用程序使用更丰富的信息。许多身份验证提供程序将创建一个 UserDetails对象作为主体。\nisAuthenticated（）：如果令牌已经过身份验证，并且AbstractSecurityInterceptor不需要AuthenticationManager再次将令牌呈现 给重新身份验证，则为true 。\n公共接口 AuthenticationProvider\n表示类可以处理特定的 Authentication实现。\nauthenticate(Authentication authentication)：尝试对传递的Authentication对象进行身份验证，Authentication如果成功则返回完全填充的对象（包括授予的权限也就是 凭据）。\nSpring安全参考 "},{"id":300,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E6%B3%A8%E8%A7%A3/","title":"Spring Boot 注解","parent":"Spring Boot","content":" SpringBoot 注解 @Value List .yml 文件配置：\ntest:\rlist:\r- aaa\r- bbb\r- ccc .properties 文件配置：\ntest.list[0]=aaa\rtest.list[1]=bbb\rtest.list[2]=ccc 取值：\n@Value(\u0026#34;${test.list}\u0026#34;)\rprivate String[] list; 加默认值取值：\n@Value(\u0026#34;${test.list:}\u0026#34;)\rprivate String[] list; EL 表达式：\n设置:\ntest:\rlist: aaa,bbb,ccc 取值：\n@Value(\u0026#34;#{\u0026#39;${test.list}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;)\rprivate List\u0026lt;String\u0026gt; testList; 加默认值取值：\n@Value(\u0026#34;#{\u0026#39;${test.list:}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;)\rprivate List\u0026lt;String\u0026gt; testList; "},{"id":301,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-1-%E7%AB%A0Spring-Boot-%E5%85%A5%E9%97%A8/","title":"Spring Boot 第 1 章： Spring Boot 入门","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":302,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-2-%E7%AB%A0Spring-Boot-%E9%85%8D%E7%BD%AE/","title":"Spring Boot 第 2 章： Spring Boot 配置","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":303,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-3-%E7%AB%A0Spring-Boot-%E6%97%A5%E5%BF%97/","title":"Spring Boot 第 3 章： Spring Boot 日志","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":304,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-4-%E7%AB%A0Spring-Boot-Web-%E5%BC%80%E5%8F%91/","title":"Spring Boot 第 4 章： Spring Boot Web 开发","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":305,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-5-%E7%AB%A0Spring-Boot-Docker/","title":"Spring Boot 第 5 章： Spring Boot Docker","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":306,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-6-%E7%AB%A0Spring-Boot-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/","title":"Spring Boot 第 6 章： Spring Boot 数据访问","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":307,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-7-%E7%AB%A0Spring-Boot-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/","title":"Spring Boot 第 7 章： Spring Boot 启动配置原理","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":308,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-8-%E7%AB%A0Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89starters/","title":"Spring Boot 第 8 章： Spring Boot 自定义starters","parent":"Spring Boot","content":" Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 "},{"id":309,"href":"/Tech/3Java/Spring/Spring-Boot/Spring-Boot/","title":"Spring Boot","parent":"Spring Boot","content":" SpringBoot 分布式/版本化配置，服务注册和发现，负载均衡，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态\n"},{"id":310,"href":"/Tech/3Java/Spring/Spring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","title":"Spring Boot配置文件 多配置文件","parent":"Spring","content":" Spring Boot配置文件-多配置文件 1.properties多环境配置 1、第一种：利用@PropertySource注解既可以引入配置文件，需要引入多个时，可使用@PropertySources设置数组，引入多个文件。\n@SpringBootApplication\r@PropertySource(value= \u0026#34;classpath:application-my.properties\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;)\r@ComponentScan(basePackages = {\u0026#34;com.nostyling\u0026#34;})\r@ServletComponentScan(value = \u0026#34;com.nostyling\u0026#34;)\r@MapperScan(basePackages = {\u0026#34;com.nostyling.create.modular.dao\u0026#34;})//将项目中对应的mapper类的路径加进来就可以了\rpublic class DemoApplication {\rprivate static Logger logger = LoggerFactory.getLogger(DemoApplication.class);\rpublic static void main(String[] args) {\rSpringApplication.run(DemoApplication.class, args);\rlogger.info(\u0026#34;成功启动！\u0026#34;);\r}\r} 2、第二种：配置激活选项\n我们将多个资源文件放入到resource目录下\napplication.properties\rapplication-dev.properties\rapplication-test.properties\rapplication-master.properties 在 application.properties文件中做如下配置：\n#激活哪一个环境的配置文件\rspring.profiles.active=dev\r#公共配置\rspring.jackson.date-format=yyyy-MM-dd HH:mm:ss: 2.YAML多环境配置 注意：@PropertySource注解只支持properties文件。而不支持yml文件。\n1、第一种：使用yml的配置文件，名称一定以application-开头，例如：application-dev.yml，application-pro.yml，application-redis.yml文件等你等。\n我们将多个资源文件放入到resource目录下\napplication.yml\rapplication-dev.yml\rapplication-test.yml\rapplication-master.yml 在 application.yml 文件中配置激活选项：\nspring:\rprofiles:\r# （这里只写application-之后的名称。多个之间用逗号分隔）\ractive: dev 2、第二种：在配置文件添加三个英文状态下的短横线即可区分\n例如：\n---\rspring:\rprofiles: dev 在 application.yml 文件中配置激活选项：\n#激活哪一个环境的配置文件\r#公共配置\rspring:\rprofiles:\ractive: prd\rjackson:\rdate-format: yyyy-MM-dd HH:mm:ss\r---\rspring:\rprofiles: dev\rserver:\rport: 8081\r---\rspring:\rprofiles: test\rserver:\rport: 8082\r---\rspring:\rprofiles: prd\rserver:\rport: 8083 从源代码中得知 @SpringBootApplication被@Configuration、@EnableAutoConfiguration、@ComponentScan 注解所修饰，换言之 Springboot 提供了统一的注解来替代以上三个注解。\n如果使用@PropertySource(value=\u0026ldquo;classpath:redis.properties\u0026rdquo;)注解，并配合@Value注解@Value(\u0026quot;${spring.redis.open}\u0026quot;),完成参数的注入，在未注解@SpringBootApplication时，一定要有@Configuration注解，不然不起作用。\n@Configuration\n@Configuration 是一个类级注释，指示对象是一个bean定义的源。@Configuration 类通过 @bean 注解的公共方法声明bean。\n@Bean\n@Bean 注释是用来表示一个方法实例化，配置和初始化是由 Spring IoC 容器管理的一个新的对象。\n通俗的讲 @Configuration 一般与 @Bean 注解配合使用，用 @Configuration 注解类等价与 XML 中配置 beans，用 @Bean 注解方法等价于 XML 中配置 bean。举例说明：\n@EnableAutoConfiguration\n启用 Spring 应用程序上下文的自动配置，试图猜测和配置您可能需要的bean。自动配置类通常采用基于你的 classpath 和已经定义的 beans 对象进行应用。\n被 @EnableAutoConfiguration 注解的类所在的包有特定的意义，并且作为默认配置使用。例如，当扫描 @Entity类的时候它将本使用。通常推荐将 @EnableAutoConfiguration 配置在 root 包下，这样所有的子包、类都可以被查找到。\n@ComponentScan\n为 @Configuration注解的类配置组件扫描指令。同时提供与 Spring XML’s 元素并行的支持。\n通俗的讲，@ComponentScan 注解会自动扫描指定包下的全部标有 @Component注解 的类，并注册成bean，当然包括 @Component 下的子注解@Service、@Repository、@Controller。@ComponentScan 注解没有类似 、的属性。\n"},{"id":311,"href":"/Tech/3Java/Spring/Spring-Cloud/Spring-Cloud/","title":"Spring Cloud","parent":"Spring Cloud","content":" Hello World Spring Cloud 分布式/版本化配置，服务注册和发现，负载均衡，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态\n"},{"id":312,"href":"/Tech/3Java/Spring/Spring-Framework/Spring-Framework-1-%E6%A6%82%E8%BF%B0/","title":"Spring Framework 1 概述","parent":"Spring Framework","content":"Spring Framework\n來源：\n链接：https://docs.spring.io/spring-framework/docs/current/reference/html/index.html\n概述 Spring 使创建 Java 企业应用程序变得容易。它提供您所需的一切 需要在企业环境中拥抱Java语言，并支持Groovy。 和 Kotlin 作为 JVM 上的替代语言，并且可以灵活地创建许多 各种体系结构，具体取决于应用程序的需求。从 Spring Framework 6.0 开始， Spring 需要 Java 17+。\nSpring 支持广泛的应用场景。在大型企业中，应用程序 经常存在很长时间，并且必须在其升级的JDK和应用程序服务器上运行 周期超出了开发人员的控制范围。其他人可能作为嵌入服务器的单个jar运行， 可能在云环境中。还有一些可能是独立的应用程序（例如批处理 或不需要服务器的集成工作负载。\n春天是开源的。它有一个庞大而活跃的社区，提供持续的反馈 基于各种实际用例。这帮助Spring成功 经过很长时间的发展。\n1. 我们所说的 “Spring” 是什么意思 “Spring”这个词在不同的语境中有不同的含义。它可以用来指代 Spring Framework 项目本身，它是一切的起点。随着时间的推移，其他 Spring 项目已经建立在 Spring 框架之上。大多数情况下，当人们说“Spring”时，他们指的是整个项目系列。本参考文档侧重于基础：Spring 框架本身。\nSpring Framework 分为模块。应用程序可以选择他们需要的模块。核心是核心容器的模块，包括配置模型和依赖注入机制。除此之外，Spring Framework 还为不同的应用程序架构提供基础支持，包括消息传递、事务数据和持久性以及 Web。它还包括基于 Servlet 的 Spring MVC Web 框架，以及并行的 Spring WebFlux 反应式 Web 框架。\n关于模块的注意事项：Spring 的框架 jar 允许部署到 JDK 9 的模块路径（“Jigsaw”）。为了在支持 Jigsaw 的应用程序中使用，Spring Framework 5 jar 带有“Automatic-Module-Name”清单条目，它定义了稳定的语言级模块名称（“spring.core”、“spring.context”等），独立于jar 工件名称（jar 遵循相同的命名模式，使用“-”而不是“.”，例如“spring-core”和“spring-context”）。当然，Spring 的框架 jar 可以在 JDK 8 和 9+ 的类路径上正常工作。\n2. Spring 和 Spring 框架的历史 Spring 于 2003 年应运而生，以应对早期 J2EE规范的复杂性。虽然有些人认为 Java EE 及其现代继承者 Jakarta EE 与 Spring 竞争，但实际上它们是互补的。Spring 编程模型不包含 Jakarta EE 平台规范；相反，它集成了从传统 EE 伞中精心挑选的个别规范：\n小服务程序 API ( JSR 340 )\nWebSocket API ( JSR 356 )\n并发实用程序 ( JSR 236 )\nJSON 绑定 API ( JSR 367 )\nBean 验证（JSR 303）\n联合行动计划 ( JSR 338 )\nJMS（JSR 914）\n以及用于事务协调的 JTA/JCA 设置（如有必要）。\nSpring Framework 还支持 Dependency Injection ( JSR 330 ) 和 Common Annotations ( JSR 250 ) 规范，应用程序开发人员可以选择使用这些规范来代替 Spring Framework 提供的特定于 Spring 的机制。最初，那些是基于通用javax包的。\n依赖注入(Dependency Injection) Spring的两个核心内容为控制反转(Ioc)和面向切面(AOP),\n从 Spring Framework 6.0 开始，Spring 已经升级到 Jakarta EE 9 级别（例如 Servlet 5.0+，JPA 3.0+），基于jakarta命名空间而不是传统的javax包。以 EE 9 作为最低标准并支持 EE 10，Spring 准备为 Jakarta EE API 的进一步发展提供开箱即用的支持。Spring Framework 6.0 与作为 Web 服务器的 Tomcat 10.1、Jetty 11 和 Undertow 2.3 以及 Hibernate ORM 6.1 完全兼容。\n随着时间的推移，Java/Jakarta EE 在应用程序开发中的作用发生了变化。在 J2EE 和 Spring 的早期，创建应用程序是为了部署到应用程序服务器。如今，在 Spring Boot 的帮助下，应用程序以开发运维和云友好的方式创建，嵌入了 Servlet 容器并且更改起来微不足道。从 Spring Framework 5 开始，WebFlux 应用程序甚至不直接使用 Servlet API，而是可以在非 Servlet 容器的服务器（例如 Netty）上运行。\nSpring 不断创新和发展。除了 Spring Framework，还有其他项目，例如 Spring Boot、Spring Security、Spring Data、Spring Cloud、Spring Batch 等。请务必记住，每个项目都有自己的源代码存储库、问题跟踪器和发布节奏。有关 Spring 项目的完整列表，请参阅spring.io/projects。\n三、设计理念 当您了解一个框架时，重要的是不仅要知道它做什么，还要知道它遵循什么原则。以下是 Spring 框架的指导原则：\n在每个级别提供选择。Spring 让您尽可能晚地推迟设计决策。例如，您可以在不更改代码的情况下通过配置切换持久性提供程序。许多其他基础设施问题和与第三方 API 的集成也是如此。\n包容不同的观点。Spring 拥抱灵活性，并且对事情应该如何完成没有固执己见。它以不同的视角支持广泛的应用需求。\n保持强大的向后兼容性。Spring 的演变经过精心管理，以强制在版本之间进行一些重大更改。Spring 支持精心选择的一系列 JDK 版本和第三方库，以方便维护依赖于 Spring 的应用程序和库。\n关心API设计。Spring 团队投入了大量的心思和时间来制作直观的 API，并且可以跨多个版本和多年使用。\n为代码质量设定高标准。Spring 框架非常强调有意义的、最新的和准确的 javadoc。它是极少数可以声称代码结构清晰且包之间没有循环依赖关系的项目之一。\n4. 反馈和贡献 对于操作方法问题或诊断或调试问题，我们建议使用 Stack Overflow。单击 此处 获取要在 Stack Overflow 上使用的建议标签列表。如果您相当确定 Spring Framework 中存在问题或想建议某个功能，请使用GitHub Issues。\n如果您有解决方案或建议的修复方法，可以在 Github上提交拉取请求。但是，请记住，除了最琐碎的问题之外，我们希望在问题跟踪器中提交一张票，在那里进行讨论并留下记录以供将来参考。\n有关更多详细信息，请参阅CONTRIBUTING顶级项目页面上的指南。\n5. 开始 如果您刚刚开始使用 Spring，您可能希望通过创建基于Spring Boot的应用程序来开始使用 Spring 框架。Spring Boot 提供了一种快速（且固执己见）的方法来创建生产就绪的基于 Spring 的应用程序。它基于 Spring Framework，有利于约定优于配置，旨在让您尽快启动和运行。\n您可以使用start.spring.io生成基本项目或遵循“入门”指南之一，例如“ 开始构建 RESTful Web 服务” 。除了更容易理解之外，这些指南非常专注于任务，其中大部分都基于 Spring Boot。它们还涵盖了您在解决特定问题时可能要考虑的 Spring 产品组合中的其他项目。\n"},{"id":313,"href":"/Tech/3Java/Spring/Spring-Framework/Spring-Framework-2-%E6%A0%B8%E5%BF%83/","title":"Spring Framework 2 核心","parent":"Spring Framework","content":"Spring Framework\n來源：\n链接：https://docs.spring.io/spring-framework/docs/current/reference/html/index.html\n核心 IoC 容器， 事件， 资源， i18n， 验证、数据绑定、类型转换、SpEL、AOP、AOT。 息\n参考文档的这一部分涵盖了 Spring 框架绝对不可或缺的所有技术。\n其中最重要的是 Spring 框架的 控制反转 (IoC) 容器。在全面介绍 Spring Framework 的 IoC 容器之后，将全面介绍 Spring 的面向方面编程 (AOP) 技术。Spring Framework 有自己的 AOP 框架，概念上很容易理解，成功解决了 Java 企业编程中 80% 的 AOP 需求。\n还提供了 Spring 与 AspectJ 的集成（就功能而言，目前是最丰富的，当然也是 Java 企业领域中最成熟的 AOP 实现）。\nAOT 处理可用于提前优化您的应用程序。它通常用于使用 GraalVM 的本机映像部署。\nAspectJ 是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。\nJIT (Just-In-Time - 实时编译) 和 AOT (Ahead-Of-Time - 预先编译)\n1. IoC 容器 本章涵盖 Spring 的控制反转 (IoC) 容器。\n1.1. Spring IoC 容器和 Bean 介绍 本章涵盖控制反转 (IoC) 原则的 Spring Framework 实现。IoC 也称为依赖注入 (DI)。在这个过程中，对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即它们使用的其他对象） . 然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转），它通过使用类的直接构造或服务定位器模式等机制来控制其依赖项的实例化或位置。\norg.springframework.beans和org.springframework.context包是 Spring Framework 的 IoC 容器的基础。该 BeanFactory 接口提供了一种高级配置机制，能够管理任何类型的对象。 ApplicationContext 是 的子接口 BeanFactory。它补充说：\n更容易与 Spring 的 AOP 特性集成 消息资源处理（用于国际化） 活动发布 应用层特定的上下文，例如 WebApplicationContext 用于 Web 应用程序的。 简而言之，它 BeanFactory 提供了配置框架和基本功能，并 ApplicationContext 添加了更多企业特定的功能。是的 ApplicationContext 完整超集，BeanFactory 本章专门用于描述 Spring 的 IoC 容器。有关使用 BeanFactory 而不是 的更多信息，ApplicationContext ,请参阅涵盖 BeanFactoryAPI 的部分。\n在 Spring 中，构成应用程序主干并由 Spring IoC 容器管理的对象称为 bean。bean 是由 Spring IoC 容器实例化、组装和管理的对象。否则，bean 只是应用程序中众多对象中的一个。Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\n”IoC 也称为依赖注入 (DI)。在这个过程中，对象仅通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系（即它们使用的其他对象） . 然后容器在创建 bean 时注入这些依赖项。这个过程基本上是 bean 本身的逆过程（因此得名，控制反转）“\n这句话解释了 IoC、DI：\n个人解释是：\n1、对象的属性是对象的依赖\n2、通常对象想使用 依赖，比如说你的 Controller 对象，想使用 Servlet 对象，需要 new 一个 Servlet 对象 ，再通过 set 方法设置到 Controller 属性，这样 Controller 才能 使用，但是由容器注入这些依赖性，由容器创建这些依赖项，就可以称之为：控制反转、依赖注入\nBean\n可复用的组件 Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat）的，所以 Java Bean 应具有一个无参的构造器，另外，通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 bean 译过来即为“豆子”的意思，大家对豆子的印象是什么，大概就是只能看到豆子硬硬的外皮，而看不到内部的东西。那么在 java 中，bean 可以看成是一个黑盒子，即只需要知道其功能而不必知道其内部构造和设计。 简单笼统来说就是一个类，一个可复用的类。 Spring 对 Bean 的管理的3个方面：\nBean 对象的创建方式（3种） Bean 对象的作用域（5种） Bean 对象的生命周期 单例 多例 1.2. 容器概述 该 org.springframework.context.ApplicationContext 接口表示 Spring IoC 容器，负责实例化、配置和组装 bean。容器通过读取配置元数据获取有关要实例化、配置和组装哪些对象的指令。配置元数据以 XML、Java 注释或 Java 代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。\nApplicationContext Spring 提供了该接口的多个实现。在独立应用程序中，通常创建 ClassPathXmlApplicationContext 或的实例 FileSystemXmlApplicationContext 。虽然 XML 一直是定义配置元数据的传统格式，但您可以通过提供少量 XML 配置以声明方式启用对这些额外元数据格式的支持，从而指示容器使用 Java 注释或代码作为元数据格式。\n在大多数应用场景中，不需要显式的用户代码来实例化一个或多个 Spring IoC 容器实例。例如，在 Web 应用程序场景中，应用程序web.xml文件中简单的八（或左右）行样板 Web 描述符 XML 通常就足够了（请参阅方便的 Web 应用程序的 ApplicationContext 实例化）。如果您使用 Spring Tools for Eclipse（一个由 Eclipse 驱动的开发环境），您可以通过几次鼠标点击或击键轻松地创建这个样板配置。\n下图显示了 Spring 工作原理的高级视图。您的应用程序类与配置元数据相结合，以便在 ApplicationContext 创建和初始化之后，您拥有一个完全配置且可执行的系统或应用程序。\n1.2.1. 配置元数据 如上图所示，Spring IoC 容器使用一种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉 Spring 容器在您的应用程序中实例化、配置和组装对象。\n配置元数据传统上以简单直观的 XML 格式提供，本章的大部分内容都使用这种格式来传达 Spring IoC 容器的关键概念和功能。\n基于 XML 的元数据不是唯一允许的配置元数据形式。Spring IoC 容器本身与实际写入配置元数据的格式完全分离。如今，许多开发人员 为其 Spring 应用程序 选择 基于 Java 的配置 。\n有关将其他形式的元数据用于 Spring 容器的信息，请参阅：\n基于注释的配置 ：使用基于注释的配置元数据定义 bean。 基于 Java 的配置：使用 Java 而不是 XML 文件来定义应用程序类外部的 bean。要使用这些功能，请参阅 @Configuration、 @Bean、 @Import和@DependsOn注释。 Spring 配置包含至少一个且通常不止一个容器必须管理的 bean 定义。基于 XML 的配置元数据将这些 bean 配置为\u0026lt;bean/\u0026gt;顶级元素中的\u0026lt;beans/\u0026gt;元素。Java 配置通常@Bean在类中使用带注释的方法@Configuration。\n这些 bean 定义对应于构成您的应用程序的实际对象。通常，您定义服务层对象、持久层对象（例如存储库或数据访问对象 (DAO)）、表示对象（例如 Web 控制器）、基础结构对象（例如 JPAEntityManagerFactory和 JMS 队列）等等。通常，不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是存储库和业务逻辑的责任。\n以下示例显示了基于 XML 的配置元数据的基本结构：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; (1) (2) \u0026lt;!-- collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;...\u0026#34; class=\u0026#34;...\u0026#34;\u0026gt; \u0026lt;!-- collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- more bean definitions go here --\u0026gt; \u0026lt;/beans\u0026gt; 该id属性是一个字符串，用于标识单个 bean 定义。 该class属性定义 bean 的类型并使用完全限定的类名。 属性的值id可用于引用协作对象。此示例中未显示用于引用协作对象的 XML。有关详细信息，请参阅 依赖项。\n1.2.2. 实例化容器 提供给构造函数的位置路径或路径 ApplicationContext 是资源字符串，让容器从各种外部资源（如本地文件系统、Java 等）加载配置元数据 CLASSPATH 。\nApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;services.xml\u0026#34;, \u0026#34;daos.xml\u0026#34;); 在了解了 Spring 的 IoC 容器之后，您可能想了解更多关于 Spring 的 Resource抽象（如参考资料中所述），它提供了一种方便的机制，用于从 URI 语法中定义的位置读取 InputStream。特别是， Resource路径用于构造应用程序上下文，如应用程序上下文和资源路径中所述。\n以下示例显示了服务层对象(services.xml)配置文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- services --\u0026gt; \u0026lt;bean id=\u0026#34;petStore\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.services.PetStoreServiceImpl\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;accountDao\u0026#34; ref=\u0026#34;accountDao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;itemDao\u0026#34; ref=\u0026#34;itemDao\u0026#34;/\u0026gt; \u0026lt;!-- additional collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- more bean definitions for services go here --\u0026gt; \u0026lt;/beans\u0026gt; 以下示例显示了数据访问对象daos.xml文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;accountDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\u0026#34;\u0026gt; \u0026lt;!-- additional collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;itemDao\u0026#34; class=\u0026#34;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\u0026#34;\u0026gt; \u0026lt;!-- additional collaborators and configuration for this bean go here --\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- more bean definitions for data access objects go here --\u0026gt; \u0026lt;/beans\u0026gt; "},{"id":314,"href":"/Tech/3Java/Spring/Spring-Framework/Spring-Framework/","title":"Spring Framework","parent":"Spring Framework","content":"Spring Framework\n來源：\n链接：https://docs.spring.io/spring-framework/docs/current/reference/html/index.html\n概述 历史、设计理念、反馈、 开始。\n核心 IoC 容器， 事件， 资源， i18n， 验证、数据绑定、类型转换、SpEL、AOP、AOT。\n测试 模拟对象， 测试上下文框架， Spring MVC Test， WebTestClient.\n数据访问 交易， DAO 支持， JDBC， R2DBC， O/R Mapping， XML Marshalling.\nWeb Servlet Spring MVC， WebSocket， SockJS， 跺脚消息。\n网络响应式 Spring WebFlux， WebClient， WebSocket， RSocket.\n集成 REST Client， JMS， JCA， JMX， 电子邮件、任务、计划、缓存、可观测性。\n语言 Kotlin，Groovy，动态语言。\n附录 弹簧属性。\n维基 最新消息， 升级说明、支持的版本、其他跨版本信息。\n"},{"id":315,"href":"/Tech/3Java/Spring/Spring-%E6%B3%A8%E8%A7%A3/","title":"Spring 注解","parent":"Spring","content":" Spring 注解 @Value 注入 String yml populate:\rstring: stringValue 注入 @Value(\u0026#34;${populate.string2:}\u0026#34;)\t// 默认值是空字符串“”\rprivate String stringV;\r@Value(\u0026#34;${populate.string:null}\u0026#34;)\t// 默认值是null\rprivate String stringV2;\r@Value(\u0026#34;${populate.string:defaultValue}\u0026#34;)\t// 默认值是“defaultValue”\rprivate String stringV3;\r@Value(\u0026#34;#{\u0026#39;${allowNameRepetitionPlatformCode:0}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;)\rprivate List\u0026lt;String\u0026gt; allowNameRepetitionPlatformCode;\rprivate List\u0026lt;Long\u0026gt; allowNameRepetitionPlatformCode;\r// 在 yml 文件未对 allowNameRepetitionPlatformCode 配置时，allowNameRepetitionPlatformCode 属性加载默认值，[0], 在 yml 做了相应配置时，属性值为 配置结果，不加载默认值。 注入 Array yml populate:\rarray: array1,array2,array3 注入 @Value(\u0026#34;${populate.array:}\u0026#34;) // 默认值是[]\rprivate String[] array;\r@Value(\u0026#34;${populate.array:a1,a2,a3}\u0026#34;) // 默认值是[a1,a2,a3]\rprivate String[] array1; 注入 List yml populate:\rlist: list1,list2,list3 注入 #{\u0026rsquo;${populate.list:}\u0026rsquo;.split(\u0026rsquo;,\u0026rsquo;)}： #{} 内是SpEL表达式，使用 split 函数指定了分隔符； ${populate.list}：不指定分隔符则会默认以, 作为分隔符。（可能较低版本的Spring不支持，未验证） @Value(\u0026#34;${populate.list:}\u0026#34;) // 默认值是空List，{}\rprivate List\u0026lt;String\u0026gt; list0;\r@Value(\u0026#34;#{\u0026#39;${populate.list:}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) // 默认值是包含一个空字符串的List {“”}\rprivate List\u0026lt;String\u0026gt; list1;\r@Value(\u0026#34;${populate.list:l1,l2,l3}\u0026#34;) // 默认值是{l1,l2,l3}\rprivate List\u0026lt;String\u0026gt; list2;\r@Value(\u0026#34;#{\u0026#39;${populate.list:l1,l2,l3}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) // 默认值是{l1,l2,l3}\rprivate List\u0026lt;String\u0026gt; list3;\r@Value(\u0026#34;#{\u0026#39;${populate.list:,}\u0026#39;.split(\u0026#39;,\u0026#39;)}\u0026#34;) // 默认值是空List，{}\rprivate List\u0026lt;String\u0026gt; list4; 注入 Map yml key可以但不必被单引号包围 value必须被单引号包围 populate:\rmap: \u0026#34;{\r\u0026#39;key1\u0026#39;: \u0026#39;value1\u0026#39;,\r\u0026#39;key2\u0026#39;: \u0026#39;value2\u0026#39;,\r\u0026#39;key3\u0026#39;: \u0026#39;value3\u0026#39;\r}\u0026#34;\rmapList: \u0026#34;{\rkey1: \u0026#39;v11,v12\u0026#39;,\rkey2: \u0026#39;v21,v22\u0026#39;,\rkey3: \u0026#39;v31,v32\u0026#39;\r}\u0026#34; 注入 @Value(\u0026#34;#{${populate.map:{}}}\u0026#34;)\t// 默认值是null\rprivate Map\u0026lt;String,String\u0026gt; map;\r@Value(\u0026#34;#{${populate.map:null}}}\u0026#34;) // 默认值是null\rprivate Map\u0026lt;String, String\u0026gt; map2;\r@Value(\u0026#34;#{${populate.map:{k1:\u0026#39;v1\u0026#39;,k2:\u0026#39;v2\u0026#39;}}}\u0026#34;) // 默认值是{\u0026#34;k1\u0026#34;:\u0026#34;v1\u0026#34;,\u0026#34;k2\u0026#34;:\u0026#34;v2\u0026#34;}\rprivate Map\u0026lt;String, String\u0026gt; map3;\r@Value(\u0026#34;#{${populate.mapList:{}}}\u0026#34;)\t// 值为{\u0026#34;key1\u0026#34;:[\u0026#34;v11\u0026#34;,\u0026#34;v12\u0026#34;],\u0026#34;key2\u0026#34;:[\u0026#34;v21\u0026#34;,\u0026#34;v22\u0026#34;],\u0026#34;key3\u0026#34;:[\u0026#34;v31\u0026#34;,\u0026#34;v32\u0026#34;]}\rprivate Map\u0026lt;String,List\u0026lt;String\u0026gt;\u0026gt; mapList; ${} 与 #{…} 主要用于加载外部属性文件中的值 ${…} 用于执行SpEl表达式，并将内容赋值给属性 #{…} 和 $ {…} 可以混合使用，但是必须#{}外面，${}在里面 注入 静态变量 spring 不允许/不支持把值注入到静态变量中 在spring支持set方法注入，我们可以利用非静态setter 方法注入静态变量。 注入 @Value(\u0026#34;#{${populate.map:{}}}\u0026#34;)\t// 默认值是null\rprivate static String CLUSTER_NAME;\r@Value(\u0026#34;${ES.CLUSTER_NAME}\u0026#34;)\rpublic void setClusterName(String clusterName) {\rCLUSTER_NAME = clusterName;\r} "},{"id":316,"href":"/Tech/3Java/Spring/Spring-1-%E6%A6%82%E5%BF%B5/","title":"Spring 1 概念","parent":"Spring","content":" 设计理念 提供各个层面的选择。Spring 允许您尽可能推迟设计决策。例如，可以通过配置切换持久性提供程序，而无需更改代码。对于许多其他基础架构问题以及与第三方 API 的集成也是如此。 核心技术 Ioc 和 DI 和 POI Ioc DI POI Ioc 和 DI 框架的一个重要特征是用户定义的用于定制框架的方法通常从框架本身调用，而不是从用户的应用程序代码调用。该框架通常在协调和排序应用程序活动中扮演主要程序的角色。这种控制反转使框架具有作为可扩展骨架的能力。用户提供的方法定制框架中为特定应用程序定义的通用算法。\n库本质上是一组可以调用的函数。\n框架体现了一些抽象设计，内置了更多行为。为了使用它，您需要通过子类化或插入自己的类将行为插入到框架中的各个位置。然后框架的代码在这些点上调用您的代码。\n我将方法的控制权交给了框架系统。然后根据我对框架所做的设定，决定何时调用我的方法。控制被颠倒了 - 它叫我而不是我调用框架。这种现象是控制倒置（也称为好莱坞原则 - “不要打电话给我们，我们会打电话给你”）。\n它执行调用，您的代码作出反应 - 所以再次控制被反转。\n（个人总结：将 控制反转 称为 反向控制 就容易理解的多了。。。）\nSpring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。\n控制的什么被反转了？就是：获得依赖对象的方式反转了。\n传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。\nIoC 的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过 DI（Dependency Injection，依赖注入）来实现的。\nDI 是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。\n来自：https://www.martinfowler.com/bliki/InversionOfControl.html\nIoc 和 DI 和 POI 控制反转和依赖注入是框架的特性，而 spring 的核心的精神是依赖注入！！！\n"},{"id":317,"href":"/Tech/3Java/Spring/springMVC/","title":"Spring Mvc","parent":"Spring","content":" springMVC HandlerMethod 类：\n简单来说HandlerMethod包含的信息包括类、方法和参数的一个信息类。\n"},{"id":318,"href":"/Tech/3Java/Spring/Spring%E4%BA%8B%E5%8A%A1/","title":"Spring事务","parent":"Spring","content":"SpringAOP 代理的实现过程；事务管理也是AOP的一个重要的功能。\n"},{"id":319,"href":"/Tech/3Java/Spring/%E5%9F%BA%E4%BA%8ESpringBoot-AOP%E6%9D%A1%E4%BB%B6%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%B3%A8%E8%A7%A3/","title":"基于 Spring Boot Aop条件下自定义、实现注解","parent":"Spring","content":" 基于SpringBoot AOP条件下自定义、实现注解 转自： 青灯抽丝-基于SpringBoot AOP条件下自定义、实现注解\n作者： 青灯抽丝\n链接：https://mp.weixin.qq.com/s/qGpd2_6MwP5sYbSVPbxaPQ\n来源： 青灯抽丝\n本文介绍SpringBoot条件下，借助于AOP实现自定义注解\nMeta Annotation元注解 所谓元注解，就是Java提供的、负责修饰其他注解的注解。常见地有：\n@Target注解 其定义了注解可以作用的位置，其value属性地常用取值有：\nElementType.PACKAGE：包 ElementType.TYPE：类、接口、枚举 ElementType.FIELD：字段 ElementType.METHOD：方法 ElementType.PARAMETER：方法形参 ElementType.CONSTRUCTOR：构造器方法 @Target 注解的 value 是数组类型，当只有一个元素时，可以省略数组写法。示例如下所示：\n// 该注解可用于方法上\r@Target(ElementType.METHOD)\r// 该注解可用于字段、方法、构造器方法上\r@Target({\rElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR\r}) @Retention注解 其定义了注解的生命周期。其value属性地常用取值有：\nRetentionPolicy.SOURCE：在Java源文件中有效。编译器会丢弃掉 RetentionPolicy.CLASS：在Class文件中有效。运行时JVM会丢弃掉 RetentionPolicy.RUNTIME：运行时有效。此时即可通过反射获取到该注解 日常开发中，对于@Retention注解而言。我们用的更多的就是RetentionPolicy.RUNTIME了。示例如下\n// 该注解保留到运行时\r@Retention(RetentionPolicy.RUNTIME) @Repeatable注解 默认情况下，注解不可以在同一处重复使用。为此 Java 8中引入了 @Repeatable 注解解决该问题。通过添加 @Repeatable 注解表示 @Family 注解可在同一处重复使用。同时，我们需要在 @Repeatable 注解的值中指定另一个注解 @Families。表示可以通过 @Families 注解的值来包含这个可重复的注解 @Family。显然此时，@Families 中 value 属性的类型则必须是 @Family 注解的数组\n@Target(ElementType.FIELD) // 该注解用于字段\r@Retention(RetentionPolicy.RUNTIME) // 该注解保留到运行时\r@Repeatable(Families.class) // 该注解可重复\rpublic @interface Family {\rString value() default \u0026#34;\u0026#34;;\r}\r...\r@Target(ElementType.FIELD) // 该注解用于字段\r@Retention(RetentionPolicy.RUNTIME) // 该注解保留到运行时\rpublic @interface Families {\rFamily[] value();\r} 现在，我们就可以在同一处重复使用@Family注解了。下述两种写法均可\npublic class User {\r@Family(\u0026#34;Aaron\u0026#34;)\r@Family(\u0026#34;Bob\u0026#34;)\rprivate int name1;\r@Families({\r@Family(\u0026#34;Aaron\u0026#34;), @Family(\u0026#34;Bob\u0026#34;)\r})\rprivate String name2;\r} 自定义注解 自定义注解的基本语法格式如下例所示。其中自定义注解可通过下述形式定义注解属性。可通过default指定属性的默认值，如果不指定默认值，则在使用注解时必须显式设置属性值，而无法使用默认值。需注意属性类型仅限下述几种：\n基本数据类型(boolean, byte, char, short, int, long, float, double) String类型、Class类型、注解类型、枚举类 上述类型的数组 /**\r* 自定义注解\r*/\r@Target(ElementType.METHOD) // 该注解用于方法\r@Retention(RetentionPolicy.RUNTIME) // 该注解保留到运行时\rpublic @interface MyLog {\r// 定义类型为long、名为value的属性\rlong value();\r// 定义类型为String、名为level的属性, 默认值为 \u0026#34;INFO\u0026#34;\rString level() default \u0026#34;INFO\u0026#34;;\r} 基于AOP实现注解 完成自定义注解后，我们期望在方法上添加注解，能够在调用方法的前后实现日志输出（包含方法入参、方法结果等信息）。这里我们结合SpringBoot的AOP来实现对自定义注解输出日志的功能\n/**\r* 实现@Mylog注解功能的切面类\r*/\r@Component\r@Aspect\r@Slf4j\rpublic class MyLogAop {\r@Around( \u0026#34;@annotation(com.aaron.SpringBoot1.annotation.MyLog)\u0026#34; )\rpublic void log(ProceedingJoinPoint joinPoint) throws Throwable {\r// 获取方法信息\rMethodSignature methodSignature = (MethodSignature)joinPoint.getSignature();\rString methodName = methodSignature.getName(); // 获取方法名\rString[] paramNames = methodSignature.getParameterNames(); // 获取方法参数名\rObject[] args = joinPoint.getArgs(); // 获取方法参数值\r// 获取注解信息\rMyLog myLog = methodSignature.getMethod().getAnnotation( MyLog.class);\rlong timestamp = myLog.value();\rString level = myLog.level();\rStringBuilder sb = new StringBuilder();\rfor (int i=0; i\u0026lt;paramNames.length; i++) {\rsb.append(\u0026#34;\u0026lt;\u0026#34;).append(paramNames[i]).append(\u0026#34;:\u0026#34;).append(args[i]).append(\u0026#34;\u0026gt;\u0026#34;);\r}\r// 执行开始前打印日志\rString startMsg = \u0026#34;[START] TS: \u0026#34;+ timestamp + \u0026#34; \u0026lt;\u0026#34;+level+\u0026#34;\u0026gt;\u0026#34; + \u0026#34; MethodName: \u0026#34; + methodName + \u0026#34; Param: \u0026#34; + sb.toString();\rlog.info(startMsg);\r// 调用目标方法\rObject res=\u0026#34;Exec Failed\u0026#34;;\rtry {\rres = joinPoint.proceed();\r} catch (Exception e) {\rlog.error(\u0026#34;Happen Excep: {}\u0026#34;, e.getMessage());\r}\r// 执行完成后打印日志\rString endMsg = \u0026#34;[END] TS: \u0026#34;+ timestamp + \u0026#34; \u0026lt;\u0026#34;+level+\u0026#34;\u0026gt;\u0026#34; + \u0026#34; MethodName: \u0026#34; + methodName + \u0026#34; Result: \u0026#34; + res;\rlog.info(endMsg);\r}\r} 至此，就可以使用该注解了\n@RestController\r@RequestMapping(\u0026#34;test\u0026#34;)\rpublic class TestController {\r@MyLog(1995832)\r@GetMapping(\u0026#34;/demo1\u0026#34;)\rpublic String test1(@RequestParam(required = false) String firstName, @RequestParam(required = false) String lastName) {\rString res = \u0026#34;Hello\u0026#34;;\rif( firstName!=null ) {\rres += \u0026#34; \u0026#34; + firstName;\r}\rif( lastName!=null ) {\rres += \u0026#34; \u0026#34; + lastName;\r}\rreturn res;\r}\r} 发送下述请求\ncurl \u0026#34;127.0.0.1:8080/test/demo1?firstName=Tony\u0026amp;lastName=Wang\u0026#34; 结果如下所示\n其它 如果一个注解中有一个名为value的属性。在使用该注解时，如果只设置value属性的话(要么该注解中只有一个value属性、要么其他属性均使用默认值)，则可以省略掉属性名value。如下所示\npublic class Task { @MyLog(22)\rpublic void runTask1() {\r...\r}\r@MyLog(value = 22)\rpublic void runTask2() {\r...\r} "},{"id":320,"href":"/Tech/3Java/Spring/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8-Spring-Cloud-Stream/","title":"消息驱动—— Spring Cloud Stream","parent":"Spring","content":" 消息驱动—— Spring Cloud Stream 标签：Java、业务模型、进阶、Java框架 时间：2019年10月11日10:39:53 连接：https://www.saveload.cn/html/technology/消息驱动—— Spring Cloud Stream.mk 我们与世界的互动并不是同步的、线性的、严格按照提问-回应的模式进行的，而是消息驱动，不断的接发信息。当我们接收到消息，会对这些消息做出反应，当然，我们也经常会被打断正在执行的主要工作。 通过异步消息与其它微服务互相交互的微服务。使用异步消息在应用间互相通信并不是什么新概念，新的概念是使用消息来传达事件状态的改变——Event Driven Architecture(EDA)，即事件驱动架构，也可以称为Message Driven Architecture(MDA)，消息驱动架构。基于事件驱动架构，我们可以构建高度解耦的系统，需要互相通信的服务不用通过特定的库或其它服务紧密耦合在一起。当与微服务结合时，我们只需让服务监听应用程序发出的事件(消息)流，接收到事件(消息)后作出对应的响应，就可以在应用程序中快速添加新功能。 Spring Cloud的子项目Spring Cloud Stream，能让基于消息驱动的应用开发变得更加简单，使用它，我们可以很容易地就能实现“消息发布和消费”，而且会对底层消息传递平台(后文会介绍)屏蔽服务（包括发布者和消费者）的实现细节。 "},{"id":321,"href":"/Tech/3Java/Spring/%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90/","title":"路由数据源","parent":"Spring","content":"1、定义多个数据源，有不同的ID\n\u0026lt;!-- Druid --\u0026gt;\r\u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${dataSource.driverClassName}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${dataSource.url}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${dataSource.username}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${dataSource.password}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;initialSize\u0026#34; value=\u0026#34;${dataSource.initialSize}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;maxIdle\u0026#34; value=\u0026#34;${dataSource.maxIdle}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;maxActive\u0026#34; value=\u0026#34;${dataSource.maxActive}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;maxWait\u0026#34; value=\u0026#34;${dataSource.maxWait}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;validationQuery\u0026#34; value=\u0026#34;SELECT 1 FROM DUAL\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;testWhileIdle\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;testOnBorrow\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;testOnReturn\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;bean id=\u0026#34;dataSourceHanaJCZC\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${hana.driverClassName}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${hanaJCZC.url}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${hanaJCZC.username}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${hanaJCZC.password}\u0026#34;/\u0026gt;\r\u0026lt;/bean\u0026gt;\r\u0026lt;bean id=\u0026#34;dataSourceHanaSJCK\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${hana.driverClassName}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${hanaSJCK.url}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${hanaSJCK.username}\u0026#34;/\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${hanaSJCK.password}\u0026#34;/\u0026gt;\r\u0026lt;/bean\u0026gt; 2、配置路由器数据源\n\u0026lt;!-- 配置路由器数据源 --\u0026gt;\r\u0026lt;bean id=\u0026#34;dataSourceRouter\u0026#34; class=\u0026#34;com.pcitc.monitoring.common.DataSourceRouter\u0026#34;\u0026gt;\r\u0026lt;!-- 使用键值对形式管理各个具体的数据源 --\u0026gt;\r\u0026lt;property name=\u0026#34;targetDataSources\u0026#34;\u0026gt;\r\u0026lt;map\u0026gt;\r\u0026lt;!-- key的指可以自行指定 --\u0026gt;\r\u0026lt;!-- value-ref引用一个具体的数据源 --\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_MAIN\u0026#34; value-ref=\u0026#34;dataSource\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_HANA_JCZC\u0026#34; value-ref=\u0026#34;dataSourceHanaJCZC\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_HANA_SJCK\u0026#34; value-ref=\u0026#34;dataSourceHanaSJCK\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_HANA_SJFW\u0026#34; value-ref=\u0026#34;dataSourceHanaSJFW\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_HANA_XSBW\u0026#34; value-ref=\u0026#34;dataSourceHanaXSBW\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_HANA_HRBW\u0026#34; value-ref=\u0026#34;dataSourceHanaHRBW\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_DATA_SJFW\u0026#34; value-ref=\u0026#34;dataSourceDataSJFW\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_DATA_HQX\u0026#34; value-ref=\u0026#34;dataSourceDataHQX\u0026#34;/\u0026gt;\r\u0026lt;entry key=\u0026#34;DATASOURCE_HANA_XSJS\u0026#34; value-ref=\u0026#34;dataSourceHanaXSJS\u0026#34;/\u0026gt;\r\u0026lt;/map\u0026gt;\r\u0026lt;/property\u0026gt;\r\u0026lt;!-- 在determineCurrentLookupKey()方法返回null时使用默认数据源 --\u0026gt;\r\u0026lt;property name=\u0026#34;defaultTargetDataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt;\r\u0026lt;/bean\u0026gt; 3、注册SqlSessionFactoryBean\n\u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSourceRouter\u0026#34;/\u0026gt;\r\u0026lt;!-- 自动扫描mappers.xml文件 --\u0026gt;\r\u0026lt;property name=\u0026#34;mapperLocations\u0026#34;\u0026gt;\r\u0026lt;array\u0026gt;\r\u0026lt;value\u0026gt;classpath*:com/pcitc/monitoring/apply/dao/mapper/*.xml\u0026lt;/value\u0026gt;\r\u0026lt;value\u0026gt;classpath*:com/pcitc/monitoring/business/dao/mapper/*.xml\u0026lt;/value\u0026gt;\r\u0026lt;value\u0026gt;classpath*:com/pcitc/monitoring/interfaced/dao/mapper/*.xml\u0026lt;/value\u0026gt;\r\u0026lt;value\u0026gt;classpath*:com/pcitc/monitoring/realtime/dao/mapper/*.xml\u0026lt;/value\u0026gt;\r\u0026lt;value\u0026gt;classpath*:com/pcitc/monitoring/core/dao/mapper/*.xml\u0026lt;/value\u0026gt;\r\u0026lt;/array\u0026gt;\r\u0026lt;/property\u0026gt;\r\u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\r\u0026lt;/bean\u0026gt; 4、第2步 class 属性的实现类\npublic class DataSourceRouter extends AbstractRoutingDataSource {\r@Override\rprotected Object determineCurrentLookupKey() {\r//1.从当前线程上获取本次操作访问数据库需要的键\rString key = DataSourceKeyBinder.getKey();\r//2.将键的信息从当前线程上移除，避免对其它操作造成影响\rDataSourceKeyBinder.removeKey();\r//3.将1中获取到的键的信息返回用来决定到底使用哪个数据源\rreturn key;\r}\r} public class DataSourceKeyBinder {\rprivate static ThreadLocal\u0026lt;String\u0026gt; local = new ThreadLocal\u0026lt;\u0026gt;();\rpublic static void bindKey(String key) {\rlocal.set(key);\r}\rpublic static void removeKey() {\rlocal.remove();\r}\rpublic static String getKey() {\rreturn local.get();\r}\r} 5、使用\n//应用监控DUMP异常信息\r@ResponseBody\r@RequestMapping(value = \u0026#34;/getDUMPChart\u0026#34;)\rpublic List \u0026lt;Map\u0026gt; getDUMPChart() {\rDataSourceKeyBinder.bindKey(“DATASOURCE_HANA_JCZC”);\rreturn applyService.getDUMPChart();\r} "},{"id":322,"href":"/Tech/3Java/Spring/%E9%AB%98%E6%80%A7%E8%83%BDJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0HikariCP/","title":"高性能 Jdbc连接池： Hikari Cp","parent":"Spring","content":" 1、使用方法： datasource:\rhikari:\rminimum-idle: 5\rmaximum-pool-size: 15\rauto-commit: true\ridle-timeout: 30000\rpool-name: test\rmax-lifetime: 1800000\rconnection-timeout: 30000\rconnection-test-query: select 1\rdriver-class-name: com.mysql.jdbc.Driver\rjdbc-url: jdbc:mysql://192.168.2.100:3306/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;allowMultiQueries=true\rusername: admin\rpassword: d12h.Po(_f HikariConfig config = new HikariConfig();\rconfig.setMaximumPoolSize(100);\rconfig.setDataSourceClassName(\u0026#34;com.mysql.jdbc.jdbc2.optional.MysqlDataSource\u0026#34;);\rconfig.addDataSourceProperty(\u0026#34;serverName\u0026#34;, \u0026#34;localhost\u0026#34;);\rconfig.addDataSourceProperty(\u0026#34;port\u0026#34;, \u0026#34;3306\u0026#34;);\rconfig.addDataSourceProperty(\u0026#34;databaseName\u0026#34;, \u0026#34;mydb\u0026#34;);\rconfig.addDataSourceProperty(\u0026#34;user\u0026#34;, \u0026#34;bart\u0026#34;);\rconfig.addDataSourceProperty(\u0026#34;password\u0026#34;, \u0026#34;51mp50n\u0026#34;);\rHikariDataSource ds = new HikariDataSource(config); 或者 /**\rconnectionTestQuery=SELECT 1\rdataSourceClassName=org.postgresql.ds.PGSimpleDataSource\rdataSource.user=test\rdataSource.password=test\rdataSource.databaseName=mydb\rdataSource.serverName=localhost\r*/\rHikariConfig config = new HikariConfig(\u0026#34;some/path/hikari.properties\u0026#34;);\rHikariDataSource ds = new HikariDataSource(config); 或者 \u0026lt;!-- Hikari Datasource --\u0026gt;\r\u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.zaxxer.hikari.HikariDataSource\u0026#34; destroy-method=\u0026#34;shutdown\u0026#34;\u0026gt;\r\u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34; /\u0026gt; \u0026lt;!-- 无需指定，除非系统无法自动识别 --\u0026gt;\r\u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34; /\u0026gt;\r\u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34; /\u0026gt;\r\u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34; /\u0026gt;\r\u0026lt;!-- 连接只读数据库时配置为true， 保证安全 --\u0026gt;\r\u0026lt;property name=\u0026#34;readOnly\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt;\r\u0026lt;!-- 等待连接池分配连接的最大时长（毫秒），超过这个时长还没可用的连接则发生SQLException， 缺省:30秒 --\u0026gt;\r\u0026lt;property name=\u0026#34;connectionTimeout\u0026#34; value=\u0026#34;30000\u0026#34; /\u0026gt;\r\u0026lt;!-- 一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟 --\u0026gt;\r\u0026lt;property name=\u0026#34;idleTimeout\u0026#34; value=\u0026#34;600000\u0026#34; /\u0026gt;\r\u0026lt;!-- 一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数（show variables like \u0026#39;%timeout%\u0026#39;;） --\u0026gt;\r\u0026lt;property name=\u0026#34;maxLifetime\u0026#34; value=\u0026#34;1800000\u0026#34; /\u0026gt;\r\u0026lt;!-- 连接池中允许的最大连接数。缺省值：10；推荐的公式：((core_count * 2) + effective_spindle_count) --\u0026gt;\r\u0026lt;property name=\u0026#34;maximumPoolSize\u0026#34; value=\u0026#34;15\u0026#34; /\u0026gt;\r\u0026lt;/bean\u0026gt; 阿里巴巴连接池设置 datasource:\rname: test\rtype: com.alibaba.druid.pool.DruidDataSource\r#druid相关配置\rdruid:\r#监控统计拦截的filters\rfilters: stat\rdriver-class-name: com.mysql.jdbc.Driver\r#基本属性\rurl: jdbc:mysql://192.168.2.100:3306/test?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;allowMultiQueries=true\rusername: admin\rpassword: d12h.Po(_f\r#配置初始化大小/最小/最大\rinitial-size: 1\rmin-idle: 1\rmax-active: 20\r#获取连接等待超时时间\rmax-wait: 60000\r#间隔多久进行一次检测，检测需要关闭的空闲连接\rtime-between-eviction-runs-millis: 60000\r#一个连接在池中最小生存的时间\rmin-evictable-idle-time-millis: 300000\rvalidation-query: SELECT \u0026#39;x\u0026#39;\rtest-while-idle: true\rtest-on-borrow: false\rtest-on-return: false\r#打开PSCache，并指定每个连接上PSCache的大小。oracle设为true，mysql设为false。分库分表较多推荐设置为false\rpool-prepared-statements: false\rmax-pool-prepared-statement-per-connection-size: 20 "},{"id":323,"href":"/Tech/3Java/Thread/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","title":"Java 并发编程：同步并实现原理","parent":"Thread","content":" Java并发编程：Synchronized 同步并实现原理 一、Synchronized 的基本使用 修饰普通方法\n对方法的同步本质上是对对象的同步（方法本质上是属于对象的方法），所以同一同的对象，只能顺序的执行，不能并发执行。 修饰静态方法\n对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使方法属于不同的对象，但是它们都属于类的实例，所以也只能顺序的执行，不能并发执行。 修饰代码块\n对于代码块的同步实质上需要获取Synchronized关键字后面括号中对象的monitor jvm用monitorenter和monitorexit指令对同步提供显式支持。而java常用sychronized方法。\rsychronized“方法”通常不是用monitorenter和monitorexit指令实现的。往往是由“方法调用指令”检查常数池里的ACC_SYCHRONIZED标志\r但monitorenter和monitorexit指令是为了支持sychronized“语句”而存在的。\r注意这里的方法和语句的区别。\r语句实例如下：test.java\rpublic class test {\rpublic test() {\r}\rpublic static void main(String[] args) {\rsynchronized(new Object()){\rint i = 0;\r}\r}\r}\r编译完的结果：\rC:\\JBuilderX\\bin\u0026gt;javap -c -classpath \u0026#34;d:/epm40/classes\u0026#34; test\rCompiled from \u0026#34;test.java\u0026#34;\rpublic class test extends java.lang.Object{\rpublic test();\rCode:\r0: aload_0\r1: invokespecial #1; //Method java/lang/Object.\u0026#34;\u0026#34;:()V\r4: nop\r5: return\rpublic static void main(java.lang.String[]);\rCode:\r0: new #2; //class Object\r3: dup\r4: invokespecial #1; //Method java/lang/Object.\u0026#34;\u0026#34;:()V\r7: dup\r8: astore_1\r9: monitorenter\r10: iconst_0\r11: istore_2\r12: nop\r13: aload_1\r14: monitorexit\r15: goto 23\r18: astore_3\r19: aload_1\r20: monitorexit\r21: aload_3\r22: athrow\r23: nop\r24: return\rException table:\rfrom to target type\r10 15 18 any\r18 21 18 any\r}\r而synchronized方法编译没有特殊之处，只是在方法名上加了synchronzied字样。\r1、同步代码块：\rmonitorenter ：\r每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：\r1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。\r2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.\r3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。\rmonitorexit：\r执行monitorexit的线程必须是objectref所对应的monitor的所有者。\r指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。\rSynchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。\r2、同步方法\r方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。 "},{"id":324,"href":"/Tech/3Java/Thread/Java-%E7%BA%BF%E7%A8%8BThread/","title":"Java 线程（ Thread）","parent":"Thread","content":" Java线程的讲解 标签：Java、线程、Thread 时间：2020年7月8日15点42分 内容：对 Java 线程及设计的相关知识点做记录及讲解 一、Java 线程的状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE)：Java线程中将就绪（可运行）（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 二、线程的状态图 1. 初始状态 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。\n2.1. 就绪状态 就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。 调用线程的start()方法，此线程进入就绪状态。 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。 锁池里的线程拿到对象锁后，进入就绪状态。 2.2. 运行中状态 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。\n3. 阻塞状态 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。\n阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。（线程试图得到一个锁，而该锁正被其他线程持有） 当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。 运行在当前线程里的其它线程t2调用join()方法，当前线程进入阻塞状态。 等待用户输入的时候，当前线程进入阻塞状态。（线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者） 4. 等待 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n5. 超时等待 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n6. 终止状态 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。 在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 三、等待队列(本是Object里的方法，但影响了线程) 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。 与等待队列相关的步骤和图： 1.线程1获取对象A的锁，正在使用对象A。 2.线程1调用对象A的wait()方法。 3.线程1释放对象A的锁，并马上进入等待队列。 4.锁池里面的对象争抢对象A的锁。 5.线程5获得对象A的锁，进入synchronized块，使用对象A。 6.线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入同步队列。若线程5调用对象A的notify()方法，则唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入同步队列。 7.notifyAll()方法所在synchronized结束，线程5释放对象A的锁。 8.同步队列的线程争抢对象锁，但线程1什么时候能抢到就不知道了。 同步队列状态（锁池状态） 当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入同步队列。简言之，同步队列里面放的都是想争夺对象锁的线程。 当一个线程1被另外一个线程2唤醒时，1线程进入同步队列，去争夺对象锁。 同步队列是在同步的环境下才有的概念，一个对象对应一个同步队列。 几个方法的比较 Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。 调用：[运行状态]-\u0026gt;[休眠（阻塞）状态]，结束：[阻塞状态]-\u0026gt;[就绪状态] Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。yield()的作用是让步，它能够让当前线程从“运行状态”进入到“就绪状态”，从而让其他等待线程获取执行权，但是不能保证在当前线程调用yield()之后，其他线程就一定能获得执行权，也有可能是当前线程又回到“运行状态”继续运行，注意：这里我将上面的“具有相同优先级”的线程直接改为了线程，很多资料都写的是让具有相同优先级的线程开始竞争，但其实不是这样的，优先级低的线程在拿到cpu执行权后也是可以执行，只不过优先级高的线程拿到cpu执行权的概率比较大而已，并不是一定能拿到。 调用：[运行状态]-\u0026gt;[就绪状态]，结束：[就绪状态]-\u0026gt;[运行状态] or [就绪状态]-\u0026gt;[阻塞状态] t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。 t.suspend()和 t.resume()方法，两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume()被调用，才能使得线程重新进入可执行状态。典型地，suspend()和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume()使其恢复。suspend()及其它所有方法在线程阻塞时都不会释放占用的锁（如果占用了的话），而wait() 和 notify() 这一对方法则相反。 obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用 obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。 每个对象都有一个锁来控制同步访问。Synchronized 关键字可以和对象的锁交互，来实现线程的同步。 sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait()方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 除了notify()，还有一个方法 notifyAll()也可起到类似作用，唯一的区别在于，调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 简单总结一下：\n线程对象的一个代码片段要想被执行需要满足两个条件：1、线程被调起，2、获得了对象的锁。\nOS 调度选择可运行的线程（已经 Thread.start() 的线程），若线程处于堵塞状态，调度机制可以简单地跳过它，不给它分配任何CPU时间。\n优先级低的线程在拿到cpu执行权后也是可以执行，只不过优先级高的线程拿到cpu执行权的概率比较大而已，并不是一定能拿到。\n堵塞原因：Thread.sleep(long millis)、Thread.join()、obj.wait()、Synchronized、在I/O上被阻塞、\n"},{"id":325,"href":"/Tech/3Java/XStream/","title":"Xstream","parent":"3、Java","content":" XStream 1、string =\u0026gt; boolean /** * 是否重试,1-true:重试、0-false:不重试 */ @XStreamConverter(value= BooleanConverter.class, booleans={false}, strings={\u0026#34;1\u0026#34;, \u0026#34;0\u0026#34;}) @XStreamAsAttribute @XStreamAlias(\u0026#34;isretry\u0026#34;) private boolean isRetry; \u0026lt;error code=\u0026#34;1\u0026#34; analytical=\u0026#34;请登录后再操作\u0026#34; isretry=\u0026#34;0\u0026#34;/\u0026gt; "},{"id":326,"href":"/Tech/3Java/%E5%87%A0%E7%A7%8D%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%8E%E7%AE%80%E4%BB%8B/","title":"几种无损压缩算法整理与简介","parent":"3、Java","content":" 几种无损压缩算法整理与简介 转自： 小川CD\n链接：https://m.weibo.cn/profile/1202332555\n压缩算法分为无损压缩和有损压缩。简单来说无损压缩要求压缩后的数据，经过解压能够得到和压缩前一模一样的数据。例如winrar和或者zip就是一种无损压缩。有损压缩，比如视频、图像，并不要求解压后的数据和原始数据一模一样，要求的是肉眼看上去图像是差不多一样即可，例如常见的H.264、H.265算法。\n在存储系统中，要求的是无损压缩，即压缩后再解压能够得到原来的二进制数据。例如：snappy、zlib、zstd、lz4等。这几种算法也是CEPH中可选的压缩算法。一般来说衡量一种压缩算法的优劣，主要从压缩率、压缩速度、解压速度等方面来考虑。\n下面分别来看看这几种压缩算法的简介和特点。 性能评测：lzbench，详见GitHub。\n比较基准：（压缩速度、解压速度、压缩率）\n以memcpy为参考，性能指标为：（10362 MB/s, 10790 MB/s, 100.00）\nSnappy ，详见GitHub，谷歌开源。\n性能指标：（591 MB/s, 1868 MB/s, 48.19）\nSnappy 是一个 C++ 的用来压缩和解压缩的开发包。其目标不是最大限度压缩或者兼容其他压缩格式，而是旨在提供高速压缩速度和合理的压缩率。Snappy 比 zlib 更快，但文件相对要大 20% 到 100%。在 64位模式的 Core i7 处理器上，可达每秒 250~500兆的压缩速度。Snappy 在 Google 内部被广泛的使用，从 BigTable 到 MapReduce 以及内部的 RPC 系统。Google极力赞扬Snappy的各种优点，Snappy从一开始就被“设计为即便遇到损坏或者恶意的输入文件都不会崩溃”，而且被Google在生产环境中用于压缩PB级的数据。其健壮性和稳定程度可见一斑。\nZstd，详见GitHub，facebook开源。 性能指标：（1级：480 MB/s, 1203 MB/s, 34.68），压缩级别可选，级别越高，压缩率越好，但是性能越差。\nZtsd，全称Zstandard，其设计目的是提供一个高压缩比，但更快，特别是解压缩快的算法。它的压缩级别从负5级（最快）到22级（压缩速度最慢，但是压缩比最高）可以调节。压缩速度在最快和最慢级别之间可以相差20倍或更多，而解压缩速度统统很快，在最快和最慢级别之间相差不到20%。Zstandard命令行有一个“自适应”（\u0026ndash;adapt）模式，根据I/O条件改变压缩级别，主要是写入输出的速度。Zstd在其最大压缩级别下的压缩比接近lzma、lzham和ppmx，并且比lza或bzip2性能更好。 Zstandard达到了当前的Pareto边界，因为它解压缩的速度比任何其他当前可用的算法都要快，并且有类似的或者更好的压缩比。\nLz4，详见GitHub。 性能指标：（lz4 1.9.2 737 MB/s, 4448 MB/s, 47.60），lz4提供不同的参数以及压缩级别，可以达到不同的压缩率和压缩速度。\nLZ4是一种无损压缩算法，提供超过单核500MB/s的压缩速度，并且支持多核扩展。它的特点是解压速度非常块，可以达到单核心数GB/s，在多核系统上可以达到内存（RAM）的速度限制。和Zstd一样，它的压缩速度是可以调节的，那么如何在压缩率与压缩速度之间做权衡，这个是需要考虑的。\nZlib，详见GitHub。 性能指标：（lz4 1.9.2 119 MB/s, 383 MB/s, 36.45）\nzlib初版0.9版在1995年5月1日发表。zlib使用DEFLATE算法，最初是为libpng函式库所写的，后来普遍为许多软件所使用。此函式库为自由软件，使用zlib授权。截至2007年3月，zlib是包含在Coverity的美国国土安全部赞助者选择继续审查的开源项目。今天，zlib是一种事实上的业界标准，以至于在标准文档中，zlib和DEFLATE常常互换使用。数以千计的应用程序直接或间接依靠zlib压缩函式库，包括：\nLinux：使用zlib以实作网络协定的压缩、档案系统的压缩以及开机时解压缩自身的核心。 libpng，用于PNG图形格式的一个实现，对bitmap数据规定了DEFLATE作为流压缩方法。 Apache：使用zlib实作http 1.1。 \u0026hellip;\u0026hellip;\n因为其代码的可移植性，宽松的许可以及较小的内存占用，zlib在许多嵌入式设备中也有应用。\n以上是几种无损压缩算法的简介，那么在实际应用中，面对这么多算法和开源实现。既要考虑其压缩性能和压缩率，另外稳定性，开源许可都是需要考虑的。\n（以上资料均摘抄于：维基百科、百度百科、Github等。）\n"},{"id":327,"href":"/Tech/3Java/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E9%89%B4%E6%9D%83%E6%96%B9%E5%BC%8F/","title":"常见的前后端鉴权方式","parent":"3、Java","content":" 常见的前后端鉴权方式 转自：阮一峰\n链接：http://www.ruanyifeng.com/blog/\nSession-Cookie Token 验证(包括JWT，SSO) OAuth2.0（开放授权） 什么是认证（Authentication） 通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功） 互联网中的认证： 用户名密码登录 邮箱发送登录链接 手机号接收验证码 只要你能收到邮箱/验证码，就默认你是账号的主人 什么是授权（Authorization） 赋予某个认证访问某些资源的权限 实现授权的方式有：cookie、session、token、OAuth 什么是凭证（Credentials） 实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份 通过[认证]——\u0026gt;进行[授权]——\u0026gt;发放给被认证角色[凭证] 什么是 Cookie HTTP 是无状态的协议 cookie 存储在客户端 cookie 是不可跨域的 什么是 Session 服务器端为每个对话对象（浏览器）创建一个会话对象（session对象）\nsession 是另一种记录服务器和客户端会话状态的机制\nsession 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中\nsession 认证流程：\n用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 反正就是客户端（浏览器）和服务端（服务器）通过 Cookie 和 Session，标记了你是谁，我是谁，我知道你是谁，这几个信息。\n什么是 Token（令牌） 凭证\n特点：\n服务端无状态化、可扩展性好 支持移动端设备 安全 支持跨程序调用 token 的身份验证流程：\n客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 token 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里\n基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库\ntoken 完全由应用管理，所以它可以避开同源策略\nAccess Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。\nRefresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。\n什么是 JWT JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。 是一种认证授权机制。 JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。 JWT 认证流程 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie） 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样 Authorization: Bearer \u0026lt;token\u0026gt; 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制 Token 和 JWT 的区别 相同： 都是访问资源的令牌 都可以记录用户的信息 都是使服务端无状态化 都是只有验证成功后，客户端才能访问服务端上受保护的资源 区别： Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。 JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。 JWT 详解 所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。\n二、JWT 的原理 JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n{\r\u0026#34;姓名\u0026#34;: \u0026#34;张三\u0026#34;,\r\u0026#34;角色\u0026#34;: \u0026#34;管理员\u0026#34;,\r\u0026#34;到期时间\u0026#34;: \u0026#34;2018年7月1日0点0分\u0026#34;\r} 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n三、JWT 的数据结构 实际的 JWT 大概就像下面这样。\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行\nJWT 的三个部分依次如下。\nHeader（头部）\rPayload（负载）\rSignature（签名） 写成一行，就是下面的样子。\nHeader.Payload.Signature 3.1 Header Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。\n{\r\u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;,\r\u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34;\r} 上面代码中，alg 属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。\n最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串\n3.2 Payload Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。\niss (issuer)：签发人\rexp (expiration time)：过期时间\rsub (subject)：主题\raud (audience)：受众\rnbf (Not Before)：生效时间\riat (Issued At)：签发时间\rjti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n{\r\u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;,\r\u0026#34;admin\u0026#34;: true\r} 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n这个 JSON 对象也要使用 Base64URL 算法转成字符串。\n3.3 Signature Signature 部分是对前两部分的签名，防止数据篡改。\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\nHMACSHA256(\rbase64UrlEncode(header) + \u0026#34;.\u0026#34; +\rbase64UrlEncode(payload),\rsecret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\u0026quot;点\u0026quot;（.）分隔，就可以返回给用户。\n3.4 Base64URL 前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。\nJWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。\n四、JWT 的使用方式 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。\n此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。\nAuthorization: Bearer \u0026lt;token\u0026gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。\n五、JWT 的几个特点 （1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\nOAuth 2.0 详解 OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。\n四、令牌与密码 令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。\n（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。\n（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。\n（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。\n上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。\n注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。\nOAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。下一篇文章，我就来介绍这四种类型，并给出代码实例。\nOAuth 2.0 的四种方式 OAuth 2.0 的标准是 RFC 6749 文件。该文件先解释了 OAuth 是什么。\nOAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。......资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。 这段话的意思就是，OAuth 的核心就是向第三方应用颁发令牌。然后，RFC 6749 接着写道：\n（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。 也就是说，OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。下面就是这四种授权方式。\n授权码（authorization-code）\r隐藏式（implicit）\r密码式（password）：\r客户端凭证（client credentials） 注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。\n第一种授权方式：授权码 授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。\n这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。\nhttps://b.com/oauth/authorize?\rresponse_type=code\u0026amp;\rclient_id=CLIENT_ID\u0026amp;\rredirect_uri=CALLBACK_URL\u0026amp;\rscope=read 上面 URL 中，response_type 参数表示要求返回授权码（code），client_id 参数让 B 知道是谁在请求，redirect_uri 参数是 B 接受或拒绝请求后的跳转网址，scope 参数表示要求的授权范围（这里是只读）。\n第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回redirect_uri参数指定的网址。跳转时，会传回一个授权码，就像下面这样。\nhttps://a.com/callback?code=AUTHORIZATION_CODE 上面 URL 中，code参数就是授权码。\n第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。\nhttps://b.com/oauth/token?\rclient_id=CLIENT_ID\u0026amp;\rclient_secret=CLIENT_SECRET\u0026amp;\rgrant_type=authorization_code\u0026amp;\rcode=AUTHORIZATION_CODE\u0026amp;\rredirect_uri=CALLBACK_URL 上面 URL 中，client_id 参数和 client_secret 参数用来让 B 确认 A 的身份（client_secret 参数是保密的，因此只能在后端发请求），grant_type 参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码，code 参数是上一步拿到的授权码，redirect_uri 参数是令牌颁发后的回调网址。\n第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向redirect_uri指定的网址，发送一段 JSON 数据。\n{ \u0026#34;access_token\u0026#34;:\u0026#34;ACCESS_TOKEN\u0026#34;,\r\u0026#34;token_type\u0026#34;:\u0026#34;bearer\u0026#34;,\r\u0026#34;expires_in\u0026#34;:2592000,\r\u0026#34;refresh_token\u0026#34;:\u0026#34;REFRESH_TOKEN\u0026#34;,\r\u0026#34;scope\u0026#34;:\u0026#34;read\u0026#34;,\r\u0026#34;uid\u0026#34;:100101,\r\u0026#34;info\u0026#34;:{...}\r} 上面 JSON 数据中，access_token字段就是令牌，A 网站在后端拿到了。\n第二种方式：隐藏式 有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）\u0026ldquo;隐藏式\u0026rdquo;（implicit）。\n第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。\nhttps://b.com/oauth/authorize?\rresponse_type=token\u0026amp;\rclient_id=CLIENT_ID\u0026amp;\rredirect_uri=CALLBACK_URL\u0026amp;\rscope=read 上面 URL 中，response_type参数为token，表示要求直接返回令牌。\n第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回redirect_uri参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。\nhttps://a.com/callback#token=ACCESS_TOKEN 上面 URL 中，token参数就是令牌，A 网站因此直接在前端拿到令牌。\n注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在\u0026quot;中间人攻击\u0026quot;的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。\n这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。\n第三种方式：密码式 如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为\u0026quot;密码式\u0026quot;（password）。\n第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。\nttps://oauth.b.com/token?\rgrant_type=password\u0026amp;\rusername=USERNAME\u0026amp;\rpassword=PASSWORD\u0026amp;\rclient_id=CLIENT_ID 上面 URL 中，grant_type参数是授权方式，这里的password表示\u0026quot;密码式\u0026quot;，username和password是 B 的用户名和密码。\n第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。\n这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。\n第四种方式：凭证式 最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。\n第一步，A 应用在命令行向 B 发出请求。\nhttps://oauth.b.com/token?\rgrant_type=client_credentials\u0026amp;\rclient_id=CLIENT_ID\u0026amp;\rclient_secret=CLIENT_SECRET 上面 URL 中，grant_type参数等于client_credentials表示采用凭证式，client_id和client_secret用来让 B 确认 A 的身份。\n第二步，B 网站验证通过以后，直接返回令牌。\n这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。\n令牌的使用 A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。\n此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面。\ncurl -H \u0026#34;Authorization: Bearer ACCESS_TOKEN\u0026#34; \\\r\u0026#34;https://api.b.com\u0026#34; 上面命令中，ACCESS_TOKEN就是拿到的令牌。\n令牌的使用 令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。\n具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。\nhttps://b.com/oauth/token?\rgrant_type=refresh_token\u0026amp;\rclient_id=CLIENT_ID\u0026amp;\rclient_secret=CLIENT_SECRET\u0026amp;\rrefresh_token=REFRESH_TOKEN 上面 URL 中，grant_type参数为refresh_token表示要求更新令牌，client_id参数和client_secret参数用于确认身份，refresh_token参数就是用于更新令牌的令牌。\nB 网站验证通过以后，就会颁发新的令牌。\n写到这里，颁发令牌的四种方式就介绍完了。下一篇文章会编写一个真实的 Demo，演示如何通过 OAuth 2.0 向 GitHub 的 API 申请令牌，然后再用令牌获取数据。\n（正文完）\n"},{"id":328,"href":"/Tech/4Other-Language/C/C/","title":"C","parent":"C","content":""},{"id":329,"href":"/Tech/4Other-Language/GoLang/GoLang/","title":"Go Lang","parent":"GoLang","content":""},{"id":330,"href":"/Tech/4Other-Language/JavaScript/JavaScript/","title":"Java Script","parent":"JavaScript","content":""},{"id":331,"href":"/Tech/4Other-Language/rust/Rust-%E5%9C%A8-Windows-%E4%B8%8A-Release-%E7%BC%96%E8%AF%91%E5%BD%BB%E5%BA%95%E5%8E%BB%E9%99%A4%E8%B0%83%E8%AF%95%E7%AC%A6%E5%8F%B7%E4%BF%A1%E6%81%AF/","title":"Rust 在 Windows 上 Release 编译彻底去除调试符号信息","parent":"rust","content":" Rust 在 Windows 上 Release 编译彻底去除调试符号信息 转自：一年又一年\n链接：https://iyn.me/i/post-42.html\n本文介绍如何让 Rust 在以 Windows 为目标平台的 Release 编译的基础上，通过配置链接参数进一步彻底去除多余的调试符号信息，针对的工具链包括 GNU 和 MSVC。\n去除额外的符号信息能减小最终生成程序的体积。如果是在 Windows 上使用 GNU 工具链，那么这一点会很明显。\n一个 Rust 的 Hello World 程序，在 Windows 下，使用 GNU 工具链，即便是 Release 编译，最后生成的程序体积也有 3 MB 多。其中调试符号信息占了大部分体积；如果去除，程序体积可以下降至 600+ KB。好在如果使用的是 MSVC 工具链编译，调试符号会另存于 .pdb 文件，程序本体没有这样的体积问题。\n在 Linux 下，如果编译时带上了符号信息，编译完还可以用 strip 工具解决这个问题，但是 Windows 下呢？\n去除符号信息可以减小 Rust 程序体积，但本文不打算探讨减小 Rust 程序体积的各种技巧，本文只打算纯粹地介绍在 Windows 目标平台上编译 Rust 程序时如何去除额外的调试符号信息。\n读者如果想进一步研究如何减小 Rust 生成程序的体积，可以参考网上已有的讲解得很具体和专业的精彩文章。在这里笔者也列举一些供读者参考：\n优化 Rust 程序编译体积.[https://www.aloxaf.com/2018/09/reduce_rust_size/]\nMinimizing Rust Binary Size.[https://github.com/johnthagen/min-sized-rust]\n那么言归正传，本文主要关注如何在 Windows 上去除额外的符号信息。\n在 Release 模式下编译 Rust 程序，虽然自己编写的这部分程序不会生成符号信息，但是链接的 Rust 标准库会带上调试信息。如果想去除这些信息，需要指定一些链接参数。指定链接参数的方式很多，本文为了方便，以 .cargo/config 为例。\n在项目文件夹下创建文件 .cargo/config（.cargo 文件夹可能不存在，需要自行创建）\n如果是 pc-windows-gnu 工具链，欲链接时去除调试符号信息，则在 .cargo/config 中写入：（以 x86_64 为例）\n[target.x86_64-pc-windows-gnu]\rrustflags = [\r\u0026#34;-C\u0026#34;, \u0026#34;link-arg=-s\u0026#34;,\r] 这样链接时会将 -s 选项传给 GCC：\n-s: Remove all symbol table and relocation information from the executable.\n(https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html)\n此后通过 Cargo build --release 编译，生成的程序就不带调试符号信息了，但是请留意本文最后的注意事项。\n如果使用 pc-windows-msvc 工具链，那其实还好，因为符号文件(.pdb)和程序是分开的，大可不理会。但是即便这样也还是不满意，想要它彻底不产生也是可以的，在 .cargo/config 中写入：（以 x86_64 为例）\n[target.x86_64-pc-windows-msvc]\rrustflags = [\r\u0026#34;-C\u0026#34;, \u0026#34;link-arg=/DEBUG:NONE\u0026#34;,\r] 这样链接时会让 MSVC 的链接器带上 /DEBUG:NONE 选项。(参考：https://users.rust-lang.org/t/compile-in-release-mode-without-debugging-symbols/19764)\n同样，此后通过 Cargo build --release 编译，生成的程序就不带调试符号信息了。\n.cargo/config 中指定的 rustflags 会对所有 Profile （如 Release、Debug）都生效。 所以如果此后需要保留调试信息，请注意记得将以上修改注释掉，以免带来困扰，否则就算是 Debug 模式也没有调试信息，因为其直接向链接器传递了参数。现阶段 Cargo 还不支持针对特定的 Profile 设置 rustflags，所以比较狼狈，不过这个特性已经在讨论中了。当然，如果读者是行家，想必有自己的想法和技巧，能用其他方式指定这些参数，从而使其自动在正确时候生效。\n"},{"id":332,"href":"/Tech/4Other-Language/rust/Rust/","title":"Rust","parent":"rust","content":" 变量 首先必须说明，Rust 是强类型语言，但具有自动判断变量类型的能力。\n声明变量，需要使用 let 关键字\nlet a = 123; a 就被确定为整型数字，不能把字符串类型的值赋给它。\n使变量变得\u0026quot;可变\u0026quot;（mutable）只需一个 mut 关键字。\nlet mut a = 123;\ra = 456; 变量的值可以\u0026quot;重新绑定\u0026quot;，但在\u0026quot;重新绑定\u0026quot;以前不能私自被改变，\n重影（Shadowing） 重影就是刚才讲述的所谓\u0026quot;重新绑定\u0026quot;，重影就是指变量的名称可以被重新使用的机制。\nfn main() {\rlet x = 5;\rlet x = x + 1;\rlet x = x * 2;\rprintln!(\u0026#34;The value of x is: {}\u0026#34;, x);\r// The value of x is: 12\r} 重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。\n常量 const a: i32 = 123; 比那辆可以允许重影\n"},{"id":333,"href":"/Tech/4Other-Language/Vue/Vue/","title":"Vue","parent":"Vue","content":" Vue 学习笔记 1、node.js下载、安装略过 cnpm cache clear -force 清空缓存\n根据install.js，脚本通过http.get下载chromediriver二进制文件。 但是zip文件已被移动，脚本不处理这种情况。\nnpm install chromedriver \u0026ndash;chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver\nnpm audit npm audit fix\n(use npm audit fix --force to install breaking changes; or refer to npm audit for steps to fix these manually)\n"},{"id":334,"href":"/Tech/5English-Learning/Coding-English/Coding-English-A/","title":"Coding English A","parent":"Coding English","content":" A access\nadvanced\nApplication\nassembled\n"},{"id":335,"href":"/Tech/5English-Learning/Coding-English/Coding-English-B/","title":"Coding English B","parent":"Coding English","content":" B Basis\nBean\n"},{"id":336,"href":"/Tech/5English-Learning/Coding-English/Coding-English-C/","title":"Coding English C","parent":"Coding English","content":" C Classes\ncode\nconfiguration\nContainer\nContext\ncontrol\ncomplete\n"},{"id":337,"href":"/Tech/5English-Learning/Coding-English/Coding-English-D/","title":"Coding English D","parent":"Coding English","content":" D "},{"id":338,"href":"/Tech/5English-Learning/Coding-English/Coding-English-E/","title":"Coding English E","parent":"Coding English","content":" E Event\n"},{"id":339,"href":"/Tech/5English-Learning/Coding-English/Coding-English-F/","title":"Coding English F","parent":"Coding English","content":" F Factory\nFramework\nfunction + functionality\n"},{"id":340,"href":"/Tech/5English-Learning/Coding-English/Coding-English-G/","title":"Coding English G","parent":"Coding English","content":" G "},{"id":341,"href":"/Tech/5English-Learning/Coding-English/Coding-English-H/","title":"Coding English H","parent":"Coding English","content":" H "},{"id":342,"href":"/Tech/5English-Learning/Coding-English/Coding-English-I/","title":"Coding English I","parent":"Coding English","content":" I Implement\nInversion\ninstance\nInterface\n"},{"id":343,"href":"/Tech/5English-Learning/Coding-English/Coding-English-J/","title":"Coding English J","parent":"Coding English","content":" J "},{"id":344,"href":"/Tech/5English-Learning/Coding-English/Coding-English-K/","title":"Coding English K","parent":"Coding English","content":" K "},{"id":345,"href":"/Tech/5English-Learning/Coding-English/Coding-English-L/","title":"Coding English L","parent":"Coding English","content":" L "},{"id":346,"href":"/Tech/5English-Learning/Coding-English/Coding-English-M/","title":"Coding English M","parent":"Coding English","content":" M manage\nmore\nmost\n"},{"id":347,"href":"/Tech/5English-Learning/Coding-English/Coding-English-N/","title":"Coding English N","parent":"Coding English","content":" N not\n"},{"id":348,"href":"/Tech/5English-Learning/Coding-English/Coding-English-O/","title":"Coding English O","parent":"Coding English","content":" O objects\n"},{"id":349,"href":"/Tech/5English-Learning/Coding-English/Coding-English-P/","title":"Coding English P","parent":"Coding English","content":" P packages\npart\nprovides\npublic\n"},{"id":350,"href":"/Tech/5English-Learning/Coding-English/Coding-English-Q/","title":"Coding English Q","parent":"Coding English","content":" Q "},{"id":351,"href":"/Tech/5English-Learning/Coding-English/Coding-English-R/","title":"Coding English R","parent":"Coding English","content":" R root\n"},{"id":352,"href":"/Tech/5English-Learning/Coding-English/Coding-English-S/","title":"Coding English S","parent":"Coding English","content":" S scenario\nsection\nshort\nsystem\nsuperset\n"},{"id":353,"href":"/Tech/5English-Learning/Coding-English/Coding-English-T/","title":"Coding English T","parent":"Coding English","content":" T type\ntogether\n"},{"id":354,"href":"/Tech/5English-Learning/Coding-English/Coding-English-U/","title":"Coding English U","parent":"Coding English","content":" U used\nuser\n"},{"id":355,"href":"/Tech/5English-Learning/Coding-English/Coding-English-V/","title":"Coding English V","parent":"Coding English","content":" V "},{"id":356,"href":"/Tech/5English-Learning/Coding-English/Coding-English-W/","title":"Coding English W","parent":"Coding English","content":" W "},{"id":357,"href":"/Tech/5English-Learning/Coding-English/Coding-English-X/","title":"Coding English X","parent":"Coding English","content":" X "},{"id":358,"href":"/Tech/5English-Learning/Coding-English/Coding-English-Y/","title":"Coding English Y","parent":"Coding English","content":" Y "},{"id":359,"href":"/Tech/5English-Learning/Coding-English/Coding-English-Z/","title":"Coding English Z","parent":"Coding English","content":" Z "},{"id":360,"href":"/Tech/5English-Learning/Coding-English/Coding-English/","title":"Coding English","parent":"Coding English","content":""},{"id":361,"href":"/Tech/5English-Learning/English-Learning/","title":"English Learning","parent":"5、English Learning","content":"标题：English Learning\n标签：英语学习 时间：2019年2月15日16:35:13 连接：https://www.saveload.cn/html/technology/English Learning.txt 备注：我决定将自己当一个弱逼的人工智能，付出时间和艰辛解决英语问题。\ntitle：打卡格式\rtime：2020年2月25日16:33:29\rcontent：\rabout 关于\rtitle：打卡第一天\rtime：2019年2月15日16:36:40\rcontent：\r学发音咩。。。\r其实就是下了一堆App屁事没干。\rtitle：打卡第2天\rtime：2019年2月25日10:29:56\rcontent：\r学发音咩。。。\r艹，过去了这么久。。。\r音标共48个：\r元音20个：\r单元音12个：\r前元音4个：\r[i:]\r衣...;sheep;e me even\\ee beef deep\\ea meat reason tea\\ie believe achieve\\ei deceive conceive\r[i]\rA;fish;i sit picture\\u build business\\y many dictionary\\e pretty blanket\\a village private\\ui quick guitar\r对比：[i:] 音拉长，[i] 小腹绷紧，\r[e]\r哎（短促）;very;e never forget\\ea bread heaven\\a marry many\r[æ]\r哎阿;apple black cat ;e pen ten\\ea bread heaven\\a marry many\r对比：就像哎啊一样，[e]稍微含着点，上牙堂前面使劲，[æ] 嘴的张开角度更大，上牙堂后面使劲\r中元音3个：\r[ɝ:]\r阿儿（儿化音那个意思）;sir;or work worm\\ir girl bird\\er person term\\ur turn burn\\ear early pearl\r[ɚ]\r阿额;dollar;a banana away\\er teacher under\\or doctor forget \\o together lesson\\ure picture\\ur saturday\r对比：一个发音感觉，就是一个带儿化音\r[ʌ]\r阿;cup dump;u luck butter\\o monk onion\\ou trouble flourish\\oo blood flood\r后元音5个\r[u:]\r屋;school;oo school fool\\o woman wolf\\ou soup group \\u pollute blue \\oe shoe canoe\\ui fruit juice\r[u]\r屋;\r双元音8个：\r开合双元音5个：\r集合双元音3个：\r辅音28个：\r爆破音15个：\r清辅音8个：\r浊辅音7个：\r破擦音6个：\r清辅音3个：\r浊辅音3个：\r鼻音3个：\r舌则音2个：\r半元音2个：\rtitle：打卡第3天\rtime：2020年2月25日16:05:01\rcontent：\r1、词类：英语词类分十种：\r名词、形容词、代词、数词、冠词、动词、副词、介词、连词、感叹词。\r1、名词(n.)： 表示人、事物、地点或抽象概念的名称。如：boy, morning, bag, ball, class, orange.\r2、代词(pron.)： 主要用来代替名词。如：who, she, you, it .\r3、形容词(adj..)：表示人或事物的性质或特征。如：good, right, white, orange .\r4、数词(num.)： 表示数目或事物的顺序。如：one, two, three, first, second, third, fourth.\r5、动词(v.)： 表示动作或状态。如：am, is,are,have,see .\r6、副词(adv.)： 修饰动词、形容词或其他副词,说明时间、地点、程度等。如：now, very, here, often, quietly, slowly.\r7、冠词(art..)：用在名词前,帮助说明名词。如：a, an, the.\r8、介词(prep.)： 表示它后面的名词或代词与其他句子成分的关系。如in, on, from, above, behind.\r9、连词(conj.)： 用来连接词、短语或句子。如and, but, before .\r10、感叹词(interj..)表示喜、怒、哀、乐等感情。如：oh, well, hi, hello.\r2、句子成分：英语句子成分分为七种：\r主语、谓语、宾语、定语、状语、表语、宾语补足语。\r1、主语是句子所要说的人或事物,回答是“谁”或者“什么”。通常用名词或代词担任。如：I’m Miss Green.(我是格林小姐)\r2、谓语动词说明主语的动作或状态,回答“做(什么)”。主要由动词担任。如：Jack cleans the room every day. (杰克每天打扫房间)\r3、表语在系动词之后,说明主语的身份或特征,回答是“什么”或者“怎么样”。通常由名词、代词或形容词担任。如：My name is Ping ping .(我的名字叫萍萍)\r4、宾语表示及物动词的对象或结果,回答做的是“什么”。通常由名词或代词担任。如：He can spell the word.(他能拼这个词)\r有些及物动词带有两个宾语,一个指物,一个指人。指物的叫直接宾语,指人的叫间接宾语。间接宾语一般放在直接宾语的前面。如：He wrote me a letter . (他给我写了一封信)\r有时可把介词to或for加在间接宾语前构成短语,放在直接宾语后面,来强调间接宾语。如：He wrote a letter to me . (他给我写了一封信)\r5、定语修饰名词或代词,通常由形容词、代词、数词等担任。如：\rShanghai is a big city .(上海是个大城市)\r6、状语用来修饰动词、形容词、副词,通常由副词担任。如：He works hard .(他工作努力)\r7、宾语补足语用来说明宾语怎么样或干什么,通常由形容词或动词充当。如：They usually keep their classroom clean.(他们通常让教室保持清洁) / He often helps me do my lessons.(他常常帮我做功课) / The teacher wanted me to learn French all by myself.(老师要我自学法语)\r☆同位语通常紧跟在名词、代词后面,进一步说明它的情况。如：Where is your classmate Tom ?(你的同学汤姆在哪里？)\r3、英语五种基本句型列式如下：\r基本句型一： S V （主＋谓）\r基本句型二： S V P （主＋谓＋表）\r基本句型三： S V O （主＋谓＋宾）\r基本句型四： S V O间 O直 （主＋谓＋间宾＋直宾）\r基本句型五： S V O C （主＋谓＋宾＋宾补）\r基本句型 一\r此句型的句子有一个共同特点，即句子的谓语动词都能表达完整的意思。这类动词叫做不及物动词，后面可以跟副词、介词短语、状语从句等。\rS │ V （不及物动词）\r1. The moon │rose. 月亮升起了。\r2. What he said │does not matter. 他所讲的没有什么关系。\r3. They │talked for half an hour. 他们谈了半个小时。\r4. The pen │writes smoothly. 这支笔书写流利。\r基本句型 二\r此句型的句子有一个共同的特点：句子谓语动词都不能表达一个完整的意思，必须加上一个表明主语身份或状态的表语构成复合谓语，才能表达完整的意思。这类动词叫做连系动词。系动词分两类：be, look, keep, seem等属一类，表示情况；get, grow, become, turn等属另一类，表示变化。be 本身没有什么意义,只起连系主语和表语的作用。其它系动词仍保持其部分词义。\rS │V（系动词）│ P\r1. This │is │an English-Chinese dictionary. 这是本英汉辞典。\r2. The dinner │smells │good. 午餐的气味很好。\r3. His face │turned │red. 他的脸红了。\r基本句型 三\r此句型句子的共同特点是：谓语动词都具有实义，都是主语产生的动作，但不能表达完整的意思，必须跟有一个宾语，即动作的承受者，才能使意思完整。这类动词叫做及物动词。\rS │V（及物动词）│ O\r1. Who │knows │the answer? 谁知道答案？\r2. He │has refused │to help them. 他拒绝帮他们的忙。\r3. He │enjoys │reading. 他喜欢看书。\r4. They │ate │what was left over. 他们吃了剩饭。\r基本句型 四\r此句型的句子有一个共同特点：谓语动词必须跟有两个宾语才能表达完整的意思。这两个宾语一个是动作的直接承受者，另一个是动作的间接承受者。通常这一间接承受者用一个介词来连接，当动作的间接承受者在动作的直接承受者之前时，这一介词往往被省略。\rS │V（及物）│ o（多指人） │ O（多指物）\r1. She │cooked │her husband │a delicious meal.她给丈夫煮了一顿美味的饭。\r2. He │brought │you │a dictionary.他给你买了一本字典。\r3.I │told │him │that the bus was late. 我告诉他汽车晚点了。\r4. He │showed │me │how to run the machine. 他教我开机器。\r基本句型 五\r此句型的句子的共同特点是：动词虽然是及物动词，但是只跟一个宾语还不能表达完整的意思，必须加上一个补充成分来补足宾语，才能使意思完整。\rS │V（及物）│ O（宾语） │ C（宾补）\r1. They │appointed │him │manager. 他们任命他当经理。\r2. They │painted │the door │green. 他们把门漆成绿色。\r3. What │makes │him │think so? 他怎么会这样想？\r4. He │asked │me │to come back soon. 他要我早点回来。\r5. I │saw │them │getting on the bus. 我看见他们上了那辆公共汽车。\r但常用的英语句子并不都象基本句型这样简短，这些句子除了基本句型的成分不变外，通常是在这些成分的前面或后面增加一些修饰语而加以扩大。这些修饰语可以是单词（主要是形容词、副词和数词），也可以是各种类型的短语（主要是介词短语、不定式短语和分词短语）。下面以基本句型五为例：\rWe found the hall full. 我们发现礼堂坐满了。\rWe found the great hall full of students and teachers.\r我们发现大礼堂坐满了学生和教师。\rWe found the great hall full of students and teachers listening to an important report.\r我们发现大礼堂坐满了学生和教师，在听一个重要报告。\rWe found the great hall full of students and teachers listening to an important report made by a comrade from the People's Daily on current affairs inEast Europe.\r我们发现大礼堂坐满了学生和教师，在听人民日报的一位同志作有关东欧局势的重要报告。\rtitle：打卡第3天\rtime：2020年2月25日16:33:29\rcontent：\rable 有才能的\rabout 关于\rabove\rafraid 惊恐\rafter 之前\rafternoon 下午\rtitle：第四次\rtime：2020年10月30日19点51分\rcontent：\r"},{"id":362,"href":"/Tech/5English-Learning/OrterWordsBook/","title":"Orter Words Book","parent":"5、English Learning","content":"Ambition 雄心\\野心\\抱负\\志向\nsalary 工资、薪水、薪金、薪资\n"},{"id":363,"href":"/Tech/5English-Learning/Word-List/","title":"Word List","parent":"5、English Learning","content":" Word List a air air hostess American armchair assistant\nb bed bedroom big black blouse blue blunt board book bottle box boy brother brown busy\nc car carpet case catch Chinese cigarette clean clothes cold colour come cooker cost cup cupboard customs\nd daughter desk dirty dog door dress dust Dutch\ne electric employee empty engineer English excuse\nf fat father fine five floor ford fork French friend full\ng German girl give glass good grand grandfather grandmother green\nh hairdresser handbag hat heavy hello her here hi his hot house housewife how\ni I in is it Italian\nj Japanese job\nk keyboard kitchen knife korean\nl large lazy left light little long lovely\nm magazine make man matter me mechanic meet middle mini miss morning mother Mr. must my\nn name nationality near new newspaper nice Norwegian number nurse\no of office officer old on open operator orange\np pardon passport pen pencil perhaps picture plant plate please police policeman postman put\nq r red refrigerator right room Russian\ns same school see sharp shelf shirt short shut sir sister skirt small son sorry spoon stereo student suit Swedish\nt table tall teacher television these thin thirsty this ticket tie tin tired today too tourist trousers\nu umbrella upstairs\nv w wall wardrobe watch well what where which white whose window woman write\nx y yellow yes young your\nz "},{"id":364,"href":"/Tech/5English-Learning/WordsBook/","title":"Words Book","parent":"5、English Learning","content":"excuse me\nyes of course\ntoday is monday\ngive\nplease\ncup\ntea\nstudent\nMarie\nno problem\n"},{"id":365,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/animal/","title":"Animal","parent":"make progress every day","content":"animal /ˈænɪm(ə)/ n. 动物；兽类；\n"},{"id":366,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/food/","title":"Food","parent":"make progress every day","content":"food /fuːd/ n. （植物生长的）养料；食物，食品\nbotany /ˈbɑːtəni/ n. 植物学；（特定地区的）植物（生态）\nflower /ˈflaʊər/ n. 花；花朵\ntree /triː/ n. 树；木料；树状物\ngrass /ɡræs/ n. 草；草地，草坪；\u0026lt;非正式\u0026gt;大麻；\n"},{"id":367,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/people/","title":"People","parent":"make progress every day","content":"people /ˈpiːp(ə)l/ 人\nhair /her/ 毛发，（尤指）头发；些微；（植物叶茎上的）茸毛\nhead /hed/ 头；头脑，智力；顶部；排头；领导人，负责人；\nforehead /fɔːrhed/ 前额\nfore /fɔːr/ n. （尤指船）船头，前桅；前面部分 adj. （船、飞行器或动物）前部的，前面的 adv. 在（或向）船头，在（或向）飞行器头部 prep. 在……之前（before 的非标准形式）\neye /aɪ/ 眼睛；目光，所看之处；眼力，鉴赏力；眼光，视角；观点，态度；\neyebrow /ˈaɪbraʊ/ 眉，眉毛\near /ɪr/ 耳朵；灵敏的听力；倾听\nnose /noʊz/ 鼻子；\nmouth /maʊθ/ 嘴，口腔；需要供养的人，食客；入口，开口；\ntooth /tuːθ/ 牙，齿；（工具边缘、梳子、锯、拉链等的）齿状物，齿；\nlip /lɪp/ 嘴唇；（伤口或洞口）边缘；容器边缘，开口；\ntongue /tʌŋ/ 舌，舌头；（供食用的动物的）舌头，口条；语言，方言；\nthroat /θroʊt/ 喉咙，咽喉；喉部，颈前部；咽喉状部分（尤指狭窄通道、进出管路）；\nface /feɪs/ 脸，面部；面部表情，脸色；\nneck /nek/ n. 颈项，脖子；衣领，领口；\nshoulder /ˈʃoʊldər/ n. 肩，肩膀；双肩，上背部（shoulders）； v. 承担，担负；挤，闯；\narm /ɑːrm/ n. 手臂，上肢；武器，军备；扶手；袖子 v. 武装，备战；提供，配备；\nelbow /ˈelboʊ/ n. 肘，肘部；弯处，肘状物 v. 用肘推挤，用肘击打\nforearm /ˈfɔːrɑːm/ n. 前臂 v. 准备\nwrist /rɪst/ n. 手腕，腕关节；（四足动物前腿的）膝关节，\nhand /hænd/ n. 手；\nfinger /ˈfɪŋɡər/ n. 手指\nbody /ˈbɑːdi/ n. （人、动物的）身体；躯干；尸体；\nchest /tʃest/ n. 胸部，胸膛；箱子，盒子，柜子；\u0026lt;英\u0026gt;金库，钱库\nabdomen /ˈæbdəmən/ n. （人体）腹，腹部；（昆虫）腹部\nwaist /weɪst/ n. 腰，腰围；（衣服的）腰部，腰身；船腰，飞机机身中部，\narse /ɑːrs/ n. 屁股；笨蛋；饭桶\nparts /pɑːrts/ n. 部分；（动植物的）器官，部位；部件，零件；（世界、国家或城镇等的）区域，地区；\nthigh /θaɪ/ n. 大腿，股；（禽类的）腿\nknee /niː/ n. 膝盖，膝关节；（裤子的）膝部；\nfoot /fʊt/ n. 脚，足；英尺；基础，底部；\n"},{"id":368,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/surroundings/","title":"Surroundings","parent":"make progress every day","content":"environ /ɪnˈvaɪrən/ v. 环绕；包围；围住\nsurround /səˈraʊnd/ v. 围绕，环绕；（军队，警察等）包围；与……紧密相连（或相关）；喜欢结交（某类人），身边总有（某类东西） n. （物品的）边，饰边；周围的事物，环境\nsurroundings /səˈraʊndɪŋz/ n. 周围环境，周围事物\nenvironment /ɪnˈvaɪrənmənt/ n. 自然环境，生态环境；周围状况，条件；工作平台，软件包\nbrook /brʊk/ n. 小溪，小河\nriver /ˈrɪvər/ n. 河，江\nlake /leɪk/ n. 湖，湖泊；大量的液体\nsea /siː/ n. 海洋；内海；海（指月球或火星表面的一片广阔平原）；海面情况，海浪状况；大量，茫茫一片；（用于海名）海（Sea）；巨浪（seas）\nhill /hɪl/ n. 山丘，小山；（道路的）斜坡；土堆，小堆；\u0026lt;美，非正式\u0026gt;国会山,山坡 v. 使成堆\nmountain /ˈmaʊnt(ə)n/ n. 山，高山；许多，大量（a mountain/mountains of）；（食物的）过剩，积压\nroad /roʊd/ n. 路，公路，马路，街； 途径，方法，路子；\n"},{"id":369,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/Lesson1/","title":"Lesson1","parent":"新概念1","content":"Lesson1\nExcuse\nExcuse me\nexcuse me,is this you pen\nexcuse me ,what time is it\nme\ngive me that book\nplease tell me more\nyes\nyes it is\nare a student ,yes ,i am\ncan i have a cup of tea ,yes of course.\nis\nis this your handbag?\ntoday is monday\nthis car is mine\nthis\nis this your book\npardon\npardon me\npardon ,will you say again\nit\nyes it is\nwhose bike is this\nit\u0026rsquo;s mine\nthat skirt expensive ,isn\u0026rsquo;t it\nthank you\nthank you very much\nthank you for you help\nshe said thank you to me ,with a smile\nvary much\ni like vary much\nmarie like singing vary mach\n"},{"id":370,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/Lesson2/","title":"Lesson2","parent":"新概念1","content":"lesson 2\npen\nis this your pen\nmay i borrow your pen\nthis pen made in China\npencil\nit this your pencil\nthe pencil on the desk is mine\nwhose pencil is this\nbook\nis this your book\ni am reading a book\nhe has a lots of book\nwatch\nis this your watch\nmy watch has stopped\nthis watch is too dear\ncoat\nis this your coat\nHow much is this coat\nput on your coat\ndress\nis this your dress\nher new dress looks nice\nhow much is this dress\nhow much is this your dress\nskirt\nis this your skirt\nshe is wearing short skirt\nthis kind of skirt is popular this year\nshirt\nis this your shirt\nhe put on a shirt and went out\nthe man in a shirt is my uncle\ncar\nis this your car\nmany people go to work by car\nthere are many car in the street\nhouse\nis this your house\nhe lives in a big house\nhe has house in Paris\n"},{"id":371,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E9%9F%B3%E6%A0%87/%E9%9F%B3%E6%A0%87/","title":"音标","parent":"音标","content":" 音标共48个：\r元音20个：\r单元音12个：\r前元音4个：\r[i:]\r衣...;sheep;e me even\\ee beef deep\\ea meat reason tea\\ie believe achieve\\ei deceive conceive\r[i]\rA;fish;i sit picture\\u build business\\y many dictionary\\e pretty blanket\\a village private\\ui quick guitar\r对比：[i:] 音拉长，[i] 小腹绷紧，\r[e]\r哎（短促）;very;e never forget\\ea bread heaven\\a marry many\r[æ]\r哎阿;apple black cat ;e pen ten\\ea bread heaven\\a marry many\r对比：就像哎啊一样，[e]稍微含着点，上牙堂前面使劲，[æ] 嘴的张开角度更大，上牙堂后面使劲\r中元音3个：\r[ɝ:]\r阿儿（儿化音那个意思）;sir;or work worm\\ir girl bird\\er person term\\ur turn burn\\ear early pearl\r[ɚ]\r阿额;dollar;a banana away\\er teacher under\\or doctor forget \\o together lesson\\ure picture\\ur saturday\r对比：一个发音感觉，就是一个带儿化音\r[ʌ]\r阿;cup dump;u luck butter\\o monk onion\\ou trouble flourish\\oo blood flood\r后元音5个\r[u:]\r屋;school;oo school fool\\o woman wolf\\ou soup group \\u pollute blue \\oe shoe canoe\\ui fruit juice\r[u]\r屋;\r双元音8个：\r开合双元音5个：\r集合双元音3个：\r辅音28个：\r爆破音15个：\r清辅音8个：\r浊辅音7个：\r破擦音6个：\r清辅音3个：\r浊辅音3个：\r鼻音3个：\r舌则音2个：\r半元音2个：\r"},{"id":372,"href":"/Tech/6Technical-Topics/1Math/%E5%9F%BA%E7%A1%801/","title":"基础1","parent":"1、Math","content":" 1、基础 自然数 自然数 又称非负整数性，分为偶数奇数，合数质数\n自然数集是全体非负整数组成的集合，常用 N 来表示。自然数有无穷无尽的个数。自然数有有序性，无限性。分为偶数和奇数，合数和质数等。\n自然数是整数（自然数包括正整数和零），但整数不全是自然数，例如：-1 -2 -3\u0026hellip;\u0026hellip;是整数 而不是自然数。自然数是无限的。\n"},{"id":373,"href":"/Tech/6Technical-Topics/2%E5%89%8D%E7%AB%AF/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/","title":"Html和css笔记","parent":"2、前端","content":"html和css笔记\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-html和css\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 一、HTML的基本概念 1、HTML(Hyper Text Markup Language) 超文本标记语言 2、静态页面\u0026mdash;为后续的动态页面服务（JSP） 3、IP:在因特网(Internet)中唯一标识一台主机 公网IP：在整个互联网中唯一 局域网IP：在同一个局域网中唯一，不同的局域网之间可能重复。 4、URL：统一资源定位符 www.baidu.com 5、HTTP协议：超文本协议，通常是字符串 http://192.168.0.3:8989/xxx\n二、HTML的内容： 1、文件的创建及运行 .html、.htm后缀，只需浏览器就能运行。 2、HTML的语法特点： 内容都是以标签的形式，这些标签一般由前标签和后标签构成 我的第一个网页 Hello World 3、语法不严格：大小写不区分 一般情况成对出现，特殊，没有标签体的标签可以只有前标签 标签可以嵌套，但是不能交叉\n三、具体的语法： 1、head部分：在网页中不见 1)title 网页的标题 2)meta 标签 ：定义网页中信息、特点 设置网页的编码格式\n\u0026lt;META name=\u0026quot;author\u0026quot; content=\u0026quot;zpark\u0026quot;\u0026gt; 定义网页作者 \u0026lt;META name=\u0026quot;keywords\u0026quot; content=\u0026quot;云计算,,...\u0026quot;\u0026gt; 定义网页关键字 \u0026lt;META http-equiv=\u0026quot;refresh\u0026quot; content=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;META http-equiv=\u0026quot;refresh\u0026quot; content=\u0026quot;2;url=http://www.taobao.com\u0026quot;\u0026gt; 定义网页2秒后自动刷新到\u0026quot;淘宝 3)script标签 :引入或者开发javascript代码 4)link标签 ：引入css文件 2、body：在网页中可见 1)body标签 \u0026lt;BODY bgcolor=\u0026quot;#FFCCFF“ background=\u0026quot;back_image.GIF\u0026quot; text=\u0026quot;#FF0000\u0026quot;\u0026gt; bgcolor=\t背景颜色 background=\t背景图片 text=\t前景颜色(字体颜色) 2)注释 \u0026lt;!--注释内容--\u0026gt; 3)特殊的符号： 空格：\t\u0026amp;nbsp; \u0026gt;:\t\u0026amp;gt; \u0026lt;:\t\u0026amp;lt; 换行：\t\u0026lt;br/\u0026gt;; 水平线：\u0026lt;hr size=\u0026quot;30px\u0026quot; color=\u0026quot;green\u0026quot; width=\u0026quot;300px\u0026quot; align=\u0026quot;right\u0026quot;/\u0026gt; size :垂直高度 width：水平宽度 color：水平线的颜色 取值：英文值 RGB值 align：水平线的对其方式 left|center(默认)|right 版权符号：\u0026amp;copy; 水平线：\u0026lt;hr size=\u0026quot;30px\u0026quot; color=\u0026quot;green\u0026quot; width=\u0026quot;300px\u0026quot; align=\u0026quot;right\u0026quot;/\u0026gt; size :垂直高度(线的厚度) width：水平宽度(线的颜色) color：水平线的颜色 取值：英文值 RGB值 align：水平线的对其方式 left|center(默认)|right 4、body标签中的元素 1、文本相关 1)标题标签\u0026lt;H1\u0026gt;\u0026lt;H6\u0026gt; 说明：\u0026lt;H1\u0026gt;到\u0026lt;H6\u0026gt;字体大小依次递减 如果需要更大或者更小的字号借助CSS 2)\u0026lt;font\u0026gt;标签 \u0026lt;font size = \u0026quot;2\u0026quot; color = \u0026quot;red\u0026quot; face = \u0026quot;黑体\u0026quot;\u0026gt; ... \u0026lt;/font\u0026gt; size：字体的大小，最小为1号，最大为7号 color :字体的颜色 face:字体 3)字体相关 \u0026lt;i\u0026gt;文字倾斜\u0026lt;/i\u0026gt; \u0026lt;b\u0026gt;文字加粗\u0026lt;/b\u0026gt; \u0026lt;s\u0026gt;文字加删除线\u0026lt;/s\u0026gt; \u0026lt;u\u0026gt;文字加下划线\u0026lt;/u\u0026gt; 4)段落相关 \u0026lt;p\u0026gt;普通的段落\u0026lt;/p\u0026gt; 5)列表相关 有序列表 \u0026lt;ol type=\u0026quot;\u0026quot; start=\u0026quot;\u0026quot;\u0026gt; 指：提供顺序标记 \u0026lt;li\u0026gt;填写信息\u0026lt;/li\u0026gt;-------1、填写信息 \u0026lt;li\u0026gt;收电子邮件\u0026lt;/li\u0026gt;-----2、收电子邮件 \u0026lt;li\u0026gt;注册成功\u0026lt;/li\u0026gt;-------3、注册成功 \u0026lt;/ol\u0026gt; type: 1(默认) a、A、i、I start：标记起始点，只能是数字 无序列表 \u0026lt;ul type=\u0026quot;\u0026quot;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; type:circle(空心圆) 、square(实心方) 默认实心圆 2、超链接相关 \u0026lt;a href=\u0026quot;url\u0026quot; target=\u0026quot;\u0026quot;\u0026gt;下载\u0026lt;/a\u0026gt; href:超链接的地址 target：超链接的方式 _self :覆盖掉本身页面，超链到指定的页面 _blank ：重新开启新的窗口，超链到指定的页面 自定义 ：指定超链位置(回到顶部) 标签体：超链接的名字 超链接-锚记属性 作用：锚记标签用于使用户“跳”到文档的某个部分 步骤1：创建锚记 \u0026lt;a name=“marker”\u0026gt;主题名称\u0026lt;/a\u0026gt; 步骤2：在超链接的 href中使用该锚记 \u0026lt;a href=\u0026quot;#marker\u0026quot;\u0026gt;xxx\u0026lt;/a\u0026gt; 3、图像的基本语法 \u0026lt;img src = \u0026quot;images/adv.jpg\u0026quot; width = \u0026quot;300\u0026quot; height = \u0026quot;150\u0026quot; alt = \u0026quot;明星演唱会开幕\u0026quot; align = \u0026quot;middle\u0026quot;\u0026gt; src:图片路径 alt:图片描述/信息 border: 图片边框 align:图片相对文字的对其方式 align = \u0026quot;middle\u0026quot;图像与文本居中对齐还可以取top, bottom 值 align=\u0026quot;center\u0026quot; 居中 align=\u0026quot;right\u0026quot; width:图片的宽度 heigth：图片的高度 特殊标签：跑马灯 \u0026lt;marquee\u0026gt; 4、\t表格相关【重点】 \u0026lt;table border=\u0026quot;\u0026quot; cellspacing=\u0026quot;\u0026quot; align=\u0026quot;\u0026quot; width=\u0026quot;\u0026quot; bgcolor=\u0026quot;\u0026quot; background=“images/type_back.jpg” width=“360\u0026quot; height=\u0026quot;120\u0026quot; border=\u0026quot;2\u0026quot; \u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;单元格\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; table的属性 border :边框 bordercolor:边框颜色 background:设置表格的背景图片 cellspacing：单元格之间的空隙(属性用来设置表格内框宽度 ) cellpadding：属性用来设置单元格内填充距离 align：表、格、行、列的对齐方式 \u0026lt;tr\u0026gt; \u0026lt;td align=\u0026quot;right\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;50px\u0026quot;\u0026gt;我是右对齐\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026quot;center\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;50px\u0026quot;\u0026gt;我是居中\u0026lt;/td\u0026gt; \u0026lt;td align=\u0026quot;left\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;50px\u0026quot;\u0026gt;我是左对齐\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td valign=\u0026quot;top\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;50px\u0026quot;\u0026gt;顶端对齐\u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;middle\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;50px\u0026quot;\u0026gt;中对齐\u0026lt;/td\u0026gt; \u0026lt;td valign=\u0026quot;bottom\u0026quot; width=\u0026quot;100px\u0026quot; height=\u0026quot;50px\u0026quot;\u0026gt;底端对齐\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; width：表格的宽度 height：表格的高度 bgcolor：背景颜色 tr的属性： align：整行做文字相对单元的水平对齐方式 left(默认)|right|center bgcolor：一行的背景颜色 td属性： align：单元格中文字相对单元的水平对齐方式 left(默认)|right|center bgcolor：一个单元格的背景颜色 valign：文字相对于单元格垂直对齐方式 top|middle(默认)|bottom 高级属性(对表格的处理：跨行跨列) rowspan：跨行 colspan：跨列 5、表单相关【重点】 表单作用 ：通过表单元素，收集用户输入的数据 表单元素 ： \u0026lt;input type=\u0026quot;决定表单元素的种类\u0026quot;/\u0026gt; 文本框 ： text 密码框 ： password 单选按钮： radio 复选按钮： checkbox 重置按钮： reset 提交按钮： submit 普通按钮： button 表单元素的属性 ： 1)name ： 文本框、密码框 ：用于后续收集页面数据的依据 单选按钮 : name属性值要相同，才可以达到单选的效果,收集页面数据的依据 复选按钮 ：name属性值建议相同，方便后续收集数据 2)value： 文本框、密码框 ：默认值 单选按钮、单选按钮 : 单选、复选的值 重置、普通、提交按钮：在页面显示中取的名字 3)补充属性 ： size ：显示文本框的长度 maxlength ：支持输入的最大值 hidden：隐藏 readonly :只读 checked=\u0026quot;true\u0026quot; ：针对单选、复选按钮 默认选中 下拉菜单： \u0026lt;select name=\u0026quot;ss\u0026quot;\u0026gt; \u0026lt;option value=\u0026quot;1\u0026quot;\u0026gt;aaaa\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026quot;2\u0026quot;\u0026gt;bbbb\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; name : 在Select标签中，用于收集数据 value：在option标签中，下拉菜单的值 selected : 对于下拉菜单默认选中 文本域： \u0026lt;textarea name=\u0026quot;\u0026quot; cols=\u0026quot;40\u0026quot; rows=\u0026quot;6\u0026quot;\u0026gt;文本内容\u0026lt;/textarea\u0026gt; name :文本框名字\t用于收集数据，收集的是文本域中标签体的内容 cols=\u0026quot;40\u0026quot;\t文本框的列数 rows=\u0026quot;6\u0026quot;\t文本框的行数 表单标签： \u0026lt;form action=\u0026quot;url\u0026quot; method=\u0026quot;\u0026quot;\u0026gt; 表单元素 \u0026lt;/form\u0026gt; action : 提交表单的路径(url) 重置按钮：type=\u0026quot;reset\u0026quot; 页面数据恢复到表单最原始的状态 普通按钮：为后续js校验准备 提交按钮：把表单元素的数据收集，提交到action指定的路径 method :表单提交方式 get(默认)|post get ：以url?name1=value1\u0026amp;name2=value2..... 传递数据，一地址栏形式传递 特点 ：不安全，收集的数据量较小 255 中文乱码处理不容易 post ：把表单元素中的数据打包发送到请求的url,对于文件上传必须是post提交 5、frame布局/框架 \u0026lt;P\u0026gt;\u0026lt;a href=\u0026quot;right.html\u0026quot; target=\u0026quot;B\u0026quot;\u0026gt; \u0026lt;FRAMESET rows=\u0026quot;25%,50%,*\u0026quot; frameborder=\u0026quot;5\u0026quot;\u0026gt; \u0026lt;FRAME name=“top\u0026quot; src=\u0026quot;the_first.html\u0026quot;\u0026gt;--------窗口1 \u0026lt;FRAME name=\u0026quot;middle\u0026quot; src=\u0026quot;the_second.html\u0026quot;\u0026gt;----窗口2 \u0026lt;FRAME name=“bottom\u0026quot; src=\u0026quot;the_third.html\u0026quot;\u0026gt;-----窗口3 \u0026lt;FRAME name=“B\u0026quot;\u0026gt; \u0026lt;/FRAMESET\u0026gt; rows: 将窗口进行上下分割，各部分的高度用逗号分开 cols: 将窗口进行左右分割，各部分的宽度用逗号分开,可选。 frameborder:窗口边框的宽度 name:框架名 target:属性指定了要链接的文件会出现在名称为“B”的框架窗口里 \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;CSS\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nCSS：Cascade Style Sheet 级联/层叠样式表 作用：页面的美化、实现内容与样式的分离，方便团队开发\n一、目标 会创建统一外观的字体文本 会创建无下划线的超连接样式 会创建个性化的表格 会创建个性化的表单 会使用DIV实现页面布局 二、样式的基本结构 样式属性名：样式属性值 样式的分类：行内样式、内部(内嵌)样式、外部样式 三、二、行内样式(参考：hello_css.html) \u0026lt;前标签 style=\u0026ldquo;样式属性名1:样式属性值1;样式属性名2:样式属性值2;\u0026quot;\u0026gt;标签体\u0026lt;/结束标签\u0026gt; 举例： 1、超链接的下滑线 2、修改字体格式：如楷体 3、字体颜色 4、字体的大小 5、背景颜色 三、内部样式(内嵌样式)【重点】 选择器：在CSS中，根据选择器，对不同、或相同的多个标签加相同的样式 选择器语法： 在head标签： 1)标签选择器：(参考：css_table.html、css_img.html) 应用场景：针对一组相同的标签加相同的样式 选择器语法： 在head标签： 使用：标签选择器自动套用(标签名是指：、、、、) A:hover 特殊的伪类选择： 其中A代表超链接 hover：代表鼠标悬停 active：当前活动的超链接 visited：访问过的超链接 link：未访问过的超链接\n2)class(类)选择器 应用场景：针对于不同的标签加相同的样式 语法： \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; .class选择器的名字{\t----.类选择器名 样式属性名1 ：样式属性值1; 样式属性名2 ：样式属性值2; 样式属性名3 ：样式属性值3; ... 样式属性名n ：样式属性值n; } \u0026lt;/style\u0026gt; \u0026lt;font class=\u0026quot;sty1\u0026quot;\u0026gt;你好j爷\u0026lt;/font\u0026gt;\t----class=\u0026quot;类选择器名\u0026quot; 使用：在需要加样式的标签中添加一个属性 class=\u0026quot;选择器名\u0026quot;，不带. 3)id选择器：针对于某一个标签加样式(少用) id属性：在html文档中唯一标识一个html标签(js使用多) 语法： \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; #id选择器的名字{ 样式属性名1 ：样式属性值1; 样式属性名2 ：样式属性值2; 样式属性名3 ：样式属性值3; ... 样式属性名n ：样式属性值n; } \u0026lt;/style\u0026gt; \u0026lt;font id=\u0026quot;sty1\u0026quot;\u0026gt;你好j爷\u0026lt;/font\u0026gt; 使用：在需要加样式的标签中添加一个属性 id=\u0026quot;id选择器名\u0026quot;，不带# 注意：HTML标签中的id属性，通常用于唯一的标识页面中的一个页面元素，不允许重复；class允许重复。优先使用CLASS选择器；ID选择器不推荐。 四、外部样式： 应用：对应一个网站中使用相同的样式(数据与显示分离) 重点：使用 css文件的提取： 1、创建一个css文件，*.css,内容：只用样式(选择器、样式属性名：样式属性值，没有html标签) 2、使用：需要在使用的html文件(页面中)引入css文件 引入方式：\ncss文件例： #sty1{ text-decoration:none; font-size:40px; background-color:pink; } .btn1{ background-image:url(image/login_submit.gif); width:137px; height:30px; } body{ background-image:url(image/001.jpg); background-repeat :no-repeat; background-size:100%; } 注意： 1）如果有多种样式，如果规定的样式没有冲突，则叠加； 2）如果有冲突，则最先考虑行内样式表显示，如果没有，再考虑内嵌样式显示，如果还没有，最后采用外面样式表显示，否则就按HTML的默认样式显示。 五、常用的样式 1、文本文字相关： 文字大小 ：font-size 文字颜色：color 文字格式：font-family 加下划线：text-decoration ：none|underline 文字对其方式：text-align：center / left / right 字体粗细：font-weight: bold / normal 文本修饰：text-decoration: underline/none 2、背景相关： 背景颜色：background-color:#ff7300 背景图片：background-image:url(图片路径) 平铺：background-repeat :no-repeat|repeat-x |repeat-y 背景图片和页面一样大小：background-size：100% 背景图片定位：background-position:center/left/right/top/bottom 3、边框相关： border ：1px solid red;/边框为1个像素粗细、实线、红色/ 边框粗细：border-width: 1px; border-top-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-width: 1px; 边框颜色：border-color: #ff7300; border-top-color、 border-bottom-color、 border-left-color、 border-right-color 边框线类型：border-style:solid/dashed/dotted\tborder-top-style、 border-bottom-style、 border-left-style、 border-right-style\n4、鼠标相关 cursor : move|not-allowed|pointer|wait\t5、特别标签 \u0026lt;SPAN\u0026gt;是行级层标签，不可以包含图片、标题、段落等，只能包含文字内容，对其中的内容可单独做样式控制。 \u0026lt;H2\u0026gt;所有韩款童装\u0026lt;SPAN style=“color:#FF66FF; font- size:50px;”\u0026gt;10\u0026lt;/SPAN\u0026gt;元/件起拍喽 \u0026lt;/H2\u0026gt; \u0026lt;DIV z-index:1\u0026gt;是块级层标签，可以包含图片、标题、段落、文字等 position:absolute; 绝对定位 left:149px; x坐标 top:110px; y坐标 z-index:1; z坐标(位于哪一层)(数字大的覆盖数字小的) width:357px; 宽 height:87px;\t高 display: none/block/inline;\t显示方式 \u0026lt;DIV id=\u0026quot;Layer1\u0026quot; style=\u0026quot;position:absolute; left:149px; top:110px; width:357px; height:87px; z-index:1; \u0026quot; \u0026gt; \u0026lt;IMG src=\u0026quot;talk.gif\u0026quot; width=\u0026quot;91\u0026quot; height=\u0026quot;76\u0026quot;\u0026gt; \u0026lt;P\u0026gt;Z-index=1，我是第一层，我是容器，包含图片段落\u0026lt;/P\u0026gt; \u0026lt;/DIV\u0026gt; \u0026lt;DIV id=\u0026quot;Layer2\u0026quot; style=“….; z-index:2; ….\u0026quot;\u0026gt; \u0026lt;IMG src=\u0026quot;bbs_logo.gif\u0026quot; width=\u0026quot;101\u0026quot; height=\u0026quot;43\u0026quot;\u0026gt; \u0026lt;P\u0026gt;Z-index=2，我是第二层，包含图片和段落 \u0026lt;/P\u0026gt; \u0026lt;/DIV\u0026gt;… float属性：定义元素在哪个方向浮动 left-左侧浮动，从左往右排列显示 right-右侧浮动，从右往左排列显示 none-默认，显示在文档中定义的位置 \u0026lt;div class=\u0026quot;totalDiv\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;topDiv\u0026quot;\u0026gt;这是上边\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;leftDiv\u0026quot;\u0026gt;这是左边 \u0026lt;div class=\u0026quot;titleDiv\u0026quot;\u0026gt;体育频道\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;contentDiv\u0026quot;\u0026gt; \u0026lt;a href='#'\u0026gt;aaaaaaaaaa\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;a href='#'\u0026gt;bbb\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;a href='#'\u0026gt;ccc\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;a href='#'\u0026gt;dddddddd\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;mainDiv\u0026quot;\u0026gt;这是右边\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 6、页面层级 由下向上 背景颜色——\u0026gt;背景图片——\u0026gt;文字底色——\u0026gt;文字 3.\tCSS的样式属性 a)\t基本属性 i.\tcolor:值 （“red”,”black”,”#RGB” ） 作用用是该表文件的前景颜色 ii.\tfont-size:值 设置文字大小 iii.\tfont-family:值 设置字体:tahoma iv.\ttext-decoration:值 设置字体线：underline overline line-through v.\ttext-align:值 对其方式：left right center vi.\twidth:设置宽度 vii.\theight设置高度 viii.\tcursor:鼠标的设置 pointer（手） wait(等待) ix.\tdisplay:设置元素的隐藏或者显示 none:隐藏 不占用页面流 block:块级元素的显示 h1 li table p inline:行内元素的显示 \u0026lt;input b)\t背景相关 i.\tbackground-color:#RGB “red” ii.\tbackground-image:url(“”) c)\t列表相关 i.\tlist-style-type d)\t布局相关的内容 i.\t2个与布局相关的标签 1.\t\u0026lt;div\u0026gt; 块 （块级元素） 整张网页划分成若干部分，每一个部分都是一块内容 2.\t\u0026lt;span\u0026gt; 部分 （行内元素） 需要为文本加入样式，js操作 ii.\tbox盒子模型 1.\t边框相关的样式 border 2.\t内补白（内边距）padding 3.\t外补白（外边距）margin 我是右对齐 我是居中 我是左对齐 顶端对齐 中对齐 底端对齐 "},{"id":374,"href":"/Tech/6Technical-Topics/3IDEA/IDEA-jvm%E9%85%8D%E7%BD%AE/","title":"ID Ea Jvm配置","parent":"3、IDEA","content":" 默认配置 -Xms128m\r-Xmx750m\r-XX:ReservedCodeCacheSize=240m\r-XX:+UseConcMarkSweepGC\r-XX:SoftRefLRUPolicyMSPerMB=50\r-ea\r-Dsun.io.useCanonCaches=false\r-Djava.net.preferIPv4Stack=true\r-Djdk.http.auth.tunneling.disabledSchemes=\u0026#34;\u0026#34;\r-XX:+HeapDumpOnOutOfMemoryError\r-XX:-OmitStackTraceInFastThrow 一种复杂的未验证配置 -server\r-Xms2g\r-Xmx2g\r-XX:NewRatio=3\r-Xss16m\r-XX:+UseConcMarkSweepGC\r-XX:+CMSParallelRemarkEnabled\r-XX:ConcGCThreads=4\r-XX:ReservedCodeCacheSize=240m\r-XX:+AlwaysPreTouch\r-XX:+TieredCompilation\r-XX:+UseCompressedOops\r-XX:SoftRefLRUPolicyMSPerMB=50\r-Dsun.io.useCanonCaches=false\r-Djava.net.preferIPv4Stack=true\r-Djsse.enableSNIExtension=false\r-ea 关于字段的意义 #-Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；\r#-Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；\r#-Xmn Java Heap Young区大小，不熟悉最好保留默认值；\r#-Xss 每个线程的Stack大小，不熟悉最好保留默认值；\r#-XX:NewRatio\t新生代内存容量与老生代内存容量的比例\r#-XX:ReservedCodeCacheSize\t保留代码占用的内存容量\r#-XX:+UseConcMarkSweepGC\t对老生代采用并发标记交换算法进行GC "},{"id":375,"href":"/Tech/6Technical-Topics/4Flutter/Flutter-mark/","title":"Flutter Mark","parent":"4、Flutter","content":" Flutter 相关网站： 官网： https://flutter.dev/\nCN官网： https://flutter.cn/\n"},{"id":376,"href":"/Tech/6Technical-Topics/4Flutter/Flutter/","title":"Flutter","parent":"4、Flutter","content":" Flutter "},{"id":377,"href":"/Tech/6Technical-Topics/5WorkflowEngine/BPMN2.0/","title":"Bpmn2.0","parent":"5、WorkflowEngine","content":" BPMN 2.0 3.1. BPMN 2.0是什么呢？ 业务流程模型注解（Business Process Modeling Notation - BPMN）是 业务流程模型的⼀种标准图形注解。这个标准 是由对象管理组（Object Management Group - OMG）维护的。\n基本上，BPMN规范定义了任务看起来怎样的，哪些结构可以 与其他进⾏连接，等等。这就意味着 意思不会被误解。\n标准的早期版本（1.2版以及之前）仅仅限制在模型上， ⽬标是在所有的利益相关者之间形成通⽤的理解， 在⽂档，讨论和实现业务流程之上。 BPMN标准证明了它⾃⼰，现在市场上许多建模⼯具 都使⽤了BPMN标准中的元素和结构。实际上，现在的jPDL设计器也使⽤了 BPMN元素。\nBPMN规范的2.0版本，当前已经处于最终阶段了， 已经计划不就就会完成，允许添加精确的技术细节 在BPMN的图形和元素中， 同时制定BPMN元素的执行语法。 通过使用XML语言来指定业务流程的可执行语法， BPMN规范已经演变为业务流程的语言， 可以执行在任何兼容BPMN2的流程引擎中， 同时依然可以使用强大的图形注解。\n3.2. 历史和目标 jBPM BPMN2的实现是在jBPM 4.0发布之后 在2009年8月，在与社区进行了紧密协作之后启动的。 而后，我们决定了第一个发布版（比如，文档/QA） 涉及一部分BPMN2规范，将在jBPM 4.3发布。\n我们的目标是建立一个原生BPMN2运行引擎 （或者说实现\u0026rsquo;可执行的BPMN2\u0026rsquo;）基于流程虚拟机 （Process Virtual Machine - PVM）。 注意，这个版本的主要目标是原生可执行， 不是图形注解 - 但是我们清楚 对于未来的版本是很重要的。\n如果用户已经了解了jBPM，就会发现\n配置结构保持不变 API与已经存在的完全一样或者很类似 测试BPMN2流程也可以使用常用的java测试框架 数据库表结构保持不变 所以，总体来说，我们的主要目标是保持所有在jBPM上好的事情， 加强它们，使用一个标准的流程语言。\n3.3. JPDL vs BPMN 2.0 第一个问题可能是，很正当的，映入脑海的是， 为什么已经有了jPDL还要实现BPMN2。它们两个语言 的目标都是定义可执行的业务流程。从高层次来看， 两个语言是等效的。主要的区别是 BPMN2是“厂商中立”的，你可以使用标准， 而jPDL是绑定在jBPM上的（虽然会有一些争论 绑定在开源语言厂商比如jPDL 和绑定在闭源产品）。\n在jBPM中，两个语言实现都是建立在jBPM流程虚拟机上的 （PVM）。这意味着两个语言共享通用功能 （持久化，事务，配置，也有基本流程结构，等等）。 结果就是，对jBPM核心的优化 会对两个语言有益。依靠PVM，BPMN2实现 建立在基础上，已经在过去证明了它自己， 并拥有了很大的最终用户社区。\n当执行语言，把它们相互比较的时候， 下面几点必须纳入考虑：\nBPMN2是基于被BPM工业接受的一个标准。 BPMN2是与实现无关的。这一点的缺点是集成java技术 jPDL总会更早。 所以，从java开发者的角度，jPDL更简单，感觉更自然 （一些BPEL/WSDL的“层次”也在BPMN中）。 jPDL的一个目标是XML可读，BPMN2流程在 一定程度上也是可读的，但是工具和更多规范的细节 会要求实现同等级的 生产力。 java开发者可以很快学会jPDL，因为他们很了解jPDL语言， 会发现实用工具有时候很麻烦， 语言本身也过于复杂了。 BPMN2包含一个很大的描述结构的集合，在规范中。 然而，对接口代码的绑定在规范中是开放的 （与XPDL相比），即使WSDL通常会被默认使用。 这意味着流程的可移植性丧失了， 当我们把流程移植到一个引擎上，而这个引擎不支持同样的绑定机制。 比如，调用java类通常是jBPM的默认实现 的绑定方式。 很自然的，因为政治原因，BPMN2规范发展的会比较慢。 jPDL就可以快速变化，和新技术进行集成， 当他们发布的时候， 与BPMN2相比可以加快步伐进行演化。 当然，因为两个都建立在同一个PVM上，jPDL中的逻辑 也可以一直到BPMN2上， 作为一个扩展，不会出现很多麻烦。\n3.4. Bpmn 2.0 执行 BPMN2规范定义了非常丰富的语言，为建模和执行业务流程。 然而，也意味着它非常困难总览BPMN2可能是怎样 为了简化这种情况，我们决定把 BPMN2结构分为三个等级。 区分的方式主要基于Bruce Silver写的 \u0026lsquo;BPMN method and Style\u0026rsquo;这本书(http://www.bpmnstyle.com/)， Dr. Jim Arlow的培训资料( http://www.slideshare.net/jimarlow/introductiontobpmn005)， \u0026lsquo;How much BPMN do you need\u0026rsquo;( http://www.bpm-research.com/2008/03/03/how-much-bpmn-do-you-need/)， 和我们自己的经验。\n我们定义了三种BPMN2结构分类：\n基本：这个分类的结构很直接 并且容易了解。这个分类的结构可以用来为 简单的业务流程建模。 高级：包含更强大或更复杂的结构， 这些都提高了建模和执行语法的学习曲线。 业务流程的主要目标是使用这个 和之前的分类来实现结构。 复杂：这个分类的结构用来实现罕见的情况， 或者它们的语法难以理解。 3.5. 配置 3.6. 实例 3.7. 流程根元素 3.8. 基本结构 3.8.1. 事件（Events） 与活动和网关一起，事件用来在实际的每个业务流程中。 事件让业务建模工具用很自然的方式描述业务流程，比如 \u0026lsquo;当我接收到客户的订单，这个流程就启动\u0026rsquo;， \u0026lsquo;如果两天内任务没结束，就终止流程\u0026rsquo; 或者\u0026rsquo;当我收到一封取消邮件，当流程在运行时， 使用子流程处理邮件\u0026rsquo;。注意典型的业务 通常使用这种事件驱动的方式。人们不会硬编码顺序创建， 但是他们倾向于使用在他们的环境中发生的事情（比如，事件）。 在BPMN规范中，描述了很多事件类型，为了覆盖可能的事情， 在业务环境中可能出现的情况。\n总结：\n事件用来表明流程的生命周期中发生了什么事。\n例如 流程的开始 或者 流程的结束\n比如：开始事件、时间开始事件、边界消息事件、\n比如：结束事件、消息结束事件、错误结束事件、\n3.8.2. 事件：空启动事件 一个启动事件说明了流程的开始（或子流程）。图形形式，它看起来 是一个圆（可能）内部有一个小图标。图标指定了事件的实际类型 会在流程实例创建时被触发。\n空启动事件画出来是一个圆，内部没有图标，意思是 这个触发器是未知或者未指定的。\n3.8.3. 事件：空结束事件 结束事件指定了流程实例中一个流程路径的结束。 图形上，它看起来就是一个圆 拥有厚边框（可能） 内部有小图标。 图标指定了结束的时候 会执行哪种操作。\n空结束事件画出来是一个圆，拥有厚边框，内部没有图标， 这意味着当流程到达事件时，不会抛出任何信号。\n下面的例子显示了只使用空开始和结束事件的流程：\n3.8.4. 事件：终止结束事件 终止和空结束事件的区别是 实际中流程的路径是如何处理的（或者使用BPMN 2.0的术语叫做token）。 终止结束事件会结束整个流程实例，而空结束事件只会结束当前流程路径。 他们都不会抛出任何事情 当到达结束事件的时候。\n终止结束事件被描绘成结束事件一样（圆，厚边框）， 内部图标时一个完整的圆。在下面的例子中，完成task1 会结束流程实例，当完成task2时只会结束到达结束事件 的流程路径，只剩下task1打开。\n3.8.5. 顺序流 顺序流是事件，活动和网关之间的连线，显示为一条实线 带有箭头，在BPMN图形中（jPDL中等效的是transition）。 每个顺序流都有一个源头和一个 目标引用，包含了 活动，事件或网关的id。\n与jPDL的一个重要区别是多外向顺序流的行为。 在jPDL中，只有一个转移会成为外向转移，除非活动是fork （或自定义活动拥有fork行为）。然而，在BPMN中， 多外向顺序流的默认行为是切分进入的token（jBPM中术语叫做execution） 分成token集合，每个顺序流一个。在下面情况中， 在完成第一个任务，就会激活三个任务。\n为了避免使用一个顺序流，必须添加condition条件到顺序流中。 在运行时，只有当condition条件结果为true， 顺序流才会被执行。\n为了给顺序流添加condition条件，添加一个conditionExpression 元素到顺序流中。条件可以放在 ${}中。\n注意，当前必须把 xsi:type=\u0026ldquo;tFormalExpression\u0026quot;添加到 conditionExpression中。一个条件性的顺序流可以看到一个小菱形图片 在顺序流的起点。记住表达式一直可以定义在顺序流上， 但是一些结构不会解释它（比如，并行网关）。\n活动（比如用户任务）和网关（比如唯一网关）可以用户默认顺序流。 默认顺序流只会在活动或网关的 所有其他外向顺序流的condition条件为false时才会使用。 默认顺序流图形像是顺序流多了一个斜线标记。\n默认顺序流通过指定活动或网关的 \u0026lsquo;default\u0026rsquo; 属性 来使用。\n也要注意，默认顺序流上的表达式会被忽略。\n3.8.6. 网关 BPMN中的网关是用来控制流程中的流向的。更确切的是， 当一个token（BPMN 2.0中 execution 的概念注解）到达一个网关， 它会根据网关的类型进行合并或切分。\n网关描绘成一个菱形，使用一个内部图标来指定类型 （唯一，广泛，其他）。\n所有网关类型，都可以设置gatewayDirection。 下面的值可以使用：\nunspecificed (默认)：网关可能拥有多个 进入和外出顺序流。 mixed：网关必须拥有多个 进入和外出顺序流。 converging：网关必须拥有多个进入顺序流， 但是只能有一个外出顺序流。 diverging：网关必须拥有一个进入顺序流， 和多个外出顺序流。 注意：gatewayDirection属性根据规范是可选的。 这意味着我们不能通过这个属性来 在运行时知道一个网关的行为（比如，一个并行网关， 如果我们用够切分和合并行为）。然而，gatewayDirection属性用在解析时 作为约束条件对进入、外出顺序流。所以使用这个属性 会减低出错的机会，当引用顺序流时， 但不是必填的。\n3.8.7. 网关：唯一网关 唯一网关表达了一个流程中的唯一决策。 会有一个外向顺序流被使用，根据定义在 顺序流中的条件。\n对应的jPDL结构，相同的语法是 decision 活动。唯一网关的 完全技术名称是\u0026rsquo;基于数据的唯一网关\u0026rsquo;， 但是也经常称为XOR 网关。 XOR网关被描绘为一个菱形，内部有一个\u0026rsquo;X\u0026rsquo;， 一个空的菱形，没有网关也象征着唯一网关。\n下面图形显示了唯一网关的用法：根据amount变量的值， 会选择唯一网关外向的三个外向顺序流 中的一个。\n唯一网关需要所有外向顺序流上都定义条件。 对这种规则一种例外是默认顺序流。 使用default 属性来引用一个已存在的 顺序流的id。这个顺序流会被使用 当其他外向顺序流的条件都执行为false时。\n唯一网关可以同时实现汇聚和发散功能。这个逻辑很容易理解： 对于每个到达这个网关的分支流程，都会选择一个外向顺序流来继续执行。 下面的图形在BPMN 2.0中是完全合法的 （忽略名称和声明的条件）。\n3.8.8. 网关：并行网关 并行网关用来切分或同步相关的进入或外出 顺序流。\n并行网关拥有一个进入顺序流的和多于一个的外出顺序流 叫做\u0026rsquo;并行切分或 \u0026lsquo;AND-split\u0026rsquo;。所有外出顺序流都会 被并行使用。注意：像规范中定义的那样， 外出顺序流中的条件都会被忽略。 并行网关拥有多个进入顺序流和一个外出顺序流 叫做\u0026rsquo;并行归并\u0026rsquo;或 AND-join。所有进入顺序流需要 到达这个并行归并，在外向顺序流使用之前 注意，gatewayDirection属性可以被使用， 已获得建模错误，在解析阶段（参考上面）。\n下面的图形显示了一个并行网关可以如何使用。在流程启动后， \u0026lsquo;prepare shipment\u0026rsquo; 和 \u0026lsquo;bill customer\u0026rsquo;用户任务都会被激活。 并行网关被描绘为一个菱形，内部图标是一个十字， 对切分和归并行为都是一样。\n一个并行网关（其实是任何网关）可以同时拥有切分和汇聚行为。 下面的图形在BPMN 2.0中是完全合法的。 在流程启动之后，A和B任务都会激活。当A和B完成时，C,D和E 任务会被激活。\n3.8.9. 网关：包含网关 一个包含网关 - 也叫做OR-gateway - 被用来 进行“条件性”切分或汇聚顺序流。它基本的行为就和一个并行网关一样， 但是它也可以统计条件，在外出顺序流上（切分行为） 和计算，如果这儿有流程离开，可以到达网关（合并行为）。\n包含网关显示为一个典型的网关图形，里边有一个圆圈（参考\u0026rsquo;OR\u0026rsquo;的语法）。 和唯一网关不同，所有条件表达式被执行（发散或切分行为）。 对于每个表达式结果为true时，一个新的子流程分支就会被创建。 没有定义条件的顺序流会永远被选择（比如。一个子流程 在这种情况下总是会被创建）。\n一个收敛的包含网关（合并行为）有一个更困难的执行逻辑。 当一个执行（在BPMN 2.0的语法中叫做Token）到达一个合并包含网关。 就会进行下面的检测（引用规范的文字）：\n对于每个空的进入顺序流，这里没有Token\r在顺序流的图形上面，比如，这里有一个没有直接的路径\r（由顺序流组成）从Token到这个顺序流，除非\ra) 路径到达了一个包含网关，或\rb) 路径到达了一个节点，直接到一个非空的\r进入顺序流的包含网关 \u0026#34; 简单来说：当一个流程到达了这个网关，所有的激活流程会被检测 它们是否可以到达包含网关，只是统计顺序流 （注意：条件不会被执行！）。当包含网关被使用时， 它通常用在一个切分/汇聚包含网关对中。在其他情况， 流程行为足够简单，只要通过看图就可以理解了。\n当然，不难想象情况，当流程切分和汇聚在复杂的组合， 使用大量的结构，其中包括包含网关。 在那些情况，很可能出现实际的流程行为可能 与建模者的期望不符。所以，当使用包含网关时，要注意 通常的最佳实践是让包含网关成对使用。\n下面的图形演示了如何使用包含网关。 （例子来自于Bruce Silver的\u0026quot;BPMN method and style\u0026rdquo;）\n我们可以区分下面的情况：\n现金多于10000，不是国外银行：只有 \u0026ldquo;Large deposit\u0026rdquo; 任务会被激活。 现金多于10000，是国外银行： \u0026ldquo;Large deposit\u0026rdquo; 和 \u0026ldquo;Foreign deposit\u0026rdquo; 任务会被激活。 现金少于10000，是国外银行： 只有 \u0026ldquo;Foreign deposit\u0026rdquo; 任务会被激活。 现金少于10000，不是国外银行： 在这种情况 所有表达式的结果都是false，默认的顺序流会被选择。 在这个例子中国，这意味着\u0026quot;Standard deposit\u0026quot;任务会被激活。 无论在包含网关之后多少任务被激活，右侧的收敛包含网关会等到 左侧的包含网关所有外向顺序流 到达合并网关（有时，只有一个，有时两个）。\n和其他网关类型一样，包含网关类型可以同时拥有合并和切分行为。 在这种情况下，包含网关将先等到所有分支流程到达， 在位每个顺序流进行再次切分之前，这里会有一个表达式执行 为true（获得没有一个表达式）。\n3.8.10. 任务 一个任务表示工作需要被外部实体完成， 比如人工或自动服务。\n重要的是注意BPMN语法的\u0026rsquo;task\u0026rsquo;与jPDL语法的区别。 在jPDL中，\u0026rsquo;task\u0026rsquo;的概念总是用在人工做一些事情的环境。 的那个流程引擎遇到jPDL中的task，它会创建一个task， 交给一些人的任务列表，然后它会进入等待状态。然而在BPMN 2.0中， 这里有很多任务类型，一些表示等待状态（比如，User Task 一些表示自动活动（比如，Service Task。 所以小心不要混淆了任务的概念，在切换语言的时候。\n任务被描绘成一个圆角矩形，一般内部包含文字。 任务的类型（用户任务，服务任务，脚本任务，等等）显示在矩形的左上角，用小图标区别。 根据任务的类型， 引擎会执行不同的功能。\n活动（Activities）是业务流程定义的核心元素，中文可称为“活动”、“节点”、“步骤”。一个活动可以是流程中一个基本处理单元（如人工任务、服务任务），也可以是一个组合单元（如外部子流程、嵌套子流程）。\n3.8.11. 任务：人工任务 user task是典型的\u0026rsquo;人工任务\u0026rsquo;， 实际中的每个workflow或BPMN软件中都可以找到。当流程执行到达这样一个user task时， 一个新人工任务就会被创建，交给用户的任务列表。\n和manual task的主要区别是 （也与人工工作对应）是流程引擎了解任务。 引擎可以跟踪竞争，分配，时间，其他，这些不是manual task的情况。\nuser task描绘为一个圆角矩形，在左上角是一个小用户图标。\nBPMN 2.0规范包含了一些方法把任务分配给用户，组，角色等等。 当前的BPMN 2.0 jBPM实现允许使用一个 resourceAssignmentExpression来分配任务， 结合humanPerformer or PotentialOwner结构。 这部分希望在未来的版本里能够进一步演化。\npotentialOwner用来在你希望确定用户，组，角色的时候。 这是一个task的候选人。 参考下面的例子。这里的\u0026rsquo;My task\u0026rsquo;任务的候选人组是\u0026rsquo;management\u0026rsquo;用户组。 也要注意，需要在流程外部定义一个资源， 这样任务分配器可以引用到这个资源。 实际上，任何活动都可以引用一个或多个资源元素。 目前，只需要定义这个资源就可以了（因为它是规范中的一个必须的元素）， 但是在以后的发布中会进行加强（比如，资源可以拥有运行时参数）。\n注意，我们使用了一个特定的后缀 (jbpm:type=\u0026ldquo;group\u0026rdquo;)，来定义这是一个用户组的分配方式。 如果删除了这个属性，就会默认使用用户组的语法 （在这个例子中也是没问题的）。 现在假设Peter和Mary是management组的成员 (这里使用默认的身份服务)：\n当分配方式应该是候选用户时， 只需要使用jbpm:type=\u0026ldquo;user\u0026quot;属性。\nhuman performer用来，当你想把一个任务直接分配给一个人， 组，角色时。这个方法的使用方式 看起来和potential owner很像。\n因为任务分配已经完成，通过使用 formalExpression，它也可以定义表达式 在运行期解析。表达式本身需要放在 ${}中，这和jBPM一样。 比如，如果流程变量\u0026rsquo;user\u0026rsquo;被定义了，然后，它可以用在表达式中。 当然也可以使用更复杂的表达式。\n\u0026lt;userTask id=\u0026#34;myTask\u0026#34; name=\u0026#34;My User task\u0026#34;\u0026gt;\r\u0026lt;humanPerformer resourceRef=\u0026#34;employee\u0026#34;\u0026gt;\r\u0026lt;resourceAssignmentExpression\u0026gt;\r\u0026lt;formalExpression\u0026gt;${user}\u0026lt;/formalExpression\u0026gt;\r\u0026lt;/resourceAssignmentExpression\u0026gt;\r\u0026lt;/humanPerformer\u0026gt;\r\u0026lt;/userTask\u0026gt; 注意不需要在humanPerformer元素中使用\u0026rsquo;jbpm:type\u0026rsquo;，因为只能进行 直接用户分配。如果任务需要被分配给一个角色或一个组， 使用potentialOwner和group类型（当你把任务分配给一个组时， 组中的所有成员都会成为候选用户 - 参考potentialOwner的用法）。\n3.8.12. 任务：Java服务任务 Service Task是一个自动活动，它会调用一些服务， 比如web service，java service等等。当前jBPM引擎 只支持调用java service，但是web service的调用 已经在未来的版本中做了计划。\n服务任务需要一个必填的id和一个可选的 name。implementation元素 是用来表示调用服务的类型。可选值是WebService, Other或者Unspecified。 因为我们只实现了Java调用， 现在只能选择Other。\n服务任务将调用一个操作，operation的id 会在operationRef属性中引用。 这样一个操作就是下面实例的 interface的一部分。每个操作都至少有一个 输入信息，并且 最多有一个输出信息。\n对于java服务，接口的名称用来 指定java类的全类名。操作的名称 用来指定将要调用方法名。 输入/输出信息表示着java方法的参数/返回值， 定义如下所示：\nBPMN中很多元素叫做\u0026rsquo;item感知\u0026rsquo;，包括这个消息结构。 这意味着它们会在流程执行过程中保存或读取item。 负责这些元素的数据结构需要使用ItemDefinition。 在这个环境下，消息指定了它的数据结构， 通过引用 structureRef属性中定义的ItemDefinition。\n注意，这写不是标准的BPMN 2.0标准（因此都有\u0026rsquo;jbpm\u0026rsquo;的前缀）。 实际上，根据标准，ItemDefinition不应该包含多余一个数据结构定义。 实际在输入参数的映射，使用一个数据结构， 在serviceTask的ioSpecification章节已经完成了。 然而，当前jBPM BPMN 2.0实现还没有实现那个结构。 所以，这意味着当前使用的上面这种方法， 很可能在不久的未来就会出现变化。\n重要提醒：接口，ItemDefinitions和消息需要定义在 外边。参考实例 ServiceTaskTest的实际流程和单元测试。\n3.8.13. 任务：脚本任务 脚本任务时一个自动活动，当到达这个任务的时候 流程引擎会执行一个脚本。脚本任务使用方式如下：\n脚本任务，除了必填id和可选的 name之外，还允许指定 scriptLanguage和script。 因为我们使用了JSR-223（java平台的脚本语言），修改脚本语言就需要：\n把scriptLanguage 属性修改为JSR-223兼容的名称 在classpath下添加JSR规范的ScriptEngine实现 上面的XML对应图形如下所示（添加了空开始和结束事件）。\n像上面例子中显示的那样，可以在脚本中使用流程变量。 我们现在可以启动一个这个例子的流程，也要提供一些随机生成的输入变量：\n在输出控制台里，我们现在可以看到执行的执行的脚本：\n3.8.14. 任务：手工任务 手工任务时一个由外部人员执行的任务，但是没有指定是 一个BPM系统或是一个服务会被调用。在真实世界里，有很多例子： 安装一个电话系统，使用定期邮件发送一封信， 用电话联系客户，等等。\n手工任务的目标更像 文档/建模提醒的，因为它 对流程引擎的运行没有任何意义，因此，当流程引擎遇到一个手工任务时 会简单略过。\n3.8.15. 任务：java接收任务 receive task 是一个任务会等到外部消息的到来。 除了广泛使用的web service用例，规范在其他环境中的使用也是一样的。 web service用例还没有实现， 但是receive task已经可以在java环境中使用了。\nreceive task 显示为一个圆角矩形（和task图形一样） 在左上角有一个小信封的图标。 在java环境中，receive task没有其他属性，除了id和name（可选）， 行为就像是一个等待状态。为了在你的业务流程中使用等待状态， 只需要加入如下几行：\n流程执行会在这样一个receive task中等待。流程会使用 熟悉的jBPM signal methods来继续执行。 注意，这些可能在未来改变，因为\u0026rsquo;signal\u0026rsquo; 在BPMN 2.0中拥有完全不同的含义。\n3.9. 高级结构 3.9.1. 内嵌子流程 子流程的第一目的是实现流程的“继承”，意味着 设计者可以创建多个不同“级别”的细节。顶级视图理解为做 一件事情的最高级别方式，最低的级别 就关注具体细节。\n比如下面的图形。在这个模型里，只有最高级的步骤显示出来。 实际的实现\u0026quot;Check credit\u0026quot;步骤隐藏在 折叠子流程中，这可能是最完美的级别 细节来讨论业务流程，与最终用户。\n子流程的第二种主要功能是子流程\u0026quot;容器\u0026quot;作为 事件的作用域。当一个事件在子流程中触发时，获取事件 在子流程的边界上就会首先获得这个事件。\n定义在顶级流程的子流程被称为内嵌子流程。 上级流程中的所有流程数据也可以在子流程中使用。 下面的图形演示了 上面模型的展开形式。\n注意在子流程内部，事件，活动，任务的定义与顶级流程中是一样的。 子流程只允许有一个空开始事件。\n结论，一个内嵌子流程会像下面这样运行：当一个流程执行到子流程， 一个子分支会被创建。子分支以后还可以创建其他子分支， 比如，当一个并发网关使用在子流程中。 子流程，只会在没有任何活动的分支时才会完成。 这时，上级流程会 继续执行。\n比如，在下面的图形中，\u0026ldquo;Third task\u0026rdquo; 只会在\u0026quot;First task\u0026quot;和\u0026quot;Second task\u0026quot;都完成时才会到达。 子流程的其中一个任务不会触发子流程向下运行， 因为另一个分支在子流程中还是活动的。\n子流程可以拥有多个开始事件。这种情况下，多个并行分支就在流程中存在。 子流程完成的规则没有改变： 子流程只有在所有并行分支都完成时 才会结束。\n内嵌子流程也是可以的。这时，流程可以分散成多个不同级别的细节。 这里没有对内嵌级别做任何限制。\n实现提醒：按照BPMN2规范，一个没有外向顺序流的活动会隐式结束当前分支。 然而当前，必须特别指定一个结束事件 在子流程中，来结束一个分支， 这会在未来的规范兼容过程中加强。\n3.9.2. 定时启动事件 定时启动事件用来表示流程需要在指定时间启动。 可以指定一个特殊的时间点（比如，2010年10月10日下午5点）， 但是也可以用一个通常的时间（比如，每个周五的半夜）。\n定时启动事件看起来是在圆圈中有一个表的图标。 可以使用下面的时间定义：\ntimeDate: 指定一个固定时间， 这时定时器会触发，流程会继续。默认的时间格式是 \u0026ldquo;dd/MM/yyyy hh:mm:ss\u0026rdquo;。这是引擎范围的，可以通过设置 配置中的jbpm.duedatetime.format属性来改变。 注意，在使用固定事件时，流程只用在一个单独的事件。 在流程实例创建之后，定时启动事件不会再次触发。\ntimeCycle: 指定一个延迟时间段， 相对于流程进入定时器事件时。可以用两种定义方式： 这与jPDL中的定时器时间段定义是完全相同的。注意， BPMN2定时启动事件也可以理解\u0026quot;业务时间\u0026rdquo;。 这允许，比如定义一个\u0026quot;业务日期\u0026quot;作为周期，从早九点到晚五点。 这样，从下午5点到上午9点的时间就不会被计算， 当事件触发的事件被计算的时候。 请参考jPDL用户手册，获得更多信息，关于如何自定义业务日历。\nCron 表达式： 虽然时间段表达式已经很好的覆盖了 延迟定义，有时，它们不太好用。 当，比如，一个流程实例应该在每个周五晚上23点执行， cron表达式允许一个更自然的方式来定义这种重复的行为的发生。 jBPM中实现的定时启动事件也拥有如下的特性：\n声明了定时启动事件的流程定义，也可以当做一个无启动事件启动。 这就是说，比如调用 executionService.startProcessInstanceByKey(key)也是可以的。 定时启动事件的内部实现是一个定时任务。这意味着 必须配置job executor，定时启动事件才能工作。 这种实现的优点是，定时启动事件的触发是事务性的 （比如，如果定时启动事件后的一个服务任务失败了， 事务就会回滚，定时启动事件就会稍后执行） 并且可以应付服务器崩溃。（比如，当服务器备份时， 定时启动事件会由job executor获取， 就像什么也没有发生一样）。 当一个拥有定时启动事件的流程定义发布新版本时， 旧版本的定时启动事件的任务会被从系统中删除。这意味着 只有最新版本的流程定义会被使用 来创建一个流程实例。 3.9.3. 中间事件 中间事件用来表示在流程执行过程中发生的事件（比如， 在流程启动之后，在它完成之前）。中间事件看起来就像 一个有着双边线的圆圈，圆圈中的图标表示了事件的类型。\n这儿有好多种中间事件类型，比如定时器事件，触发事件，传播事件，等等。 中间事件既可以抛出也可以捕获：\n抛出：当一个流程到达事件中， 它会立刻触发一个对应的触发器（一个激活，一个错误，等等）。 抛出事件用图形表示起来就是使用黑色填充的图标。 捕获：当一个流程到达事件中， 它会等待一个对应的触发器发生（一个错误，一个定时器，等等）。 捕获事件用图形表示起来就是没有使用黑色填充的图标（比如，内部是白色的）。 3.9.4. 内部捕获事件：定时器 内部定时器事件用来表示一个流程的延迟。 直接的用例是收集数据， 只在没有人工作的晚上执行大量的逻辑，等等。\n注意，一个内部定时器只能是一个捕获事件（抛出一个定时器事件时没有意义的）。 下面的图形中演示了内部定时器事件的图形形式。\n有两种方法可以来指定延迟，使用timeCycle 或 a timeDate。\n下面的延迟定义也是可以用的（这与启动定时器是相同的）。\ntimeDate: 指定一个固定时间， 这时定时器会触发，流程会继续。默认的时间格式是 \u0026ldquo;dd/MM/yyyy hh:mm:ss\u0026rdquo;。这是引擎范围的，可以通过设置 配置中的jbpm.duedatetime.format属性来改变。\ntimeCycle: 指定一个延迟时间段， 相对于流程进入定时器事件时。\nCron 表达式：允许我们定义延迟，这种方式很多人都知道（因为CRON表达式 在Unix中用来定义任务）。注意一个cron表达式 通常用来定义重复执行。在这个环境下，就是 第一个满足cron表达式的时间点 用来设置定时器事件的持续时间（所以不会重复执行）。\n3.10. 完全的实例（包括控制台任务表单） 注意，流程变量可以使用 ${my_process_variable}来访问。也要注意输入控件的名称。 （比如，输入文本框，提交表单）可以用来 定义新流程变量。\n"},{"id":378,"href":"/Tech/6Technical-Topics/Hugo/Hugo/","title":"Hugo","parent":"Hugo","content":" Hugo hugo new site demosite\rcd demosite\rhugo server -D "},{"id":379,"href":"/Tech/7Security/TheHackerPlaybook/","title":"The Hacker Playbook","parent":"7、Security","content":" TheHackerPlaybook 第一章：环境建设 "},{"id":380,"href":"/Tech/8IDE/Cmake/Cmake/","title":"Cmake","parent":"Cmake","content":""},{"id":381,"href":"/Tech/8IDE/Docker/Docker-Dockerfile/","title":"Docker Dockerfile","parent":"Docker","content":" Docker Dockerfile 什么是 Dockerfile？ Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。\n使用 Dockerfile 定制镜像 FROM nginx\rRUN echo \u0026#39;这是一个本地构建的nginx镜像\u0026#39; \u0026gt; /usr/share/nginx/html/index.html 2、FROM 和 RUN 指令的作用 FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。\nRUN：用于执行后面跟着的命令行命令。有以下俩种格式：\nshell 格式：\nRUN \u0026lt;命令行命令\u0026gt;\r# \u0026lt;命令行命令\u0026gt; 等同于，在终端操作的 shell 命令。 exec 格式：\nRUN [\u0026#34;可执行文件\u0026#34;, \u0026#34;参数1\u0026#34;, \u0026#34;参数2\u0026#34;]\r# 例如：\r# RUN [\u0026#34;./test.php\u0026#34;, \u0026#34;dev\u0026#34;, \u0026#34;offline\u0026#34;] 等价于 RUN ./test.php dev offline 注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：\nFROM centos\rRUN yum -y install wget\rRUN wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026#34;\rRUN tar -xvf redis.tar.gz 以上执行会创建 3 层镜像。可简化为以下格式：\nFROM centos\rRUN yum -y install wget \\\r\u0026amp;\u0026amp; wget -O redis.tar.gz \u0026#34;http://download.redis.io/releases/redis-5.0.3.tar.gz\u0026#34; \\\r\u0026amp;\u0026amp; tar -xvf redis.tar.gz 如上，以 \u0026amp;\u0026amp; 符号连接命令，这样执行后，只会创建 1 层镜像。\n开始构建镜像 在 Dockerfile 文件的存放目录下，执行构建动作。\n以下示例，通过目录下的 Dockerfile 构建一个 nginx:v3（镜像名称:镜像标签）。\n注：最后的 . 代表本次执行的上下文路径，下一节会介绍。\n$ docker build -t nginx:v3 .\n上下文路径 上一节中，有提到指令最后一个.是上下文路径，那么什么是上下文路径呢？\n$ docker build -t nginx:v3 .\n上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n解析：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n指令详解 COPY 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。\n格式：\nCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] \u0026lt;源路径1\u0026gt;... \u0026lt;目标路径\u0026gt;\rCOPY [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;] [\u0026#34;\u0026lt;源路径1\u0026gt;\u0026#34;,... \u0026#34;\u0026lt;目标路径\u0026gt;\u0026#34;] [--chown=\u0026lt;user\u0026gt;:\u0026lt;group\u0026gt;]：可选参数，用户改变复制到容器内文件的拥有者和属组。\n\u0026lt;源路径\u0026gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：\nCOPY hom* /mydir/\rCOPY hom?.txt /mydir/ \u0026lt;目标路径\u0026gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。\nADD ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：\nADD 的优点：在执行 \u0026lt;源文件\u0026gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 \u0026lt;目标路径\u0026gt;。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。 CMD 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\nRUN 是在 docker build。 CMD 在docker run 时运行。 作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n注意：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\nCMD \u0026lt;shell 命令\u0026gt; CMD [\u0026#34;\u0026lt;可执行文件或命令\u0026gt;\u0026#34;,\u0026#34;\u0026lt;param1\u0026gt;\u0026#34;,\u0026#34;\u0026lt;param2\u0026gt;\u0026#34;,...] CMD [\u0026#34;\u0026lt;param1\u0026gt;\u0026#34;,\u0026#34;\u0026lt;param2\u0026gt;\u0026#34;,...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。\nENTRYPOINT 类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\n但是, 如果运行 docker run 时使用了 \u0026ndash;entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。\n优点：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。\n注意：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\n格式：\nENTRYPOINT [\u0026#34;\u0026lt;executeable\u0026gt;\u0026#34;,\u0026#34;\u0026lt;param1\u0026gt;\u0026#34;,\u0026#34;\u0026lt;param2\u0026gt;\u0026#34;,...] 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。\n示例：\n假设已通过 Dockerfile 构建了 nginx:test 镜像：\nFROM nginx\rENTRYPOINT [\u0026#34;nginx\u0026#34;, \u0026#34;-c\u0026#34;] # 定参\rCMD [\u0026#34;/etc/nginx/nginx.conf\u0026#34;] # 变参 1、不传参运行\n$ docker run nginx:test\n容器内会默认运行以下命令，启动主进程。\nnginx -c /etc/nginx/nginx.conf\n2、传参运行\n$ docker run nginx:test -c /etc/nginx/new.conf\n容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)\nnginx -c /etc/nginx/new.conf\nENV 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。\n格式：\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\rENV \u0026lt;key1\u0026gt;=\u0026lt;value1\u0026gt; \u0026lt;key2\u0026gt;=\u0026lt;value2\u0026gt;... 以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：\nENV NODE_VERSION 7.2.0\rRUN curl -SLO \u0026#34;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\u0026#34; \\\r\u0026amp;\u0026amp; curl -SLO \u0026#34;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\u0026#34; ARG 构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。\n构建命令 docker build 中可以用 \u0026ndash;build-arg \u0026lt;参数名\u0026gt;=\u0026lt;值\u0026gt; 来覆盖。\n格式：\nARG \u0026lt;参数名\u0026gt;[=\u0026lt;默认值\u0026gt;]\nVOLUME 定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n作用：\n避免重要的数据，因容器重启而丢失，这是非常致命的。 避免容器不断变大。\nVOLUME [\u0026#34;\u0026lt;路径1\u0026gt;\u0026#34;, \u0026#34;\u0026lt;路径2\u0026gt;\u0026#34;...]\rVOLUME \u0026lt;路径\u0026gt; 在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\nEXPOSE 仅仅只是声明端口。\n作用：\n帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 格式：\nEXPOSE \u0026lt;端口1\u0026gt; [\u0026lt;端口2\u0026gt;...]\nWORKDIR 指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。\ndocker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。\n格式：\nWORKDIR \u0026lt;工作目录路径\u0026gt;\nUSER 用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。\n格式：\nUSER \u0026lt;用户名\u0026gt;[:\u0026lt;用户组\u0026gt;]\nHEALTHCHECK 用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\n格式：\nHEALTHCHECK [选项] CMD \u0026lt;命令\u0026gt;：设置检查容器健康状况的命令\rHEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\rHEALTHCHECK [选项] CMD \u0026lt;命令\u0026gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。 ONBUILD 用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。\n格式：\nONBUILD \u0026lt;其它指令\u0026gt; LABEL LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：\n格式：\nLABEL \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; \u0026lt;key\u0026gt;=\u0026lt;value\u0026gt; ... 比如我们可以添加镜像的作者：\nLABEL org.opencontainers.image.authors=\u0026#34;runoob\u0026#34; MAINTAINER 镜像维护者姓名或邮箱地址：\n格式：\nMAINTAINER \u0026lt;name\u0026gt; \u0026lt;mail\u0026gt; "},{"id":382,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-1-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/","title":"Docker 命令 1 容器生命周期管理","parent":"Docker 命令","content":" Docker 命令大全 容器生命周期管理 run start/stop/restart kill rm pause/unpause create exec Docker run 命令 docker run ：创建一个新的容器并运行一个命令\n语法 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明：\n-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； \u0026ndash;name=\u0026ldquo;nginx-lb\u0026rdquo;: 为容器指定一个名称； \u0026ndash;dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； \u0026ndash;dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h \u0026ldquo;mars\u0026rdquo;: 指定容器的hostname； -e username=\u0026ldquo;ritchie\u0026rdquo;: 设置环境变量； \u0026ndash;env-file=[]: 从指定文件读入环境变量； \u0026ndash;cpuset=\u0026ldquo;0-2\u0026rdquo; or \u0026ndash;cpuset=\u0026ldquo;0,1,2\u0026rdquo;: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； \u0026ndash;net=\u0026ldquo;bridge\u0026rdquo;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； \u0026ndash;link=[]: 添加链接到另一个容器； \u0026ndash;expose=[]: 开放一个端口或一组端口； \u0026ndash;volume , -v: 绑定一个卷 \u0026ndash;ulimit , 生成的进程的资源进行限制 实例 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。\ndocker run --name mynginx -d nginx:latest 使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。\ndocker run -P -d nginx:latest 使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。\ndocker run -p 80:80 -v /data:/data -d nginx:latest 绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。\ndocker run -p 127.0.0.1:80:8080/tcp ubuntu bash 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。\nrunoob@runoob:~$ docker run -it nginx:latest /bin/bash\rroot@b8573233d675:/# 常用的docker ulimit设置项:\n参数 意义 例子 nofile shell进程打开文件数目 docker run \u0026ndash;ulimit nofile=20 core 进程生成core文件的尺寸 docker run \u0026ndash;ulimit core =-1 //开启进程core nproc shell能打开的进程多少 Na fsize 进程写文件的最大尺寸 Na Docker start/stop/restart 命令 docker start :启动一个或多个已经被停止的容器\ndocker stop :停止一个运行中的容器\ndocker restart :重启容器\n语法 docker start [OPTIONS] CONTAINER [CONTAINER...] docker stop [OPTIONS] CONTAINER [CONTAINER...] docker restart [OPTIONS] CONTAINER [CONTAINER...] 实例 启动已被停止的容器myrunoob\ndocker start myrunoob 停止运行中的容器myrunoob\ndocker stop myrunoob 重启容器myrunoob\n重启容器myrunoob Docker kill 命令 docker kill ：杀掉一个运行中的容器。\n语法 docker kill [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-s :向容器发送一个信号 实例 杀掉运行中的容器mynginx\nrunoob@runoob:~$ docker kill -s KILL mynginx\rmynginx Docker rm 命令 docker rm ：删除一个或多个容器。\n语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n实例 强制删除容器 db01、db02：\ndocker rm -f db01 db02 移除容器 nginx01 对容器 db01 的连接，连接名 db：\ndocker rm -l db 删除容器 nginx01, 并删除容器挂载的数据卷：\ndocker rm -v nginx01 除所有已经停止的容器：\ndocker rm $(docker ps -a -q) Docker pause/unpause 命令 docker pause ：暂停容器中所有的进程。\ndocker unpause ：恢复容器中所有的进程。\n语法 docker pause [OPTIONS] CONTAINER [CONTAINER...] docker unpause [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n实例 暂停数据库容器db01提供服务。\ndocker pause db01 恢复数据库容器 db01 提供服务。\nocker unpause db01 Docker create 命令 **docker create ** ：创建一个新的容器但不启动它。\n用法同 docker run\n语法 docker create [OPTIONS] IMAGE [COMMAND] [ARG...] 同 docker run\nDocker exec 命令 docker exec ：在运行的容器中执行命令。\n语法 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTIONS说明：\n-d :分离模式: 在后台运行\n-i :即使没有附加也保持STDIN 打开\n-t :分配一个伪终端\n实例 在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:\nrunoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh\rhttp://www.runoob.com/ 在容器 mynginx 中开启一个交互模式的终端:\nrunoob@runoob:~$ docker exec -i -t mynginx /bin/bash\rroot@b1a0703e41e7:/# 也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。\n查看已经在运行的容器 ID：\ndocker ps -a ...\r9df70f9a0714 openjdk \u0026#34;/usercode/script.sh…\u0026#34; ... 第一列的 9df70f9a0714 就是容器 ID。\n通过 exec 命令对指定的容器执行 bash:\ndocker exec -it 9df70f9a0714 /bin/bash "},{"id":383,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-2-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/","title":"Docker 命令 2 容器操作","parent":"Docker 命令","content":" Docker 命令大全 容器操作 ps inspect top attach events logs wait export port Docker rm 命令 docker rm ：删除一个或多个容器。\n语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n实例 强制删除容器 db01、db02：\ndocker rm -f db01 db02 "},{"id":384,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-3-%E5%AE%B9%E5%99%A8rootfs%E5%91%BD%E4%BB%A4/","title":"Docker 命令 3 容器rootfs命令","parent":"Docker 命令","content":" Docker 命令大全 容器rootfs命令 commit cp diff Docker rm 命令 docker rm ：删除一个或多个容器。\n语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n实例 强制删除容器 db01、db02：\ndocker rm -f db01 db02 "},{"id":385,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-4-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/","title":"Docker 命令 4 镜像仓库","parent":"Docker 命令","content":" Docker 命令大全 镜像仓库 login pull push search Docker rm 命令 docker rm ：删除一个或多个容器。\n语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n实例 强制删除容器 db01、db02：\ndocker rm -f db01 db02 "},{"id":386,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-5-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/","title":"Docker 命令 5 本地镜像管理","parent":"Docker 命令","content":" Docker 命令大全 本地镜像管理 images rmi tag build history save load import Docker rm 命令 docker rm ：删除一个或多个容器。\n语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n实例 强制删除容器 db01、db02：\ndocker rm -f db01 db02 "},{"id":387,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-6-info-version/","title":"Docker 命令 6 Info Version","parent":"Docker 命令","content":" Docker 命令大全 info|version info version Docker rm 命令 docker rm ：删除一个或多个容器。\n语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n实例 强制删除容器 db01、db02：\ndocker rm -f db01 db02 "},{"id":388,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4/","title":"Docker 命令","parent":"Docker 命令","content":" Docker 命令大全 转自：菜鸟教程\n链接：https://www.runoob.com/docker/docker-command-manual.html\n容器生命周期管理 run start/stop/restart kill rm pause/unpause create exec 容器操作 ps inspect top attach events logs wait export port 容器rootfs命令 commit cp diff 镜像仓库 login pull push search 本地镜像管理 images rmi tag build history save load import info|version info version "},{"id":389,"href":"/Tech/8IDE/Docker/Docker/","title":"Docker","parent":"Docker","content":" Docker 应知应会 1、关于 Docker 1.1、关于 Docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n1.1.1、Docker 的应用场景 Web 应用的自动化打包和发布。\n自动化测试和持续集成、发布。\n在服务型环境中部署和调整数据库或其他的后台应用。\n从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境\n1.1.2、相关链接 Docker 官网：https://www.docker.com\nGithub Docker 源码：https://github.com/docker/docker-ce\n1.2、Docker 架构 Docker 包括三个基本概念:\n镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker 容器。\nDocker 容器通过 Docker 镜像来创建。\n容器与镜像的关系类似于面向对象编程中的对象与类。\n概念 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker Registry Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。 Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 \u0026lt;仓库名\u0026gt;:\u0026lt;标签\u0026gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 "},{"id":390,"href":"/Tech/8IDE/Docker/DockerDocs/DockerDocs-1-Docker-%E6%A6%82%E8%BF%B0/","title":"Docker Docs 1 Docker 概述","parent":"DockerDocs","content":" Docker Docs 转自：Docker 官网\n链接：https://docs.docker.com/get-started/overview/\nDocker 概述 Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分离，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础架构。通过利用 Docker 的快速发布、测试和部署代码的方法，您可以显著减少编写代码和在生产环境中运行代码之间的延迟。\nDocker 平台 Docker 提供了在松散隔离的环境中打包和运行应用程序（称为容器）的功能。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的所有内容，因此您无需依赖主机上当前安装的内容。您可以在工作时轻松共享容器，并确保与之共享的每个人都能获得以相同方式工作的相同容器。\nDocker 提供了工具和平台来管理容器的生命周期：\n使用容器开发应用程序及其支持组件。 容器将成为分发和测试应用程序的单元 准备就绪后，将应用程序作为容器或编排服务部署到生产环境中。无论您的生产环境是本地数据中心、云提供商还是两者的混合体，这都是一样的。 我可以使用 Docker 做什么？ 快速、一致地交付您的应用程序 Docker 允许开发人员使用提供应用程序和服务的本地容器在标准化环境中工作，从而简化了开发生命周期。容器非常适合持续集成和持续交付 （CI/CD） 工作流。\n请考虑以下示例方案：\n您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。 他们使用 Docker 将其应用程序推送到测试环境中，并执行自动和手动测试。 当开发人员发现 Bug 时，他们可以在开发环境中修复它们，并将其重新部署到测试环境中进行测试和验证。 测试完成后，将修复程序推送到生产环境非常简单。. 响应式部署和扩展 Docker 基于容器的平台允许高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑、数据中心的物理机或虚拟机、云提供商或混合环境中运行。\nDocker 的可移植性和轻量级特性还使得能够近乎实时地动态管理工作负载、根据业务需求扩展或拆除应用程序和服务变得容易。\n在同一硬件上运行更多工作负载 Docker 是轻量级和快速的。它为基于虚拟机管理程序的虚拟机提供了一种可行且经济高效的替代方案，因此您可以使用更多的计算容量来实现业务目标。Docker 非常适合高密度环境以及需要用更少资源完成更多工作的中小型部署。\nDocker 体系结构 Docker 使用 客户端-服务器 体系结构。Docker 客户端与 Docker 守护程序通信，后者负责构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护程序可以在同一系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序使用 REST API、UNIX 套接字或网络接口进行通信。另一个 Docker 客户端是 Docker Compose，它允许您使用由一组容器组成的应用程序。 Docker 守护程序 Docker daemon Docker 守护程序（） 侦听 Docker API 请求并管理 Docker 对象，如映像、容器、网络和卷。守护程序还可以与其他守护程序通信以管理 Docker 服务。dockerd\nDocker 客户端 Docker client Docker 客户端（） 是许多 Docker 用户与 Docker 交互的主要方式。使用 诸如 之类的命令时，客户端会将这些命令发送到 ，后者会执行这些命令。该命令使用 Docker API。Docker 客户端可以与多个守护程序进行通信。 docker docker run dockerd docker\nDocker Desktop Docker Desktop 是一款适用于 Mac 或 Windows 环境的易于安装的应用程序，使您能够构建和共享容器化应用程序和微服务。Docker Desktop 包括 Docker 守护程序 （）、Docker 客户端 （）、Docker Compose、Docker Content Trust、Kubernetes 和 Credential Helper。有关详细信息，请参阅 。Docker Desktop docker ddocker\nDocker 注册表 Docker registries Docker 注册表存储 Docker 映像。Docker Hub 是任何人都可以使用的公共注册表，默认情况下，Docker 配置为在 Docker Hub 上查找映像。您甚至可以运行自己的私有注册表。\n使用 or 命令时，将从配置的注册表中拉取所需的映像。使用该命令时，映像将推送到已配置的注册表。\ndocker pulldocker rundocker push\nDocker 对象 Docker objects 使用 Docker 时，您正在创建和使用映像、容器、网络、卷、插件和其他对象。本节简要概述了其中一些对象。\nImages 映像是一个只读模板，其中包含有关创建 Docker 容器的说明。通常，一个映像基于另一个映像，并具有一些额外的自定义。例如，您可以构建一个基于该映像的映像，但会安装 Apache Web 服务器和应用程序，以及使应用程序运行所需的配置详细信息。 ubuntu 您可以创建自己的映像，也可以只使用其他人创建并在注册表中发布的映像。若要生成自己的映像，请使用简单的语法创建一个 Dockerfile，用于定义创建映像并运行映像所需的步骤。Dockerfile 中的每条指令都会在映像中创建一个层。更改 Dockerfile 并重新生成映像时，只会重新生成已更改的层。与其他虚拟化技术相比，这是使映像如此轻巧、小巧和快速的部分原因。\n容器 Containers 容器是映像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。可以将容器连接到一个或多个网络，将存储附加到该网络，甚至可以根据其当前状态创建新映像。\n默认情况下，容器与其他容器及其主机相对隔离。您可以控制容器的网络、存储或其他底层子系统与其他容器或主机的隔离程度。\n容器由其映像以及您在创建或启动容器时提供给它的任何配置选项定义。删除容器后，未存储在持久性存储中的任何对其状态所做的任何更改都将消失。\n示例命令 docker run\n以下命令运行容器，以交互方式附加到本地命令行会话，然后运行。 ubuntu/bin/bash\ndocker run -i -t ubuntu /bin/bash 运行此命令时，将发生以下情况（假设您使用的是默认注册表配置）：\n如果本地没有映像，Docker 会从配置的注册表中提取该映像，就像手动运行一样。 ubuntu docker pull ubuntu Docker 会创建一个新容器，就像手动运行命令一样。 docker container create Docker 将读写文件系统分配给容器，作为其最后一层。这允许正在运行的容器在其本地文件系统中创建或修改文件和目录。 Docker 创建一个网络接口以将容器连接到默认网络，因为您没有指定任何网络选项。这包括为容器分配 IP 地址。默认情况下，容器可以使用主机的网络连接连接到外部网络。 Docker 启动容器并执行 。由于容器以交互方式运行并附加到终端（由于 and 标志），因此您可以在将输出记录到终端时使用键盘提供输入。/bin/bash -i -t 键入以终止命令时，容器将停止但不会被删除。您可以再次启动它或删除它。exit /bin/bash 底层技术 Docker是用Go编程语言编写的，并利用 Linux 内核的几个特性来提供其功能。Docker 使用一种称为“容器”的技术来提供称为容器的独立工作区。运行容器时，Docker 会为该容器创建一组命名空间。namespaces\n这些命名空间提供了一个隔离层。容器的每个方面都在单独的命名空间中运行，其访问权限仅限于该命名空间。\n三. 今后的步骤 阅读有关安装 Docker 的信息。 通过 Docker 入门教程获取实践经验。 "},{"id":391,"href":"/Tech/8IDE/Docker/DockerDocs/DockerDocs-2-%E8%8E%B7%E5%8F%96-Docker/","title":"Docker Docs 2 获取 Docker","parent":"DockerDocs","content":" Docker Docs 转自：Docker 官网\n链接：https://docs.docker.com/get-started/overview/\n获取 Docker 单独有写一篇如何安装\ndocker run hello-world "},{"id":392,"href":"/Tech/8IDE/Docker/DockerDocs/DockerDocs-3-%E7%AB%8B%E5%8D%B3%E5%BC%80%E5%A7%8B/","title":"Docker Docs 3 立即开始","parent":"DockerDocs","content":" Docker Docs 转自：Docker 官网\n链接：https://docs.docker.com/get-started/overview/\n立即开始 第 1 部分：入门 方向和设置 欢迎！我们很高兴您想学习 Docker。\n本页包含有关如何开始使用 Docker 的分步说明。在本教程中，您将学习如何：\n将映像作为容器生成和运行 使用 Docker Hub 共享映像 使用多个容器和一个数据库部署 Docker 应用程序 使用 Docker Compose 运行应用程序 此外，您还将了解构建映像的最佳做法，包括有关如何扫描映像以查找安全漏洞的说明。\n下载并安装 Docker 建议在 Linux 系统上安装 Docker。\n开始教程 如果您已经运行了该命令以开始使用本教程，那么恭喜您！如果没有，请打开命令提示符或 bash 窗口，然后运行以下命令：\ndocker run -d -p 80:80 docker/getting-started 您会注意到正在使用一些标志。以下是有关它们的更多信息：\n-d- 在分离模式下运行容器（在后台） -p 80:80- 将主机的端口 80 映射到容器中的端口 80 docker/getting-started- 要使用的图像 提示\n您可以组合单个字符标志以缩短完整命令。例如，上面的命令可以写成：\ndocker run -dp 80:80 docker/getting-started Docker 仪表板 Docker Dashboard 在走得太远之前，我们想突出显示 Docker 仪表板，它让你可以快速查看计算机上运行的容器。Docker Dashboard 适用于 Mac 和 Windows。它使您可以快速访问容器日志，让您在容器内获得一个shell，并允许您轻松管理容器生命周期（停止，删除等）。\n若要访问仪表板，请按照 Docker 桌面手册 中的说明进行操作。如果现在打开仪表板，您将看到本教程正在运行！容器名称（见下文）是随机创建的名称。因此，您很可能会有不同的名称。jolly_bouman\n什么是容器？ What is a container? 现在您已经运行了一个容器，什么是容器？简而言之，容器是计算机上的沙盒进程，与主机上的所有其他进程隔离。这种隔离利用了内核命名空间和 cgroups，这些功能已经在 Linux 中存在了很长时间。Docker 致力于使这些功能平易近人且易于使用。总而言之，容器：\n是映像的可运行实例。您可以使用 DockerAPI 或 CLI 创建、启动、停止、移动或删除容器。 可以在本地机器、虚拟机上运行或部署到云中。 可移植（可以在任何操作系统上运行） 容器彼此隔离，并运行自己的软件、二进制文件和配置。 什么是容器映像？ What is a container image？ 运行容器时，它使用隔离的文件系统。此自定义文件系统由容器映像提供。由于映像包含容器的文件系统，因此它必须包含运行应用程序所需的一切 - 所有依赖项、配置、脚本、二进制文件等。该映像还包含容器的其他配置，例如环境变量、要运行的默认命令和其他元数据。\n稍后我们将深入探讨图像，涵盖分层、最佳实践等主题。\n第 2 部分：示例应用程序 在本教程的其余部分，我们将使用一个在 Node.js 中运行的简单待办事项列表管理器。如果您不熟悉 Node.js，请不要担心。不需要真正的 JavaScript 经验。\n在这一点上，你的开发团队非常小，你只是在构建一个应用程序来证明你的MVP（最小可行产品）。你想展示它是如何工作的，以及它能够做什么，而不需要考虑它将如何为一个大型团队、多个开发人员等工作。\n获取应用 在运行应用程序之前，我们需要将应用程序源代码获取到我们的计算机上。对于实际项目，通常会克隆存储库。但是，对于本教程，我们创建了一个包含该应用程序的 ZIP 文件。\n下载应用程序内容。您可以拉取整个项目，也可以将其下载为zip并将其解压缩出应用程序文件夹以开始使用。 提取后，使用您喜欢的代码编辑器打开项目。如果你需要一个编辑器，你可以使用Visual Studio Code。您应该看到 和 两个子目录 （ 和 ）。package.json src spec 生成应用的容器映像 为了构建应用程序，我们需要使用 .Dockerfile 只是一个基于文本的指令脚本，用于创建容器映像。如果您之前创建过 Dockerfile，您可能会在下面的 Dockerfile 中看到一些缺陷。但是，别担心。我们将介绍它们。Dockerfile\n创建一个与该文件同名的文件，该文件与包含以下内容的文件位于同一文件夹中。 # syntax=docker/dockerfile:1\rFROM node:12-alpine\rRUN apk add --no-cache python2 g++ make\rWORKDIR /app\rCOPY . .\rRUN yarn install --production\rCMD [\u0026#34;node\u0026#34;, \u0026#34;src/index.js\u0026#34;]\rEXPOSE 3000 请检查文件没有像.某些编辑器可能会自动附加此文件扩展名，这将导致下一步中的错误。 Dockerfile.txt 2. 如果尚未执行此操作，请打开终端并转到包含 的目录。现在，使用命令生成容器映像。\ndocker build -t getting-started . 此命令使用 Dockerfile 生成新的容器映像。您可能已经注意到下载了很多“图层”。这是因为我们指示构建者要从映像开始。但是，由于我们的计算机上没有该图像，因此需要下载该图像。`node:12-alpine`\r下载映像后，我们在应用程序中复制并用于安装应用程序的依赖项。该指令指定从此映像启动容器时要运行的默认命令。yarn CMD\n最后，标志标记我们的图像。只需将其视为最终图像的人类可读名称。由于我们命名了图像，因此我们可以在运行容器时引用该图像。-t getting-started\n该命令的末尾指示 Docker 应在当前目录中查找 。. docker build Dockerfile\n启动应用容器 现在我们有了一个映像，让我们运行该应用程序。为此，我们将使用该命令（还记得前面的命令吗？ docker run\n使用以下命令启动容器，并指定我们刚刚创建的映像的名称：docker run docker run -dp 3000:3000 getting-started 还记得 和 标志吗？我们在“分离”模式下（在后台）运行新容器，并在主机的端口 3000 到容器的端口 3000 之间创建映射。如果没有端口映射，我们将无法访问该应用程序。-d -p 几秒钟后，打开 Web 浏览器以 http://localhost:3000。您应该会看到我们的应用程序。 第 3 部分：更新应用程序 作为一个小的功能请求，产品团队要求我们在没有任何待办事项列表项时更改“空文本”。他们希望将其更改为以下内容：\n您还没有待办事项！在上面添加一个！ 很简单，对吧？让我们进行更改。\n更新源代码 在文件中，更新第 56 行以使用新的空文本。src/static/js/app.js - \u0026lt;p className=\u0026#34;text-center\u0026#34;\u0026gt;No items yet! Add one above!\u0026lt;/p\u0026gt;\r+ \u0026lt;p className=\u0026#34;text-center\u0026#34;\u0026gt;You have no todo items yet! Add one above!\u0026lt;/p\u0026gt; 让我们使用之前使用的相同命令构建映像的更新版本。 docker build -t getting-started . 让我们使用更新的代码启动一个新容器。 docker run -dp 3000:3000 getting-started 哎呀！您可能看到过这样的错误（ID 会有所不同）：\ndocker: Error response from daemon: driver failed programming external connectivity on endpoint laughing_burnell (bb242b2ca4d67eba76e79474fb36bb5125708ebdabd7f45c8eaf16caaabde9dd): Bind for 0.0.0.0:3000 failed: port is already allocated. 那么，发生了什么事呢？我们无法启动新容器，因为我们的旧容器仍在运行。这是因为容器正在使用主机的端口 3000，并且计算机上只有一个进程（包括容器）可以侦听特定端口。要解决此问题，我们需要删除旧容器。\n更换旧容器 要删除容器，首先需要停止该容器。一旦停止，就可以将其删除。我们有两种方法可以删除旧容器。随意选择您最熟悉的路径。\n使用 CLI 删除容器 使用命令获取容器的 ID。docker ps docker ps 使用命令停止容器。docker stop Swap out \u0026lt;the-container-id\u0026gt; with the ID from docker ps\rdocker stop \u0026lt;the-container-id\u0026gt; 容器停止后，可以使用该命令将其删除。docker rm docker rm \u0026lt;the-container-id\u0026gt; 注意\n您可以通过向命令添加“force”标志来停止和删除单个命令中的容器。例如：\ndocker rmdocker rm -f \u0026lt;the-container-id\u0026gt;\n使用 Docker 仪表板删除容器 如果打开 Docker 仪表板，只需单击两下即可删除容器！这当然比查找容器 ID 并将其删除要容易得多。\n打开仪表板后，将鼠标悬停在应用容器上，你将看到右侧显示一组操作按钮。 单击垃圾桶图标以删除容器。 确认删除，您就完成了！ 启动更新后的应用容器 现在，启动更新后的应用。 docker run -dp 3000:3000 getting-started 在 http://localhost:3000 上刷新浏览器，您应该会看到更新的帮助文本！ 回顾 虽然我们能够构建更新，但您可能已经注意到两件事：\n我们待办事项列表中的所有现有项目都不见了！这不是一个非常好的应用程序！我们很快就会讨论这个问题。 对于如此小的更改，涉及很多步骤。在即将推出的部分中，我们将讨论如何查看代码更新，而无需在每次进行更改时重新生成和启动新容器。 在谈论持久性之前，我们将快速了解如何与他人共享这些图像。\n第 4 部分：共享应用程序 现在我们已经构建了一个映像，让我们分享它！若要共享 Docker 映像，必须使用 Docker 注册表。默认注册表是 Docker Hub，是我们使用的所有映像的来源。\nDocker ID\nDocker ID 允许你访问 Docker Hub，它是世界上最大的容器映像库和社区。如果没有 Docker ID，请免费创建一个 Docker ID。\n创建存储库 若要推送映像，我们首先需要在 Docker Hub 上创建一个存储库。\n注册或登录到 Docker Hub。 单击创建存储库按钮。 对于存储库名称，请使用 。确保可见性为 。getting-startedPublic 私有仓库\n您是否知道 Docker 提供了私有存储库，允许您将内容限制为特定用户或团队？查看 Docker 定价页上的详细信息。\n点击创建按钮！ 如果您查看下面的图像，可以看到一个示例 Docker 命令。此命令将推送到此存储库。\n推送映像 在命令行中，尝试运行你在 Docker Hub 上看到的 push 命令。请注意，您的命令将使用您的命名空间，而不是“docker”。 $ docker push docker/getting-started\rThe push refers to repository [docker.io/docker/getting-started]\rAn image does not exist locally with the tag: docker/getting-started 为什么会失败？push 命令正在寻找一个名为 docker/getting-started 的映像，但没有找到一个。如果运行 ，则也不会看到一个。docker image ls\n要解决此问题，我们需要“标记”我们构建的现有映像，以便为其命名。 使用命令登录到 Docker 中心。docker login -u YOUR-USER-NAME 使用该命令为映像指定一个新名称。请务必使用您的 Docker ID 进行换出。docker tag getting-started YOUR-USER-NAME docker tag getting-started YOUR-USER-NAME/getting-started 现在再次尝试推送命令。如果要从 Docker Hub 复制值，则可以删除该部分，因为我们没有向映像名称添加标记。如果未指定标记，Docker 将使用名为 的标记。tagname latest docker push YOUR-USER-NAME/getting-started 在新实例上运行映像 现在，我们的映像已构建并推送到注册表中，让我们尝试在从未见过此容器映像的全新实例上运行我们的应用！为此，我们将使用 Play with Docker。\n打开浏览器以使用 Docker 玩游戏。 单击“登录”，然后从下拉列表中选择“docker”。 使用 Docker Hub 帐户进行连接。 登录后，单击左侧栏上的“添加新实例”选项。如果您没有看到它，请将浏览器放宽一点。几秒钟后，浏览器中将打开一个终端窗口。 5. 在终端中，启动新推送的应用。\ndocker run -dp 3000:3000 YOUR-USER-NAME/getting-started 您应该看到图像被拉下并最终启动！\n当它出现时，单击3000徽章，您应该会看到带有修改的应用程序！万岁！如果3000徽章未显示，您可以单击“打开端口”按钮并输入3000。 第 5 部分：保留数据库 如果您没有注意到，每次启动容器时，我们的待办事项列表都会被擦除干净。这是为什么呢？让我们深入了解容器的工作原理。\n容器的文件系统 当容器运行时，它将映像中的各个层用于其文件系统。每个容器还拥有自己的“暂存空间”来创建/更新/删除文件。任何更改都不会在另一个容器中看到，即使它们使用相同的映像也是如此。\n在实践中看到这一点 要查看其实际效果，我们将启动两个容器，并在每个容器中创建一个文件。您将看到的是，在一个容器中创建的文件在另一个容器中不可用。\n启动一个容器，该容器将创建一个以随机数 1 到 10000 命名的文件。ubuntu /data.txt docker run -d ubuntu bash -c \u0026#34;shuf -i 1-10000 -n 1 -o /data.txt \u0026amp;\u0026amp; tail -f /dev/null\u0026#34; 如果您对该命令感到好奇，我们将启动一个 bash shell 并调用两个命令（为什么我们有 ）。第一部分选取一个随机数并将其写入 。第二个命令是简单地监视文件以保持容器运行。\u0026amp;\u0026amp; /data.txt 验证我们是否可以通过放入容器来查看输出。为此，请打开仪表板，然后单击运行映像的容器的第一个操作。exec ubuntu\n您将看到一个在 ubuntu 容器中运行 shell 的终端。运行以下命令以查看文件的内容。之后再次关闭此终端。/data.txt cat /data.txt 如果您更喜欢命令行，则可以使用该命令执行相同的操作。需要获取容器的 ID（用于获取它）并使用以下命令获取内容。 docker exec \u0026lt;container-id\u0026gt; cat /data.txt 您应该看到一个随机数！ 现在，让我们启动另一个容器（相同的图像），我们将看到我们没有相同的文件。 docker run -it ubuntu ls / 瞧！那里没有文件！这是因为它只是被写入第一个容器的暂存空间。 继续使用该命令删除第一个容器。 docker rm -f \u0026lt;container-id\u0026gt; 容器卷 Container volumes 在前面的实验中，我们看到每个容器每次启动时都从映像定义开始。虽然容器可以创建、更新和删除文件，但当删除容器并且所有更改都与该容器隔离时，这些更改将丢失。通过 volumes，我们可以改变这一切。\nvolumes 提供了将容器的特定文件系统路径连接回主机的功能。如果装载了容器中的某个目录，则该目录中的更改也会显示在主机上。如果我们在容器重启之间挂载相同的目录，我们将看到相同的文件。\n卷主要有两种类型。我们最终将同时使用这两个卷，但我们将从命名卷开始。\n保留待办事项数据 默认情况下，待办事项应用将其数据存储在容器文件系统的 SQLite 数据库中。如果您不熟悉 SQLite，不用担心！它只是一个关系数据库，其中所有数据存储在单个文件中。虽然这不是大型应用程序的最佳选择，但它适用于小型演示。稍后我们将讨论如何将其切换到其他数据库引擎。\n由于数据库是单个文件，如果我们可以将该文件保留在主机上并使其可用于下一个容器，则它应该能够从最后一个容器中断的位置继续。通过创建一个卷并将其附加（通常称为“挂载”）到数据存储的目录，我们可以持久保存数据。当我们的容器写入文件时，它将持久保存到卷中的主机。\n如前所述，我们将使用命名卷。将命名卷视为一个数据桶。Docker 维护磁盘上的物理位置，您只需要记住卷的名称即可。每次使用卷时，Docker 都会确保提供正确的数据。\n使用该命令创建卷。\ndocker volume create todo-db 在仪表板中再次停止并删除 todo 应用容器（或使用 ），因为它仍在运行，而无需使用持久卷。\ndocker rm -f 启动 todo 应用容器，但添加标志以指定卷装入。我们将使用命名卷并将其装载到 ，这将捕获在路径中创建的所有文件。\ndocker run -dp 3000:3000 -v todo-db:/etc/todos getting-started 容器启动后，打开应用并将一些项目添加到待办事项列表。\n停止并删除待办事项应用的容器。使用仪表板或获取 ID，然后将其删除。\ndocker psdocker rm -f \u0026lt;id\u0026gt; 使用上面的相同命令启动新容器。\n打开应用。您应该会看到您的项目仍在列表中！\n签出列表后，请继续删除容器。\n深入了解 volume 很多人经常问“当我使用命名卷时，Docker 实际上在哪里存储我的数据？如果您想知道，可以使用该命令。\ndocker volume inspect docker volume inspect todo-db 是磁盘上存储数据的实际位置。请注意，在大多数计算机上，您需要具有 root 访问权限才能从主机访问此目录。但是，这就是它所在的地方！\n第 6 部分：使用绑定装载 mounts 在上一章中，我们讨论并使用命名卷来持久保存数据库中的数据。如果我们只想存储数据，命名卷非常有用，因为我们不必担心数据存储的位置。\n使用绑定挂载，我们控制主机上的确切挂载点。我们可以使用它来持久保存数据，但它通常用于向容器中提供其他数据。在处理应用程序时，我们可以使用绑定挂载将源代码挂载到容器中，让它看到代码更改，做出响应，并让我们立即看到更改。\n对于基于节点的应用程序，nodemon是监视文件更改然后重新启动应用程序的绝佳工具。在大多数其他语言和框架中都有等效的工具。\n快速卷类型比较 绑定装载和命名卷是 Docker 引擎附带的两种主要类型的卷。但是，其他卷驱动程序可用于支持其他用例（SFTP、Ceph、NetApp、S3 等）。\n比较项 命名卷 绑定挂载 主机位置 Docker 选择 由您控制 装载示例（使用-v) my-volume:/usr/local/data /path/to/data:/usr/local/data 用容器内容填充新卷 Yes No 支持卷驱动程序 Yes No 启动开发模式容器 绑定装载和命名卷是 Docker 引擎附带的两种主要类型的卷。但是，其他卷驱动程序可用于支持其他用例（SFTP、Ceph、NetApp、S3 等）。\n若要运行容器以支持开发工作流，我们将执行以下操作：\n将我们的源代码挂载到容器中 安装所有依赖项，包括“开发”依赖项 启动 nodemon 以监视文件系统更改 使用绑定挂载对于本地开发设置非常普遍。优点是开发计算机不需要安装所有生成工具和环境。只需一个命令，即可拉取开发环境并准备就绪。我们将在下一步中讨论 Docker Compose，因为这将有助于简化我们的命令（我们已经得到了很多标志）。\n第 7 部分：多容器应用 到目前为止，我们一直在使用单容器应用。但是，我们现在想将MySQL添加到应用程序堆栈中。以下问题经常出现 - “MySQL将在哪里运行？将其安装在同一容器中还是单独运行？一般来说，每个容器都应该做一件事，并且做得很好。几个原因：\n很有可能您必须以不同于数据库的方式扩展 API 和前端 单独的容器允许您隔离版本和更新版本 虽然可以在本地对数据库使用容器，但可能需要在生产环境中对数据库使用托管服务。你不希望随应用一起提供数据库引擎。 运行多个进程将需要一个进程管理器（容器仅启动一个进程），这增加了容器启动/关闭的复杂性 还有更多的原因。因此，我们将更新我们的应用程序，使其按如下方式工作：\n容器网络 请记住，默认情况下，容器是独立运行的，对同一台计算机上的其他进程或容器一无所知。那么，我们如何允许一个容器与另一个容器通信呢？答案是网络。现在，您不必成为网络工程师（万岁！只要记住这个规则\u0026hellip;\n注意\n如果两个容器位于同一网络上，它们可以相互通信。如果他们不是，他们就不能。\n启动 MySQL 有两种方法可以将容器放在网络上：1） 在开始时分配它或 2） 连接现有容器。现在，我们将首先创建网络，并在启动时附加MySQL容器。\n创建网络。\ndocker network create todo-app 启动MySQL容器并将其附加到网络。我们还将定义一些数据库将用于初始化数据库的环境变量（请参阅MySQL Docker Hub列表中的“环境变量”部分）。\ndocker run -d \\\r--network todo-app --network-alias mysql \\\r-v todo-mysql-data:/var/lib/mysql \\\r-e MYSQL_ROOT_PASSWORD=secret \\\r-e MYSQL_DATABASE=todos \\\rmysql:5.7 您还将看到我们指定了该标志。我们一会儿再回到这个问题上来。--network-alias\n提示\n您会注意到，我们正在使用此处命名的卷并将其挂载在 ，这是MySQL存储其数据的位置。但是，我们从未运行过命令。Docker 识别出我们想要使用命名卷，并自动为我们创建一个。 todo-mysql-data /var/lib/mysql docker volume create\n要确认数据库已启动并运行，请连接到数据库并验证其是否连接。\ndocker exec -it \u0026lt;mysql-container-id\u0026gt; mysql -u root -p 出现密码提示时，请键入 secret。在 MySQL 外壳中，列出数据库并验证您是否看到了该数据库。\nSHOW DATABASES; 您应看到如下所示的输出：\n+--------------------+\r| Database |\r+--------------------+\r| information_schema |\r| mysql |\r| performance_schema |\r| sys |\r| todos |\r+--------------------+\r5 rows in set (0.00 sec) 退出 MySQL shell 以返回到我们计算机上的 shell。\nexit 万岁！我们有我们的数据库，它已经准备好供我们使用！\n连接到 MySQL 现在我们知道MySQL已经启动并运行，让我们使用它！但是，问题是\u0026hellip;如何？如果我们在同一网络上运行另一个容器，我们如何找到容器（请记住每个容器都有自己的IP地址）？\n为了解决这个问题，我们将使用nicolaka/netshoot容器，它附带了许多对故障排除或调试网络问题有用的工具。\n使用 nicolaka/netshoot 映像启动新容器。确保将其连接到同一网络。\ndocker run -it --network todo-app nicolaka/netshoot 在容器中，我们将使用该命令，这是一个有用的 DNS 工具。我们将查找主机名的IP地址。\ndig mysql 你会得到这样的输出\u0026hellip;\n; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.14.1 \u0026lt;\u0026lt;\u0026gt;\u0026gt; mysql\r;; global options: +cmd\r;; Got answer:\r;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 32162\r;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\r;; QUESTION SECTION:\r;mysql.\tIN\tA\r;; ANSWER SECTION:\rmysql.\t600\tIN\tA\t172.23.0.2\r;; Query time: 0 msec\r;; SERVER: 127.0.0.11#53(127.0.0.11)\r;; WHEN: Tue Oct 01 23:47:24 UTC 2019\r;; MSG SIZE rcvd: 44 在“答案部分”中，您将看到解析为的记录（您的IP地址很可能具有不同的值）。虽然通常不是有效的主机名，但 Docker 能够将其解析为具有该网络别名的容器的 IP 地址（还记得我们之前使用的标志吗？）。\nA mysql 172.23.0.2 mysql --network-alias 这意味着\u0026hellip;我们的应用程序只需要连接到一个名为的主机，它就会与数据库通信！没有比这更简单的了\n使用 MySQL🔗 运行您的应用 待办事项应用程序支持设置一些环境变量来指定MySQL连接设置。它们是：\nMYSQL_HOST- 正在运行的 MySQL 服务器的主机名 MYSQL_USER- 用于连接的用户名 MYSQL_PASSWORD- 用于连接的密码 MYSQL_DB- 连接后要使用的数据库 通过 Env Vars 设置连接设置 虽然使用 env vars 设置连接设置通常适用于开发，但在生产环境中运行应用程序时，强烈建议不要这样做。Docker的前安全主管Diogo Monica写了一篇精彩的博客文章，解释了原因。\n更安全的机制是使用容器业务流程框架提供的机密支持。在大多数情况下，这些机密作为文件装载到正在运行的容器中。你会看到许多应用程序（包括MySQL图像和todo应用程序）也支持带有后缀的env vars，以指向包含变量的文件。\n例如，设置 var 将导致应用使用引用文件的内容作为连接密码。Docker 不做任何事情来支持这些 env vars。你的应用需要知道查找变量并获取文件内容。\n解释完所有这些，让我们开始我们的开发就绪容器！\n注意：对于MySQL版本8.0及更高版本，请确保在 中包含以下命令\nALTER USER \u0026#39;root\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;secret\u0026#39;;\rflush privileges; 我们将指定上述每个环境变量，并将容器连接到我们的应用网络。\ndocker run -dp 3000:3000 \\\r-w /app -v \u0026#34;$(pwd):/app\u0026#34; \\\r--network todo-app \\\r-e MYSQL_HOST=mysql \\\r-e MYSQL_USER=root \\\r-e MYSQL_PASSWORD=secret \\\r-e MYSQL_DB=todos \\\rnode:12-alpine \\\rsh -c \u0026#34;yarn install \u0026amp;\u0026amp; yarn run dev\u0026#34; 如果您使用的是Windows，请在PowerShell中使用此命令。\nPS\u0026gt; docker run -dp 3000:3000 `\r-w /app -v \u0026#34;$(pwd):/app\u0026#34; `\r--network todo-app `\r-e MYSQL_HOST=mysql `\r-e MYSQL_USER=root `\r-e MYSQL_PASSWORD=secret `\r-e MYSQL_DB=todos `\rnode:12-alpine `\rsh -c \u0026#34;yarn install \u0026amp;\u0026amp; yarn run dev\u0026#34; 如果我们查看容器的日志（），我们应该看到一条消息，指示它正在使用mysql数据库。docker logs nodemon src/index.js 在浏览器中打开应用程序，并将一些项目添加到待办事项列表中。\n连接到 mysql 数据库并证明项目正在写入数据库。请记住，密码是秘密的。\ndocker exec -it \u0026lt;mysql-container-id\u0026gt; mysql -p todos 在 mysql shell 中，运行以下命令：\nselect * from todo_items; 显然，您的桌子看起来会有所不同，因为它有您的物品。但是，您应该看到它们存储在那里！\n如果你快速浏览一下 Docker 仪表板，就会发现我们有两个应用容器正在运行。但是，没有真正的迹象表明它们在单个应用程序中组合在一起。我们很快就会看到如何让它变得更好！\n使用 Docker Compose Docker Compose 是一个工具，旨在帮助定义和共享多容器应用程序。使用Compose，我们可以创建一个YAML文件来定义服务，并且使用单个命令，可以启动所有内容或将其全部拆除。\n使用 Compose 的最大优点是，您可以在文件中定义应用程序堆栈，将其保留在项目存储库的根目录下（现在受版本控制），并轻松使其他人能够为您的项目做出贡献。有人只需要克隆你的存储库并启动撰写应用。事实上，你可能会看到GitHub/GitLab上有相当多的项目正在这样做。\n那么，我们该如何开始呢？\n"},{"id":393,"href":"/Tech/8IDE/Docker/DockerDocs/DockerDocs/","title":"Docker Docs","parent":"DockerDocs","content":" Docker Docs 转自：Docker 官网\n链接：https://docs.docker.com/get-started/overview/\nDocker 概述 "},{"id":394,"href":"/Tech/8IDE/Git/Git-%E5%91%BD%E4%BB%A4/Git-%E5%91%BD%E4%BB%A4/","title":"Git 命令","parent":"Git 命令","content":" Git 命令 创建存储库 # 创建一个新的本地存储库\r$ git init [项目名称]\r# 克隆存储库\r$ git clone \u0026lt;git 仓库 url 地址\u0026gt;\r# 将存储库克隆到指定目录\r$ git clone \u0026lt;git 仓库 url 地址\u0026gt; \u0026lt;我的文件夹\u0026gt; 配置 # 设置将附加到您的提交(commit)和标签(tags)的名称\r$ git config --global user.name \u0026#34;name\u0026#34;\r# 设置将附加到您的提交(commit)和标签(tags)的电子邮件地址\r$ git config --global user.email \u0026#34;email\u0026#34;\r# 启用 Git 输出的一些着色\r$ git config --global color.ui auto\r# 在文本编辑器中编辑全局配置文件\r$ git config --global --edit 变更 # 在工作目录中显示修改后的文件，为您的下一次提交暂存\r$ git status\r# 暂存文件，准备提交\r$ git add [file]\r# 暂存所有更改的文件，准备提交\r$ git add .\r# 将所有暂存文件提交到版本化历史记录\r$ git commit -m \u0026#34;commit message\u0026#34;\r# 将所有跟踪的文件提交到版本化历史记录\r$ git commit -am \u0026#34;commit message\u0026#34;\r# 取消暂存文件，保留文件更改\r$ git reset [file]\r# 将所有内容恢复到最后一次提交\r$ git reset --hard\r# 已更改但未暂存（ staged ）的内容的差异\r$ git diff\r# 已暂存（ staged ）但尚未提交的内容的差异\r$ git diff --staged\r# 在指定之前应用当前分支的任何提交\r$ git rebase [branch] 分支 # 列出所有本地分支\r$ git branch\r# 列出所有分支，本地和远程\r$ git branch -av\r# 切换到 my_branch ，并更新工作目录\r$ git checkout my_branch\r# 创建一个名为 new_branch 的新分支\r$ git checkout -b new_branch\r# 删除名为 my_branch 的分支\r$ git branch -d my_branch\r# 将 branchA 分支合并到 branchB 分之上\r$ git checkout branchB\r$ git merge branchA\r# 标记当前提交\r$ git tag my_tag\r# 重命名为 new_name\r$ git branch -m \u0026lt;new_name\u0026gt;\r# 推送和重置\r$ git push origin -u \u0026lt;new_name\u0026gt;\r# 删除远程分支\r$ git push origin --delete \u0026lt;old\u0026gt; 观察存储库 # 显示当前活动分支的提交历史\r$ git log\r# 显示 branchA 上不在 branchB 上的提交\r$ git log branchB..branchA\r# 显示更改文件的提交，即使重命名\r$ git log --follow [file]\r# 显示 branchA 中的内容与 branchB 中的差异\r$ git diff branchB...branchA\r# 在 Git 中以 人类可读 格式显示任何对象\r$ git show [SHA]\r# 按内容搜索更改\r$ git log -S\u0026#39;\u0026lt;a term in the source\u0026gt;\u0026#39;\r# 显示特定文件随时间的变化\r$ git log -p \u0026lt;file_name\u0026gt;\r# 打印出很酷的日志可视化\r$ git log --pretty=oneline --graph --decorate --all 同步 # 从该 Git 远程获取所有分支\r$ git fetch [alias]\r# 将远程分支合并到当前分支以使其保持最新状态\r$ git merge [alias]/[branch]\rNo fast-forward\r$ git merge --no-ff [alias]/[branch]\rOnly fast-forward\r$ git merge --ff-only [alias]/[branch]\r# 将本地分支提交传输到远程存储库分支\r$ git push [alias] [branch]\r# 从跟踪远程分支获取并合并任何提交\r$ git pull\r# 将另一个分支的一个特定提交合并到当前分支\r$ git cherry-pick [commit_id] 远程 # 添加一个 git URL 作为别名(alias)\r$ git remote add [alias] [url]\r# 显示您设置的远程存储库的名称\r$ git remote\r# 显示远程存储库的名称和 URL\r$ git remote -v\r# 删除远程存储库\r$ git remote rm [remote repo name]\r# 更改 git repo 的 URL\r$ git remote set-url origin [git_url] 临时提交 # 保存已修改和分阶段的更改\r$ git stash\r# 列出隐藏文件更改的堆栈顺序\r$ git stash list\r# 从存储堆栈顶部编写工作\r$ git stash pop\r# 丢弃存储堆栈顶部的更改\r$ git stash drop 跟踪路径更改 # 从项目中删除文件并暂存删除以进行提交\r$ git rm [file]\r# 更改现有文件路径并暂存移动\r$ git mv [existing-path] [new-path]\r# 显示所有提交日志，并指示任何移动的路径\r$ git log --stat -M 忽略文件 .gitignore 文件指定了 Git 应该忽略的故意未跟踪的文件\n/logs/*\r# \u0026#34;!\u0026#34; 意思是不要忽视\r!logs/.gitkeep\r# 忽略 Mac 系统文件\r.DS_store\r# 忽略 node_modules 文件夹\rnode_modules\r# 忽略 SASS 配置文件\r.sass-cache 分支 # 列出所有分支及其上游\r$ git branch -vv # 快速切换到上一个分支\r$ git checkout -\r# 只获取远程分支\r$ git branch -r\r# 从另一个分支签出单个文件\r$ git checkout \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt; "},{"id":395,"href":"/Tech/8IDE/Git/IDEA-Git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/","title":"ID Ea Git 配置代理","parent":"Git","content":"IDEA Git 配置代理\nidea需要git操作的这样配置代理，在当前项目目录进入命令行：\n配置全局参数：\u0026ndash;global\n全局代理命令 ：git config \u0026ndash;global http.proxy http://127.0.0.1:7890 代理命令 ：git config http.proxy http://127.0.0.1:7890 全局取消代理： git config \u0026ndash;global \u0026ndash;unset http.proxy 取消代理： git config \u0026ndash;unset http.proxy 全局查询是否使用：git config \u0026ndash;global http.proxy 查询是否使用：git config http.proxy\n"},{"id":396,"href":"/Tech/8IDE/Git/Pro-Git-Simple/Pro-Git-Simple-1-%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6/","title":"Pro Git Simple 1 分支和合并","parent":"Pro Git  Simple","content":" Pro Git Simple-1-分支和合并 "},{"id":397,"href":"/Tech/8IDE/Git/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%A3%80%E5%87%BA%E5%AE%A1%E6%A0%B8%E5%92%8C%E5%90%88%E5%B9%B6/","title":"合并冲突：在本地检出、审核和合并","parent":"Git","content":"第 1 步. 获取并查看此合并请求的分支\ngit fetch origin\rgit checkout -b \u0026#34;feature-快递停发\u0026#34; \u0026#34;origin/feature-快递停发\u0026#34; 第 2 步. 在本地查看更改 第 3 步. 合并分支并解决出现的任何冲突\ngit fetch origin\rgit checkout \u0026#34;test\u0026#34;\rgit merge --no-ff \u0026#34;feature-快递停发\u0026#34; 第 4 步. 将合并结果推送到GitLab\ngit push origin \u0026#34;test\u0026#34; "},{"id":398,"href":"/Tech/8IDE/Git/%E6%82%A8%E7%9A%84%E6%9C%AC%E5%9C%B0-Git-%E6%8F%90%E4%BA%A4%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%9C%AA%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%82%A8%E7%9A%84%E5%B8%90%E6%88%B7/","title":"您的本地 Git 提交电子邮件地址未连接到您的帐户","parent":"Git","content":"在 Git 中设置您的提交电子邮件地址 您可以使用 git config 命令更改与 Git 提交关联的电子邮件地址。 您设置的新电子邮件地址将在从命令行推送到 GitHub.com 的任何未来提交中显示。 在您更改提交电子邮件地址之前进行的任何提交仍与之前的电子邮件地址关联。\n为计算机上的每个仓库设置电子邮件地址 打开 Git Bash。 在 Git 中设置电子邮件地址。 您可以使用 GitHub 提供的 no-reply 电子邮件地址或任何电子邮件地址。 $ git config \u0026ndash;global user.email \u0026ldquo;email@example.com\u0026rdquo; 确认在 Git 中正确设置了电子邮件地址： $ git config \u0026ndash;global user.email email@example.com 将电子邮件地址添加到您在 GitHub 上的帐户，以便您的提交归因于您并且出现在您的贡献图中。 更多信息请参阅“添加电子邮件地址到 GitHub 帐户”。\n"},{"id":399,"href":"/Tech/8IDE/Linux/CentOS-7-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/","title":"Cent Os 7 开发环境部署","parent":"Linux","content":"=======================================================================================================================================================================================\n查看安装 rpm -aq| grep postgres\n查看启动 ps -ax | grep postgres\n列出所有端口 netstat -ntlp\nmkdir /usr/pgsql-10/data\nchown postgres /usr/pgsql-10/data\nCREATE USER finley WITH PASSWORD \u0026lsquo;password\u0026rsquo;;\nALTER USER postgres WITH PASSWORD \u0026lsquo;password\u0026rsquo;\npsql mydb -U finley\n============================================================================================ CentOS 7 开发环境部署 =================================================================\nCentOS 7的网络配置以及设置主机名和绑定IP的问题\n说明：截止目前CentOS 7.x最新版本为CentOS 7.0-1804，下面介绍CentOS 7.0的具体安装配置过程\r前置工作 VMware 设置 1、点击工具栏：编辑（E） 2、点击：虚拟网络编辑器 3、点击：更改设置（需具备管理员权限） 4、点击条目：VNnet8 5、取消勾选：使用本地DHCP服务奖IP地址分配给虚拟机（D） 6、修改：子网IP（I）：192.168.2.0 子网掩码（M）：255.255.255.0 7、点击：NAT设置（S） 8、修改：网关IP（G）：192.168.2.2 #下方的 端口转发（F）：可在实现虚拟机的端口穿透功能。 9、将虚拟机的 网络适配器 选择 NAT模式。 win系统的网络适配器设置 将 VMware Neteork Adapter VMnet8 设置为固定IP：192.168.2.1 子网掩码（M）：255.255.255.0\n进入登录界面\n账号输入root 回车\r再输入上面设置的root密码回车\r系统登录成功\r设置IP地址、网关DNS ip addr\t#显示网卡信息 ping 127.0.0.1 #看网卡是否是好的\n说明：CentOS 7.0默认安装好之后是没有自动开启网络连接的！\rcd /etc/sysconfig/network-scripts/ #进入网络配置文件目录\rvi ifcfg-ens33 #编辑配置文件，添加修改以下内容\ri #进入修改\rHWADDR=00:0C:29:8D:24:73\rTYPE=Ethernet BOOTPROTO=static #启用静态IP地址 DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes\rIPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no NAME=eno16777736 UUID=ae0965e7-22b9-45aa-8ec9-3f0a20a85d11 ONBOOT=yes #开启自动启用网络连接 IPADDR=192.168.2.100 #设置IP地址 NETMASK=255.255.255.0 #设置子网掩码 GATEWAY0=192.168.2.2 #设置网关 DNS1=8.8.8.8 #设置主DNS DNS2=8.8.4.4 #设置备DNS :wq! #保存退出 service network restart #重启网络 ping www.baidu.com #测试网络是否正常\rip addr #查看IP地址\r设置主机名为www\rhostname www #设置主机名为www\rvi /etc/hostname #编辑配置文件\rwww #修改localhost.localdomain为www\r:wq! #保存退出\rvi /etc/hosts #编辑配置文件\r127.0.0.1 localhost www #修改localhost.localdomain为www\r:wq! #保存退出\rshutdown -r now #重启系统\r================================================================ 更新ContOS ============================================================== 阿里镜像网站地址 https://opsx.alibaba.com/mirror\n安装wget\ryum -y install wget\r添加阿里云镜像\rwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r在CentOS 7下更改yum源与更新系统。\r[1] 首先备份/etc/yum.repos.d/CentOS-Base.repo\rcp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\r[2] 进入yum源配置文件所在文件夹\r[root@localhost yum.repos.d]# cd /etc/yum.repos.d/\r[3] 下载163的yum源配置文件，放入/etc/yum.repos.d/(操作前请做好相应备份)\r[root@localhost yum.repos.d]# wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo\r[4] 运行yum makecache生成缓存\r[root@localhost yum.repos.d]# yum makecache\r[5] 更新系统(时间比较久,主要看个人网速)\r[root@localhost yum.repos.d]# yum -y update\r[6] 安装vim编辑器\r[root@localhost ~]# yum -y install vim*\r================================================================ 安装 MySQL\t============================================================ mysql -u root -p vHGnmre56l)_w%\nsa\t5dsfGGhfdl)_w%\tCRUD@%\radmin\td12h.Po(_f\tALL@%\rroot\tvHGnmre56l)_w%\tALL@localhost\tcustomer\t5sfR3o3_osfdl)_w%\tCRUD+CD@%\rdts\t5sfR3o3_osfdl)_w%\tCRUD+CD@%\r使用yum 命令更新MySQL\tyum update mysql-server\r使用yum 命令安装MySQL\r查看有没有安装包:\ryum list installed | grep mysql\r如果有，就先全部卸载，命令如下：\tyum -y remove mysql-libs.x86_64\ryum remove mysql mysql-server mysql-libs compat-mysql80\rrm -rf /var/lib/mysql\rrm /etc/my.cnf\rrm /var/log/mysqld.log\r查看是否还有mysql软件:\trpm -qa | grep mysql\r如果有，就先全部卸载，命令如下：\trpm -e mysql　// 普通删除模式\rrpm -e --nodeps mysql　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除\r安装 MySQL：\r下载 MySQL Yum Repository\r下载地址为：https://dev.mysql.com/downloads/repo/yum/\rwget https://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm\r添加 MySQL Yum Repository\r添加 MySQL Yum Repository 到你的系统 repository 列表中，执行:\ryum localinstall mysql80-community-release-el7-1.noarch.rpm\r验证下是否添加成功\ryum repolist enabled | grep \u0026quot;mysql.*-community.*\u0026quot;\r/*\r可以看到下面内容：\r[root@bogon software]# yum repolist enabled | grep \u0026quot;mysql.*-community.*\u0026quot;\rmysql-connectors-community/x86_64 MySQL Connectors Community 1\rmysql-tools-community/x86_64 MySQL Tools Community 1\rmysql56-community/x86_64 MySQL 5.6 Community Server 13\r*/\r选择要启用 MySQL 版本\r查看 MySQL 版本，执行\ryum repolist all | grep mysql\r可以通过类似下面的语句来启动某些版本\r/*\ryum-config-manager --disable mysql56-community\ryum-config-manager --enable mysql57-community-dmr\r或者通过修改 /etc/yum.repos.d/mysql-community.repo 文件\r# Enable to use MySQL 5.6\r[mysql56-community]\rname=MySQL 5.6 Community Server\rbaseurl=http://repo.mysql.com/yum/mysql-5.6-community/el/7/$basearch/\renabled=1\rgpgcheck=1\rgpgkey=file:/etc/pki/rpm-gpg/RPM-GPG-KEY-mysql\r其中 enabled=0 是指禁用，enabled=1 指启用。\r注意： 任何时候，只能启用一个版本。\r执行\ryum repolist enabled | grep mysql\r查看当前的启动的 MySQL 版本\r[root@bogon software]# yum repolist enabled | grep mysql\rmysql-connectors-community/x86_64 MySQL Connectors Community 14\rmysql-tools-community/x86_64 MySQL Tools Community 17\rmysql56-community/x86_64 MySQL 5.6 Community Server 139\r*/\r通过 Yum 来安装 MySQL\ryum install mysql-community-server 验证 MySQL 安装\rwhereis mysql\rmysqladmin --version\r可以看到 MySQL 的安装目录是 /usr/bin/\r[root@localhost ~]# whereis mysql\rmysql: /usr/bin/mysql /usr/lib64/mysql /usr/share/mysql /usr/share/man/man1/mysql.1.gz\t方式（1）：（这个方法好像不行啊！！！！）\r初始化 MySQL：\rmysqld --initialize\rMysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码：（好像不行啊！！！！）\rmysqladmin -u root password \u0026quot;vHGnmre56l)_w%\u0026quot;;\r通过以下命令来连接到Mysql服务器：\r[root@host]# mysql -u root -p\rEnter password:*******\t方式（2）：\rservice mysqld start\rservice mysqld status\rgrep 'temporary password' /var/log/mysqld.log\r在服务器初始启动时，如果服务器的数据目录为空，则会发生以下情况：\r服务器已初始化。\rSSL证书和密钥文件在数据目录中生成。\rvalidate_password 已安装并已启用。\r将'root'@'localhost创建一个超级用户帐户。设置超级用户的密码并将其存储在错误日志文件中。要显示它，请使用以下命令：\rgrep 'temporary password' /var/log/mysqld.log\r/*\rA temporary password is generated for root@localhost: vHrs77dl)_w%\r*/\t通过使用生成的临时密码登录并为超级用户帐户设置自定义密码，尽快更改root密码：\rshell\u0026gt; mysql -uroot -p\rmysql\u0026gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'vHGnmre56l)_w%';\r注意\rvalidate_password 默认安装。实现的默认密码策略validate_password要求密码包含至少一个大写字母，一个小写字母，一个数字和一个特殊字符，并且密码总长度至少为8个字符。\r至此，整个 MySQL 安装完成！！！\r防火墙设置\t执行\rfirewall-cmd --permanent --zone=public --add-port=3306/tcp\rfirewall-cmd --permanent --zone=public --add-port=3306/udp\r这样就开放了相应的端口。\r执行\rfirewall-cmd --reload 使最新的防火墙设置规则生效。\r启动和关闭 MySQL Server\r启动 MySQL Server\rsystemctl start mysqld\r查看 MySQL Server 状态\rsystemctl status mysqld\r关闭 MySQL Server\rsystemctl stop mysqld\t重启 MySQL Server\rservice mysqld restart\r测试是否安装成功\rmysql\r远程访问设置\r1、创建一个普通用户 sa ，密码是 5dsfGGhfdl)_w%\rCREATE USER 'sa'@'%' IDENTIFIED BY '5dsfGGhfdl)_w%';\r给这个用户授予 SELECT,INSERT,UPDATE,DELETE 的远程访问的权限，这个账号一般用于提供给实施的系统访问\rGRANT SELECT,INSERT,UPDATE,DELETE ON *.* TO 'sa'@'%';\t2、创建一个管理员用户 admin 账号 ，密码是 d12h.Po(_f\rCREATE USER 'admin'@'%' IDENTIFIED BY 'd12h.Po(_f';\r给这个用户授予所有的远程访问的权限。这个用户主要用于管理整个数据库、备份、还原等操作。\rGRANT ALL ON *.* TO 'admin'@'%';\r3、创建一个普通用户 customer ，密码是 5sfR3o3_osfdl)_w%\rCREATE USER 'customer'@'%' IDENTIFIED BY '5sfR3o3_osfdl)_w%';\r给这个用户授予 SELECT,INSERT,UPDATE,DELETE,CREATE,DROP 的远程访问的权限，这个账号一般用于提供给实施的系统访问\rGRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON *.* TO 'customer'@'%';\r使授权立刻生效\rflush privileges;\r开机自起(貌似会自动开机自启！！！)（下面的命令有问题）\r查看 MySQL 服务是否开机启动\r[root@localhost ~]# systemctl is-enabled mysql.service;echo $?\renabled\r0\r如果是 enabled 则说明是开机自动，如果不是，执行\rchkconfig --levels 235 mysqld on\rLinux MySQL 几个重要 的目录\r数据库目录 /var/lib/mysql/\r配置文件 /usr/share /mysql（mysql.server命令及配置文件）\r相关命令 /usr/bin（mysqladmin mysqldump等命令）\r启动脚本 /etc/rc.d/init.d/（启动脚本文件mysql的目录）\rdatadir=/var/lib/mysql\rsocket=/var/lib/mysql/mysql.sock\rlog-error=/var/log/mysqld.log\rpid-file=/var/run/mysqld/mysqld.pid\t设置字符集\r一般的，为了支持中文，我们应该讲字符集设为 UTF-8， 执行\rSHOW VARIABLES LIKE 'character%';\r查看当前 MySQL 字符集\rmysql\u0026gt; SHOW VARIABLES LIKE 'character%';\t设置\rvi /etc/my.cnf\r添加：\r[mysqld] character_set_server = utf8\r=============================================================== JDK安装： ================================================================\nJDK安装： 一：解压安装 cd /usr/local/src\ntar -zxvf jdk-9.0.4_linux-x64_bin.tar.gz\r或\r％tar zxvf jdk-8uversion-linux-x64.tar.gz\r二：设置环境变量 [root@localhost java]# vi /etc/profile 在profile中添加如下内容:\n#set java environment\rJAVA_HOME=/usr/local/src/jdk1.8.0_181\rJRE_HOME=/usr/local/src/jdk1.8.0_181/jre\rCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\rPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\rexport JAVA_HOME JRE_HOME CLASS_PATH PATH\r让修改生效:\r[root@localhost java]# source /etc/profile\r三：验证JDK有效性\n[root@localhost java]# java -version\rjava version \u0026quot;1.7.0_79\u0026quot;\rJava(TM) SE Runtime Environment (build 1.7.0_79-b15)\rJava HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)\r=============================================================== TomCat9 ================================================================\nTomCat安装： 一：解压安装 cd /usr/local/src\ntar -zxvf apache-tomcat-9.0.10.tar.gz 二：防火墙设置 执行 firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=8080/tcp firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=8080/udp 这样就开放了相应的端口。\n执行\rfirewall-cmd --reload 使最新的防火墙设置规则生效。\r列出所有端口\rnetstat -ntlp\r查看Nginx是否运行\rps -ax | grep Nginx\r=============================================================== Nginx ================================================================\n安装依赖 yum install gcc yum install pcre-devel yum install zlib zlib-devel yum install openssl openssl-devel //一键安装上面四个依赖 yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel\n下载nginx的tar包\n//创建一个文件夹\rcd /usr/local\rmkdir nginx\rcd nginx\r//下载tar包\rwget http://nginx.org/download/nginx-1.13.7.tar.gz\rtar -zxvf nginx-1.13.7.tar.g\r安装nginx //进入nginx目录 cd /usr/local/nginx //执行命令 ./configure //执行make命令 make //执行make install命令 make install\nNginx常用命令\n启动命令\r[root@bogon sbin]# cd /usr/local/nginx/sbin/\r[root@bogon sbin]# ./nginx 查看进程命令\rps -ef | grep nginx\r创建 Nginx 运行使用的用户 www：\r[root@bogon conf]# /usr/sbin/groupadd www [root@bogon conf]# /usr/sbin/useradd -g www www\r配置nginx.conf /usr/local/nginx/conf/nginx.conf\rNginx 其他命令:\r一旦nginx启动，就可以通过调用带有-s参数的可执行文件来控制它。使用以下语法：\r/usr/local/nginx/sbin/nginx -t # 检查配置文件ngnix.conf的正确性命令\r/usr/local/nginx/sbin/nginx -s reload # 重新载入配置文件\r/usr/local/nginx/sbin/nginx -s reopen # 重启 Nginx\rkill -HUP Nginx主进程号\t# 平滑重启\r/usr/local/nginx/sbin/nginx -s quit # 优雅停止 Nginx\r/usr/local/nginx/sbin/nginx -s stop # 停止 Nginx\r/usr/local/nginx/sbin/nginx -v\t# Nginx 版本号_验证安装\r配置防火墙 //打开防火墙文件 sudo vim /etc/sysconfig/iptables //新增行 开放80端口 -A INPUT -p tcp -m state \u0026ndash;state NEW -m tcp \u0026ndash;dport 80 -j ACCEPT //保存退 //重启防火墙 sudo service iptables restart\nfirewall-cmd --permanent --zone=public --add-port=80/tcp\rfirewall-cmd --permanent --zone=public --add-port=80/udp\r执行\rfirewall-cmd --reload 使最新的防火墙设置规则生\r列出所有端口\rnetstat -ntlp\r查看Nginx是否运行\rps -ax | grep nginx\rNginx虚拟域名配置及测试验证\n//编辑nginx.conf\rsudo vi /usr/local/nginx/conf/nginx.conf\r//增加行 include vhost/*.conf\r//保存退出\r//在/usr/local/nginx/conf目录新建vhost文件夹\rmkdir vhost\r//创建每个域名的配置\rsudo vim jimisun.com.conf\r//节点中增加入响应的配置 端口转发 或者访问文件系统\rNginx启动 //进入nginx安装目录 cd sbin sudo ./nginx 测试访问 http://ip地址\n=============================================================== redis ================================================================\ntar -zxvf redis-4.0.11.tar.gz cd redis-4.0.11\rmake\rcd src\rcd /usr/local/src/redis-4.0.11/src\r./usr/local/src/redis-4.0.11/src/redis-server /usr/local/src/redis-4.0.11/redis.conf\r./usr/local/src/redis-4.0.11/src/redis-cli\r./redis-server redis.conf\t#redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。\r./redis-cli\rset foo bar\rget foo\rfirewall-cmd --permanent --zone=public --add-port=6379/tcp\rfirewall-cmd --permanent --zone=public --add-port=6379/udp\rfirewall-cmd --reload 使最新的防火墙设置规则生\r设置主从\rslaveof 192.168.2.100 6379\rmasterauth aB(D2f9\r查看redis是否运行\tps -ax | grep redis\rredis设置密码访问\rvi /redis-4.0.11/redis.conf\r#requirepass foobared去掉注释，foobared改为自己的密码，我在这里改为\rrequirepass aB(D2f9\r#后台运行\rdaemonize yes\rauth aB(D2f9\rredis启动\r./usr/local/src/redis-4.0.11/src/redis-server /usr/local/src/redis-4.0.11/redis.conf\rredis关闭\rpkill redis\r=============================================================== MongoDB ================================================================ MongoDB\nfirewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=27017/tcp\n查看 mongod 是否运行 ps -ax | grep mongod ps -ef | grep mongod\nwhereis mongod\n利用阿里云的源yum方式安装Mongodb 1）在/etc/yum.repos.d 创建一个mongodb-org.repo 源文件 [root@qd-vpc-dev-op01 ~]$ cd /etc/yum.repos.d/ [root@qd-vpc-dev-op01 yum.repos.d]$ touch mongodb-org.repo [root@qd-vpc-dev-op01 yum.repos.d]$ cat mongodb-org.repo\n[mongodb-org]\rname=MongoDB Repository\rbaseurl=https://mirrors.aliyun.com/mongodb/yum/redhat/7Server/mongodb-org/4.1/x86_64/\rgpgcheck=0\renabled=1\r或\r[mongodb-org-4.0]\rname=MongoDB Repository\rbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.0/x86_64/\rgpgcheck=1\renabled=1\rgpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc\r2）清空缓存和更新yum源 [root@qd-vpc-dev-op01 yum.repos.d]$ yum clean all [root@qd-vpc-dev-op01 yum.repos.d]$ yum makecache #更新yum源 [root@qd-vpc-dev-op01 yum.repos.d]$ yum update\n安装MongoDB [root@qd-vpc-dev-op01 yum.repos.d]$ yum install -y mongodb-org 或 yum install -y mongodb-enterprise\n启动MongoDB [root@localhost ~]# service mongod start Redirecting to /bin/systemctl start mongod.service\n或\nmongod \u0026ndash;auth \u0026ndash;port 27017 \u0026ndash;dbpath /var/lib/mongo -f /etc/mongod.conf -fork\n[root@localhost ~]# ps -ef | grep mongod mongod 24960 1 1 23:43 ? 00:00:00 /usr/bin/mongod -f /etc/mongod.conf root 24989 24056 0 23:43 pts/0 00:00:00 grep \u0026ndash;color=auto mongod 查看mongo状态 systemctl status mongod.service\n停止MongoDB [root@localhost ~]# service mongod stop\n重启MongoDB\nsudo service mongod restart\n开始使用MongoDB\nmongo \u0026ndash;host 127.0.0.1:27017\n在连接期间进行身份验证 mongo \u0026ndash;host 127.0.0.1:27017 -u \u0026ldquo;admin\u0026rdquo; -p \u0026ldquo;148895\u0026rdquo; \u0026ndash;authenticationDatabase \u0026ldquo;admin\u0026rdquo;\n开机自启\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-安装完就是开机自启不要执行这个命令 [root@localhost ~]# chkconfig mongod on\n安全 use admin; db.createUser({user: \u0026lsquo;admin\u0026rsquo;, pwd: \u0026lsquo;148895\u0026rsquo;, roles: [{role: \u0026lsquo;userAdminAnyDatabase\u0026rsquo;, db: \u0026lsquo;admin\u0026rsquo;}]}) db.auth(\u0026lsquo;admin\u0026rsquo;, \u0026lsquo;148895\u0026rsquo;)\t#输出 1 表示验证成功 db.createCollection(\u0026ldquo;myAdmincollection\u0026rdquo;) db.myAdmincollection.insert({ _id: 100, title: \u0026lsquo;MongoDB Overview\u0026rsquo;, description: \u0026lsquo;MongoDB is no sql database\u0026rsquo;, by: \u0026lsquo;yiibai tutorials\u0026rsquo;, url: \u0026lsquo;http://www.yiibai.com\u0026rsquo;, tags: [\u0026lsquo;mongodb\u0026rsquo;, \u0026lsquo;database\u0026rsquo;, \u0026lsquo;NoSQL\u0026rsquo;], likes: 100, }) show collections db.myAdmincollection.find().pretty()\nuse test;\rdb.createUser(\r{\ruser: \u0026quot;myTester\u0026quot;,\rpwd: \u0026quot;xyz123\u0026quot;,\rroles: [ { role: \u0026quot;readWrite\u0026quot;, db: \u0026quot;test\u0026quot; },\r{ role: \u0026quot;read\u0026quot;, db: \u0026quot;reporting\u0026quot; } ]\r}\r)\rshow collections\rdb.auth('myTester', 'xyz123')\rdb.createUser(\r{\ruser: \u0026quot;dts\u0026quot;,\rpwd: \u0026quot;123456\u0026quot;,\rroles: [ { role: \u0026quot;readWrite\u0026quot;, db: \u0026quot;mongo_oms_api\u0026quot; },\r{ role: \u0026quot;readWrite\u0026quot;, db: \u0026quot;oms_api_log\u0026quot;,\r{ role: \u0026quot;readWrite\u0026quot;, db: \u0026quot;platform_task_info\u0026quot;,\r{ role: \u0026quot;readWrite\u0026quot;, db: \u0026quot;platform_task_error\u0026quot; } ]\r}\r)\rdb.auth('dts', '123456')\rmongod --auth --port 27017 --dbpath /var/lib/mongo\r#启动命令\r./bin/mongod -f /etc/mongod.conf --auth\r#启动命令\r/*\r如果/etc/mongod.conf已经做了如下配置，就不用添加 --auth\rsecurity:\rauthorization: enabled\r*/\t./bin/mongod -f /etc/mongod.conf #关闭命令\r./bin/mongod --shutdown -f /etc/mongod.conf --auth\rdb.createCollection(\u0026quot;mycollection\u0026quot;)\rshow collections\rdb.mycollection.insert({\r_id: 100,\rtitle: 'MongoDB Overview', description: 'MongoDB is no sql database',\rby: 'yiibai tutorials',\rurl: 'http://www.yiibai.com',\rtags: ['mongodb', 'database', 'NoSQL'],\rlikes: 100,\r})\rdb.mycollection.find().pretty()\ruse test\rdb.createUser(\r{\ruser: \u0026quot;simpleUser\u0026quot;,\rpwd: \u0026quot;simplePass\u0026quot;,\rroles: [{ role: \u0026quot;readWrite\u0026quot;, db: \u0026quot;test\u0026quot; }}]\r}\r)\rmongo \u0026ndash;port 27017 -u \u0026ldquo;adminUser\u0026rdquo; -p \u0026ldquo;adminPass\u0026rdquo; \u0026ndash;authenticationDatabase \u0026ldquo;admin\u0026rdquo;\n命令 show dbs\t#显示数据库大小情况 db\t#显示当前数据库 三、URI 形式的访问 生产中常用 URI 形式对数据库进行连接\nmongodb://your.db.ip.address:27017/foo\r添加用户名密码验证\rmongodb://simpleUser:simplePass@your.db.ip.address:27017/foo\r四、卸载\n4.1 关闭服务\rservice mongod stop\r4.2 删除相关的包\ryum erase $(rpm -qa | grep mongodb-org)\r4.3 删除目录和文件\rrm -r /var/log/mongodb\rrm -r /var/lib/mongo\t=============================================================== zookeeper ================================================================\ntar -zxvf zookeeper-3.4.13.tar.gz\n开启防火墙端口 firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=2181/tcp firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=2888/tcp firewall-cmd \u0026ndash;permanent \u0026ndash;zone=public \u0026ndash;add-port=3888/tcp\n创建数据和日志文件夹 cd /tmp/zookeeper\n//cd /usr/local/zookeeper-3.4.6 mkdir data mkdir logs\n将zookeeper目录下conf下的zoo_sample.cfg拷贝一份，命名为zoo.cfg cp zoo_sample.cfg zoo.cfg 6.配置集群服务器 server.1=192.168.2.100:2888:3888\t//其中2888是zookeeper服务之间通信的端口；3888是zookeeper与其他应用程序通信端口 server.2=192.168.2.101:2888:3888 server.3=192.168.2.102:2888:3888\n在上面创建的／home/www/zookeeper-3.4.8/data下创建myid文件,并在其中写入对应的ip的机器的编号（上面的server.1）中的1 vi myid 1 8、启动 zookeeper 服务： ./zkServer.sh start 如打印如下信息则表明启动成功： ZooKeeper JMX enabled by default Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg Starting zookeeper \u0026hellip; STARTED\n13、查询 zookeeper 状态： ./zkServer.sh status\n14、关闭 zookeeper 服务： zkServer.sh stop 如打印如下信息则表明成功关闭： ZooKeeper JMX enabled by default Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg Stopping zookeeper \u0026hellip; STOPPED\n15、重启 zookeeper 服务： zkServer.sh restart 如打印如下信息则表明重启成功： ZooKeeper JMX enabled by default Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg ZooKeeper JMX enabled by default Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg Stopping zookeeper \u0026hellip; STOPPED ZooKeeper JMX enabled by default Using config: /usr/local/services/zookeeper/zookeeper-3.4.9/bin/../conf/zoo.cfg Starting zookeeper \u0026hellip; STARTED\n验证 ./zkCli.sh -server 192.168.2.100:2181 help =============================================================== Kafka ================================================================ 快速开始\n防火墙设置\t执行\rfirewall-cmd --permanent --zone=public --add-port=9092/tcp\rfirewall-cmd --permanent --zone=public --add-port=9092/udp\r这样就开放了相应的端口。\r执行\rfirewall-cmd --reload\r使最新的防火墙设置规则生效。\r第1步：下载代码并解压缩它。\ntar -zxvf kafka_2.12-2.0.0.tgz\r第2步：启动服务器 Kafka使用ZooKeeper，因此如果您还没有ZooKeeper服务器，则需要先启动它。 现在启动Kafka服务器： bin/kafka-server-start.sh config/server.properties\n停止Kafka服务器：\tbin/kafka-server-stop.sh config/server.properties\r第3步：创建主题 1、让我们创建一个名为“test”的主题，它只包含一个分区，只有一个副本： 说明：备份因子replication-factor越大，则说明集群容错性越强，就是当集群down掉后，数据恢复的可能性越大。所有的分区数里的内容共同组成了一份数据， 分区数partions越大，则该topic的消息就越分散，集群中的消息分布就越均匀。\nbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test\r集群上创建备份因子为3，分区数为4的Topic：\rbin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 3 --partitions 4 --topic kafka\r知道哪个经纪人（broker）正在做什么？要查看运行“describe topics”命令：\rbin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic my-replicated-topic\rTopic:my-replicated-topic PartitionCount:1 ReplicationFactor:3 Configs:\rTopic: my-replicated-topic Partition: 0 Leader: 1 Replicas: 1,2,0 Isr: 1,2,0\r这是输出的解释。第一行给出了所有分区的摘要，每个附加行提供有关一个分区的信息。由于我们只有一个分区用于此主题，因此只有一行。\r“leader”是负责给定分区的所有读取和写入的节点。每个节点将成为随机选择的分区部分的领导者。\r“replicas”是复制此分区日志的节点列表，无论它们是否为领导者，或者即使它们当前处于活动状态。\r“isr”是“同步”复制品的集合。这是副本列表的子集，该列表当前处于活跃状态并且已经被领导者捕获。\r拿partition:0这个分区来说，该分区的Leader是server0，分布在id为0，1，2这三个节点上，而且这三个节点都活着。\r2、运行list topic命令，我们现在可以看到该主题：\rbin/kafka-topics.sh --list --zookeeper localhost:2181\r\u0026gt; test\r3、修改topic，添加分区数：\rbin/kafka-topics.sh --zookeeper localhost:2181 --alter --topic test --partitions 4\r4、删除topic：\rbin/kafka-topics.sh --zookeeper localhost:2181 --delete --topic test\r此时你若想真正删除它，可以登录zookeeper客户端：\r命令：./zkCli.sh -server 192.168.2.100:2181\rrmr /\rrmr /cluster\rrmr /controller_epoch\rrmr /brokers rmr /admin\rrmr /isr_change_notification\rrmr /consumers\rrmr /log_dir_event_notification\rrmr /latest_producer_id_block\rrmr /config\r找到topic所在的目录：ls /brokers/topics\r找到要删除的topic，执行命令：rmr /brokers/topics/【topic name】即可，此时topic被彻底删除。\r5、检查消费者的位置\rbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group\r6、列出所有主题的所有使用者组：\rbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list\r7、要查看偏移量，如前所述，我们“描述”这样的消费者群体：\tbin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group\r第4步：发送一些消息 Kafka附带一个命令行客户端，它将从文件或标准输入中获取输入，并将其作为消息发送到Kafka集群。默认情况下，每行将作为单独的消息发送。 运行生产者，然后在控制台中键入一些消息以发送到服务器： bin/kafka-console-producer.sh \u0026ndash;broker-list 192.168.2.100:9092 \u0026ndash;topic test\n第5步：启动消费者 Kafka还有一个命令行使用者，它会将消息转储到标准输出。 bin/kafka-console-consumer.sh \u0026ndash;bootstrap-server 192.168.2.102:9092 \u0026ndash;topic test3 \u0026ndash;from-beginning\n======================================================================常用命令============================================================== clear 清屏\nifconfig 查看网络情况\ntop -c\nkill 1352\nservice mysqld status MySQL已经自动启动\n列出所有端口： netstat -ntlp redis 6379 kafka 9092 mysql 3306 mongod 27017 zookeeper 2181 zookeeper 2888 zookeeper 3888\n参数说明： a：表示所有 n：表示不查询dns t：表示tcp协议 u：表示udp协议 p：表示查询占用的程序 l：表示查询正在监听的程序\nzookeeper 启动 ./usr/local/src/zookeeper-3.4.12/bin/zkServer.sh start /usr/local/src/zookeeper-3.4.12/conf/zoo.cfg\nzookeeper 查看各个zk服务器的角色信息 ./usr/local/src/zookeeper-3.4.12/bin/zkServer.sh status /usr/local/src/zookeeper-3.4.12/conf/zoo.cfg\nzookeeper 重启 ./usr/local/src/zookeeper-3.4.12/bin/zkServer.sh restart /usr/local/src/zookeeper-3.4.12/conf/zoo.cfg\nredis启动 ./usr/local/src/redis-4.0.11/src/redis-server /usr/local/src/redis-4.0.11/redis.conf\nkafka 启动 /usr/local/src/kafka_2.12-2.0.0/bin/kafka-server-start.sh /usr/local/src/kafka_2.12-2.0.0/config/server.properties\nkafka 查看主题列表： /usr/local/src/kafka_2.12-2.0.0/bin/kafka-topics.sh \u0026ndash;list \u0026ndash;zookeeper localhost:2181\nkafka 查看主题的broker： /usr/local/src/kafka_2.12-2.0.0/bin/kafka-topics.sh \u0026ndash;describe \u0026ndash;zookeeper localhost:2181 \u0026ndash;topic my-replicated-topic\nkafka 运行生产者 /usr/local/src/kafka_2.12-2.0.0/bin/kafka-console-producer.sh \u0026ndash;broker-list 192.168.2.100:9092 \u0026ndash;topic test\nkafka 启动消费者 /usr/local/src/kafka_2.12-2.0.0/bin/kafka-console-consumer.sh \u0026ndash;bootstrap-server 192.168.2.102:9092 \u0026ndash;topic test3 \u0026ndash;from-beginn\nkafka 停止 /usr/local/src/kafka_2.12-2.0.0/bin/kafka-server-stop.sh /usr/local/src/kafka_2.12-2.0.0/config/server.properties Ctrl + C\nNoSyncDeliverCause\nyum安装：\n# yum install 包名\ryum卸载：\n# yum -y remove 包名\ryum升级：\n# yum update 包名\r"},{"id":400,"href":"/Tech/8IDE/Linux/Ubuntu/Ubuntu-%E5%AE%89%E8%A3%85JDK/","title":"Ubuntu 安装 Jdk","parent":"Ubuntu","content":" 查找合适的openjdk版本: apt-cache search openjdk 安装: sudo apt-get install openjdk-17-jdk 测试jdk是否安装成功: java -version 设置系统默认jdk: sudo update-java-alternatives -s openjdk-11-jdk 如果需要： 配置环境变量, 编辑如下文件: vim ~/.bashrc 在最后一行加:\nexport JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64 export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar "},{"id":401,"href":"/Tech/8IDE/Linux/Ubuntu/Ubuntu/","title":"Ubuntu","parent":"Ubuntu","content":" Docker 应知应会 1、Ubuntu 镜像文件下载 官方下载地址（不推荐）\rhttps://www.ubuntu.com/download\r中国官网（推荐）\rhttps://cn.ubuntu.com/\r中科大源\rhttp://mirrors.ustc.edu.cn/ubuntu-releases/16.04/\r阿里云开源镜像站\rhttp://mirrors.aliyun.com/ubuntu-releases/16.04/\r兰州大学开源镜像站\rhttp://mirror.lzu.edu.cn/ubuntu-releases/16.04/\r北京理工大学开源\rhttp://mirror.bit.edu.cn/ubuntu-releases/16.04/\r浙江大学\rhttp://mirrors.zju.edu.cn/ubuntu-releases/16.04/\r不知名镜像网站\rhttp://mirror.pnl.gov/releases/xenial/\r各个版本下载网址：\rhttp://mirrors.melbourne.co.uk/ubuntu-releases/ Ubuntu忘记密码的解决办法 ubuntu忘记root密码怎么办？如果普通用户忘记了怎么办\n第一种方法：\r无论你是否申请了root帐号，或是普通账号密码忘记了都没有问题的！\r1、重启ubuntu，随即长按shift进入grub菜单；\r2、选择第二个高级模式recovery mode进入\r3、进入Recovery Menu界面，选择root Drop to root shell prompt ,也就是获取root权限\r4、在命令行# 后面敲入 cat /etc/shadow 查看用户名（如果连用户名都忘记的话）\r5、敲入：passwd \u0026#34;用户名\u0026#34; 之后再敲两次密码就可以修改用户名密码了。\r另外想修改root密码可使用下面的方法：\r修改root密码操作：#passwd\r输入新密码：# 再输入一遍密码：#\r这是设置root密码，如果是设置其它用户密码使用命令：passwd 用户名 即可\r6、按ctrl+alt+del重启系统，完成。 Linux RPM和DEB包的区别 关于rpm和deb RPM(Red Hat Package Manager)，是基于Red hat的Linux Distribution的包管理系统，同时也指rpm包本身，RPM用于rpm包的管理（诸如安装、卸载、升级等），像Mandrake和SuSE这些基于RPM的发行版通常有自己特定的rpm包，如果混合安装可能不会正常工作，而对于第三方发行的rpm包一般都能在基于RPM的系统上正常安装。 对于基于Debian的系统使用deb格式的包，有包转换工具使rpm与deb及其他文件之间互相转换(Alien Package Converter），其安装和升级可用dpkg，不过它不能很方便地处理包的依赖关系，比较省事的有dselect和apt-get, Ubunut是debian的变种, 其软件以deb包或者源文件的形式出现. deb软件包的格式和使用 (1).deb软件包命令遵行如下约定： soft_ver-rev_arch.deb , 如:pptview_8.0-5_i386.deb 中名字是pptview, 版本号8.0, 架构为i386平台.**** 有些时候，您使用“dpkg”安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包\ndpkg -i | --install xxx.deb 安装deb软件包 dpkg -r | --remove xxx.deb 删除软件包 dpkg -r -P | --purge xxx.deb 连同配置文件一起删除 dpkg -I | -info xxx.deb 查看软件包信息 dpkg -L xxx.deb 查看文件拷贝详情 dpkg -l 查看系统中已安装软件包信息 dpkg-reconfigure xxx 重新配置软件包 如果一个软件依赖关系过于复杂，使用“dpkg”来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过预设的方 式来获得相关软件包，并自动安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。\nAPT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为“源”。“源”可以是网络服务器，安装CD或者本地软件仓库。您需要修改\nrpm包-在红帽LINUX、 SUSE、Fedora可以直接进行安装,但在Ubuntu中却无法识别;\ndeb包-是Ubuntu的专利,在Ubuntu中双击deb包就可以进入自动安装进程;\ntar.gz包-在所有的Linux版本中都能使用,但安装过程也最麻烦。 要先解压缩,然后在“终端”里用cd命令进入刚才解压的目录,再找到安装链接文件安装。\n比如tar.gz包解压到了\u0026quot;/temp/*****.tar.gz/\u0026quot;, tar.gz包中的安装链接文件为install: 1- cd /temp/*****.tar.gz/ 2- ./install 3-根据提示输入“ENTER”或“安装目录” 4-结束 虽然都是for linux版,但下载安装包之前,要搞清楚是哪一种包,。\n"},{"id":402,"href":"/Tech/8IDE/Redis/Redis/","title":"Redis","parent":"Redis","content":" Redis 命令 模糊匹配到Key\nKEYS \u0026#34;oms-original-order-service:OMS_Original_Order_PlatOrderNo:*\u0026#34; keys \u0026ldquo;[$Key]*\u0026rdquo; d\n"},{"id":403,"href":"/Tech/8IDE/Window/Window-Mark/","title":"Window Mark","parent":"Window","content":" Window Mark Wind10系统C盘各个文件夹及重要文件的作用 一、C盘根目录常见文件夹\n1、Intel\nIntel文件夹是安装了intel芯片组驱动留下来的log类文件夹,主要是给安装者提供一些信息：安装了哪些驱动，是否安装成功等等，没什么大用，你不喜欢完全可以删除。但安装或更新驱动还是会出现该文件夹。\n2、debug\ndebug是系统调试文件夹，用来存放系统运行过程中调试模块的日志文件，以便管理员根据这些日志文件来发现计算机所存在的问题。一般为空文件夹。\n3、PerfLogs\nPerfLogs是系统日志信息文件夹，如磁盘扫描错误信息，是系统自动生成的，系统测试之后，测试记录文件也会自动存放在这个文件夹下。可以删掉，但不建议，因为这样反而降低系统速度。\n4、Program Files\nProgram Files是系统自带应用应用和软件的安装目录。\n64位系统会有Program Files(X86)文件夹，这是系统中32位软件的安装目录。\n5、Windows\n它是Windows系统安装文件所在文件夹，一般用来存储系统安装文件和硬件驱动程序等内容，是系统正常运转的必要保证。\n6、用户\n它是用来储存系统所有用户数据、用户应用程序数据、桌面、我的文档、我的图片、我的视频和开始菜单等内容的文件夹。\n二、C盘隐藏文件夹（点查看，勾选“隐藏的项目”即可看到）\n1、$Recycle.Bin\n回收站文件，删除后会自动重建，用于保存删除文件数据。\n2、Boot\n用于保存操作系统引导文件的文件夹。绝对不能删除。\n3、Documents and Settings\n系统用户设置文件夹，包括各个用户的文档、收藏夹、上网浏览信息、配置文件等。这里面保存着系统所有用户的文档和账户设置，尤其是里面的default user、all users、administrator和以你当前登陆用户名的文件夹。切忌随便删除这里面的东西，否则会造成系统重新启动不能登陆的情况发生。\n4、Program Data\nWindows 7以上系统系统文件夹，放置程序的使用数据、设置等文件，不建议删除。\n5、Recovery\n用于存放恢复系统用的恢复环境的文件夹，如果用户习惯于系统出现状况后重装系统的话，可以删除这个文件夹，对系统不会造成任何影响。\n6、System Volume Information\n这是任何一个分区下都会存在的一个文件夹，一般翻译成系统卷标信息文件夹。用于存储系统还原的备份信息以及磁盘分区数据信息。\n最后说一点，不要磁盘空间不够用了就随意删除系统C盘文件，平时注意养成良好的使用习惯，及时清理系统垃圾，这样才能从根本上解决问题，否则真的是得不偿失！\nWindows系统目录结构 Windows系统目录 ├—WINDOWS │ ├—system32（存放Windows的系统文件和硬件驱动程序） │ │ ├—config（用户配置信息和密码信息） │ │ │ └—systemprofile（系统配置信息，用于恢复系统） │ │ ├—drivers（用来存放硬件驱动文件，不建议删除） │ │ ├—spool（用来存放系统打印文件。包括打印的色彩、打印预存等） │ │ ├—wbem（存放WMI测试程序，用于查看和更改公共信息模型类、实例和方法等。请勿删除） │ │ ├—IME（用来存放系统输入法文件，类似WINDOWS下的IME文件夹） │ │ ├—CatRoot（计算机启动测试信息目录，包括了计算机启动时检测的硬软件信息） │ │ ├—Com（用来存放组件服务文件） │ │ ├—ReinstallBackups（电脑中硬件的驱动程序备份） │ │ ├—DllCache（用来存放系统缓存文件。当系统文件被替换时，文件保护机制会复制这个文件夹下的文件去覆盖非系统文件） │ │ ├—GroupPolicy（组策略文件夹） │ │ │ ├—system（系统文件夹，用来存放系统虚拟设备文件） │ ├—N t U n i n s t a l l NtUninstallNtUninstall（每给系统打一个补丁，系统就会自动创建这样的一个目录，可删除） │ ├—security（系统安全文件夹，用来存放系统重要的数据文件） │ ├—srchasst（搜索助手文件夹，用来存放系统搜索助手文件，与msagent文件夹类似） │ ├—repair（系统修复文件夹，用来存放修复系统时所需的配置文件） │ ├—Downloaded Program Files（下载程序文件夹，用来存放扩展IE功能的ActiveX等插件） │ ├—inf（用来存放INF文件。INF文件最常见的应用是为硬件设备提供驱动程序服务，不建议删除其中文件） │ ├—Help（Windows帮助文件） │ ├—Config（系统配置文件夹，用来存放系统的一些临时配置的文件） │ ├—msagent（微软助手文件夹，存放动态的卡通形象，协助你更好地使用系统。若觉得没有必要，可直接删除） │ ├—Cursors（鼠标指针文件夹） │ ├—Media（声音文件夹，开关机等wav文件存放于此） │ ├—Mui（多语言包文件夹，用来存放多国语言文件。简体中文系统中这个文件夹默认是空的，但不建议删除此文件夹） │ ├—java（存放Java运行的组件及其程序文件。不建议删除其中文件） │ ├—Web │ │ ├—Wall*****（存放桌面壁纸的文件夹） │ │ │ ├—addins（系统附加文件夹，用来存放系统附加功能的文件） │ ├—Connection Wizard（连接向导文件夹，用来存放“Internet连接向导”的相关文件） │ ├—Driver Cache（驱动缓存文件夹，用来存放系统已知硬件的驱动文件） │ │ └—i386（Windows操作系统自带的已知硬件驱动文件，可删除以节省空间） │ ├—TEMP（系统临时文件夹，其中内容可以全部删除） │ ├—twain_32（扫描仪相关） │ ├—AppPatch（应用程序修补备份文件夹，用来存放应用程序的修补文件） │ ├—Debug（系统调试文件夹，用来存放系统运行过程中调试模块的日志文件） │ ├—Resources（系统资源文件夹，用来存放系统SHELL资源文件，就是我们在桌面上所看到的主题） │ │ └—Themes（桌面主题都存放于此，可删除无用主题） │ ├—WinSxS（存储各个版本的Windows XP组件，减少因为DLL文件而引起的配置问题） │ ├—ime（输入法信息） │ ├—PCHealth（用来存放协调、配置和管理计算机正常运行的文件） │ │ └—HelpCtr（帮助和支持） │ │ ├—Binaries（我们常用的msconfig就在这里哟） │ ├—Offline Web Pages（脱机浏览文件存放于此） │ ├—Prefetch（预读取文件夹，用来存放系统已访问过的文件的预读信息(此信息是系统在访问时自动生成的新信息)，以加快文件的访问速度，其扩展名为“PF”。可以将此文件夹中的文件删除） │ ├—ShellNew │ ├—Fonts（字体文件夹。要安装某种字体只需将字体文件复制到该目录下即可） │ ├—pss（用来备份系统启动配置文件的，一般对“Boot.ini”、“System.ini”和“Win.ini”三个文件进行备份，扩展名为“backup”。如果系统原有的这三个文件损坏的话，可以从这里进行恢复。不建议删除） │ ├—Registration（注册文件夹，用来存放用于系统COM+或者其他组件注册的相关文件。不建议删除这里的文件） │ └—Downloaded Installations（存放一些使用Windows Installer技术的安装程序，主要用来对程序进行修复等操作） ├—Documents and Settings │ ├—Default User │ │ ├—Application Data（通用应用程序数据文件夹。此处存放着已经安装的一些应用程序的专用数据） │ │ ├—桌面 │ │ ├—Favorites（收藏夹） │ │ ├—NetHood（网络共享目录） │ │ ├—My Documents（我的文档） │ │ ├—PrintHood（打印共享目录） │ │ ├—Recent（最近打开的文档） │ │ ├—SendTo（鼠标右键发送到） │ │ ├—「开始」菜单 │ │ ├—Templates（模板文件夹，可能有Word、Excel等的模板文件） │ │ └—Local Settings │ │ ├—Application Data │ │ └—Temp（临时文件目录。在系统和软件的运行过程中产生的临时文件就存放在于此。需定期清理） │ │ └—Temporary Internet Files（Internet临时文件夹。需定期清理） │ ├—All Users（所有用户文件夹，这里的更改对所有用户有效） │ └—Administrator（系统管理员帐户的文件夹） ├—Program Files │ ├—Common Files（共享的应用程序文件存放于此） │ ├—Internet Explorer（IE浏览器） │ ├—ComPlus Applications（COM+ 组件的配置和跟踪，一般为空） │ ├—Windows Media Player（WINDOWS媒体播放器） │ ├—WindowsUpdate（用于Windows的升级，可删除） │ ├—InstallShield Installation Information │ ├—Uninstall Information（存放软件卸载信息，删除后可能导致部分软件无法卸载） ├—wmpub（windowsmedia service的目录） ├—boot（一键还原等软件的文件夹） ├—Inetpub（IIS文件夹） ├—Downloads(Flashget默认下载文件夹) ├—System Volume Information(系统还原文件夹)\nDocuments and Settings Documents and Settings文件夹是Windows NT/2000/XP/2003操作系统中用来存放用户配置信息的文件夹。默认情况下在系统分区根目录下，其下包括：Administrator、All Users、Default User、用户文件夹。如果你将隐藏和系统的文件（夹）都显示出来的话，还会发现诸如LocalService、NetworkService等更多的文件夹。 1、用户名/「开始」菜单 All Users\\「开始」菜单 2、收藏夹：该文件夹位于每个用户名目录下。 3、My Documents：我的文档 4、Local Settings：该文件夹保存了应用程序数据、历史和临时文件 等\nProgram Files Program Files 是程序文件，就是说Windows 操作系统，当然也包括其它的操作系统各种软件默认安装到的目录，位于C盘分区（“C:\\Program Files”，\u0026quot;%ProgramFiles%\u0026quot;）。但也可根据用户的需要自定义到别的分区。 一个初始的 Windows 系统中的 Program Files 里一般有以下文件夹：\nCommon Files: 提供程序中的一些共享配置文件。 Internet Explorer: 网络浏览器。 Windows Media Player: 媒体播放器。 Movie Maker: 影片制作工具。 Outlook Express: 提供邮件收发功能。 NetMeeting: 网络聊天软件。 Messenger: 新版网络聊天工具。 Online Services: 提供创建网络连接的服务商。 Microsoft Office: 办公软件集合，包括文字处理 Word、表格处理 Excel、幻灯处理 PowerPoint、数据库处理 Access、邮件处理 Outlook 和网页处理 FrontPage。 其余的文件夹，都是之后安装的程序所在文件夹。 更改默认安装路径 由于系统分区空间宝贵，因此许多人会将应用程序安装到其他分区，比如D:。然而，一般情况下软件在安装时都会自动选择系统默认的C:\\Program Files文件夹，每次都要更换安装路径，非常麻烦，需要更改默认安装路径来解决。一般通过修改注册表键值来解决该问题。步骤如下： 1.打开注册表编辑器（按Windows+R键打开运行命令，输入regedit，即可打开注册表编辑器）。 2.定位到 【HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion】。 3.将ProgramFilesDir字符串值改为D:\\Program Files或其他路径。 注：文件一般路径的分隔符为\u0026quot;\u0026quot;，注册表路径分隔符为\u0026quot;\u0026quot;。\nProgramData programdata是位于电脑系统盘（默认C盘）根目录的一个系统文件夹，它是公用的被创建文件夹或文件存放的地方，多为软件缓存，这些文件夹或文件由程序或管理员用户控制.很多软件卸载后并没有删除配置，需要我们手动删除。\n"},{"id":404,"href":"/Tech/8IDE/Window/Window10-%E4%B8%8B%E6%90%AD%E5%BB%BA-Rust-%E7%8E%AF%E5%A2%83/","title":"Window10 下搭建 Rust 环境","parent":"Window","content":" Window10 下搭建 Rust 环境 首先要说明的是，本文是介绍 windows + MSYS2 + Rust ，非 MSVC。\nWindows作业系统中的Rust程式，预设会使用MSVC来编译的。但是如果Rust程式有使用到GNU相关的函式库(例如GTK)时，就得搭配MinGW来编译了。MSYS2 是一套整合MinGW和POSIX环境的工具，可以在Windows作业系统上模拟出Linux作业系统的开发环境，且能利用MinGW直接编译出在Windows作业系统上执行的程式。\n1、安装和设定 MSYS2 已经有其他博文做过介绍，参考即可\n2、安在Windows作业系统安装Rust开发环境 现在官方推荐使用 rustup 来安装 Rust 环境。\n首先在MSYS2的终端机上执行以下指令：\ncurl https://sh.rustup.rs -sSf | sh 注意，在 Windows 上面，Rust 编译需要 Visual C++ Build Tools。请先安装这个之后再安装 rustup。\n安装程式可能会提示说需要微软的Visual C++ Build Tools。不要理它，输入「y」继续。\n选择第二个选项，自定义Rust要如何安装\nhost triple的部份，输入「x86_64-pc-windows-gnu」，也就是我们的Rust编译器预设使用的目标(target)名称。\n接着输入Rust的版本，建议使用「stable」，如果有nightly需求的话就用「nightly」吧！\n概要文件(要安装哪些工具和数据)?(最小/违约/完成) Profile (which tools and data to install)? (minimal/default/complete)\ndefault\n接着设定是否要修改「PATH」环境变数，输入「y」。\n然后回到选单，选择第一项，开始用我们刚才的设定来安装Rust。\n更新与卸载 更新所有 Rust，运行：\nrustup update 校验Rust编译环境\nrustc --version\rcargo --version 检查 rustup 自身是否有更新：\nrustup self update 卸载 rustup：\nrustup self uninstall 配置代理： 卡在 update crates.io crates.io 镜像\n在～/.cargo 下：创建一个 config 文件，\n将下面的代码贴进去：\n# 放到 `$HOME/.cargo/config` 文件中\r[source.crates-io]\rregistry = \u0026#34;https://github.com/rust-lang/crates.io-index\u0026#34;\r# 替换成你偏好的镜像源\r#replace-with = \u0026#39;sjtu\u0026#39;\r#replace-with = \u0026#39;ustc\u0026#39;\rreplace-with = \u0026#39;rsproxy\u0026#39;\r# 清华大学\r[source.tuna]\rregistry = \u0026#34;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git\u0026#34;\r# 中国科学技术大学\r[source.ustc]\rregistry = \u0026#34;git://mirrors.ustc.edu.cn/crates.io-index\u0026#34;\r# 上海交通大学\r[source.sjtu]\rregistry = \u0026#34;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index\u0026#34;\r# rustcc社区\r[source.rustcc]\rregistry = \u0026#34;git://crates.rustcc.cn/crates.io-index\u0026#34;\r# 字节跳动 rsproxy\r[source.crates-io]\r# To use sparse index, change \u0026#39;rsproxy\u0026#39; to \u0026#39;rsproxy-sparse\u0026#39;\r[source.rsproxy]\rregistry = \u0026#34;https://rsproxy.cn/crates.io-index\u0026#34;\r[source.rsproxy-sparse]\rregistry = \u0026#34;sparse+https://rsproxy.cn/index/\u0026#34;\r[registries.rsproxy]\rindex = \u0026#34;https://rsproxy.cn/crates.io-index\u0026#34;\r[net]\rgit-fetch-with-cli = true RustUp 镜像 国内有些地区访问 RustUp 的服务器不太顺畅，设置环境变量\n中科大的 RustUp 镜像\nRUSTUP_DIST_SERVER=http://mirrors.ustc.edu.cn/rust-static\rRUSTUP_UPDATE_ROOT=http://mirrors.ustc.edu.cn/rust-static/rustup 字节跳动\nRUSTUP_DIST_SERVER=\u0026#34;https://rsproxy.cn\u0026#34;\rRUSTUP_UPDATE_ROOT=\u0026#34;https://rsproxy.cn/rustup\u0026#34; Rust GTK GTK_LIB_DIR=C:\\msys64\\mingew64\\bin PKG_CONFIG_ALLOW_CROSS=1 The error persisted so I added the environment variable PKG_CONFIG_PATH = H:\\MSYS2\\usr\\lib\\pkgconfig, and I added H:\\MSYS2\\usr\\lib\\pkgconfig to the path variable "},{"id":405,"href":"/Tech/8IDE/Window/Windows-%E5%91%BD%E4%BB%A4/","title":"Windows 命令","parent":"Window","content":" Windows 命令 网络复位\nnetsh winsock reset 查看曾经连接过的无线网络:\nnetsh wlan show profiles 查看指定无线网络（WIFI）的明文密码:\nnetsh wlan show profiles name=\u0026#34;361\u0026#34; key=clear "},{"id":406,"href":"/Tech/8IDE/Window/Windward-C-%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"Windward C 语言开发环境配置","parent":"Window","content":" Windward C 语言开发环境配置 1、下载安装 MSYS2 MSYS2官方网站：http://www.msys2.org/\n清华大学开源镜像：https://mirrors.tuna.tsinghua.edu.cn/help/msys2/\n中国科学技术大学源 https://mirrors.ustc.edu.cn/help/msys2.html\n2、修改软件源： 可修改 中科大源 或者 清华大学 源\n3、配置更新 执行 pacman -Sy 刷新软件包数据即可。 执行 pacman-key \u0026ndash;init\npacman -Syu\n更新软件，更新过程中可能要求重新打开终端，另外更新的时候，pacman的软件源可能恢复到默认，需要手动再修改一次。 gpg: 警告：服务器 ‘gpg-agent’ 比我们的版本更老 （2.2.19-unknown \u0026lt; 2.2.20-unknown） gpg: 注意： 过时的服务器可能缺少重要的安全修复。 gpg: 注意： 使用 “gpgconf \u0026ndash;kill all” 来重启他们。\n4、安装工具链 pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-extra-cmake-modules pacman -S mingw-w64-x86_64-make pacman -S mingw-w64-x86_64-gdb pacman -S mingw-w64-x86_64-toolchain 命令出错可重新执行。\n5、安装GTK3及其依赖项 运行： pacman -S mingw-w64-x86_64-gtk3 pacman -S mingw-w64-x86_64-gtk4 pacman -S mingw-w64-x86_64-gtk4 mingw-w64-x86_64-pkgconf mingw-w64-x86_64-gcc\n步骤5（可选）：安装构建工具 如果要用其他语言（例如C，C ++，Fortran等）开发GTK3应用程序，则需要像gcc和其他开发工具这样的编译器： pacman -S mingw-w64-x86_64-toolchain base-devel\n6、在做GTK开发时隐藏 cmd窗口的办法 第一种：CMakeLists.txt # cmake所需的最低版本\rcmake_minimum_required(VERSION 3.13)\r# naming项目\rproject(test)\r# 指定编译器\r# CMAKE_C_FLAGS_DEBUG ---- C 编译器\r# CMAKE_CXX_FLAGS_DEBUG ---- C++ 编译器\r# -g：只是编译器，在编译的时候，产生调试信息。\r# -Wall：生成所有警告信息。一下是具体的选项，可以单独使用\rset(CMAKE_C_STANDARD 11)\r# 使用包PkgConfig检测 GTK+ 头文件/库文件\rfind_package(PkgConfig REQUIRED)\rpkg_check_modules(GTK3 REQUIRED gtk+-3.0)\r# 配置加载native依赖\r# CMake使用GTK +，告诉编译器在哪里查找头文件\r# 和链接器在哪里查找库文件\rinclude_directories(${GTK3_INCLUDE_DIRS})\rlink_directories(${GTK3_LIBRARY_DIRS})\r# 将其他标志添加到编译器\radd_definitions(${GTK3_CFLAGS_OTHER})\r# 添加从hello.c编译的可执行文件\radd_executable(test main.c)\r# 与上面的区别在于：这意味着您将使它成为Windows程序，并提供WinMain函数(int main(int, char **)是入口点的控制台版本。int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int))。（可以隐藏CMD）\r#add_executable(test WIN32 main.c)\r# 链接库\rtarget_link_libraries(test ${GTK3_LIBRARIES})\r# 隐藏 CMD target_link_options(test PRIVATE -mwindows) 第二种 可以通过gcc实现： https://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/i386-and-x86_002d64-Windows-Options.html gcc -mwindows -o simple simple.c 如果仍想通过gcc传递“ -mwindows”标志，但仍然使用“ main”，则只需将CMAKE_CXX_FLAGS和/或CMAKE_C_FLAGS值添加“ -mwindows”。您可以在cmake-gui程序中通过交互式调整这些变量以使其包含“ -mwindows”来执行此操作，也可以使用命令行CMake进行此操作，如下所示： cmake -DCMAKE_C_FLAGS=\u0026#34;-mwindows\u0026#34; 在 GUI 环境相同设置： 安裝文字介面下的純文字編輯器─vim pacman -S vim 安裝 MinGW pacman -S pacman -S mingw-w64-x86_64-toolchain 如果要查看目前工作目錄對應Windows環境的檔案路徑，可以再對「pwd」指令加上「-W」選項 pwd -W 更新 MSYS2 pacman -Syu 更新到一半時，MSYS2可能會要求使用者要直接關閉MSYS2。\n此時要用一般關閉視窗的方法來關閉MSYS2的終端機，而不要用「Ctrl+c」去中止MSYS2的更新程式。\n關閉MSYS2後，重新開啟MSYS2的終端機，並輸入以下指令：\npacman -Su 接著繼續把套件的更新跑完。\n如何在MSYS2中編譯Rust程式 Windows作業系統中的Rust程式，預設會使用MSVC來編譯的。但是如果Rust程式有使用到GNU相關的函式庫(例如GTK)時，就得搭配MinGW來編譯了。MSYS2是一套整合MinGW和POSIX環境的工具，可以在Windows作業系統上模擬出Linux作業系統的開發環境，且能利用MinGW直接編譯出在Windows作業系統上執行的程式。\n在Windows作業系統安裝Rust開發環境 如果您的Windows作業系統已經有Rust的開發環境(在命令提示字元下可以直接使用rustup、cargo等指令)，可以跳過這個部份。\n首先在MSYS2的終端機上執行以下指令：\ncurl https://sh.rustup.rs -sSf | sh 1、安裝程式可能會提示說需要微軟的Visual C++ Build Tools。不要理它，輸入「y」繼續。\n2、選擇第二個選項來自訂Rust要如何安裝。\n3、host triple的部份，輸入「x86_64-pc-windows-gnu」，也就是我們的Rust編譯器預設使用的目標(target)名稱。\n接著輸入Rust的版本，建議使用「stable」，如果有nightly需求的話就用「nightly」吧！\nDefault toolchain? (stable/beta/nightly/none)\rnightly\rProfile (which tools and data to install)? (minimal/default/complete)\rcomplete\rinfo: installing component \u0026#39;cargo\u0026#39;\rinfo: installing component \u0026#39;clippy\u0026#39;\rinfo: installing component \u0026#39;llvm-tools-preview\u0026#39;\rinfo: installing component \u0026#39;miri\u0026#39;\rinfo: installing component \u0026#39;rls\u0026#39;\rinfo: installing component \u0026#39;rust-analysis\u0026#39;\rinfo: installing component \u0026#39;rust-docs\u0026#39;\rinfo: installing component \u0026#39;rust-mingw\u0026#39;\rinfo: installing component \u0026#39;rust-src\u0026#39;\rinfo: installing component \u0026#39;rust-std\u0026#39;\rinfo: installing component \u0026#39;rustc\u0026#39;\rinfo: installing component \u0026#39;rustc-dev\u0026#39; 4、接著設定是否要修改「PATH」環境變數，輸入「y」。\n5、然後回到選單，選擇第一項，開始用我們剛才的設定來安裝Rust。\n6、安裝好後，確認「PATH」環境變數是否有包含「%USERPROFILE%.cargo\\bin」路徑，沒有的話就加上去。\n7、在命令提示字元中輸入「rustup」和「cargo」指令來確認Windows作業系統的Rust開發環境是否安裝且設定成功。如果有設定成功，指令才會存在。\n8、此時可以在MSYS2的終端機中利用以下指令來查看「PATH」環境變數：\necho $PATH 9、之後就可以在MSYS2的終端機中使用「rustup」和「cargo」等Rust開發環境的相關指令了！\n替Rust加入「x86_64-pc-windows-gnu」目標 如果您在安裝Rust的時候已經設定使用了「x86_64-pc-windows-gnu」目標，可以跳過這個部份。\n在MSYS2的終端機中使用以下指令，來查看Rust開發環境目前已加入的目標：\nrustup toolchain list 如果沒有看到「x86_64-pc-windows-gnu」目標的話，可以使用以下指令來安裝：\nrustup target add x86_64-pc-windows-gnu 讓Rust使用MinGW 在MSYS2的終端機中使用vim等文字編輯軟體，開啟「/c/Users/您的Windows使用者名稱/.cargo/config」檔案。\nvim \u0026#34;/c/User/Magic Len/.cargo/config\u0026#34; 在檔案內加上以下內容：\n[target.x86_64-pc-windows-gnu]\rlinker = \u0026#34;C:\\msys64\\mingw64\\bin\\gcc.exe\u0026#34;\rar = \u0026#34;C:\\msys64\\mingw64\\bin\\ar.exe\u0026#34; 如此一來，不論是哪個Cargo程式專案，在使用「x86_64-pc-windows-gnu」目標來編譯程式時，就會去用MinGW提供的「gcc.exe」和「ar.exe」來做函式庫的連結。\nRust與MSYS2的Hello World\n為了確定我們的Rust開發環境沒有問題，可以在MSYS2的終端機中，使用以下幾個指令來測試預設的Cargo程式專案(Hello World)是否可以正常被編譯執行。\ncargo new --bin hello cd hello cargo run pacman命令\npacman -Sy 更新软件包数据\rpacman -Syu 更新所有\rpacman -Ss xx 查询软件xx的信息\rpacman -S xx 安装软件xx\rpacman -R package_name 删除软件package_name 解决msys2“无法升级 mingw64 (无效或已损坏的数据库 (PGP 签名))”密钥失效问题 最近在使用msys2的时候，发现无法使用pacman -Syu进行更新，会出现如下提示：\n错误：msys: 来自 \u0026#34;David Macek \u0026lt;david.macek.0@gmail.com\u0026gt;\u0026#34; 的签名是勉强信任的\r错误：无法升级 msys (无效或已损坏的数据库 (PGP 签名))\r错误：未能成功同步所有数据库 原因是密钥无法信赖(rely on)msys2-keyring密钥服务器，如果不及时更新msys2-keyring，就会出现上面的错误提示。msys2官方提供了一个msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz的软件包来修复。\n下载安装该软件包之前，无法通过验证：\n# pacman-key --verify msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz{.sig,} 解决方法：\n下载 msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz 软件包 # curl -O http://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz\r# curl -O http://repo.msys2.org/msys/x86_64/msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz.sig 验证签名是否建立完好 # pacman-key --verify msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz{.sig,} 安装 msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz 包 # pacman -U --config \u0026lt;(echo) msys2-keyring-r21.b39fb11-1-any.pkg.tar.xz 然后就可以使用pacman -Syu进行更新 "},{"id":407,"href":"/Tech/8IDE/WSL/WSL2-1%E6%A6%82%E8%BF%B0/","title":"Wsl2 1、概述","parent":"WSL","content":" WSL2 概述 什么是 WSL？ 适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。\n您可以：\n在 Microsoft Store 中选择你偏好的 GNU/Linux 分发版。 运行常用的命令行软件工具（例如 grep、sed、awk）或其他 ELF-64 二进制文件。 运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括： 工具：vim、emacs、tmux 语言：NodeJS、Javascript、Python、Ruby、C/C++、C# 与 F#、Rust、Go 等 服务：SSHD、MySQL、Apache、lighttpd、MongoDB、PostgreSQL。 使用自己的 GNU/Linux 分发包管理器安装其他软件。 使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。 在 Windows 上调用 GNU/Linux 应用程序。 WSL 的基本命令 安装 PowerShell 命令：\nwsl --install 安装特定的 Linux 发行版 PowerShell 命令：\nwsl --install --distribution \u0026lt;Distribution Name\u0026gt; 通过将 替换为发行版名称，指定除默认发行版 (Ubuntu) 之外的 Linux 发行版进行安装。 此命令也可输入为：wsl -d 。\n列出可用的 Linux 发行版 PowerShell 命令：\nwsl --list --online 查看可通过在线商店获得的 Linux 发行版列表。 此命令也可输入为：wsl -l -o。\n列出已安装的 Linux 发行版 PowerShell 命令：\nwsl --list --verbose 查看安装在 Windows 计算机上的 Linux 发行版列表，其中包括状态（发行版是正在运行还是已停止）和运行发行版的 WSL 版本（WSL 1 或 WSL 2）。 比较 WSL 1 和 WSL 2。 此命令也可输入为：wsl -l -v。 可与 list 命令一起使用的其他选项包括：--all（列出所有发行版）、--running（仅列出当前正在运行的发行版）或 --quiet（仅显示发行版名称）。\n将 WSL 版本设置为 1 或 2 PowerShell 命令：\nwsl --set-version \u0026lt;distribution name\u0026gt; \u0026lt;versionNumber\u0026gt; 若要指定运行 Linux 发行版的 WSL 版本（1 或 2），请将 替换为发行版的名称，并将 替换为 1 或 2。\n设置默认 WSL 版本 PowerShell 命令：\nwsl --set-default-version \u0026lt;Version\u0026gt; 若要将默认版本设置为 WSL 1 或 WSL 2，请将 替换为数字 1 或 2，表示对于安装新的 Linux 发行版，你希望默认使用哪个版本的 WSL。 例如，wsl \u0026ndash;set-default-version 2。\n设置默认 Linux 发行版 PowerShell 命令：\nwsl --set-default \u0026lt;Distribution Name\u0026gt; 若要设置 WSL 命令将用于运行的默认 Linux 发行版，请将 替换为你首选的 Linux 发行版的名称。\n将目录更改为主页 PowerShell 命令：\nwsl ~ ~ 可与 wsl 一起使用，以在用户的主目录中启动。 若要在 WSL 命令提示符中从任何目录跳回到主目录，可使用命令 cd ~。\n通过 PowerShell 或 CMD 运行特定的 Linux 发行版 PowerShell 命令：\nwsl --distribution \u0026lt;Distribution Name\u0026gt; --user \u0026lt;User Name\u0026gt; 若要通过特定用户运行特定 Linux 发行版，请将 替换为你首选的 Linux 发行版的名称（例如 Debian），将 替换为现有用户的名称（例如 root）。 如果 WSL 发行版中不存在该用户，你将会收到一个错误。 若要输出当前用户名，请使用 whoami 命令\n更新 WSL PowerShell 命令：\nwsl --update 手动更新 WSL Linux 内核的版本。 还可以使用 wsl \u0026ndash;update rollback 命令回滚到 WSL Linux 内核的上一版本。\n检查 WSL 状态 PowerShell 命令：\nwsl --status 查看有关 WSL 配置的常规信息，例如默认发行版类型、默认发行版和内核版本\nHelp 命令 PowerShell 命令：\nwsl --help 查看 WSL 中可用的选项和命令列表。\n以特定用户的身份运行 PowerShell 命令：\nwsl -u \u0026lt;Username\u0026gt;`, `wsl --user \u0026lt;Username\u0026gt; 若要以指定用户身份运行 WSL，请将 替换为 WSL 发行版中存在的用户名。\n更改发行版的默认用户 PowerShell 命令：\n\u0026lt;DistributionName\u0026gt; config --default-user \u0026lt;Username\u0026gt; 更改用于发行版登录的默认用户。 用户必须已经存在于发行版中才能成为默认用户。\n例如：ubuntu config \u0026ndash;default-user johndoe 会将 Ubuntu 发行版的默认用户更改为“johndoe”用户。\n关闭 PowerShell 命令：\nwsl --shutdown 立即终止所有正在运行的发行版和 WSL 2 轻量级实用工具虚拟机。 在需要重启 WSL 2 虚拟机环境的情形下，例如更改内存使用限制或更改 .wslconfig 文件，可能必须使用此命令。\nTerminate PowerShell 命令：\nwsl --terminate \u0026lt;Distribution Name\u0026gt; 若要终止指定的发行版或阻止其运行，请将 替换为目标发行版的名称。\n将发行版导出到 TAR 文件 PowerShell 命令：\nwsl --export \u0026lt;Distribution Name\u0026gt; \u0026lt;FileName\u0026gt; 将分发版导出到 tar 文件。 在标准输出中，文件名可以是 -。\n导入新发行版 PowerShell 命令：\nwsl --import \u0026lt;Distribution Name\u0026gt; \u0026lt;InstallLocation\u0026gt; \u0026lt;FileName\u0026gt; 导入指定的 tar 文件作为新的分发版。 在标准输入中，文件名可以是 -。 \u0026ndash;version 选项还可与此命令一起使用，用于指定导入的发行版将在 WSL 1 还是 WSL 2 上运行。\n注销或卸载 Linux 发行版 尽管可以通过 Microsoft Store 安装 Linux 发行版，但无法通过 Store 将其卸载。\n注销并卸载 WSL 发行版：\nPowerShell 命令：\nwsl --unregister \u0026lt;DistributionName\u0026gt; 如果将 替换为目标 Linux 发行版的名称，则将从 WSL 取消注册该发行版，以便可以重新安装或清理它。 警告：取消注册后，与该分发版关联的所有数据、设置和软件将永久丢失。 从 Store 重新安装会安装分发版的干净副本。 例如：wsl \u0026ndash;unregister Ubuntu 将从可用于 WSL 的发行版中删除 Ubuntu。 运行 wsl \u0026ndash;list 将会显示它不再列出。\n还可以像卸载任何其他应用商店应用程序一样卸载 Windows 计算机上的 Linux 发行版应用。 若要重新安装，请在 Microsoft Store 中找到该发行版，然后选择“启动”。\n装载磁盘或设备 PowerShell 命令：\nwsl --mount \u0026lt;DiskPath\u0026gt; 通过将 替换为物理磁盘所在的目录\\文件路径，在所有 WSL2 发行版中附加和装载该磁盘。 请参阅在 WSL 2 中装载 Linux 磁盘。 选项包括：\nwsl --mount --bare：将磁盘附加到 WSL2，但不进行装载。 wsl --mount --type \u0026lt;Filesystem\u0026gt;：装载磁盘时使用的文件系统类型默认为 ext4（如果未指定）。 此命令也可输入为：wsl --mount -t \u0026lt;Filesystem\u0026gt;。可以使用 blkid \u0026lt;BlockDevice\u0026gt; 命令检测文件系统类型，例如：blkid \u0026lt;dev/sdb1\u0026gt;。 wsl --mount --partition \u0026lt;Partition Number\u0026gt;：要装载的分区的索引号默认为整个磁盘（如果未指定）。 wsl --mount --options \u0026lt;MountOptions\u0026gt;：装载磁盘时，可以包括一些特定于文件系统的选项。 例如，wsl --mount -o \u0026quot;data-ordered\u0026quot; 或 wsl --mount -o \u0026quot;data=writeback 之类的 ext4 装载选项。 但是，目前仅支持特定于文件系统的选项。 不支持通用选项，例如 ro、rw 或 noatime。 wsl --unmount \u0026lt;DiskPath\u0026gt;：从所有 WSL 2 发行版中卸载和分离磁盘。 如果未包含 ，则此命令将卸载并分离所有装载的磁盘。 wsl --update\rwsl --list --online\rwsl --install --d Ubuntu-20.04\rsudo apt update \u0026amp;\u0026amp; sudo apt upgrade\rnetsh winsock reset "},{"id":408,"href":"/Tech/8IDE/WSL/WSL2-2%E5%AE%89%E8%A3%85/","title":"Wsl2 2、安装","parent":"WSL","content":" WSL2 安装 安装？ https://docs.microsoft.com/zh-cn/windows/wsl/install\n"},{"id":409,"href":"/Tech/8IDE/WSL/WSL2-3%E6%95%99%E7%A8%8B/","title":"Wsl2 3、教程","parent":"WSL","content":" WSL2 教程 入门？ 更新和升级包 Bash 命令：\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade 建议使用发行版的首选包管理器定期更新和升级包。 对于 Ubuntu 或 Debian，请使用以下命令：\n文件存储 若要在 Windows 文件资源管理器中打开 WSL 项目，请输入：explorer.exe . 请确保在命令的末尾添加句点以打开当前目录。 将项目文件与计划使用的工具存储在相同的操作系统上。 若想获得最快的性能速度，请将文件存储在 WSL 文件系统中，前提是使用 Linux 工具在 Linux 命令行（Ubuntu、OpenSUSE 等）中处理这些文件。 如果是使用 Windows 工具在 Windows 命令行（PowerShell、命令提示符）中工作，请将文件存储在 Windows 文件系统中。 可以跨操作系统访问文件，但这可能会显著降低性能。 "},{"id":410,"href":"/Tech/8IDE/x64dbg/x64dbg/","title":"X64dbg","parent":"x64dbg","content":" x64dbg "},{"id":411,"href":"/Tech/8IDE/%E6%B5%8F%E8%A7%88%E5%99%A8/chrom/","title":"Chrom","parent":"浏览器","content":" 手动强制同步 地址栏输入：chrome://sync-internals中间那列中下方，点击“Stop Sync (Keep Data)”，之后点击“Request Start”两个设备上的Chrome都进行一次这个操作更新：如果不行，重启chrome再重复以上操作\n解除网页鼠标右键被禁 Console:\ndocument.oncontextmenu = null; CSDN未登录禁止复制解决办法 F12 Console面板，复制如下命令粘贴并回车执行。\njavascript:document.body.contentEditable=\u0026#39;true\u0026#39;; document.designMode = \u0026#39;on\u0026#39;; 按下F12进入开发者模式。注意此模式在IE内核中无效。然后在开发者模式中选择Elements面板，找到 id=\u0026ldquo;content_views\u0026rdquo; 这句，将其中的 content_views 删除或者重命名即可。双击即可修改。\n"},{"id":412,"href":"/Tech/8IDE/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8/","title":"浏览器","parent":"浏览器","content":"浏览器\n浏览器历史记录位置： 目录： C:\\Users\\****\\AppData\\Local\\Microsoft\\Edge\\User Data\\Default 文件： WebAssistDatabase 说明： WebAssistDatabase 是一个 SQLite 数据库，用IDEA打开 手动强制同步 地址栏输入：chrome://sync-internals 中间那列中下方，点击“Stop Sync (Keep Data)”，之后点击“Request Start”两个设备上的Chrome都进行一次这个操作更新：如果不行，重启chrome再重复以上操作 CSDN未登录禁止复制解决办法\nF12 Console面板，复制如下命令粘贴并回车执行。 javascript:document.body.contentEditable='true';document.designMode='on'\n按下F12进入开发者模式。注意此模式在IE内核中无效。然后在开发者模式中选择Elements面板，找到 id=\u0026ldquo;content_views\u0026rdquo; 这句，将其中的 content_views 删除或者重命名即可。双击即可修改。\n"},{"id":413,"href":"/Tech/9Archive/CPU-%E9%AB%98%E8%B4%9F%E8%BD%BD%E6%8E%92%E6%9F%A5%E5%AE%9E%E8%B7%B5/","title":"CPU 高负载排查实践","parent":"9、Archive","content":" CPU 高负载排查实践 作者：crossoverJie\nsegmentfault.com/a/1190000019507028\n问题分析 1、首先利用 top -c 将系统资源使用情况实时显示出来 （-c 参数可以完整显示命令）。获得Java应用 pid 接着输入大写 P 将应用按照 CPU 使用率排序，第一个就是使用率最高的程序。 常规操作第二步自然是得知道这个应用中最耗 CPU 的线程到底再干嘛。 2、利用 top -Hp pid 然后输入 P 依然可以按照 CPU 使用率将线程排序。**** pid 是第一步获得的，获得3步所需pid**** 3、这时我们只需要记住线程的 ID 将其转换为 16 进制存储起来，通过 jstack pid \u0026gt;pid.log 生成日志文件，利用刚才保存的 16 进制进程 ID 去这个线程快照中搜索即可知道消耗 CPU 的线程在干啥了。4856 如果你嫌麻烦，我也强烈推荐阿里开源的问题定位神器 arthas 来定位问题。 比如上述操作便可精简为一个命令 thread -n 3 即可将最忙碌的三个线程快照打印出来，非常高效。 最忙绿的线程是一个 GC 线程，也就意味着它在忙着做垃圾回收。 GC 查看 排查到这里，有经验的老司机一定会想到：多半是应用内存使用有问题导致的。 于是我通过 jstat -gcutil pid 200 50 将内存使用、gc 回收状况打印出来（每隔 200ms 打印 50次）。 内存分析 既然是初步定位是内存问题，所以还是得拿一份内存快照分析才能最终定位到问题。 通过命令 jmap -dump:live,format=b,file=dump.hprof pid 可以导出一份快照文件。 这时就得借助 MAT 这类的分析工具出马了。 问题定位 MAT 这个工具，他还能帮你预测出这个内存快照可能出现问题地方同时给出线程快照。 "},{"id":414,"href":"/Tech/9Archive/Web-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AE%80%E5%8F%B2/","title":"Web 浏览器简史","parent":"9、Archive","content":" Web 浏览器简史 标签：Web、浏览器、简史、 时间：2023年4月3日 14点16分 连接：https://www.mozilla.org/zh-CN/firefox/browsers/browser-history/ 世界历史从不缺少史诗般的权力斗争，有征服世界的暴君，也有落败的勇士。Web 浏览器的历史也大抵如此。学术先驱们编写出引发信息革命的简易软件，并为浏览器的优势和互联网用户而战。\n前 Web 时代 1950 年，一台计算机要占据整个房间，性能却比不上现在的袖珍计算器。但技术发展日新月异，到了 1960 年，它们已能运行复杂的程序。全球各国政府和大学都认为，如果这些机器可以相互连通，以促进合作共赢和科学突破，那将是一件大好事。\n阿帕网（ARPANET）是第一个成功的网络连接计划，1969 年，第一条消息从美国加州大学洛杉矶分校（UCLA）计算机科学实验室发送到同样位于加州的斯坦福研究院（Stanford Research Institute, SRI）。\n由此，引发了计算机网络的一场革命。之后不同的网络相继建立，连接了全球的各所大学与研究中心。但在接下来的 20 年里，公众仍无法访问互联网，只有大学与政府机关内的研究人员、学生与私人企业可以使用。有许多程序可以通过电话线在计算机间交换信息，但都算不上好用。真正开放的互联网与第一款 Web 浏览器，直到 1990 年才显露雏形。\nWeb 时代 1990 年，英国计算机工程师蒂姆·伯纳斯·李（Tim Berners-Lee）在瑞士的欧洲核子研究组织（CERN）工作时，开发出首个 Web 服务器与图形化 Web 浏览器。他将这个进入互联网世界的新窗口，称为“WorldWideWeb”（即“万维网”）。这是一款为 NeXT 计算机开发的易于使用的图形化界面浏览器，超文本第一次通过公开网络被链接起来——即我们现在所熟知的 Web。\n一年后，伯纳斯·李（Berners-Lee）委托 CERN 的数学系学生尼古拉·佩洛（Nicola Pellow）编写了“命令行模式浏览器”，这是一款可在简易计算机终端中使用的浏览器。\n到了 1993 年，网络发展突飞猛进。 各所大学、政府机关、私人企业都看到了开放互联网中的机会，每个人都需要新的计算机程序来访问网络。 这一年，美国伊利诺伊大学厄巴纳-香槟分校的美国国家超级计算机应用中心（NCSA）的计算机科学家马克·安德森（Marc Andreessen）开发了 Mosaic，这是第一款流行的 Web 浏览器，也是 Mozilla Firefox 的早期版本。\nNCSA Mosaic 易于使用，又可以在 Windows 计算机运行，让任何拥有 PC 的人都可以浏览早期的网页、聊天室、图库。隔年（1994 年），安德森创立 Netscape 并公开发行了 Netscape Navigator。这是第一款面向普通用户的浏览器，取得了巨大成功。 这也是针对互联网用户的新型战争的开端。\n浏览器大战 来到 1995 年，Netscape Navigator 已不是上网冲浪的唯一选择。计算机软件巨头 Microsoft 获得了旧版 Mosaic 的代码授权，从而建立了自己的“Web 窗口”—— Internet Explorer。该浏览器的推出引发了战争。Netscape 与 Microsoft 竭力为各自的产品推出新版本，试图以更快、更好的产品来超越对方。\nNetscape 设计并推出了 JavaScript，从而让网站拥有了前所未有的强大计算能力。（他们还创造了声名狼藉的 标签。）而 Microsoft 一方也反对后来成为网页设计标准的层叠样式表（CSS）。\n1997 年，Microsoft 发行了 Internet Explorer 4.0，事情逐渐失控。Microsoft 团队制作了一个大大的字母“e”并放在 Netscape 总部的草坪上。Netscape 团队迅速敲碎了这个巨大的字母，并将吉祥物 Mozilla 恐龙放在上面。\n接下来，Microsoft 开始将 Internet Explorer 与 Windows 操作系统捆绑发行。四年内，IE 获得了 75% 的市场份额，到 1999 年甚至达到了 99% 。此举最终使 Microsoft 面临反垄断诉讼。意识到垄断浏览器市场并不符合用户与开放网络的最佳利益后，Netscape 决定开放源代码，转型为非营利的 Mozilla，并于 2002 年发布 Firefox。到了 2010 年，Mozilla Firefox 及其他浏览器将 Internet Explorer 的市场份额降低到 50%。\n浏览器市场在上世纪 90 年代末和本世纪初涌现出许多竞争者，包括 Opera、Safari、Google Chrome。2015 年，Microsoft 发布 Windows 10，用 Microsoft Edge 取代了 Internet Explorer。\n现今的 Web 环境 Firefox、Google Chrome、Microsoft Edge、Safari 与 Opera 是市场中主要的竞争者。在过去的十年中，移动设备已成为访问互联网的首选方式。 目前，大多数用户只使用移动浏览器与应用程序来上网。主流浏览器也都提供了适用于 iOS 及 Android 设备的移动版本。尽管这些应用程序在特定用途上相当好用，但只提供了受限的上网功能。\n在未来，Web 可能会跳脱原始的超文本，提供各式不同而广阔的互动式体验。虚拟现实已经出现了几十年（从 1992 年的《割草者（Lawnmower Man）》 与 1995 年的任天堂 Virtual Boy 算起），但 Web 最可能将其带入大众。Firefox 已经支持 WebVR 与 A-Frame，可让开发者快速便捷地构建虚拟现实网站。大多数现代移动设备都支持 WebVR，可以将手机插入简单的纸盒中，变成 VR 头戴设备。由科幻小说家尼尔·斯蒂芬森（Neal Stephenson）所描绘的 3D 虚拟现实 Web 世界可能已经离我们不远。如果是这样的话，网页浏览器可能会融入为另一个世界的真实入口。\n无论 Web 未来如何发展，Mozilla 与 Firefox 都将坚持为用户提供服务，确保用户拥有强大的工具来遨游网络。我们相信 Web 是属于所有人的，每个人都有权掌控自己的上网体验。这也是为什么我们在 Firefox 中提供各种能够保护用户隐私的工具，并且我们绝不会向广告商出售用户数据。\n资源 https://en.wikipedia.org/wiki/Mosaic_(web_browser) https://en.wikipedia.org/wiki/History_of_the_web_browser https://en.wikipedia.org/wiki/History_of_the_Internet https://en.wikipedia.org/wiki/Browser_wars https://home.cern/topics/birth-web https://www.zdnet.com/article/before-the-web-the-internet-in-1991/\n"},{"id":415,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/","title":"-随笔","parent":"2、Diary","content":"-随笔\n"},{"id":416,"href":"/Life/1Book/","title":"1、Book","parent":"Life","content":"1、Book\n"},{"id":417,"href":"/Tech/1Book/","title":"1、Book","parent":"Tech","content":"1、Book\n"},{"id":418,"href":"/Tech/2Computer-Science/1Crash-Course-Computer-Science/","title":"1、Crash Course Computer Science","parent":"2、Computer Science","content":"1、Crash Course Computer Science\n"},{"id":419,"href":"/Tech/6Technical-Topics/1Math/","title":"1、Math","parent":"6、Technical Topics","content":"1、Math\n"},{"id":420,"href":"/Tech/10Miscellaneous/","title":"10、Miscellaneous","parent":"Tech","content":"10、Miscellaneous\n"},{"id":421,"href":"/Tech/2Computer-Science/","title":"2、Computer Science","parent":"Tech","content":"2、Computer Science\n"},{"id":422,"href":"/Tech/2Computer-Science/2Data-Structure-Algorithms/","title":"2、Data Structure \u0026 Algorithms","parent":"2、Computer Science","content":"2、Data Structure \u0026amp; Algorithms\n"},{"id":423,"href":"/Life/2Diary/","title":"2、Diary","parent":"Life","content":"2、Diary\n"},{"id":424,"href":"/Tech/6Technical-Topics/2%E5%89%8D%E7%AB%AF/","title":"2、前端","parent":"6、Technical Topics","content":"2、前端\n"},{"id":425,"href":"/Life/2Diary/2018/","title":"2018","parent":"2、Diary","content":"2018\n"},{"id":426,"href":"/Life/2Diary/2019/","title":"2019","parent":"2、Diary","content":"2019\n"},{"id":427,"href":"/Life/2Diary/2020/","title":"2020","parent":"2、Diary","content":"2020\n"},{"id":428,"href":"/Life/2Diary/2021/","title":"2021","parent":"2、Diary","content":"2021\n"},{"id":429,"href":"/Life/2Diary/2022/","title":"2022","parent":"2、Diary","content":"2022\n"},{"id":430,"href":"/Tech/2Computer-Science/3Design-Patterns/","title":"3、Design Patterns","parent":"2、Computer Science","content":"3、Design Patterns\n"},{"id":431,"href":"/Tech/6Technical-Topics/3IDEA/","title":"3、IDEA","parent":"6、Technical Topics","content":"3、IDEA\n"},{"id":432,"href":"/Tech/3Java/","title":"3、Java","parent":"Tech","content":"3、Java\n"},{"id":433,"href":"/Life/3Music/","title":"3、Music","parent":"Life","content":"3、Music\n"},{"id":434,"href":"/Tech/6Technical-Topics/4Flutter/","title":"4、Flutter","parent":"6、Technical Topics","content":"4、Flutter\n"},{"id":435,"href":"/Tech/2Computer-Science/4Operating-System/","title":"4、Operating System","parent":"2、Computer Science","content":"4、Operating System\n"},{"id":436,"href":"/Tech/4Other-Language/","title":"4、Other Language","parent":"Tech","content":"4、Other Language\n"},{"id":437,"href":"/Tech/2Computer-Science/5Computer-Networks/","title":"5、Computer Networks","parent":"2、Computer Science","content":"5、Computer Networks\n"},{"id":438,"href":"/Tech/5English-Learning/","title":"5、English Learning","parent":"Tech","content":"5、English Learning\n"},{"id":439,"href":"/Tech/6Technical-Topics/5WorkflowEngine/","title":"5、WorkflowEngine","parent":"6、Technical Topics","content":"5、WorkflowEngine\n"},{"id":440,"href":"/Tech/2Computer-Science/6Database/","title":"6、Database","parent":"2、Computer Science","content":"6、Database\n"},{"id":441,"href":"/Tech/6Technical-Topics/","title":"6、Technical Topics","parent":"Tech","content":"6、Technical Topics\n"},{"id":442,"href":"/Tech/7Security/","title":"7、Security","parent":"Tech","content":"7、Security\n"},{"id":443,"href":"/Tech/8IDE/","title":"8、IDE","parent":"Tech","content":"8、IDE\n"},{"id":444,"href":"/Tech/9Archive/","title":"9、Archive","parent":"Tech","content":"9、Archive\n"},{"id":445,"href":"/Tech/3Java/Apache-Flink/","title":"Apache Flink","parent":"3、Java","content":"Apache Flink\n"},{"id":446,"href":"/Tech/3Java/Apache-Shiro/","title":"Apache Shiro","parent":"3、Java","content":"Apache Shiro\n"},{"id":447,"href":"/Tech/1Book/Beginning-C-Fifth-Edition/","title":"Beginning C ,Fifth Edition","parent":"1、Book","content":"Beginning C ,Fifth Edition\n"},{"id":448,"href":"/Tech/4Other-Language/C/","title":"C","parent":"4、Other Language","content":"C\n"},{"id":449,"href":"/Tech/8IDE/Cmake/","title":"Cmake","parent":"8、IDE","content":"Cmake\n"},{"id":450,"href":"/Tech/5English-Learning/Coding-English/","title":"Coding English","parent":"5、English Learning","content":"Coding English\n"},{"id":451,"href":"/Tech/8IDE/Docker/","title":"Docker","parent":"8、IDE","content":"Docker\n"},{"id":452,"href":"/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/","title":"Docker 命令","parent":"Docker","content":"Docker 命令\n"},{"id":453,"href":"/Tech/8IDE/Docker/DockerDocs/","title":"DockerDocs","parent":"Docker","content":"DockerDocs\n"},{"id":454,"href":"/Tech/3Java/FreeMarker/","title":"FreeMarker","parent":"3、Java","content":"FreeMarker\n"},{"id":455,"href":"/Tech/8IDE/Git/","title":"Git","parent":"8、IDE","content":"Git\n"},{"id":456,"href":"/Tech/8IDE/Git/Git-%E5%91%BD%E4%BB%A4/","title":"Git 命令","parent":"Git","content":"Git 命令\n"},{"id":457,"href":"/Tech/4Other-Language/GoLang/","title":"GoLang","parent":"4、Other Language","content":"GoLang\n"},{"id":458,"href":"/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/","title":"Go入门指南","parent":"1、Book","content":"Go入门指南\n"},{"id":459,"href":"/Tech/6Technical-Topics/Hugo/","title":"Hugo","parent":"6、Technical Topics","content":"Hugo\n"},{"id":460,"href":"/Tech/3Java/Java-Code/","title":"Java Code","parent":"3、Java","content":"Java Code\n"},{"id":461,"href":"/Tech/3Java/Java-FX/","title":"Java FX","parent":"3、Java","content":"Java FX\n"},{"id":462,"href":"/Tech/3Java/Java-Version/","title":"Java Version","parent":"3、Java","content":"Java Version\n"},{"id":463,"href":"/Tech/3Java/Java-%E5%91%BD%E4%BB%A4/","title":"Java 命令","parent":"3、Java","content":"Java 命令\n"},{"id":464,"href":"/Tech/4Other-Language/JavaScript/","title":"JavaScript","parent":"4、Other Language","content":"JavaScript\n"},{"id":465,"href":"/Tech/3Java/jvm/","title":"jvm","parent":"3、Java","content":"jvm\n"},{"id":466,"href":"/Life/","title":"Life","parent":"Save Load","content":"Life\n"},{"id":467,"href":"/Tech/8IDE/Linux/","title":"Linux","parent":"8、IDE","content":"Linux\n"},{"id":468,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/","title":"make progress every day","parent":"新概念","content":"make progress every day\n"},{"id":469,"href":"/Tech/3Java/maven/","title":"maven","parent":"3、Java","content":"maven\n"},{"id":470,"href":"/Tech/3Java/MQ/","title":"MQ","parent":"3、Java","content":"MQ\n"},{"id":471,"href":"/Tech/3Java/MyBatis/","title":"MyBatis","parent":"3、Java","content":"MyBatis\n"},{"id":472,"href":"/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/","title":"MyBatis 教程","parent":"MyBatis","content":"MyBatis 教程\n"},{"id":473,"href":"/Tech/2Computer-Science/4Operating-System/NTFS/","title":"NTFS","parent":"4、Operating System","content":"NTFS\n"},{"id":474,"href":"/Tech/8IDE/Git/Pro-Git-Simple/","title":"Pro Git  Simple","parent":"Git","content":"Pro Git Simple\n"},{"id":475,"href":"/Tech/8IDE/Redis/","title":"Redis","parent":"8、IDE","content":"Redis\n"},{"id":476,"href":"/Tech/4Other-Language/rust/","title":"rust","parent":"4、Other Language","content":"rust\n"},{"id":477,"href":"/","title":"Save Load","parent":"","content":"欢迎来到 Save Load.\n"},{"id":478,"href":"/Tech/7Security/scz/","title":"scz","parent":"7、Security","content":"scz\n"},{"id":479,"href":"/Tech/3Java/Spring/","title":"Spring","parent":"3、Java","content":"Spring\n"},{"id":480,"href":"/Tech/3Java/Spring/Spring-Boot/","title":"Spring Boot","parent":"Spring","content":"Spring Boot\n"},{"id":481,"href":"/Tech/3Java/Spring/Spring-Cloud/","title":"Spring Cloud","parent":"Spring","content":"Spring Cloud\n"},{"id":482,"href":"/Tech/3Java/Spring/Spring-Framework/","title":"Spring Framework","parent":"Spring","content":"Spring Framework\n"},{"id":483,"href":"/tags/","title":"Tags","parent":"Save Load","content":""},{"id":484,"href":"/Tech/","title":"Tech","parent":"Save Load","content":"Tech\n"},{"id":485,"href":"/Tech/1Book/The-Rust-Programming-Language/","title":"The Rust Programming Language","parent":"1、Book","content":"The Rust Programming Language\n"},{"id":486,"href":"/Tech/1Book/Thinking-In-Java/","title":"Thinking In Java","parent":"1、Book","content":"Thinking In Java\n"},{"id":487,"href":"/Tech/3Java/Thread/","title":"Thread","parent":"3、Java","content":"Thread\n"},{"id":488,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/tombkeeper/","title":"tombkeeper","parent":"他人存档","content":"tombkeeper\n"},{"id":489,"href":"/Tech/10Miscellaneous/Toolkit/","title":"Toolkit","parent":"10、Miscellaneous","content":"Toolkit\n"},{"id":490,"href":"/Tech/8IDE/Linux/Ubuntu/","title":"Ubuntu","parent":"Linux","content":"Ubuntu\n"},{"id":491,"href":"/Tech/4Other-Language/Vue/","title":"Vue","parent":"4、Other Language","content":"Vue\n"},{"id":492,"href":"/Tech/8IDE/Window/","title":"Window","parent":"8、IDE","content":"Window\n"},{"id":493,"href":"/Tech/8IDE/WSL/","title":"WSL","parent":"8、IDE","content":"WSL\n"},{"id":494,"href":"/Tech/8IDE/x64dbg/","title":"x64dbg","parent":"8、IDE","content":"x64dbg\n"},{"id":495,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/","title":"计算机科学导论（原书第3版）","parent":"1、Book","content":"计算机科学导论（原书第3版）\n"},{"id":496,"href":"/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/","title":"计算机网络：原理、协议和实践，第三版","parent":"1、Book","content":"计算机网络：原理、协议和实践，第三版\n"},{"id":497,"href":"/Tech/1Book/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","title":"加密与解密","parent":"1、Book","content":"加密与解密\n"},{"id":498,"href":"/Tech/8IDE/%E6%B5%8F%E8%A7%88%E5%99%A8/","title":"浏览器","parent":"8、IDE","content":"浏览器\n"},{"id":499,"href":"/Tech/2Computer-Science/1Crash-Course-Computer-Science/%E5%85%A840%E9%9B%86%E4%B8%AD%E8%8B%B1%E5%AD%97%E5%B9%95%E6%96%87%E6%9C%AC/","title":"全40集中英字幕文本","parent":"1、Crash Course Computer Science","content":"全40集中英字幕文本\n"},{"id":500,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"深入理解Java虚拟机","parent":"1、Book","content":"深入理解Java虚拟机\n"},{"id":501,"href":"/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","title":"深入理解计算机系统","parent":"1、Book","content":"深入理解计算机系统\n"},{"id":502,"href":"/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/","title":"数据结构与算法（Java 描述）","parent":"1、Book","content":"数据结构与算法（Java 描述）\n"},{"id":503,"href":"/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/","title":"算法导论","parent":"1、Book","content":"算法导论\n"},{"id":504,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/","title":"他人存档","parent":"-随笔","content":"他人存档\n"},{"id":505,"href":"/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/","title":"文件 IO 简明概述","parent":"1、Book","content":"文件 IO 简明概述\n"},{"id":506,"href":"/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/","title":"我的","parent":"-随笔","content":"我的\n"},{"id":507,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/","title":"新概念","parent":"5、English Learning","content":"新概念\n"},{"id":508,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/","title":"新概念1","parent":"新概念","content":"新概念1\n"},{"id":509,"href":"/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E9%9F%B3%E6%A0%87/","title":"音标","parent":"新概念","content":"音标\n"}]
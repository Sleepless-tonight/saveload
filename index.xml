<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Save Load</title>
    <link>https://www.saveload.cn/</link>
    <description>Recent content on Save Load</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.saveload.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/1Book/Book/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/1Book/Book/</guid>
      <description>Book</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%B8%B8%E8%A4%92%E7%A6%85%E5%B1%B1%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%B8%B8%E8%A4%92%E7%A6%85%E5%B1%B1%E8%AE%B0/</guid>
      <description>王安石的《游褒禅山记》中学应该都学过。我记得好像还要求全文背诵。这篇文字并不艰深，里面讲的道理也并不复杂。如果你当年一直把这个道理记在心里，可能现在有些事会不同：
夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%B8%80%E7%94%9F%E5%9B%9B%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%B8%80%E7%94%9F%E5%9B%9B%E8%AF%8D/</guid>
      <description>一生四词：虚掷，空投，蹉跎，错付。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/tombkeeper/2005-10-02-tombkeeper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/tombkeeper/2005-10-02-tombkeeper/</guid>
      <description>tombkeeper 2005.10.02
这两天论坛上又有人开始抱怨世风日下，大家都现实了，都不开放了，不交流了。对这种“月经贴”，我基本上已经习惯了，不过因为吃了粉皮炖鸡，心情比较好，于是就说了两句。
三四年前，当时我对人性的看法还不像现在这样。有几个人加了我的QQ，说想学Windows，我居然就好为人师起来，自不量力地教人学Windows。我很天真地把自己的经验告诉他们：
一、先把Windows的帮助文件从头到尾看一遍。
二、在Windows目录下搜索*.txt、.htm?、.log、*.ini，把每一个文件内容都看一遍。
三、把注册表浏览一遍。
没有诀窍，也不用花钱买书。任何人把这三步做完之后，只要不是傻子，在Windows应用方面都可以非常熟练。并且如果想进一步学，也自然知道应该去看什么了。
结果甚至没有一个人能看完Windows帮助文件，看完三分之一的都没有，都说看不下去。我很奇怪，我看Windows的帮助文件就像看金庸小说一样愉快，怎么会有人觉得辛苦？
后来我想明白了：因为我爱她，而他们不爱她，只是想占有她而已。
他们要的不是交流，不是开放，甚至也不是想找个人“拜师”，他们想要的不是郭靖遇到的洪七公，而是虚竹遇到的无涯子。
再后来，一个偶然的机会，我看到了小四同学写的那篇《你尽力了么？》，才知道原来这不只是我一个人的看法。
这两天在家，在笔记本上折腾Linux，遇到了很多问题，我就把内核每一个编译选项的说明都细细看了一遍，反复编译上二十多遍——然后，所有问题的答案都找到了。显然，学Linux和学Windows的方法并没有什么不同。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E8%BF%99%E5%87%A0%E5%A4%A9%E5%81%9A%E5%B0%81%E9%97%AD%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%87%E8%91%A9%E4%BA%8B%E5%84%BF%E8%B7%9F%E4%BD%A0%E4%BB%AC%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E8%BF%99%E5%87%A0%E5%A4%A9%E5%81%9A%E5%B0%81%E9%97%AD%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%87%E8%91%A9%E4%BA%8B%E5%84%BF%E8%B7%9F%E4%BD%A0%E4%BB%AC%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B/</guid>
      <description>这几天做封闭规划的奇葩事儿跟你们总结一下：
1、这些人坚信现在的f腐是zz斗争，是铲除异己。
2、觉得现在是倒退，无限怀念hw十年。我一脸好奇：“你们说得对，那十年确实很好，就跟飞国际航线的机组，觉得三十年前好一样，他们从外国飞回来的时候，可以带洋货回来，自用也可以买卖赚钱，在国际航线机组人员看，我国其实不是倒退十年，而是倒退三十年，是不是这个意思？”专家：“那话不能这么说。”“那该怎么说？您教我一下？”
3、坚信票选制是好的，因为全世界有更多国家在用这种方式。我：“可是这里大部分是失败的国家。”专家：“那也不可否认的是更多人在用这种模式，更多人用一定有他合理的一面。”我：“所以制度的目的不是为了结果，而是为了制度本身？那你们坐在这里那么辛苦干活为了啥？是为了工作本身而不是为了报酬？那干嘛不打报告给人力说下个月义务干活，别发工资了？”
4、做宏观研究也很从众，把市场上的普遍观点，比如把各路券商的研报，收拢在一起，然后东拼西凑后，搞出一份报告。
5、问他们知道不知道mz与zy其实概念上矛盾的，西方人的mz是多数人暴z的意思，所以制度建设上要千方百计预防这种倾向，他们一脸懵逼。“你们知道托克维尔就很反这种mz吗？等等，我还是不难为您了，这个问题你们别回答了，换一个，您知道托克维尔是哪个国家的吗？代表作有哪些？”
6、他们无法理解“西方如果有主义的话，归根到底只有一种，就是zy主义”。跟他们说“你们最向往的美国，其实政治制度是很反mz的”，他们不信，甚至连什么是选举人团都不知道。“你们知道你们欣赏的美国国父们设计制度的时候，也千方百计预防你们欣赏的mz吗？他们称之为民粹。你们看过《联邦党人文集》、《联邦论》还有《汉密尔顿传》吗？什么？没有看过？那我跟你们说不上话了。”
7、他们不知道西式zy主义所推崇的个人主义，本质是对千年zj压迫的反抗。提到zj，他们的第一反应是中国人没信仰。
8、他们不知道美国的关税历史，不知道美国退出国联、割裂世界贸易体系，间接导致了二战；不知道美国在欧洲战场上，其实是下山摘桃子的；不知道直至1950年前，美国一直都是高关税壁垒、高贸易壁垒，所以不懂得“孤立主义”。我笑了。
9、他们坚定地捍卫比自己更富上百倍万倍的人的财富，认为这是他们的奋斗所得。同时认为咱们国家应该像美国一样征收遗产税。我：“美国的遗产税其实有很成熟的避税方式，其实这个制度并不管用。”行研员：“那起码有一套这样的制度啊，如果连制度都没有如何避免阶层固化？”他似乎忘了前面还挺热衷捍卫富人的财富。
10、他们觉得如果我们和美国打战，应该是先上常规武器的，无法理解我这种上来就要甩30个氢弹是什么意思。“为什么上来就要核武器？至于到那一步吗？”他们无法理解大国战争是你死我活的，就该上手甩氢弹甚至连美国已经没有现役氢弹都不知道。
11、行研员觉得扶贫是违背市场规律的，如果赚钱的话，市场自然会去扶贫。如果市场不扶贫，那么扶贫就是错的。行研员是湖南农村出身，和这群专家一样，都有农村生活经历，但现在坚信市场是对的，然后急切想抛弃他们的农村老乡。
12、我跟他们讲商品和货币的关系时，他们下意识地认为这是马列主义的观点，是洗脑。我只能微笑地告诉他们，“不，这是市场经济鼻祖亚当斯密的观点，是美国经济学家、诺贝尔奖获得者弗里德曼的观点”。这些人连《国富论》这类经典都没通读过，就可以服服帖帖地崇拜市场；同样，连马列主义经典都不知悉，就有勇气抨击别人是被洗脑了，也不知道谁的脑子被洗了。连亚当斯密和弗里德曼的思想都打不过，怎么就敢叫阵马列？无知者无畏？
13、他们抨击红x代，但无视美国子承父业当总统、妻承夫业选总统，还觉得那是美国人民自己的选择。
14、崇尚西式zy的他们，却连个车胎都不会自己换，这种人如果在美国广袤的中部开车爆胎，该如何实现自己自己的zy？而且只许他们zy，却不许森林的树木zy。 专家：“瑞士的森林可好了，很美，很整齐，你看我们山上那些树长得乱糟糟的。” 我；“瑞士海拔高、纬度高，气温低，森林树种的多样性较低，树种少，藤本、草本少，大型裸子植物多，自然看起来整齐。深圳更温暖，森林树种的多样性更高，看起来乱也很正常，而且多样性高的森林，其实有更强的抗病能力和稳定性。”
15、动不动就怪gcd，比如说自己没做好风控的情况下，逆周期扩张，吃了一波坏账，怪gcd体制，可是你们都是一个自诩为市场化金融机构的风控人员诶，甩锅姿势不能这么优雅的。
16、安排工作后，属下交差，原稿不满意，提了新要求，发回重改，然后看了修改稿之后发现把原稿的内容改没了，就来一句“我让他改东西，他就把原来有用的全改了，唉，中国人容易走极端”。话说自己工作没沟通好，是可以甩锅中国人的？欧洲那种不是无政府就是法西斯，看来还真是中庸极了。
17、群里分享明年基建计划，一阵预期明年经济差，政府在兜底。我：“巴菲特抄底美股和美油，是嗅觉敏锐而不是资金自救，而我国在低成本时搞基建扩张，就是被迫刺激经济？为什么双重标准？”
18、另外一个差别是，他们都是gcd员，而我是d外人士。[微笑][微笑][微笑]
附：鉴于60后、70后、80后抗议，我改一下第18条。有人质疑我为什么不讲道理，任意拉黑，拜托，讲道理是双向的。还有人在这个吐槽贴上寻找什么成体系的逻辑，你们该去找老师上课，而不是看我吐槽。mmp，睡觉去。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%AA%E5%8A%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%AA%E5%8A%9B/</guid>
      <description>有时候别人会问，你为什么要这么拼呢？平平淡淡的日子不也是一生吗？ 对不起，我不想和无知庸碌的人为伍，我不愿跟审美低下的人同行，我不能与道德缺失的人作伴。 所以，就得往上冲。 盘古开天的时候，清而轻者上升为天，浊而拙者下沉为地。 美好在上面，不美好在下面。 为什么一定要去一线城市啊，为什么去北上广深啊，因为我想撞的是山，不想撞的是墙。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%BA%BA%E7%94%9F%E7%9A%84%E6%84%8F%E4%B9%89/</guid>
      <description>作者：AI Fuzz 链接：https://www.zhihu.com/question/20518940/answer/233132972 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
人生的意义
因为意义是外物赋予的，而人生的本质，不能由他人决定，也不由物化的标准评判。人并不是某种标签或者集合，主体的每一种行为，无一不昭示其本质，故其不籍意义而存在。
我不为什么东西而生，也不为什么东西而死，不需要任何标签化的认同，不作为什么而存在，不需要任何标签化的定义，不需要任何标签化的解释。
不自信的一个特点是：被看低、嘲讽，拒绝后内心会非常抵触和敏感、沮丧。
喜欢就改变它，仇恨就超越它
（改变他的原因是他不可能完全符合内心的标准？还是因为自私？当时很理解这句话，现在有点不理解了。。。 ）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%BD%95%E4%BB%A5%E8%90%A7%E5%A3%B0%E9%BB%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E4%BD%95%E4%BB%A5%E8%90%A7%E5%A3%B0%E9%BB%98/</guid>
      <description>首先我没有看过电视剧也未曾看过原著，纯粹是吐槽来着，玻璃心退避。不是顺口就好了啊，不是对偶就好了，只求对偶那是对联啊，这是这句东西犯的错：孤平仄、半文半白（既然是现代汉语用法啊！）、虚词多余实词、形容词强行做动词，你考虑过人家“默”的感受么？意向强行组合、，还有这么多乐器我都没见过真的，其实我真是一个没见过世面的逗比。大众文学么、矫情么，网文么，不能要求太多，毕竟谁没个青春啊，谁没点情怀啊（我确定罗永浩是个SB）。我不是对它要求太对，是社交平台被刷屏（长期）不爽啊，好烦这种存在感太强的东西。琼瑶奶奶都不敢拽古文，现在这些小屁孩哪来的胆子啊，无知者无畏啊？我是不是要鼓励这种二x精神啊。文法、对偶、格、律、音律。还不如：不悔梦归处，只恨太匆匆。以下还有我整理的网友吐槽。如果说平仄，（仄平平仄仄，平仄平平仄—不是律句，连靠近点古风平仄都不能！）今天天气真好啊。周杰伦当年感觉水平一般还能拽出几句古文来，好像有一句rap；胡言岂一派，风生谈笑中。竟然感觉甩这这感觉甩这几条街了，（不要提许嵩，提它我会疯）、天王盖地虎，宝塔镇河妖也比这强啊。1既然牙已洗，何以又吃馍？2、天网恢恢，地塞米松， 寻道南山，盘尼西林。
安非他命，如是我闻，
镜花水月，诺氟沙星。3既然琴瑟起，何以笙萧默？
感觉文学界，还要学习个。
人生的经验，作为一长者；
西方的国家，哪个没去过？
我和华莱士，谈笑在美国！
就有一个好，你们这作者；
但是编口号，图样图森破。
是什么意思，你们来问我；
我的解释权，也很重要的！4、当郭德纲那首著名的诗
一去残冬晓日红，三杯泪酒奠苍穹。
鸡肠曲曲今何在，始信人间报应灵。
被网民们称作打油诗的时候，我有一位慧眼爱德纲的学妹义愤填膺地指出，
“那些说它是打油诗的长眼了么，这明明是首七绝”。
向来热爱学妹和祖国花朵的我忍不住想要端正一下学妹的语文基础常识，劝她道，
“其实吧，管它叫打油诗已经算是给面子了，因为打油诗都要求第二、四句押韵呢。至于七绝，不是我说啊，格律实在是太严格了，咱还是不高攀这名号了吧。”
学妹说。。。。
“呵呵哒。”
然后把我拖黑了。
“哎学妹，等等啊学妹！学长改答案还不行么？”</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%85%B8%E5%9E%8B%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%85%B8%E5%9E%8B%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF/</guid>
      <description>微博上出现最多的典型逻辑错误
不管你罗列什么逻辑，它们都必须遵循自身的规律。违反者有二：一，逻辑思维不清晰。二，有意而为。它在不同的时间与空间里，能产生核聚，亦能发生核爆。这些错误包括：偷换概念、偷换论题、自相矛盾、模棱两可、循环定义、同语反复、概念不当并列、因果倒置、循环论证、难于推理其逻辑思维等。如：排中律的逻辑要求是：对于是非问题必须作出明确而肯定的回答。否定了其中的一个，就必须肯定另一个。否则要犯“两不可”的逻辑错误。但当下人们并不在意这些错误，因为这些错误在特定的条件下，会带来难于估量的利润和不可多得的利益。
让我们来看看而写错误的本质是什么吧。
1.同语反复 例如：乐观主义者就是乐观地对待生活的人。
2.循环定义
例如：如果把丈夫定义为妻子的爱人，那么，妻子就是丈夫的爱人。
3.概念不当并列
例如：音乐分为古典音乐、乡村音乐、流行音乐和民族音乐等。
4.偷换概念
例如：司马光说：“我要去看花灯。”
司马光夫人说：“家中这么多灯，何必去看？”
司马光夫人说：“我要去看游人。”
司马光说：&amp;lsquo;家中这么多人，何必出去看？&amp;rsquo;
5.转移论题
例如：“我以为中学生没有必要学习地理。整个国家的地形和位置完全可以和这个国家的历史同时学习。我主张可以把历史课和地理课合并，这样对学生是方便的。”
6.自相矛盾
例如：“这件事情我没有问过，只是侧面了解一下情况，提点意见，仅供参考。”
7.两不可
例如：“这篇文章的观点不能说是全面的，也不能说是片面的。”
8.以偏概全
这是不正确构造简单枚举归纳推理时出现的逻辑错误。
9.循环论证
这种错误发生在一个论证中，论据的证明需要依赖前提的情况。
10.倒置因果
例如：为了加快我国的发展，必须大力发展航天工业。因为在发达国家，航天工业发展很快。
常见逻辑错误例析
摘要：逻辑有其自身的规律，如果违反其规律,人们的思维就会出现错误.常见的逻辑错误有偷换概念、偷换论题、自相矛盾、模棱两可、循环定义、同语反复、概念不当并列、因果倒置、循环论证、推不出等。
逻辑的规律：
逻辑有其自身的规律，不管使用什么概念和命题，进行何种推理和论证,都必须遵守最基本的逻辑规律.
否则，人们的思维就会出现错误。常见的逻辑错误有偷换概念、偷换论题、自相矛盾、模棱两可、循环定义、同语反复、概念不当并列、因果倒置、循环论证、推不出等。
一、偷换概念、偷换论题
在同一思维过程中，每一个思想必须与其自身保持同一，这是同一律的要求。可用公式表示：A是A，A表示 一个概念或命题。一个概念反映什么对象就反映什么对象，在同一语言环境中，它不能既反映这类对象，又反映彼类对象。在概念上有意识地违背同一律的要求而出现的逻辑错误,逻辑上称之为“偷换概念”.
其特点是有意不明确某个概念的含义，进而在这个概念中塞进新的含义。商家“买一赠一”的促销广告，玩的就是“偷换概念”的把戏。两个“一”的概念内涵大不相同，“买一”的
存储设备上的逻辑错误：
“一”是你要买的东西，比如：一件西服，“赠一”的“一”，如果你也理解成一件西服，那就太幼稚了。这个“一” 有可能是一根领带或一个精美的袋子而已，决不会是一件西服。
在概念的运用方面，有的人是不了解某个概念的确切含义，以至在后面运用这一概念时改变了这一概念的含义。这种错误叫做&amp;rsquo;混淆概念&amp;rsquo;。
同一律还要求，在同一思维过程中一个命题肯定什么就肯定什么，否定什么就否定什么。一个命题必须具有确定的“真”、“假”意义。我们把不自觉地违背同一律的逻辑错误称为“转移论题”。其表现为在说话或论述中，把所要说明或论证的问题无意识地变成了另外的问题。比如小孩子讲话，前言不搭后语，即属于此。
对于在命题上有意识地违背同一律的要求而出现的逻辑错误，逻辑上称之为“偷换论题”。其表现是有意识地改变论题内容，偷梁换柱，从而达到某种目的。例如清朝时，某一书生坐于高台之上读书,台高风大,吹得书页哗哗乱翻，书生随口吟出两句诗：“清风不识字，何故乱翻书？”居心叵测之人有意歪曲“清”字的含义，诬陷书生讽刺清廷没文化，犯了大不敬罪。
二、自相矛盾
在同一思维过程中，两个互相矛盾或互相反对的思想不能都是真的，其中必有一个是假的，这是矛盾律的要求。可用公式表示：A不是非A，A表示一个概念或一个命题。一个概念不能既是它，又不是它，就好像一个人，不能既是人又不是人；一个命题不能既肯定某一对象又否定这一对象。违反矛盾律的要求而出现的逻辑错误，称之为“自相矛盾”。比如那个著名的卖矛与盾的楚人的笑话：他夸口自己的盾非常坚实，任何东西都不能穿过；又夸口自己的矛锐利无比，能刺穿任何东西。他犯的错误就是典型的自相矛盾。再如有人说“一个月来，这个问题时刻缠绕着我，而在非常繁忙或心情非常好的时候，我又暂时抛开了这一问题，顾不上去想它了。”既是“时刻缠绕着我”,就不会出现“顾不上去想它”的情况说话人也犯了“自相矛盾”的错误。
三、模棱两可
两个相互矛盾的思想不能都是假的，其中必有一个是真的，这是排中律的要求。可用公式表示：A或者非A，A表示一个概念或一个命题。在同一思维过程中，如果A不反映某一对象，那么非A便反映这个对象。比如这个人是学生，他要么属于“中专生”，要么属于“非中专生”，二者必居其一，不能同假。
任何命题或者肯定某对象具有某种情况，或者否定某对象具有这种情况，二者必居其一，两个相互矛盾的命题不能同假。它要求在两个相互矛盾的思想中，必须旗帜鲜明地承认一个是真的。如果违背了这一要求，既不承认这个，又不承认那个，含混模糊，那就犯了“模棱两可”的逻辑错误。由于这种逻辑错误的特征是对两个相互矛盾的思想都予以否定，因此，又有人把这种错误称为“模棱两不可”。
楚人夸口自己的矛与盾，当别人反问他：用你的矛穿你的盾如何时，他既没有做出“我的矛能穿过我的盾”的回答，也没有回答“我的矛不能穿过我的盾”，这就表示他既否定了A又否定了非A，从逻辑上讲，他的沉默就违反了排中律。也就是说，楚人回答任何一句都违反了矛盾律，一句不回答又违反了排中律。 当人们对一组矛盾的命题缺乏足够的认识时，不能明确地肯定什么或否定什么，这种情况不能诊断为违背了排中律。比如“火星上有生命”，“火星上没有生命”，这是一组矛盾命题。虽然其中必有一真，但人们却不能明确表态。另外，对于不是矛盾关系的概念或命题，都加以否定，也不是违反了排中律。如“今天不会下雨也不会下雪”。“下雨”或“下雪”不具有矛盾关系，所以可以同时否定。
四、循环定义、同语反复
定义是揭示概念内涵的逻辑方法，就是用简明的语句概括地说明对象的本质属性。定义由被定义项、定义项和定义联项三部分组成。被定义项就是通过定义来揭示其内涵的概念；定义项就是用来揭示被定义项内涵的概念；联结被定义项和定义项组成定义的概念是定义联项。下定义有一定的规则，它要求定义项不能直接或间接地包含被定义项。如果直接包含被定义项，那就犯了“同语反复”的逻辑错误；如果间接包含被定义项，那就犯了“循环定义”的逻辑错误。例如“顶针就是一种运用顶针手法的修辞格”。用“顶针手法”去说明“顶针”，这等于什么也没有说。这一定义就犯了“同语反复”的错误。再如“如果把‘奇数’定义为‘偶数加一’，那么‘偶数’是‘奇数加一’得到的数”。用“偶数”解释“奇数”，用“奇数”解释“偶数”，这一定义就犯了“循环定义”的错误。
五、概念不当并列
概念并列问题属于概念划分的范围。所谓划分，是明确概念外延的逻辑方法，即依据某一概念，把一个属概念分为若干子概念。划分由三部分组成，即划分的母项、划分的子项和划分的标准。其中，被划分的对象称为划分的母项；从母项中划分出来的概念，称为划分的子项；划分的依据通常是事物的某一属性，称为划分的标准。在对一个属概念进行划分时，可以把划分后得到的子概念作为母项再进行划分，这称之为“连续划分”。不管把一个概念划分成多少层次，每一次划分都必须遵循划分规则，即在一次划分中必须遵循同一个标准。根据不同标准划分的概念不可以并列，如果在同一次划分中并列了不同层次的概念，就会犯“概念不当并列”的逻辑错误。例如“我喜欢读外国作品、古典作品、小说、散文、唐诗等”。这句话对作品的分类用了多个标准，它把用不同标准划分的概念并列在了一起，犯了“概念不当并列”的错误。
六、因果倒置
因果关系是事物之间普遍联系的一种方式。如果一个现象的存在必然引起另一种现象发生，那么这两个现象就具有因果关系，其中，引起某一种现象产生的现象叫做原因，被引起的现象叫做结果。原因和结果在因果链中是相对的，此事的结果可能是彼事的原因，但就这一对因果来说，它又是绝对的，原因就是原因，结果就是结果，既不能倒因为果，也不能倒果为因。例如，19世纪英国有一位改革家发现,每个勤劳的农夫,都至少拥有两头牛；那些没有牛的，通常是些好吃懒做的人。因此，他的改革方式便是国家给每一个没有牛的农夫两头牛，这样，整个国家就没有好吃懒做的人了。这位改革家就犯了因果倒置的错误。农夫因勤劳才拥有两头牛，不是因拥有两头牛而变得勤劳。这种改革的结果自然还是勤者自勤，懒者亦懒。
七、循环论证
论证就是用几个真实命题确定另一命题真实性的过程。论证有一条重要原则，
避免组策略逻辑错误
即论据的真实性不应依赖论题的真实性。论题能否确立依赖论据的真实性来论证，如果论据的真实性反过来以论题的真实性为依据，那就等于什么也没有论证。违反这一规则所犯的逻辑错误，称为“循环论证”。例如，曾经有人反对哥白尼的太阳中心说，他们认为宇宙是有限的。其论据是宇宙在一昼夜之间绕地球一周，而论据的真实性又依赖“宇宙是有限的”这一论题（因为如果宇宙是无限的，就不能理解为什么无限的宇宙能在一昼夜之间绕自己的中心——地球运转一周）。这就犯了“循环论证”的错误。
八、推不出
论证的另一条重要规则是要求从论据出发能合乎逻辑地推出论题，即论据和论题之间要有必然的联系。
违反这条规则就会犯“推不出”的逻辑错误。有以下几种常见的情况：
1.推理形式不正确
从论据不能必然地推出论题。例如：“他近视得很厉害，一定很聪明。”“近视”跟“聪明”之间没 有必然的联系，我们不能以近视为依据，证明他是否聪明。这个论证实际上运用了如下推理：
所有的聪明人都是近视眼，
他近视得很厉害，
所以，他一定很聪明。
这一推理违反了三段论的推理规则：中项至少要周延一次。两个前提中的“近视”，表述方式都是肯 定的，均不周延，所以这个推理形式是无效的。
2.论据和论题毫不相干</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%86%99%E4%BA%86%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%AA%81%E7%84%B6%E6%83%B3%E8%B5%B7%E6%9D%A5%E9%9C%8D%E9%87%91%E8%B5%B0%E4%BA%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%86%99%E4%BA%86%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%AA%81%E7%84%B6%E6%83%B3%E8%B5%B7%E6%9D%A5%E9%9C%8D%E9%87%91%E8%B5%B0%E4%BA%86/</guid>
      <description>写了几行代码突然想起来霍金走了。
当然这没什么特别伤感的，他不是我爹我也不特别崇拜他。伤感是因为他是那个旧时代的东西。
旧时代是什么意思呢？就是互联网的信息革命还没有开始。那时候人活的，相对现在这个时代而言，可能相对无聊一些；因为没有智能手机，没有朋友圈和微博，没有Google搜索，Youtube，没有吃鸡游戏或者吃其他什么。
那时候人的时间都挺多的，但堪称珍贵的信息很少，可能是一本逻辑学，一本罪与罚，一本罗马帝国衰亡史，一本APUE或者龙书，一本艺术哲学，诸如此类；就是说这些书也是那些旧时代的有很多时间的人，很专注的思考和写作的；后面的人同样专注的看。
你想霍金有那么不错的成就，一定程度上是因为他不能动弹，只好锻炼他的脑袋打发时间，认真思考了很多问题，当然不是所有的残疾人都成了物理学家，但那个旧时代，信息还是稀有品的时代，人们普遍的value它。
在90年代的互联网诞生的时候，求知若渴的人们有着非常好的愿景；信息将会自由流动了，似乎很快世界上人人都很容易成为大师——你不再会因为找不到一本书而埋没你的才华。
互联网20多年过去了。信息泛滥了，贬值到一钱不值——只剩一些骗子们在向傻子们兜售付费阅读。
但同时人们的时间突然都没了，忙着刷微博和朋友圈，前端后端一个月开五场会，唉，哪有时间坐下来看看离散数学；春天秋天要郊游了，不能辜负性爱和美食。
我曾经想是不是因为世界大了，人们突然变得挑剔了，所以看不见大师了；但是感觉不是，那些在旧时代里如笋生三年一般积淀下来的人在越来越少，一个个的离去，剩下的张牙舞爪的人们，跟你我一样普通。
岁月浓缩的精品，是无可替代的。互联网正在让社会和它的缔造者的愿景背道而驰。一个新文盲时代在蓬勃兴起，各行各业，你再难看到那些勤学苦练至高山仰止的人。
上帝和人类开了一个玩笑。他就知道人类从来不会懂得珍惜。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%8F%A4%E4%B9%9D%E5%8F%A4%E5%8D%81-%E7%8E%AF%E4%BF%9D%E4%B8%BB%E4%B9%89%E7%AC%A6%E5%90%88%E5%AE%97%E6%95%99%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E7%89%B9%E5%BE%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%8F%A4%E4%B9%9D%E5%8F%A4%E5%8D%81-%E7%8E%AF%E4%BF%9D%E4%B8%BB%E4%B9%89%E7%AC%A6%E5%90%88%E5%AE%97%E6%95%99%E7%9A%84%E6%AF%8F%E4%B8%80%E9%A1%B9%E7%89%B9%E5%BE%81/</guid>
      <description>环保主义符合宗教的每一项特征
古九古十 2022-12-06 18:03 发表于广东 以下文章来源于漫天霹雳 ，作者漫天雪798
米塞斯说：“宗教的典型特征是：面对事实不为所动。”
当今世界最大的宗教有两种，它们既不是基督教，也不是伊斯兰教，更不是佛教，而是环保教和拜国家教。
所有宗教都是人为制造的。并不是神创造人，而是人创造了神。人们不愿意相信科学、将自己无法解释的事情归结为神秘的力量，更不愿意相信巧合，以及心灵上的嫉妒和苦楚无法宣泄，于是有些人抓住了这些特点，用自相矛盾的解释吸引信众，由此成了宗教领袖。他们并不是为了宗教而成为领袖，而是为了成为领袖而创造宗教。
先有权力，后有宗教——真正意义的现代宗教，不同于古代人们的迷信和神秘信仰。
注意，自相矛盾对于宗教来讲并非坏事，反而是它的必备特征。越是含混的反而越好，必须自相矛盾，才能让人们相信神秘的力量，才能增强其神秘感，独占其解释权。信者恒信，哪怕这些矛盾是多么荒谬。
他们只需要做一件事，将那些怀疑它自相矛盾的人视为异教徒、打为异端、送上火刑架即可。
毕竟，逻辑推理和科学验证，并不是宗教的强项，也不可能为宗教所采纳。科学与宗教是一对死敌。科学讲究理性，而宗教极端反感理性思维，因为理性思维就是对宗教的反动。
宗教，不需要你的思考，信就行了。
《理性乐观派》的作者马特·里德利在他的另一部著作《自下而上》——你看他这书的名字，就知道他在赞美什么反对什么了。当然是在赞美市场的自愿秩序，反对自上而下的人为设计——为我们展示了环保主义的宗教特征：
环保主义者告诉我们，我们正在犯下罪过（排放二氧化碳），我们有原罪（人类的贪婪），我们被逐出了伊甸园（前工业化时代），我们必须忏悔（谴责不负责任的消费主义），必须赎罪（缴纳碳税），悔改（坚持让政治家喋喋不休地就气候变化提出警告），寻求救赎（可持续性）。有钱人可以购买赎罪券（碳补偿），留下自己的私人飞机，但任何人都不得背叛《圣经》（政府间气候变化专门委员会公布的报告）里规定的（对二氧化碳的）信仰。谴责异端（不信神的人）、尊崇圣人（阿尔·戈尔）、听奉先知（政府间气候变化专门委员会）是所有人的责任。如果我们不这样做，审判日（不可逆转的临界点）定会降临，届时，我们会感受到来自地狱的火焰（未来的热浪），体验到神祇的愤怒（更强烈的暴风雨）。幸运的是，上帝已经为我们送来了牺牲献祭的征兆，风力发电厂看起来是那么的像耶稣受难地。
你看，跟宗教的叙事一模一样；在现实中跟宗教的手法也一模一样：谁要是不按他们的宗教戒律（限制二氧化碳排放，防止气候变暖和地球毁灭）办事，就是异教徒，必须受到惩罚，由此，每个人都必须按照他们的戒律行事，让它侵入你的私有财产，改变你的自由选择，因为那实际上就是你上交的赎罪券。
推行他们所谓的环保政策，冻死饿死了无数人，在他们看来也无关紧要，那都是为信仰而必须做出的牺牲，就如同十字军东征中的杀人与被杀一样。
尽管无数科学家已经用无可辩驳的研究成果表明，气候变化主要是地球轨道运动引起，与人类活动的关系微乎其微。在遥远的间冰期，二氧化碳含量比现在高，然而那时候并没有人类活动；20世纪全球气温上升仅为0.6℃；以及气候变化是自然的进程，也没有什么大不了，温度上升并非什么坏事……
不论你拿出多少证据，都无法让他们改变信仰，一句我不听我不听我不听、顾左右而言他、描绘出一副未来的想象中的可怖景象、或者认为你是个不可理喻的顽固分子，就结束了这场辩论。
然后继续捍卫他们的宗教，具体做法是：去卢浮宫泼油漆、开着大排量汽车反对尾气排放、睡在沥青路面上反对石油制品，坐着波音747开气候变化大会，关掉火力发电厂冻死人或者让人们承受更高的能源价格，让一个10来岁的、患有严重妄想症和精神分裂症的“环保少女”格雷塔·通贝里去拯救已经45亿岁高龄的地球，以及，对牛放屁征税……
他们从来不会认为自己精神分裂，而是认为自己虔诚。
当然，那些虔诚虔诚都是装出来的，就像装神弄鬼的太平天国领袖，目的不过是权力和金钱。而且这的确是来钱的快速途径。
他们并非不知道相关关系与因果关系的区别。他们只是需要一个理由，一个在他们看来看似“科学”的理由，以推进他们的议程。这个理由到底与气候变化有无关系，其实并不是他们关心的。与他们推动的环保产业进程相关，才是最重要的。他们是先找目标，后找因果关系的，是先打枪再画靶子的。
每年每个国家数亿美元的环保专项资金，环保产业集团为了垄断而给他们的赞助，源源不断地流入了他们的所谓基金会。他们用人们缴纳的税金全球旅游，出席各种名流宴会，收取高额的演讲、出场费、游说经费，制造无数垃圾论文，养活了无数寄生虫，数钱数到手发软，还能树立热爱地球和人类的人设，做梦都没有这么好骗钱的事情。
当初的教士阶层，不就过的是这样的生活吗？他们有高高在上的地位、有高人一等的特权、有信众们的捐献供他们挥霍、还可以去性侵女教徒，以及变态地玩起恋童癖。这种事情至今不衰，看看2016年奥斯卡金像奖最佳影片《聚焦》，就知道了，那是一篇新闻报道改编的，也就是说，那电影讲的是真事。
环保教是席卷全球的最大宗教，它是超越国界的最具破坏力的宗教。其目的与他们宣称的保护自然恰恰相反，那就是改变亘古不变的自然规律和人类社会的基本法则，让所有人对他们俯首称臣。
能够与这个宗教相媲美的，还有一种全球性宗教：“拜国家教”。
人们相信一个人只因为具备了某种特殊身份就立即变成天使，相信某种机构具有比上帝还强大的伟力，它不但可以提供安全，还可以提供幸福，提供衣食住行等人们需要的一切东西，不论它干了多少坏事情，人们都相信它是善良和正义的化身，不论你拜的是英国教、美国教还是德国教，它们共同的名字都叫“国家”。这是一个“宗教连锁店”，只要你的地球上，你就逃不掉。
多么匪夷所思的事情啊，人们希望一个劫掠他钱财的人给他幸福；希望从事各种如果个人去干就是严重刑事犯罪的事情的集团，去保证他们的安全。跟所有宗教一样，它同样来历不明，明明来自于征服与没收，然而人们相信它来自于神秘的“社会契约”。任何精神正常的人都不会认为他曾经签过这样愚蠢的契约：让人随时拿走它的钱财乃至生命。
然而人们就是信。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E7%AE%80%E6%98%8E%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89%E7%AE%80%E6%98%8E%E7%AC%94%E8%AE%B0/</guid>
      <description>存在主义简明笔记
作者：子小孙 江左乱弹 2020-02-23 17:38
链接：https://mp.weixin.qq.com/s?__biz=MzI2MzA2NDUwNQ==&amp;amp;mid=2649195026&amp;amp;idx=1&amp;amp;sn=4662ddd24d89a1d6a6c6cadaa9611caa&amp;amp;chksm=f252bcc4c52535d2b9c553b36dc8d94496eaf849f2b7f4890719e64246a4a241ac571865f7b7&amp;amp;scene=21#wechat_redirect
来源：微信公众号
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
01 存在先于本质 先有存在，后有意义。在事物存在之前，并没有一个它应该存在的意义。意义是被后天赋予的。抽象来说，实然之前，并无应然。
02 上帝死了 在人类存在之前，并无存在一个先验的绝对的永恒的意义。人类存在的意义是自己赋予的，而非上帝。上帝无法定义人类是什么，无法指导或规定人类应该做什么。因为对于人类而言先有自己的存在，而后才有上帝的概念。是人创造了上帝，而非上帝创造了人类。
此处的上帝可解释为“一切所谓的应然之物”：道德、伦理、规范、制度、法律等等。先有人类，后有道德。当两者冲突时，遵循人性，摒弃道德。最本能的，最道德，最人性。
03 道德就是偏好 通俗的讲，你喜欢一个人，先有了你喜欢ta这一事实，而后才有你喜欢ta的各种理由。这些理由是你用来说服自己，以使得自己喜欢这一事实有理有据。
道德亦然。你认为它是道德的，是因为它符合你的价值观和逻辑链，或者说“偏好”。
尼采：不存在道德现象，只存在对现象的道德解释。
04 人是自由的 既然上帝死了，道德只是偏好，那么人就是自由的。没有什么是应该做的，也没有什么是不应该做的。
陀思妥耶夫斯基：一切都是被允许的。
尼采：在任何情况下都不存在什么必须要去做的事。
05 自由就是选择 自由不是绝对的。人的自由是选择的自由。人不能选择自己的出身，但是可以选择自己的活法；人不能改变必死的结局，但可以选择以怎样的态度来面对死神。
《黑客帝国》neo：这是我的选择。
《哈利波特》邓皇：定义我们的不是我们是谁，而是我们的选择。
06 人对自己负责 人有选择的自由，不同的选择会导向不同的结果，因此人要对自己负责。假设人没有自由，或者说人的选择对最终的结局没有任何影响，那么人就不对这结局负有责任。因为他对最终结果无能为力。
反过来说，如果一个人知道自己清楚地知道自己在选择什么，且明白该选择可能导致的结果，并且愿意去承担这个结果，那么他做何种选择都是可以理解的。因为这时的他是自由的。该选择可以是先放鸡蛋还是番茄等无关紧要的问题（我为什么要举这个例子？），也可以是反社会反人类的选择。
07 焦虑的本质 人有不同的的选择，不同选择会导向不同的结果，并要对最终结果承担责任，所以人是焦虑的。焦虑，可视为选择恐惧症。
尼布尔祈祷文：赐我平静，去接受我无能力的；赐我勇气，去改变我能改变的；最后赐我智慧，去识别两者的区别。
08 世界是荒诞的 既然存在先于本质，那么意义就是一种人造之物。所有维系人类发展的使命感、荣誉、爱都是人类用来自欺欺人的发明。人类社会是空中楼阁，它唯一的支点在于信仰。宗教是信仰，政治、经济、文化也是信仰。货币是信用。国家和人民的概念建立在讲好故事的基础上。
无意义才是人生的本质。无意义，也就是无根据，荒诞。
加缪所说的唯一严肃的哲学问题，其实应该解释为：在认识人生的荒诞和无意义后，如何重新确立信仰，以自欺欺人地活下去。
尼采：重估一切价值
09 天上天下，唯我独尊 重估一切价值，这事我觉得王阳明做过。史称“守仁格竹”。格竹时的王阳明尚未通透，观花时的他倒通透了：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。两者的区别只在于“有我与无我”之境。万物皆备于我。
释尊诞生时，向四方行七步，举右手而唱咏之偈句：天上天下唯我独尊，今兹而往生分已尽。
重估一切价值的标准，只在于我而已。人类存在，上帝就死了；我一存在，人类就死了。万物必须通过我的意志来对我产生作用。
人生并不是网游，而是一场单机游戏。只有我一人是玩家，其他都是NPC。
10 世界是意志的 《不能承受之轻》中有这样一句问答：muss es sein? es muss sein.
非此不可吗？非此不可。
既然“尼采说在任何情况下都不存在什么必须要去做的事”，那又为什么非做不可呢？既然去做一件事情没有意义，没有必须去做的依据，为什么偏偏又去做了呢？世间的很多事情其实都处于可作不做之间；许多事情你去追问一句为什么，会发现其实并没有为什么。你做了，只是因为你乐意。俗话说“千金难买我乐意”。
没有值不值得，只有愿不愿意；没有可不可以，只有想不想要。（如果你一定要说，我想要啊，但是我买不起啊。请参见“人的自由是选择的自由”）
这个我乐意，就是叔本华和尼采说的“意志”。所有的一切都是意志的具象化。
11 自我和本我 既然重估一切价值的标准只在于我的意志，那么加缪的哲学问题是否就迎刃而解了呢？其实难题才刚刚开始。
认识你自己，本身就是个大难题。
什么是我？哪个是我？人是否具有自由意志？
自我？本我？超我？
后面的还没整理好，今天先到这里吧。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%BE%88%E5%A4%9A%E5%B9%B4%E5%89%8D%E6%88%91%E5%AF%B9%E7%84%A6%E8%99%91%E7%97%87%E7%9A%84%E7%97%87%E7%8A%B6%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E5%BE%88%E5%A4%9A%E5%B9%B4%E5%89%8D%E6%88%91%E5%AF%B9%E7%84%A6%E8%99%91%E7%97%87%E7%9A%84%E7%97%87%E7%8A%B6%E6%8F%8F%E8%BF%B0/</guid>
      <description>2018/12/15 17:00
第一组：头晕，出虚汗，心悸，心跳过速，大脑昏沉，会以为是心脏病发作。 第二组：头疼，胃疼，特定部分疼痛，部分肢体颤抖。 第三组：失眠，反复失眠，基本上废了一两个小时刚睡着，然后一睁眼，刚睡了一小时，人整个都要疯掉了。 第四组：失去时间感官，开始有“不真实的感觉”，一夜过后没有“睡了一觉的感觉”。 第五组：会突然暴躁，</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E7%88%B1%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E7%88%B1%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88-/</guid>
      <description>作者：adg9q 链接：https://www.zhihu.com/question/444126370/answer/1743255025 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
作者：知乎用户链接：https://www.zhihu.com/question/444126370/answer/1743255025来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。#爱#今天追本溯源的说一下爱这个概念。如果你有英语基础，对深入的理解这个概念会大有好处。下面是拉丁文版本、英王钦定本和中文和合本的对照。这三个版本本身有无数的小版本差异，我们这里不去打这个口舌官司，只看最显然的大局。为什么要选Bible？因为我们现在在东亚所谈的这个“爱”的概念，不是一个本来直接存在于东亚文化里的原生概念，为什么选择这三个版本？这个拉丁文版本，是基督教被立为罗马国教后确立的正典版本。带着你们一个词一个词的过一过。我先说明一下——我并不专精拉丁文，也并不主张你们以这里的答案为标准答案，因为与其说断言文字的原意就是如此，不如说这些是我个人的理解。Caritas patiens est, benigna est.Charity suffereth long, and is kind.爱是恒久忍耐，又有恩慈。patiens。这是“病人”吗？这是耐心。专指忍耐痛苦的耐心。也因此，会将忍耐病痛的人称为patient。suffereth - surffers - 受苦Caritas non aemulatur,charity envieth not;爱是不嫉妒envieth - envy - 嫉妒non agit perperam,charity vaunteth not itself,不自夸non inflatur.is not puffed up.不张狂inflatur - inflate - 膨胀，给轮胎充气。5 non est ambitiosa,doth not behave itself unseemly,爱是不做害羞的事ambitiosa - ambition - 野心爱没有野心。这句被英王钦定版翻成了doth not behave itself unseemly。拉丁文版是由修士一天祈祷几个小时，然后在精神和肉体的巅峰提笔抄几个词在羊皮卷上，这样抄若干年才出一本的东西。是给各个教区座堂的镇殿之宝。詹姆士王版本是印刷机像印报纸一样印了准备发给基本不识字、只会说英文白话的老百姓当报纸读的通俗读物。英王钦定本和莎士比亚作品一起奠定了现代英语的根基——实际上前者的作用更为根本。但这也带来了一个非常致命的问题——它导致圣经的原意被英语文化的语境迁移了。比如这句至关重要的“爱无野心”，被迁移成了“爱是不做害羞的事”。但微妙的是，何谓理应“害羞”的事，何谓unseemly，却是一件“皇家御准事业”。这一句转译，其实将原文的解释权轻轻巧巧的从教会的大公会议上转移到了国王御案上。non quaerit quae sua sunt,seeketh not her own,爱是不求自己的益处Seeketh - seeks - 寻求non irritatur,is not easily provoked,爱是不轻易发怒irritatur - irritate - 被激怒provoked - 被挑衅爱不受挑衅。non cogitat malum,thinketh no evil;爱是不计较人的恶这实际上是——爱不想象恶，不向恶思索，爱不以恶意揣测人。爱不思恶。6 non gaudet super iniquitate,rejoiceth not in iniquity,不喜欢不义iniquity 敌意的行为、恶意的行为中文翻译成不喜欢不义，实际上是指不喜欢任何对ta人含有恶意、冀望人受损的行为。congaudet autem veritati:but rejoiceth in the truth;只喜欢真理无论一个幻觉让你如何享受，一个事实让你如何折磨，得以明了事实、摆脱幻觉，都是一件值得庆贺和欣喜的事。爱之中根植了“事实自身永远是善”的价值观。爱以真实为乐。7 omnia suffert,beareth all things,凡事包容suffert - 忍耐omnia - 全向的、全部的。omni light，就是指全向射灯，一个向所有方向发射光的的灯，如同太阳那样。beareth - bears - 忍受这其实应该译作“凡事忍受”。但是很显然中文译者意识得到在中文语境中说“凡事忍受”恐怕因为文化心理隔阂造成极大的信仰障碍，所以他们转了个身，翻译成了包容、宽容。但其实在拉丁文中其实就是“忍饥挨饿”那样性质的忍受。爱以忍受包容一切。omnia credit,believeth all things,凡事相信这又是一个至关重要的迁移就我个人理解，credit不是“相信”，而是“授信”。“相信”涉及到了信仰，是指“认信为真”，而credit，“授信”，是指“以真视之”。credit card 信用卡，是对你的授信，是指首先假定你是真的，等你违信了再作反应。而believe，则是认定你为真，这意味着当出现暗示你为假的迹象时，believer有拒绝采纳为证据、拒绝转为不信的义务，即坚信的义务。没有这种“对怀疑的免疫力”，是不成其为believe的，只可以称为credit。所以，这句按拉丁文，实际上应该译为“凡事授信”，即对一切人的声称，首先当作真实的诚实的来对待，直到看到事实与此相悖。omnia sperat,hopeth all things,凡事盼望hopeth - hopes - 希望、期盼对一切都寄予希望。也就是永远无所谓“我对你绝望了”，或者“我对这事绝望了”。你可以决定以其他的任何理由来停止投入某事或者停止服务某人，但这不可以是因为“绝望”。因为作为不能预测未来、不能决定历史的人类，没有逻辑上有效的能力来做出“绝望”的结论。omnia sustinet.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E7%8B%B8%E5%8F%91%E8%B4%A2-%E6%B5%85%E8%B0%88%E7%88%B1%E6%83%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E7%8B%B8%E5%8F%91%E8%B4%A2-%E6%B5%85%E8%B0%88%E7%88%B1%E6%83%85/</guid>
      <description>原创 狸发财 狸发财 2022-09-19 10:18 发表于湖北
谈个屁，我也不懂。
我只知道爱情对我来说出现的概率太低，我这个人普通但刁钻。我之前的恋爱都是在对方对我好的前提让我去习惯从而产生依赖，但那就是爱了吗？显然不是。感觉每次分开所产生的难过只不过是为接下来的生活都要自己一个抗了哦而感到不爽。我哪有什么爱情，我是一个没有感情的生物，我对人类的身体亲密接触有一种天然的抵触，我很难去跟人牵手接吻，因为这个原因，我前任都怀疑我不爱他，不在乎他。这么仔细想来，他说得也有道理。但我很需要人跟我讲话，跟我聊天，听我那不切实际的幻想。我的幻想世界很想要别人的加入，因为我从小到大就喜欢和人分享，这个毛病导致于我长这么大了还是没办法吃独食。只要家里有维修师傅或者钟点工阿姨我就不吃东西，再饿都不吃，因为我没法吃独食，也不喜欢跟陌生人一起吃东西，所以我只能饿肚子。
你要问我爱情是什么，我也不知道。我总感觉我还没有长大到能拥有这个东西，因为我幼稚且无知，还拥有无穷无尽的幻想。我对两个人的开心不建立在大众标准中，当然高端的大众标准能给人带来一些虚荣感的满足。比如对方多帅多有钱多拿得出手。但那就是爱了吗？显然不是。
我非常记得《我爱上的人是奇葩》里面女主坐在大导演家的浴缸里给男主打电话聊了好久好久的天。我当时看到这一场景的时候，就觉得这是爱情吧？我觉得爱情没什么其他的，就是两个人每天都能聊天，有个人陪自己做一些奇怪的事情，然后疯狂做爱。性器官匹配确实是爱情缺一不少的条件，有些人一年半载才搞一次的是纯爱吗？应该不是吧。
有些人真的会谈非常非常多的恋爱，多到你不知道他谈那么多爱有什么用，是集满就获得一个传说吗？还有一些人一些恋爱谈很多很多年再分手，想分手谈那么久干什么，能颁奖吗？
你看感情就是如此让人摸不着头脑。
我对爱情有很多很多的疑惑，所以我感觉我不会结婚，我无法维持长久关系，但如果结婚能收不少份子钱的话，我还是会选择结。因为这个东西对我来说不重要，我没什么道德感，我也并不认为结几次婚有什么说法，但如果你结了十三次婚自然可以收获我一句“牛逼，收了不少份子钱吧。”
我真的是一个很没有道德感的小混蛋，爱情根本不是婚姻可以理解的，感觉婚姻只是为了社会关系的稳定。我今天爱你，明天遇到了他可能就爱他了。所以“我今天还爱着你”这句话可比“我永远爱你”这句承诺来得动听。
当然我非常反对出轨这件事情，倒不是我道德感有多强，我在好几年前特别小的时候也出过轨，我出得还特别坦然自若。直接告诉对方，并让对方看着办。只要把问题抛给对方，我就不用解决问题。我不建议大家都这么干，我当时能这么干，是因为那时候的我们年纪都小得可怕，可怕到做一些匪夷所思的事情也是可以理解的。
我觉得隐瞒性出轨这件事说白了，就是你这个人没种。你又压不住自己的欲望，你又没有勇气去坦白。偷偷摸摸享受两个人的爱恋，感觉也很辛苦吧，一句话要讲两遍。但迟早有翻船的一天，建议坦白从宽抗拒从严。我觉得被出轨的人真的要硬气一点，我看过好多对方出轨了，但依旧念念不忘委曲求全的人，看着真可怜。
希望无论男女，面对配偶出轨，都可以直接嫣然一笑，转头就走，一句话都不要讲。让对方懵逼到自我否认：“怎么出轨都不跟我吵，是不是不在乎我，是不是不爱我”。真的，一旦你这样，没人能伤害你。虽然戴绿帽子肯定不好受，但戴了绿帽子还要在大庭广众之下跟人打一架更不好看。世界上真没那么多人关心你的情感情绪问题，大家都只是单纯想吃点瓜，单纯找点乐子，千万别让自己的痛苦成为他人的笑柄。被出轨的人听我一句劝，咱们默默找个没人的地方把绿帽子摘下就得了，摘完还是一条好汉。
真的很奇怪，我明明是想讲爱情，莫名其妙在末尾就变成了绿帽子。我怀疑我思维方式很有问题，我好像一直都如此不清白。所以也不要听我乱讲了，直接点击下面得了。
文章已于2022-09-19修改</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B3%E4%BA%8E%E9%98%B6%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98-%E9%B2%B8%E4%B9%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%85%B3%E4%BA%8E%E9%98%B6%E7%BA%A7%E7%9A%84%E9%97%AE%E9%A2%98-%E9%B2%B8%E4%B9%A6/</guid>
      <description>前一阵儿有一位导演请我看剧本，有个情节是主人公爱看一个破烂的小建筑，终于他的困境解决了，那个破楼突然也修好了，有点呼应感。导演却担心：主角是个农村穷孩子，就图挣钱，怎么可能关注到一个小破楼，还拿赏花赏月的闲情关心它呢？
我一听就有点堵得慌，除去戏剧创作的逻辑，其实是下意识生气了，不好发作，也就没立刻接话。
一旁的@文正北 却说，没有啊，你看下雪了，春天桃花开了，那些清洁工嬢嬢也会拍拍发朋友圈的，爱美的心是人都有的。
我心想，是啊，人家刚毕业小朋友都能明白的理，到你这就怎么顺不通呢？但我也理解这位导演，他毕竟读了太多社会学的书了。
现在特别流行阶级分析论，能套一切文本，万精油，超越思聪逃离北上广凤凰男去哪过春节装腔指南降PU找一个布男北京女子图鉴金融街没有爱情……一切都能用阶级那一套分析。
也对，毕竟这可能是我们这个时代最大的痛点了。谁不焦虑呢？天花板是透明的，好像离得也不远，谁踩你头上也看得清清楚楚，好像也没比我厉害多少啊，可这个天花板钢筋铁打的一样，头破血流，跳不上去了。
为什么明星类真人秀受限，不止是娱乐化不爱国的问题，更是“阶级差异视觉化”的问题，黄圣依为了不露富，特意买一座2000W别墅录节目，以为可以避险就可见一斑了。明明大家都该活得养猪场似的，你的床上却是天鹅绒，凭啥啊？
这些都对。
但是阶级之外，买买买之外，甚至人类生活之外，还有一个更广博高远的世界。再极端的国家也没有不允许人看花，也没有任何一条法律能阻止人相爱，养猪场里也有闻一闻春天的风的自由。
得从焦躁的精准的阶级自我定位里跳出来，叉死房间里的大象，烧了社会学的书，体会一下纯然为人的快乐吧。✌️</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E9%BA%A6%E5%87%AF%E6%81%A9%E4%B9%8B%E6%AD%BB%E4%B8%8E%E8%BF%99%E4%B8%AA%E8%87%AA%E6%81%8B%E7%9A%84%E6%97%B6%E4%BB%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BB%96%E4%BA%BA%E5%AD%98%E6%A1%A3/%E9%BA%A6%E5%87%AF%E6%81%A9%E4%B9%8B%E6%AD%BB%E4%B8%8E%E8%BF%99%E4%B8%AA%E8%87%AA%E6%81%8B%E7%9A%84%E6%97%B6%E4%BB%A3/</guid>
      <description>麦凯恩之死与这个自恋的时代 Death in the Age of Narcissism 弗兰克·布鲁尼 2018年8月28日
Just before and after John McCain’s death on Saturday, I read many tweets, Facebook posts and essays that beautifully captured his importance. 就在约翰·麦凯恩(John McCain)上周六去世前后，我阅读了许多推文、Facebook帖子和各种文章，它们都很好地说明了麦凯恩的重要性。 I read many that were equally concerned with the importance of their authors: 我还读到，许多文字同样旨在彰显说话者自身何其重要： Here’s how much time I spent around McCain. I’m also close to his daughter Meghan. This is the compliment he once gave me. This is what I said back.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BD%93%E9%87%8D%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BD%93%E9%87%8D%E8%AE%B0%E5%BD%95/</guid>
      <description>体重记录： 2017、9、20 早餐前：84.9kg 早餐后：85.6kg 午餐前: 午餐后： 晚餐前： 晚餐后： 睡前
体重记录： 2017、9、21 早餐前： 早餐后：86.3kg 午餐前: 午餐后： 晚餐前： 晚餐后： 睡前 理论上当热量缺口累计到达7700kcal时，人体就会减少1kg的脂肪。
7700 / 7 = 1100 kcal
我的基础代谢率（BMR） 为 1772.25 千卡 / 天
公式： 1 千焦=238.9 卡(卡路里)
1千卡=1大卡=1000卡=1000卡路里 =4184焦耳=4.184千焦
2022年10月9日 早餐： 豆腐脑 192 kcal 蒸饺 454 kcal 646 大卡
午餐： 160g * 1065/100 = 1704 千焦 三明治 140g * 1287/100 = 1801.8 千焦 鸡肉卷
午餐热量计算： 3505.8 千焦 837535.62 卡路里 837.53562 大卡</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BD%9C%E4%B8%BA%E8%81%8C%E4%B8%9A%E5%AF%B9%E6%AF%94%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C%E5%85%AC%E5%8A%A1%E5%91%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E4%BD%9C%E4%B8%BA%E8%81%8C%E4%B8%9A%E5%AF%B9%E6%AF%94%E7%A8%8B%E5%BA%8F%E5%91%98%E5%92%8C%E5%85%AC%E5%8A%A1%E5%91%98/</guid>
      <description>中国公务员有两种统计口径。狭义的公务员是指,各级行政机关工作人员,数量为500万人;宽义的公务员是指,行政机关、政党机关和社会团体的工作人员,数量为1053万人。”
中国公务员总数为716万人，中国的县处级以上干部60多万人。中国的厅局级干部有5万多人。中国的省部级干部大约有3000多人。不包括国有企事业单位的干部。北京市拥有1.3万多名正处级以上的干部。我们中国公务员和事业编加起来5600万人。
程序员，2019年9月初，有600w上下。
入行难度： 素质要求：吃苦耐劳、自律、自学、专注、抗压能力 工资： 福利： 发展前景： 1、阶级跃升的概率 稳定性： 岗位数量： 流动性： 工作强度： 社会地位： 人脉关系： 努力、运气、贵人 对个人轨迹的影响：能不能接受 努力 没用？ 工资高、流动性好：那么就会有无数的新驴入行，把前浪拍死在沙滩上。卷疯（程序员） 工资高、流动性差：潜规则就容易多。（教师、医生、公务员）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E5%87%8F%E8%82%A5%E5%81%A5%E8%BA%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E5%87%8F%E8%82%A5%E5%81%A5%E8%BA%AB/</guid>
      <description>减肥、健身 基础代谢率（BMR） 基础代谢率是指人体维持心跳、呼吸等基本生理活动所消耗的热量。 基础代谢率（Basal Metabolic Rate，BMR）是指在自然温度（18 ~ 25℃）环境中，清醒、静卧、空腹、思想放松状态下，维持生命（心跳、呼吸、腺体分泌、肾脏过滤排泄、解毒等）所需消耗的最低能量。 这里采用与实测相差最小的 Mifflin-St 公式为计算方法
Mifflin-St Jeor公式如下所示：对于女性：（10×体重公斤）+（6.25×身高厘米）−（5×年龄岁）− 161对于男性：（10×体重（kg））+（6.25×身高（cm））−（5×年龄（岁））+ 586.0 * 10 + 6.25 * 169 - 5 * 30 + 5 = 1771.25860 + 1056.25 - 150 + 5 = 1771.251771.25 * 1.2 = 2125.51771.25 * 1.375 = 2435.461771.25 * 1.55 = 2745.431771.25 * 1.725 = 3055.40 该公式还考虑了您的身体活动，因此您需要将结果乘以一定的数字：
如果您没有进行任何体育锻炼，而您必须花费大量的时间坐下来，则将结果乘以1.2。 如果您每周进行少量运动或进行1-3次运动，则将结果乘以1.375。 如果您每周进行3-5次中等运动，则将卡路里数乘以1.55。 如果您每周进行6-7次完整锻炼，则需要将该数字乘以1.725。 最后，如果您的工作与体育锻炼有关，并且每周至少运动两次，则需要将结果乘以1.9。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%84%8F%E4%B9%89%E4%B8%8D%E6%98%8E%E7%9A%84%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD-%E4%B8%8D%E6%88%90%E7%AB%A0%E5%8F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%84%8F%E4%B9%89%E4%B8%8D%E6%98%8E%E7%9A%84%E5%8F%AA%E8%A8%80%E7%89%87%E8%AF%AD-%E4%B8%8D%E6%88%90%E7%AB%A0%E5%8F%A5/</guid>
      <description>意义不明的只言片语-不成章句
沉沦超拔，进入超越。
热气球，铁路，九天空轨；
骚扰电话自动应答机器人；（自动设置应答后通话时间，自动设置应答语音语色，离线运行、语义分析、陌生号码自动应答，通话录音，数据收集）；
听出 不了情
极品音乐音乐论坛。
大眼睛，希望工程。
广告：香奈儿，我永远添加</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%98%8E%E6%9C%9D%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%98%8E%E6%9C%9D%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</guid>
      <description>《明朝的那些事》读后感
2022年7月24日
今天终于将《明朝的那些事》看完，这书我之前看了不下五次，之前每回都是在明朝山河日下，所有坚持、执着都难以如愿时脱坑，我都一如既往的缺乏勇气，难以直面结果，心智如同逃兵一样偷偷的自欺欺人，蒙骗自己，选择放弃。 我好像走了很远的路，很幸运，一路上解决了很多很多简单且基础的问题，如何生存，如何像一个成熟的大人，如何与孤独相处，如何处理温柔、感伤，涌动的情绪，我开始有了一些自由的时间，自由的空间，新的问题是：什么在阻碍我利用这些时间。我该如何利用这些时间。新的目标是：去做一个自己喜欢的人，而要达成此目标，我现在了解到的唯一方法是，做自己喜欢的事，做自己喜欢的选择。 坚持自己选择和执着，不为有利可图，不为道德，不为放纵的欲望，选择相信，选择爱，选择直面自己的欲望，选择正视自己的缺点，选择永远不放弃去修改自己的缺点，选择了解自己的身心，这些选择，它们无高下之分，只是我相信的选择，选择的相信。 当年明月在最后一段，写的是徐宏祖，写了这句：“成功只有一个——按照自己的方式，去度过人生。”是完美的结束语。深以为然，希望我可以努力践行。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%9E%AA%E7%82%AE%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90%E8%AF%BB%E5%90%8E%E6%84%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%9E%AA%E7%82%AE%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90%E8%AF%BB%E5%90%8E%E6%84%9F/</guid>
      <description>《枪炮、病菌与钢铁：人类社会的命运》读后感
2022年8月12日
此书大约是在上周末读完，这两周状态不好就没有写读后感，今天工作告一段落又是周五就开始摸鱼了。
我早就听闻此书大名，但是这些年一直没有读严肃一点文学作品的想法，很多久闻大名的书都一直在书架呆着。
这次再次回到微信读书的主要原因是：之前在与一位微信群的陌生人争论时，突然意识到，争论完全不会有共识，此前我之前一直避免在网络上与人争论，更多的原因是：“歧义和重点难以精确传达”，通常都是各说各的，而此次不同，此次我清晰的感受到，要想有共识，对方必须要多读一些书，能以更复杂更全面的角度去看待问题才有可能，但很明显，很多人在脱离教育阶段后，就再也没有认真的阅读过严肃一点的文学作品了，他们的一切相应积累都来源于曾经教材中的只言片语、各种帖子和一些碎片化的信息，我也意识到，我也接近这样了。另外你不可能直接的向对方建议：“你应该多读一些书”，这是赤裸裸的冒犯，而且也很容易被反诘：“你读了多少书”，虽然罗素在西方哲学简史中说过：“我的浅薄不是我应该谨守缄默的充分理由”，但这个反诘通常会被对方当作有力的回击，我又不能把读的书背下来，这时候微信读书全面的阅读时间统计就派上用场了（其实不会，只是 nerd 的脑子幻想）。这次应该会在微信读书停留许久。
我很久没有去读不是很喜欢的书了，因为容易出现智慧退避，大脑拒绝接收和处理这些信息，导致视而不见，进不去脑子的情况，也不会引起思维火花。本书就是一本我不是很喜欢的书，全书风格类似数学应用题描述，作者：我观察到了***，我了解到***，我有一些数据***，我的结论是***，表述技巧几等于冇，而我倾向于更能引动情绪的表述。
很久前，我就意识到，人与周遭环境有非常紧密的互相联系，但仅仅是一个模糊的概念，并不了作用方式和范围。本书通过作者广泛的研究和事实逻辑，回答了一些关键的问题：”是什么塑造了这样的一个现代世界？为什么有的国家富裕有的国家贫穷？为什么有的民族创造了灿烂的文明？为什么是欧洲人征服了新大陆而不是新大陆的人登陆欧洲？是什么对文明发展、技术传播、传染病、社会演化带来了决定性影响？“作者给出一个令人信服的结论：“环境——&amp;gt;食物的生产是终极因，各种近因（技术、病菌、文化、政治组织制度、钢铁等）都是从终极因发展而来”，本书的作者在书中罗列了大量的事实和逻辑分析证明了，近因是因终极因的演化而成，与人种无关，不已个人意志而转移，环境决定各大陆各民族的命运。
另：作者在罗列的事实中写到了孤岛的文明退化的现象，让我想到：“桃花源是不存在的，文明与病毒一样，是栖息于人群之上的，失去人群，失去文明。”
另：作者写到，技术的发明虽然重要，但在时间长河中终归是会被反复发明出来，但是技术的传播更重要，过少的人口，技术传播的损耗大于新技术的发明，会导致文明退化。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/</guid>
      <description>一些计算机&amp;amp;互联网的自问自答
2021/10/13
0、SQL、EL、正则三个表达式的本质都是：从数据源获得数据
1、信息技术是研究如何获取信息、处理信息、传输信息和使用信息的技术
2、什么是计算机：仅仅从辅助计算方面看，计算机本质上和算盘区别不大，都是抽象计算复杂度，降低处理计算的难度，完成计算得到结果。（计算机和算盘一样，都是根据规则，由处理已知信息，得到未知信息。）。
3、什么是程序：先看大家都比较熟悉的数学计算公式，数学计算表达式（公式），主要分为：数据和数据操作符，程序也是如此，由数据和操作数据的指令组成，程序可以指挥计算机完成指定的任务，通常是信息处理任务，（信息就是数据，数据就是信息，）例如：我现在做的订单管理，20万订单，即使人工一秒钟处理一单，一天24小时也只能处理不到9万单（获得客户买了哪个商品，要发哪去，扣减库存，发货，同步发货信息），而程序处理就极快了。程序和数学的函数差别不大，都是根据已知信息，处理信息，得到未知信息。
4、什么是互联网：网络和共享（主要是信息共享）。资源更高效和更容易的分配和利用，这个时代，信息本身也是一种资源：影视、音乐、电子游戏、软件、文章。
5、关于编程行业：有无数聪明的大脑投入其中，使其上限足够高，有明确的路径和阶梯，不像“寿司之神”卷到头了，提升变成了玄学（握十万次饭团的技艺，比九万次的技艺更好？）。也不像很多工作，在技艺上差别不大，开始内卷其它与技艺不相关的事务，比如接人待物，计算机很大程度上你只需要专注技艺就可以（为邋遢找的借口）（代价是献祭头发）。另一个是计算机编程行业是“有标准”、“有门槛”、“有正确”，是的，很多行业是没有客观标准、客观门槛和客观正确的，比如编剧、绘画、它们看起来好像有手就行，它们的“评价标准”、“结果”相对来说，主观的影响更大，甚至是运气。而计算机编程行业“伪科学”和“民科”显而易见，程序能跑就是能跑，不能跑就是不能跑，能跑，大家都能得到正确相同的圆周率的第十万位，不以个人意志而转移。
6、关于程序员：众所周知的高工资、秃头，其实还有的是面对无数挫折、失败、挫败感继续坚持下去的努力。现实世界中最接近魔法或者武功的就是编程技术，每一个程序员都是魔法师，编程语言就是咒文，各种程序就是咒语，比如抖音的变美换头魔法，比如时空变换，千里眼与顺风耳的实现。
7、关于骇客和安全：如果程序、电脑和网络是植物与农场，那么普通程序员就是农民与建筑工人和工程师是生产者，那么骇客就是侠客和卫兵、土匪、强盗。任何计算机都是不安全的，每个人的手机和电脑都是可以被攻破，被洗劫的，需要权衡的无外乎是成本和价值，而我们安全的一个主要原因是：以现在的网民数量和网络设备数量，针对个人的侵害来说，坏人的数量不够用（傻子太多，坏人不够用也发生在网络上，很多人不被欺骗的原因不是够聪明，够谨慎，仅仅是没有遇到骗子），在网络上我们芸芸众生如滴水入海。
8、最后，程序不是万能的，解释与描述已知的可以用逻辑，解释与描述已知与未知之间的可以用哲学，解释与描述彻底未知的可以用神学。计算机只能处理部分已知的。
9、信息与决策与自动化：未来的社会必定是高度自动化的社会，而要想自动完成某些工作，必须充分的获得信息，获得大量信息（全知则全能），以及对信息处理，进而产生决策，决策驱动自动化。
这是不能拒绝的未来啊。“信息、决策、自动化：未来的社会必定是高度自动化的社会，而要想自动完成某些工作，必须充分的获得信息，获得大量信息（全知则全能），以及对信息处理，进而利用信息产生决策，决策驱动自动化。”（无论是互联网对信息的共享，物联网对信息的获取，人工智能、机器学习对信息的识别和处理，Hadoop等技术对信息的加工和储存）；未来的社会必将是更加导致个人信息暴露的社会，古代你完全不知道几百公里外的人任何信息，现在你可以看到他（她）（它（二次元））在对着你笑，这是一条没有回头的路，只会愈演愈烈。
10月2号 到 3号早 北京到无锡 10月4号 晚 到连云港 10月5日 下午 回北京</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%A5%E9%87%8D%E8%B6%85%E6%A0%87%E7%9A%84%E4%B8%80%E5%A4%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%A5%E9%87%8D%E8%B6%85%E6%A0%87%E7%9A%84%E4%B8%80%E5%A4%A9/</guid>
      <description>劳动节假期后的第一天 NoFashion
2022-05-06 14:49
不确定性严重超标的一天
昨天因为某些不确定的原因（据说是核酸检测次数不足），导致北京健康宝出现【弹窗④】，因为前一天未弹窗，因为前一天有做核酸，所以直到在公司楼下才发现这个问题，我站在公司楼下，顶着太阳，感觉自己正慢慢裂开。
经过咨询行政同事，我需要先做核酸，再请假，我先挂了上地医院的核酸检测的预约，等我蹬自行车到了，被告知，不能给健康宝有弹窗的做核酸，建议去其它几个医院做，在不久前我还在庆幸，我挂上了唯一剩下的一个预约名额，现在我望着核酸检测窗口，看着手中的预约二维码，感觉自己正慢慢裂开。
其实这个时候我有点想笑，因为少做核酸，所以弹窗，因为弹窗，所以不给做核酸，但是我止住了我笑意，去旁边买了瓶肥宅快乐水，补充了一下快乐，（这个时候我运动轨迹是：从家跑到公司，从公司跑到家，从家再跑到附近的上地医院）。
整理收拾了一下心情，在小区的买菜群，公司的外卖红包点点群，继续收集着信息。这时一个同事说：西苑医院给【弹窗④】做核酸，得，跑，我将自行车丢在了最近的地铁口，下地铁，到了西苑医院，排着一个未见过的长队，顶着太阳，队伍好久冇动，从前前后后的交谈中得知，队伍已经一个小时未动，据说医生去吃午饭了，已经中午了，是该吃饭了，我看了看了看队伍左手边的两个厕所和一个垃圾堆，感觉自己正慢慢裂开。
这时，我得到了另外一条消息，一些自费的核酸检测机构的检测点，给出现【弹窗④】的做核酸，另外一个同事说，公司附近的一个医院中午一直在做核酸，我想了一下，这面排着队伍的长度 and 医生剩余的午休时间，我决定一面要在自费的检测机构先挂上预约，一面去另外一个医院看看，去到另外的一个医院，先本能的排队，这时候，我在西苑医院的小伙伴说，医生加班了，队伍在飞速前进，正排着的时候，在小区的买菜群里刷到消息，之前是禁止弹窗人员检测核酸的，小区的临时核酸检测点，在13:30 到 15:30 会有弹窗专场，可以允许弹窗人员进行检测，我看了下时间：13:00，回村时间约 30 分钟，今天已经确定无法上班了，再次放弃排队，等我到小区排起队伍（此时 13:30），在西苑医院的小伙伴跟我说，他已经检测好了。呜呜呜，在这两难的坏与更坏的选择中，我选到了更坏的，不过大约 20 分钟后我也顺利的检测到了核酸。
按照得到消息：“如果今天核酸的检测结果在 24 点前顺利上传，将会在 24 点后解除弹窗”，虽然我刷了一下午的核酸检测结果，但显然我这行为对核酸检测结果上传进度没有影响，在 24 点我未在北京健康宝上查到今天的核酸检测记录，白天的东奔西走、可能不如预期了。
在新的一天的 1:30 我看着北京健康宝的弹窗，我觉得我要继续准备请假了，我控制了一下去开了一瓶冷藏的之前屯的肥宅快乐水的冲动（实在是有点晚），再次收拾精神，我不能放弃，还有个渠道是在北京12345上面民意直通上面申诉一下，崩溃的是这个网站一直在崩溃，它跟我一起崩溃，又经过了半个多小时，我在反复的崩溃中提交了申诉。看了下天气，明天会下雨，我的自行车还孤独的在某个地铁口，“对不起，我的车车。”
作为一个焦虑患者，我经常在不确定性面前溃不成军，辗转反侧，失去控制，今天的“不确定性”已经严重超标，之前囤积的野格、RIO 还没有喝完，但是，哒咩，该睡觉了，应该去睡觉了，去睡觉了。
5月6日早上，弹窗消失，拎起我的电脑包，出发，去搬砖啦！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%9C%E5%8C%97%E8%80%81%E5%AE%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%9C%E5%8C%97%E8%80%81%E5%AE%B6/</guid>
      <description>17/10/19 05:01
前段时间我回了趟东北老家，上次回去还是过15年春节的时候，大略有三年没有回去了，那是个只有两个区两个县的一个非常小的市下面的一个非常小的小山村。城市是个在半丘陵地带的资源型城市，不过煤在好多年前就挖光了，我去市区里看到最高的大楼还是一九九八年建的那个，不过大楼上的广告牌显示不是原先的那家公司了。老家和大部分东北农村一样，村里都是老人和小孩、不愿出去打工的中年人（会搞养殖和种地）和二流子，这两年老家村里主要有两件大事：其一是路修的更好了，村里通了更宽的沥青路，水泥路则修到了每户的门口，路边有修垃圾站，是一种三面用水泥墙围起来大约三四平米的非常简易的一种，据说垃圾站点之间有大的塑料的垃圾桶的，但是我村的我没有看见，被偷走了，据说放了两次都被偷走了，垃圾站也被秸秆堆满，没办法用了。另一件事是：试行打地归大户，打地就是丈量土地，算下每户实际上有多少地，然后土地入股，整村整体出租，由个人或者企业经营，每户每年按入股土地多少分钱，这样再加上春秋农忙时打工会比以前种地能略多一点点，还不用操心。我一个亲戚包了几百亩地给他儿子种，亲戚他自己养猪，平时在栏500头左右，去年据说利润就有150多万。跪👻……我回老家时去他家吃饭喝酒，他说现在村里空的厉害，没以前人多了，好多人家都空了，我说村里的人还是多，东北的人也还是多，国家要脱贫，耕地就那么多，一亩地一年也就六七百块的利，现在这么多人一家也就能分个二三十亩地，把人固定在这里种地效率太低了，以后归大户的方式肯定会越来越多，那样的话村里大概有三种角色，大户，失地农民和像你这样搞养猪、或者养牛养鹿、人参养殖这些搞特种经营的，但搞养殖是做生意，不是每个人都有条件的，也不是有条件的就能做成的，要看天赋和运气，你们大户站到了改革的风口还好过些，失地农民就不那么好过了，头几年他们还会给你们打工，再过几年他们就会发现南方工厂打工更轻松赚的更多，老人也许喜欢老家不会去南方，年轻人如果在南方干个十几年就不会回来了，到时见你们只能上机械化了，一般去流水线训练个几个星期，完全就可以参与到工厂生产了，他们的劳动附加值就跟产品和工厂跟相关了，算是工业人口了。这个过程肯定有不能顺利适应转变的，这就要看命了。大体方向就是农业人口变为工业人口和服务业人口。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%BA%E5%95%A5%E8%A6%81%E5%9C%A8%E7%A9%BA%E9%97%B4%E5%8F%91%E5%B9%BF%E5%91%8A%E5%95%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%B8%BA%E5%95%A5%E8%A6%81%E5%9C%A8%E7%A9%BA%E9%97%B4%E5%8F%91%E5%B9%BF%E5%91%8A%E5%95%8A/</guid>
      <description>2017/09/18 17:40
为啥要在空间发广告啊？想赚零花钱么？其实根本是赔本啊（为啥赔本后面说），有时间看看书，学习学习比这个好多了啊，即使不能学习，去学个乐器（最近我就对吉他有点感兴趣，就是手太笨、、、摔！） 跑个步也很好啊。钱不是那么好赚的，要想赚钱：本质上都要有自己一套完整的运作体系和优势，产品研发（需求：技术）、货源把控（需求：渠道人脉 例如：我有个当官的叔叔，那我可以拿到市政工程，或者我在行业内用心工作十几年，掌握并维护了大量的一级供应商，这些都是渠道）、{产品推广、客源开拓、客户维护、售后服务}（需求：体力 和 时间 还有 技能工具，学习的本质是让我们能掌握更高等的技能工具比如电脑、汽车，可以在出同等力气的情况下获得更多的收益）等环节在内的一套完整的运营系统，每个环节环环相扣，任何一个环节拿出来都是庞杂的，想过怎么运营一个项目么？有没有独立或者合作运营过一个项目没？没有系统学习过商业运作的知识，没有任何的行业经验，只会发广告。软文不会编，文案不会写，自嗨交易收益和PS的截图（别告诉我说你发的截图都是真的，我是你哥。。。。。。捂脸⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄），就能赚钱？想过怎么开发客户么？那些是潜在客户需要开发，那些是绝缘客户只需要基本的覆盖，不需要浪费精力努力开发，旧有客户如何维护？整么让客户保持忠心，如何让客户排斥其他家产品？竞品对手的产品优势是什么？自己产品区别于同类产品的核心竞争力是什么？为什么别人要买你的东西？你的客户定位在哪类群体身上？他们有什么特征？适合做什么类型的推广？你怎么去开拓新客源和维护好老顾客？怎么去培养用户推广自己的产品？即使这些都不考虑，你有想过你选的代理产品有没有特征和优势？是不是三无产品，用了会不会生病？会不会有法律风险，需不需要缴税，现在国家对虚拟商城（及网络贩售）的政策是什么样的？即使！！！你想说我就是只想利用点时间从 朋友亲戚！！！ 口袋里赚点买零食的钱，我也想告诉你你付出了什么，才换到了这点钱，（呼应开头的赔本）（道德的事我不想说，每个人有自己的道德标准），第一：那么任何行业都是有门槛的！！有！门！槛！的！（代价一：你想好了被人屏蔽，还在朋友圈落得一个刷屏做微商的笑柄，以后别人一问，啊某某某，原来你还做过微商，被人轻慢的代价了么？？？）第二：任何商业收益都是有成本的！！！有！成！本！的！（代价二：任何只依靠人情做的买卖，本质上都是在透支自己朋友圈的额度（朋友是相互的，当你索取却没有付出的时候，很快就不会再是朋友了。）。朋友不是赚零花钱的工具，他是你分享快乐，抚慰忧伤，互相竞争成长的有限宝贵资源，你确定，你的朋友就要这么消耗掉了么？备注：这个代价太大了，要留心体会朋友的珍贵，当然越老越会感受到朋友的珍贵，比如我这老家伙&amp;hellip;.摔。。。/(ㄒoㄒ)/~~）	综上所述：这是个完全不可行的赔本买卖，不值当投入精力与金钱！！！（特别是金钱，精力换教训。）	如果你真想做，学着去做陌生人的生意，自己去做个自媒体，去圈粉，如果连吸引粉丝他人关注的能力都没有，说明你真的不适合做这个，，还是适合老老实实的去打工去学习，毕竟这个社会就是绝大多数人在给极小部分人打工（你看人家刘备虽然不能打，但是粉丝多啊。。。）	最后，梦想总是要有的，前提是先好好学习（不是要赌那万一实现了的几率）。	————————————周末码代码期间的唠叨，未经过认真校验，所以就不要关注错别字啦。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BB%8A%E6%97%A5%E6%8A%84%E6%96%B0%E9%97%BB%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E5%90%91%E9%9D%9E%E6%B4%B2%E6%8F%90%E4%BE%9B600%E4%BA%BF%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%80%E7%82%B9%E8%A7%81%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BB%8A%E6%97%A5%E6%8A%84%E6%96%B0%E9%97%BB%E5%85%B3%E4%BA%8E%E4%B8%AD%E5%9B%BD%E5%90%91%E9%9D%9E%E6%B4%B2%E6%8F%90%E4%BE%9B600%E4%BA%BF%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%80%E7%82%B9%E8%A7%81%E8%A7%A3/</guid>
      <description>2018/08/04 13:58
今日抄新闻：关于《中国向非洲提供600亿支持》的一点见解：第一：专款专用，贷出去的钱，有严格的使用要求，钱其实不是直接给外头，而是让国内公司去那边接活儿，然后钱还是给国内公司。本质上其实是用国内过剩的基建能力去那边换东西，也就是去产能，举个例子：尼日尔阿泽里克铀矿，中国两家企业共持股 62%，尼日尔政府持股 33%；纳米比亚的哈萨博铀矿，中国企业持股 90%，纳米比亚政府持股 10% ；如果还不明白给你再举个例子，光绪年间，英国人瞒着清政府自己掏钱给中国建了吴淞铁路。当时大清还有点银子，自己买下来又给拆了。
至于可以不可以把钱投给买房者，复习下高中政治：商品的价值是由生产这种商品所耗费的社会必要劳动时间决定，商品价格是商品价值的货币表现形态。商品的价值不能自我表现，一个商品的价值必须由另一个商品来表现，并且只能在同另外一个商品相交换时才能实现。而这个“另一个商品”通常为一般等价物，也就是货币。货币作为商品的一种也是受供需关系和买卖意愿影响，举个例子：市场有1W个房子和1W个需要买房子的个体，每个个体有1W货币，当有人向每个个体发放1W货币的时候，在自由的市场，第二天房子就会有原先的1W/栋变为2W/栋达到新的平衡，只要市场中的提供者和需求者没有发生变化，货币的多少变化毫无意义，央行通过不断的印货币，和不断的通过无形有型的资产吸收货币，来维护货币的价值，当然我们是社会主义国家，并不全是自由市场，也有反例，比如火车票，节假日一票难求，因为供需关系和买卖意愿（供应方只能提供有限的产品，需求方需求巨大），且价格锁定，照成买票基本是靠运气，反过来说也就是个人努力照成的影响不大，你并不会因为更努力而变得更容易买到票（当然，真实的现实并不是绝对的随机，有各种路子走动），不知道大家更喜欢哪一种？这些例子比比皆是，比如摇号机动车牌照，深圳的摇号买房，因为后两种不像火车票一样拒绝私人交易，买到就是赚到，转手一买就是血赚一笔，前段时间有个专家说：火车票之所以难买，就是因为太便宜。结果被骂的狗血淋头，嘿嘿嘿，这专家是忘了我们是人民民主专政国家了吧。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BB%A3%E8%A1%A8%E6%9C%88%E4%BA%AE%E8%AF%85%E5%92%92%E4%BD%A0%E5%AF%B9%E4%BA%8E%E6%84%9A%E8%A1%8C%E7%9A%84%E4%B8%8D%E5%BF%8D%E8%A7%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BB%A3%E8%A1%A8%E6%9C%88%E4%BA%AE%E8%AF%85%E5%92%92%E4%BD%A0%E5%AF%B9%E4%BA%8E%E6%84%9A%E8%A1%8C%E7%9A%84%E4%B8%8D%E5%BF%8D%E8%A7%81/</guid>
      <description>代表月亮诅咒你
我就不会简单的诅咒，他的所行，暴露了他的愚蠢和嫉妒，如果不出大的意外，他将永难获得幸福，他将在愚蠢与嫉妒的地狱里挣扎，这世间所有好人对他的厌弃，就是他的诅咒，我，在这里，代表这世间好的人们，对你审批，为你定罪，告知你，你的所行，被我们所有人厌弃，从此，你将远离真诚，即使对最爱的人，从此，你讲背负阴暗，即使在阳光下，从此你将有一处被人唾弃。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BD%A0%E5%BA%94%E6%98%AF%E4%BC%9A%E9%94%99%E6%88%91%E6%84%8F%E4%BA%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E4%BD%A0%E5%BA%94%E6%98%AF%E4%BC%9A%E9%94%99%E6%88%91%E6%84%8F%E4%BA%86/</guid>
      <description>2015/07/06 09:33
你应是会错我意了，我是在有感而发，不是在单指你发的这个。 我之前说的：坦诚面对自己太难了，就如同我之前有说过，忠于自己太难了一样，我们本身都有着贪念，偏爱，欲望，懦弱，羞耻，这都是我们的本性，就如也拥有，爱、勇气（不是好勇斗狠，那不是勇气）、责任、善良、信任这些一样，但是我们更喜欢欺骗自己让自己相信自己没有贪念、欲望。 加之外部环境的无常和扭曲，我们必然需要靠谎言来重新解析、扭曲这个世界，使之能为我们接受，好让自己不去撞的头破血流。（谎言让世界变的更美好，谎言真好） 谎言变成了习惯和本能。 可我们还有更深的不接受谎言的本能。 所以我们想要坦诚的面对自己。 离题万里，举不恰当例子二三来说坦诚以待太难了。 比如说： 男朋友出轨了，无论精神还是肉体上，只要他有过那么想过：他要娶别人为妻子，他有那么一瞬间确定自己对另一个人的爱比对自己的女友要多，就是！接下来就是要去分析问题的 严重程度和如何处理了，如果男朋友出轨了，无非就是决然离开或者给他一次机会或者放任自流三种选择，普通女生表现就是一直在一二之间徘徊犹豫不决。为什么不去认可这个事实呢，要找些：他喝酒了，他还是更爱我多的（爱这么一种极度自私的也是可以分享的么）他一时鬼迷心窍了，他寂寞了，我对他的关心不够，我胖了对他的吸引力不够，我跟他吵架让他压力大，他没地方倾诉，我也是有不对的地方。为什么要找理由去欺骗自己呢，为什么不敢相信，我那个一直爱着的他变了，他没那么爱我了，我的爱情已经被破坏被摧毁被撕裂了，我那个一次恋爱直到结婚的童话再也不会在我身上实现了。为什么啊？无非是一些面子（不甘心、不服气、不认可自己输了，不承认失败），还有些不舍和怀念，不舍什么？不舍自己的付出，（情感、心力、心思、时间、青春、金钱）怀念什么？他的好（温柔、体贴、照顾依赖、甚至也有金钱房子）。第一种选择太痛太决绝了，好多人选择第二种，关键你能做到么？爱情需要平等、尊严的，他出轨了你怎么平等啊，他践踏了你的爱情你还跟他哪有尊严呢，以后你能做到不去介怀这事么，你能做到不再去怀疑么，你能做到一如既往的信任么？你能忍受住他出轨对自己每时每刻带来的屈辱和痛苦而不因此改变对他的态度么？能不会在吵架、心情低落、崩溃边缘不去拿这个他曾经的错误来攻击他么？等等 等等，有一点不能，只会越来越痛苦。所以纠结个屁啊，就是抬头挺胸，连痂带脓的揭掉，大步向前走。 例如 一个男生在跟一个他有认同有欣赏的单身的非其女朋友认识的女生频繁上接触沟通，这是友谊么？这是简单的友谊么？如果他再遮掩这个女生的存在，遮掩她女朋友的存在，阻挠他的女友和其的接触，这种行为正常么？他为什么会用一些，这只是普通朋友，红颜知己这类理由来掩盖着他贪婪的本性呢？他出轨了么？没有吧，他背叛了么，也没有吧，他意识到这是个危险、难以控制、不普通的关系没？我想 心里有感觉，心里是会明白的。但是他能拒绝这种关系么？他能在跟女朋友关系紧张结果不明的时候还能控制住自己么？另，我不否定男女间纯洁的友谊的存在，但我否定男女间简单友谊的存在。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E6%88%90%E5%B9%B4%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E6%88%90%E5%B9%B4%E5%90%8E%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/</guid>
      <description>2021/08/09
关于成年后继续学习的一些事：
1、时间：时间永远不够，要上班、要玩游戏、要刷微博、要刷抖音、要社交，这些有些是你无法拒绝且必要必须的，有些是精心设计利用你人性弱点，让你不知不觉难以抗拒的。
（这点我还好：1、我不在手机上下游戏已经好多年了而且对此没什么感觉。2、我告诫过自己少刷抖音，然后轻松做到一两周不打开抖音APP，而且也对此没什么感觉，3、唯一的是对微博&amp;amp;微信感觉难以脱离，我怀疑我有一种类似信息成瘾的疾病。）
2、精力：是的，”成年人是这样的“。每天工作挤地铁，你的大脑已经在拒绝工作，就是想做一些简单点、快乐点、放松点的东西。
3、路径&amp;amp;目标：目标，要说定目标是最简单的事了，没人反对吧！路径，本没有路，走的人多了，就成了路，别人的路径和计划不一定适合自己，而要想找到自己的路就是要多走。
4、坚持&amp;amp;面对挫折：放弃和定目标一样简单，过程中还会有很多干扰，而且学习某些情况是走出舒适区，会有很多挫折、会有很多碰壁，会无数次反问自己这样值不值，如果不能消化挫折，很难坚持下去。
5、选择：成年人需要做的事情太多了，能学想学的东西也太多了，要做抉择排序。
能有计划、长期的学习，我做起来很难，很多次放弃，得过且过。但是我却不是很能”甘心“的人，不甘心常常回绕，如火在烧，使我的心境得不到宁静，至死方休。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E4%BA%8E%E7%9C%9F%E5%AE%9E%E7%89%A9%E8%B4%A8%E4%B8%96%E7%95%8C%E4%B9%8B%E4%B8%8A%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%96%E7%95%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E6%8A%BD%E8%B1%A1%E4%BA%8E%E7%9C%9F%E5%AE%9E%E7%89%A9%E8%B4%A8%E4%B8%96%E7%95%8C%E4%B9%8B%E4%B8%8A%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%96%E7%95%8C/</guid>
      <description>2022年3月15日
之前，博主@闪光少女斯斯 的一场直播：#女生之间存在真友谊#的微博下我评论到： “歪个题，男女之间存在真友谊么？我的答案是：存在，至少在某个时刻，某段时期，是存在的，不掺杂其它欲望。唯心有物，很多东西你认为它存在，它就存在，你不相信它，它就不存在。友谊、爱情、上帝、国界等，这些抽象于真实之上的，如果用“它们可以对真实物质世界产生影响”来定义“存在”，那么它们都是是真实不虚的。（继续歪个题：我个人认为，友谊、友情，真的很珍贵，不次于爱情，不要因为对方是异性就混杂了友情。） 继续歪题，我想到，“唯心有物”是心学的句教，但我之前了解到的搞名相是大和尚啊，例如：“不是风动，不是幡动，仁者心动”、“身是菩提树，心如明镜台。时时勤拂拭，勿使惹尘埃”、“菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！” 《王阳明四句教》 无善无恶心之体，有善有恶意之动， 知善知恶是良知，为善去恶是格物。
有心俱是实，无心俱是幻； 有心俱是幻，无心俱是实。
心学：有心俱是实，无心俱是幻； 禅宗：有心俱是幻，无心俱是实。 心学：心为实本 禅宗：心为空幻 心学：致良知 禅宗：一切有为法，如梦幻泡影，如露亦如电，应作如是观。 禅宗：凡所有相，皆是虚妄;若见诸相非相，即见如来。 禅宗：所有皆是名相。名相，耳可闻者曰名，眼可见者曰相。 超验 和 康德的“人类无法精确认知事物”
一切唯心造 缘起性空 金刚经以名相喻空，心经更进一步，舍利子，色不异空，空不异色，色即是空，空即是色。受想行识，亦复如是。
受想行识：感受、想法、行为、见识
有些困难，科学可以解决，生老病死，科学暂时不能解决，宗教可以。
有些时候不能从正面描述，只能从反面描述，比如“无为”不好描述，就描述“有为”。 真心和妄心、本心和本性。 知行合一，禅宗多是知，近于空幻虚妄，心学：传习录里，阳明完善了心学的功夫体系，首先立圣贤之志，然后慎独、克制省察，私欲日减，回归到先天的未发之中。 《传习录》是心学的最重要经典，阳明心学是围绕大学中庸展开论述的，没有儒家四书的基础，是根本读不懂《传习录》的。 易中天曾经总结过，禅宗是以有为求无为；孔子是以有为求有为；庄子是以无为求无为；老子是以无为求有为。
心学继承儒家道统。是以有为求有为的路子
心迷法华转，心悟转法华 相由心生，境随心转，心生万物 应观法界性，一切唯心造。 明心见性，直指本心
这不是孤立和偶然，当人类文明发展到一定程度，会抽象出大量的于真实物质世界之上的概念。如何理解这些概念，这些抽象于真实物质世界之上的概念与物质世界的关系，甚至，这些“抽象于真实物质世界之上的概念”会侵蚀真实的物质世界，会重构我们对真实物质世界的理解，这些都是必然发生的，可惜我没看完罗素的《哲学简史》，在西方哲学和宗教的源流发展中一定也会有相应的概念。但是，在中西方的同时期，先秦诸子和希腊先哲，同时创建出了大量的灿烂思辩火花，我没有证据，但我个人认为，他们是重构了对真实物质世界的理解，几千年前的人们，他们眼中的世界轰然崩塌，又重组成为了一个新的世界。
过了好久我才明白：我需要一个我爱的人来注视我
我们公司有个要求是：“每年必须提供20小时的社会公益活动时间”，通常都是去做志愿者啥的。有一年是去给烈士陵园献花，陵园中有一个影壁上面记录了一些烈士的信息：有十几岁就已经参军几年后牺牲的，有兄弟三人先后牺牲的，有年纪轻轻的连长牺牲的，有无名无姓牺牲的，当时的一个比较被触动的点是，大多数战士牺牲时年龄比我现在还小，有些人的年龄甚至在我眼里就是个小孩。天灾人祸，好似疫情，你没的选。
因为反对既非共和制、又不民主的法兰西第二帝国政权，维克多·雨果被迫流亡海峡群岛，他于1861年11月25日在流放途中写下了这封信，“但我要抗议，而且我感谢你给我提供了这样一个机会。统治者犯的罪并不是被统治者的错，政府有时会成为强盗，但人民永远也不会。”
实际上我认为网络空间有多少能认真讨论交流的可能，比如我说上帝是存在的，你会认为我可能时一个有神论者，实际上需要先定义“存在”，如果用“它们可以对真实物质世界产生影响”来定义“存在”，无需置疑，上帝、国界、爱情、忠诚，这些抽象于真实世界物质之上的都是存在的，所以，稍微的想要认真点交流就需要先确定语义，大家基于一些恒定的概念进行讨论，而很明显，三次握手在日常网络聊天里并不可能。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E7%BB%8F%E9%AA%8C%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E7%BB%8F%E9%AA%8C%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
      <description>2022年3月25日
对于具备能力的人来说，经验更重要（经验是能力的另一种形式）；对于不具备能力的人来说，知识更重要（学习知识是形成能力的载体）。
（知识是固化的成果，经验是运动的信息）。
一个是客观世界，一个是主观世界。
对于未知的问题，知识更重要。 知识和经验的问题， 例如：”保持平衡“是知识，骑自行车是能力和经验，如果学会了骑自行车，即使十年没骑，再次遇到也会，这就是经验转为能力。对于具备能力的人来说，经验更重要（经验是能力的另一种形式）；对于不具备能力的人来说，知识更重要（学习知识是形成能力的载体）。（知识是固化的成果，经验是运动的信息）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E8%8F%A9%E8%90%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E8%8F%A9%E8%90%A8/</guid>
      <description>A: 你一定得尝试身心投入的喜欢一个人
A: 有点上瘾。
sky: 我知道
A: 我喜欢上了我单位的一个男同事。
A: 我只是喜欢的，不是想睡他。
A: 我不睡他，我心里也很舒服
A: 我也不想打扰他。
A: 我也不在意他喜不喜欢我。
A: 实际上他对我还挺好的。但是他做啥说啥无所谓
A: 我自己喜欢我自己的。
A: 跟别人没关系。
A: 就好像他只是个寄托
A: 放在那里，让我自律
A: 真的是痴迷。
A: 而且我也不跟他聊天，我也没啥，我感觉我每天在脑袋里就能聊
A: 自己跟自己想象中的他聊。
A: 一来一往。
A: 就是每个问题他大概的答案我都知道。
A: 或者就算我不知道
sky: 是存在于精神世界
A: 我可以推算出各种可能性来延伸每个分叉
A: 这样
A: 就是我除了睡觉的时候
A: 都在想他。跟他聊天。
A: 但是他毫不知情，也不用他知情。
A: 我也不找他。我现在也不想做爱睡觉什么的。
A: 我感觉我可能净化了一下我自己
A: 无欲无求，就是痴想。
A: 这种想，让我的上班路下班路即使不听音乐，也变得无比轻松
A: 我在想念这件事上很容易投入，所以走路一个小时我根本不知道路边是啥，凭直觉就到了我要去的地方，甚至觉得路短。
A: 就是啥都不耽误
sky: 一种寄托
A: 总之是好的影响。
A: 不是坏的。
A: 就是我走路一含胸驼背，我一想到他，我自觉就抬头收腹挺胸了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E9%80%89%E6%8B%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%85%B3%E4%BA%8E%E9%80%89%E6%8B%A9/</guid>
      <description>好像是这几年吧，哎，也不是这两年，是这几年我的一个主要的对自己的改变就是：用“无差”的角度去看很多事情。 很多事情在我眼里已经没有了，好坏和高下和正确与否的区别了。 他们全都变成了选择都不同而已。 「用“无差”的角度去看很多事情，知道找到辨出什么是自己喜欢偏爱的」，与你用什么方式来应对这个世界不冲突，明白自己的偏爱和倾向，和有能力去“入世”。 选择想做就做，选择三思而后行。 “入世”是指这“世间”的倾向和角度。
选择与过去的自己和解，选择永不原谅自己。 选择相信爱情，选择带着镣铐起舞，选择自我约束，相信自由只有存在约束才有意义。 选择丁克，选择沉默，选择不解释，选择放弃，选择坚持，选择忠诚，，选择相信金钱，选择价值博弈体系解释一切，选择相信在价值博弈体系之外还有感情体系。选择相信有纯粹的男女友谊，选择相信男女之间不可能有纯粹的友谊。
不知道我什么变成这样，可能是因为一句鸡汤：“选择决定了我们成为什么样的人”。 或者是我察觉到在漫漫人生路中能自我做出的选择太少也太珍贵了。
2021/11/08
最近无数次在脑海里回荡：“选择决定你成为何人“，但是过去种种，不知选择标准，被欲望、短视、惰性影响做出了错误选择，而更多时候是冇的选择，就这样，我做一些我不认可的选择，成为了一个我自己不喜欢的人。 最近这些年做的比较正确的选择有两个，第一个：早些年猛贷款，在房价不太离谱的时候上了车。第二个：换行半路出家的做了程序员。做对了两个正确的选择让我现在好似不是那么窘迫，但是也做了很多错误的选择，比如没有减肥、没有早点用心护肤、没有学习英语、没有提升学历、在没结果的（错误的）感情上不知回头，这些错误的选择在现在，在未来会逐渐对我饱以老拳给我教训。早些年常常在脑海中回荡的一个词是：”囿于“，外部的限制和内心限制，让人在想前行时举步维艰。那时候在脑海里回荡的是：“虽然不知道想去哪儿，但是不想在这”。 2022/01/04 11:38 前两天跟朋友吃饭聊到单身问题，朋友说：“如果 你是女生或者你的女儿，你会喜欢一个你这样的人么？”我：“这个问题我早有答案。 附上一个很久之前的自言自语【“最近无数次在 脑海里回荡：“选择决定你成为何人“，但是过去种种，不知选择标准，被欲望、短视、惰性影响 做出了错误选择，而更多时候是存的选择，就这样，我做一些我不认可的选择，成为了一个我自己不喜欢的人。 最近这些年做的比较正确的选择有两个，第一个：早些年猛货款，在房价不太离谱的时候上了车。第二个：换行半路出家的做了程序员。做对了两个正确的选择让我现在好似不是那么窘迫，但是也做了很多错误的选择，比如没有减肥、没有早点用心护肤、没有学习英语、没有提升学历、在没结果的（错误的）感情上不知回头，这些错误的选择在现在，在未来会逐渐对我饱以老拳给我教训。早些年常常在脑海中回荡的一个词 是：”国于“，外部的限制和内心限制，让人在想 前行时举步维艰。那时候在脑海里回荡的是：“虽然不知道想去哪儿，但是不想在这”。】 如果一个不喜欢、不认可的人是你的同事、同学甚至是亲戚，你都有办法远离，但这个不认 可、不喜欢的人是你自己本身呢？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%BE%88%E5%A4%9A%E5%B9%B4%E5%89%8D%E5%9B%9E%E5%A4%8D%E6%9C%8B%E5%8F%8B%E7%96%91%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A7%E5%A4%B1%E8%A1%A8%E8%BE%BE%E6%AC%B2%E4%BA%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E5%BE%88%E5%A4%9A%E5%B9%B4%E5%89%8D%E5%9B%9E%E5%A4%8D%E6%9C%8B%E5%8F%8B%E7%96%91%E9%97%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%A7%E5%A4%B1%E8%A1%A8%E8%BE%BE%E6%AC%B2%E4%BA%86/</guid>
      <description>从几个方面说吧：有一种可能是生活变的枯燥，或者机械忙碌而导致心灵麻木了。我记得我小时候有极其旺盛的好奇心，好奇新发下的书里面写有什么，好奇收音机、好奇电视天线、好奇磁铁为什么会吸引铁，即使对着一块磁铁玩一天，也毫无枯燥，会引发无穷无尽的幻想。前段时间我在路过一个地铁站的时候，看见地铁工作人员打开一个门，后面是个长长的走廊，我突然意识到，我对这些门及门后的世界不是那么好奇了，也不会迸发出无穷无尽的幻想了，像失去了看《哈利波特》第一集时那种每个门后都有一个无限新奇世界的幻想了。我不知道是每天的机械忙碌，还是日益繁杂的世界，还是被不断刺激变高的阈值，或者是被这个社会物化或者异化，我的好奇心丢掉了很多。我认为只有有着敏锐的好奇心，才会被轻易的挑动大脑神经，让你文思泉涌，喷薄而出。 第二就是要有时间、精力和日常积累，每次想BBB都要赶紧记下来。 还有个就是，我现在很少写（自由而无用）东西的一个原因是，大多数时间都是在写读书笔记、技术文档之类的（有用）东西，现在记忆里是真的不行了，看个书必须要做笔记，反复看，反复总结，耗费了大量的时间。我知道不应该把时间过多的分配给这些（有用）的东西，但是怎么说呢，技术文档还是很好玩，偏心啊。 最后：我认为“我想对这个世界说点什么”，这是本能，</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%80%A7%E5%88%AB%E6%80%A7%E6%80%A7%E8%A1%8C%E4%B8%BA%E7%88%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%80%A7%E5%88%AB%E6%80%A7%E6%80%A7%E8%A1%8C%E4%B8%BA%E7%88%B1/</guid>
      <description>性别、性、性行为的一些问题和答案（自问自答）
问题1：性欲 与其它欲望的差别？ 性欲与食欲应该是一样的本能欲望，激素波动。
问题2：性行为 与其它行为的区别？ 第一是：健康应该是第一要务。 第二是：性行为是“亲密行为”的一种。接下来是关于”亲密行为“的认知和发生的标准的选择，属于选择问题：与选择忠诚和自由，应没有差别，没有高低之分。（自由派在嘲笑忠诚派愚蠢的放弃人的部分权力甘心成为奴隶，忠诚派在嘲笑自由派不知道献祭、牺牲、信仰、真诚的价值？）。
问题2.1：性行为 的标准？ 自由、健康、平等、安全（甚至都不包含私密，我真是混乱邪恶）
问题3：对异性的认知？ 女性如何看男性，男性如何看女性？ 跟 问题7 合并
问题4：性教育和自我保护？ 在 问题2 基础上需要注意的孩子的保护和教育：私密空间、混乱场所、夜晚，不要对任何可发生性侵害的人有任何基于身份的信任，保持警惕。
问题5：性 魅力与祛魅？
性冲动和性器官相关的东西是否低俗？ 人类低俗的欲望？享乐的欲望？自私的欲望？这些欲望是否是“坏”的东西？ “荤段子”是否【全部】是暗示了色情？物化和亵渎女性？可以是仅仅是拉近关系的行为？ 大姨妈、蛋疼、逼、操是否要直接映射到性映射到“低俗”、“坏”，进而是需要避讳的言语？ （个人结论是：这些“映射”不是必然的，有些类似：“人渣是男人，男人是人渣”，有过不好性经历或者性教育认知的过往，痛苦与性夹杂在一起，打破扭转这种本能映射更难（人有很多本能的感性映射，锋利的刀尖逼近就感觉到恐惧，慈眉善目衣着华丽就本能信任，而因为某些的经历，再次见到类似因素，就映射到痛苦，这是本能的自我保护，但是因为一些经历就放弃一些东西，我总有点儿不服气。） 问题6：对自我的性欲和性冲动与异性的性欲和性冲动的客观认知？
如果鄙夷他人、异性的性冲动和性欲，也会鄙夷自己的性冲动和性欲。 骚、发情、性欲涌动应该中性的。（欲望涌动是本能的，应该是中性的，欲望涌动改变自己的行为应该也是中性的，我只对因为欲望涌动而破坏自己的原则认为是负面的，是不好的。） 问题7：男性女性的认知？ 1、我们都是人 2、我们有相似的认知和情感（关于真诚、真挚、责任、爱） 3、性别的生理差异，会带来自我认知和限制的差异 4、传统文化对性别认知的塑造，带来的进一步的自我认知差异 5、社会的性别的区别的对待，带来的进一步的自我认知差异 6、正视性别差异带了的利益的差异 7、关注仅仅因为性别不同带来的权力和义务的利益差异
问题8：物化男性女性？ 男性不过是“人形自走炮机”？
问题9：对另一半过去的性经历的看法？ 可以跟 问题10 合并。
问题10：应该是没有爱的性行为更“可怖”一些？ 我个人的选择是不支持仅仅因为生理欲望去发生性行为，因为“爱”而发生性行为更被我接受，逻辑是：性行为是亲密行为，亲密行为是在精神足够亲密的情况下才可以发生。（我们应该像保护身体一样保护我们的精神，有选择的允许什么”信息“进入我们的大脑）
问题11：异性朋友的可能？ 先说个人答案是:可能。可以是因为外貌、性格而有异性朋友的，不一定是一定有“潜在想法”，不要“恶意”揣度别人，但需要保护好自己。
问题12：性行为与自尊和自爱、自律？ 好像与暴饮暴食没啥区别，没啥特别影响。
问题13：黄色影片带入周围认识的异性及各种性癖？ 性癖是平等的，（坏事论迹，好事论心）。
问题14：强奸是因为更强烈的性冲动？ 不尊重女性，不克制自己，自私的因素更大，而不是“更强烈的性冲动”，即使不是“性冲动”，这种人也会在方方面面，不同的方式，不同的行为，去不尊重他人，不尊重女性。
最后： 要尊重强烈的情感，性欲与其它人的生理上的“低俗”欲望可以是单纯而美好的，不要异化和扭曲，夹杂太多“后天社会价值“的东西去扭曲它。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%83%B3%E8%B7%9F%E6%88%91%E6%9C%8B%E5%8F%8B%E8%AF%B4%E8%AF%B4%E8%BF%91%E5%86%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%83%B3%E8%B7%9F%E6%88%91%E6%9C%8B%E5%8F%8B%E8%AF%B4%E8%AF%B4%E8%BF%91%E5%86%B5/</guid>
      <description>想跟我朋友说说近况，从四年前说起吧，那个时候家里在装修，每天跟装修公司斗智斗勇，因为需要在不是自己擅长熟悉的， 时常有身在激流中，身不由己</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%9C%89%E8%AF%9D%E4%B8%8D%E7%9B%B4%E8%AF%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E6%9C%89%E8%AF%9D%E4%B8%8D%E7%9B%B4%E8%AF%B4/</guid>
      <description>有话不直说？
2022年8月10日
我还真想过这个问题：
1、没办法直接表述：比如：没办法描述什么是“空”，佛经里就墨迹一万遍说什么不是“空”，比如：无法直接描述什么是“无限”就描述什么是“有限”。 2、语言是阶层和身份的的一种体现，古今中外，某些“阶层”的人都喜欢说让普罗大众听不懂的“黑话”，例如：在大厂的用“抓手”、“闭环”，留学的用“中英夹杂”，某XXX，用增强“四个意识”，坚定“四个自信”，做到“两个维护”，在古文用之乎者也，大家说英文，某群体人使用拉丁文。 3、“专业术语”，特定行业是为了更精确简练的描述、更高的沟通效率而在特定行业约定出特定词语，例如：鲁棒性、幂等、单例、递归。（专业术语与黑话是不同的。） 4、炫技和习俗、文化。 5、纯纯九漏鱼，水平不行，说话颠三倒四没有逻辑。（充斥网络） </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%88%E6%88%91%E5%B0%B1-30-%E5%91%A8%E5%B2%81%E4%BA%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84/%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%88%E6%88%91%E5%B0%B1-30-%E5%91%A8%E5%B2%81%E4%BA%86/</guid>
      <description> 还有一个月我就 30 周岁了。 我小的时候是在村里，初中时在乡里，高中在县里，大学去了一个小城市，毕业后去了一个大一点的城市，几年后稳定了一点，又去了北京。这二十多年，我好像一本三流的网络小说，一直在不停的升级换地图（这给了我很多错觉、幻觉）。 好像不知不觉中选了离开家乡的一条路，故乡不断远去，却又未与周遭建立联系，融入进去，时代的巨轮缓缓碾过，似身在激流中，似无根的浮萍，怕未留下痕迹，怕被遗弃，怕丢掉自认为重要且珍贵的东西。自在的乡村，格格不入，摩擦不断茫然的新生活。 初高中毕业，我觉得我那时候，更多一点的是一种扬帆出海的心情，大学毕业更像梦醒、梦碎，被身不由己的往前推着走了一步，步入一个被厚重迷雾笼罩的梦境。 很长一段时间都不能接受自己是个色批和性欲。 有过几次幡然悔悟：“我觉得这是一种没有结果的梦。”有点类似：“然后突然有一天就不爱了，完全不爱了。” 感觉年龄越大越难以接受其他人，建立信任，互相融入生活，了解过去，了解想法习惯倾向，大家都有了一些堆积的过去，愈发变的奇形怪状，顽固难改，仿佛走入了一个越发偏僻的小径，更难遇到同路的人，也没有年轻的时候的冲动，想想都觉得好麻烦。 精神ED了，啥都觉得烦。 小时候的我，一定认不出来，也理解不了，现在的我，想不到30岁的我是这样的石某人。 偶尔会有一种：“我怎么就这样了？”的疑问。 有过随波逐流，有过放纵堕落，有过一些羞耻到想杀了当时的那位自己的事。 前段时间尝试 咖啡 + 牛奶 ，试过之后的结论是：我还是喜欢单纯的咖啡那复杂的苦味，加了牛奶就会被柔和掉所有细节。小的时候的我应该会对一个人会喜欢“复杂的苦味”嗤之以鼻。 缺乏勇气，我害怕面对结果，很多事，觉得自己还没有准备好，不敢面对接受结果，将很多事置于悬而未决的状态。错过很多。 我觉得，我现在活到30了，还是需要找点东西深入一下，否则人变得空心了，我怕空心的自己会随意堕落。 小的时候我就知道我是个懒鬼，就知道我不是个很主动积极的人，也不是一个爱主动积极的人 ，不过是我比较能委屈自己，知道取悦迎合而已。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%93%94%E5%93%94%E5%93%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%93%94%E5%93%94%E5%93%94/</guid>
      <description>给支援女医生剃头这事就是侵犯人权，有辱尊严，无论是给男医生还是女医生。但我们的“人权”和“尊严”的基准是随时代、社会、科技、物质水平在变化的，虽然“集体主意”是要“个人”“牺牲”个人权利，而无疑我们渴望得到更多的“个人”权利和尊严，我们的政治正确是什么？集体利益至上。之前我说人类社会要正常运转，就是要一定比例去种地，就是要一定比例去做理发厨师服务员，就是要定比例的人去做重复且枯燥的劳动，蓝星就这科技水平，道德也一样，法律是道德的底线，那么整个社会的道德底线都低，而你自认为的道德底线比其高的时候，法律看起来就像是在保护恶人。 在网络上经常会忍不住吐槽到：“这个人怎么不讲道理呢”。要理解你有你的利益和道理，我有我的利益和道理，有些你认为是真理的东西可能另一个人都没听过。即使是客观存在，每个人的角度位置不同，看到再描述出来可能完全不像一个东西。所以有些时候 圣经 论语 宗教是有益的，你遵从圣经我也遵从，述说一样的道理有一样的是非好坏认知。对了，网络在加剧这种隔空观念冲突，毕竟地球村了么。 我这辈子遇到过的最多的SB就是在初高中的时候，一堆男生以古惑仔为人生楷模，渴望着混社会，无端的欺凌别人，以好勇斗狠为政治正确。以 你不和我们玩就是不合群就是SB为准绳，现在这群人长大了，以你不同意我的观点，那你一定是SB来继续东征西讨。我相当长的时间的人生目标就是逃离这些SB，这几年又有一个目标就是想办法帮助一些人成为更好的人，也远离这些SB。 我很小的时候就知道，我虽然羡慕大侠，但我自己是做不成大侠了，大侠老是打坏桌子，而做一个桌子是很难很辛苦的。 我也遇到过类似于强按着给你剃头的事，我都快三十了这份耻辱感也还在回荡难以平息。
2018/12/29 11:37
最近一段时间的BBB：这些年互联网行业的发展兴起主要的一个影响因子就是移动通讯的兴起，过于珍贵的带宽和流量是无法支撑庞大智能机终端也无法建造丰富多彩的网络世界，从最开始的 博客+天涯时代主流的互联网内容是文字，后面的微信、微博、Facebook，主流已经变成图片了，到再后面的抖音 是短视频的时代，抖音的一大作用是降低了视频加工制作的门槛，现代社会的一个缺点就是无尽的机会无法及时抓住的痛苦，互联网的信息革命之前信息是珍贵的，而现在，信息泛滥了，贬值到一钱不值，无尽的信息在向所有人倾泻，阻塞着每个人接收信息的接口，现在的问题是如何发声才能在信息洪流中让适当的人接收到你信息（有个方式是蹭热点，因为注意力倾斜，让更多的人看到你的信息），互联网某种程度将人类集合成了一个社群，人类从来没建造过如此之大的社群，如何快速的获得信息是个问题，标签化是解决这种问题的一种方式，带来了明星的人设、各种地域歧视，标签 本身没有好坏之分，精简抽象了复杂的信息，抖音通过背景音乐、特定的滤镜、拼贴剪辑手法，定向且标签化的传递信息（表达作者想传递的观点）。如此多的信息在网络里流转，相应的大数据，云计算，人工智能也得到了发展，5G会进一步降低带宽和流量的成本，可以让更多的现实世界的角色进入到网络，IoT就是一个大家明确会发生的风口。
2021/01/19
有些问题科学或正确方式解决：比如亩产 500 增加到 1000。 有些问题是没有科学方式的解决的：比如生老病死，怨憎会，爱别离，求不得。 有些问题是有正确答案和执行方法的：比如很多考试考卷的标准。 有些问题是没有正确答案和执行方法的：比如人生的很多选择。
比如李子柒的视频确实好看，无论运镜还是取景，但是我对她表现的“田园生活”没有任何向往，因为我小的时候就在山上放过牛，田里河边放过鸭子，我知道隐藏在镜头下的工作量和各种琐碎麻烦，一点美化的滤镜也无。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%94%BE%E4%B8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%94%BE%E4%B8%8B/</guid>
      <description>真正的放下：就是不会再去幻想未来的跟你的无数可能性。
我曾经浓烈地，独一无二地，像献祭一般地爱过你，在我的世界里，你就像神一样，后来发现自己像个猴子。
委屈不会对你讲，快乐也不会对你分享。
我想念着你，却装作普通朋友一样去看你。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%85%B8%E6%96%87%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E7%BB%8F%E5%85%B8%E6%96%87%E5%AD%A6/</guid>
      <description>定规矩、判高下、分黑白、辨好坏。 日本大文豪：夏目漱石。福泽谕吉。井上靖。
阅读托克维尔的书、寻找那个逝去的时代
眼前的书架上有： 历史的观念，柯林伍德 植物的欲望，迈克尔波伦 单行道，本雅明 探索真理的指导原则，笛卡尔 梦书，费里尼 黑羊，蒙特罗索 百年孤独，马尔克斯 幻想图书馆，寺山修司 罪与罚，陀思妥耶夫斯基 卡拉马佐夫兄弟，陀思妥耶夫斯基 地下室手记，陀思妥耶夫斯基 浮士德，歌德 启蒙辩证法，霍克海默 我心中尚未崩坏的部分，白石一文 新恋爱讲座，三岛由纪夫 悉达多，黑塞 论人类不平等的起源，卢梭 宽容，房龙 文化理论与大众文化导论，斯道雷 西方哲学简史，赵敦华 寂静的春天，卡森 中国历史研究法，钱穆 四书章句集注，朱熹 葫芦兄弟</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E8%8D%AF%E7%89%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E8%8D%AF%E7%89%A9/</guid>
      <description>丙戊酸钠
丁螺环酮
安非他酮
曲唑酮</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E8%A7%82%E5%AF%9F%E8%AE%B0%E5%BD%95%E5%90%90%E6%A7%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E8%A7%82%E5%AF%9F%E8%AE%B0%E5%BD%95%E5%90%90%E6%A7%BD/</guid>
      <description>观察、记录、吐槽
2022年10月12日 小的时候，听到过很多大名鼎鼎的人，他们在这个世界上留下了许多痕迹，小的时候最羡慕城市的地方就是城市有图书馆，现在好像终于有些时间精力了。
2022年9月20日 节约也是好的对的，健身也是好的对的，多读书也是好的对的，但是都是相对的“更好”而不是绝对的正确，但是两个人在一起是包容成长，互相改变，而不是分高下对错
2022年6月17日 关于超限拥挤状态挤地铁 俺不行，在特别拥挤的环境，会特别特别焦躁，看书看不进去，听歌也完全感受不到节奏，只会感受到嘈杂。。。整个大脑处于一种拒绝服务状态。。。
2022年7月18日 向下俯视的人，必定会像上摇尾巴，因为在他的眼里，世界是个阶梯，与此同时，他也物化和羞辱了自己，不在眼前，就在它处，因为在他眼里的世界是个阶梯。
2022年8月1日 “文明国家”血腥的殖民行为被温情的全球化所代替，当地人在田野里大汗淋漓的劳作被外包的工厂和客服中心所取代，异域既不是完全原始的，又不是彻底城市化的。
最近看了两条微博，有些要忍不住吐槽，一条是：“长期从事重复性而非创造性的体力或脑力劳动，是对自己的一种犯罪……”，另一条大体是：“我受过高等教育，做着人类精英的工作，过所谓top5的生活，闻得出别人身上地铁站的味道了！为什么我还和蟑螂一样搋马桶”。一个评论是：“是普通劳动人民的重复劳动解放了你们这些精英，所以你们这些精英必须通过创新来解放和补偿他们。”我完全同意这个观点。一个时代，它的科技程度，思想方式，决定了生产效率，进而也很大一部分决定了进行重复而基础工作的人和进行科学研究的人在人群中的比例，而很多人认为，那只是自己努力的成果。我鄙视那些不努力的人，但我完全不鄙视那些在劳动分工中从事比较简单基础工作的人。
对于程序设计第一步就是划分角色！！！
每种编程语言都有自己的特点和作用，Python 的特点就是简单，让人可以简单便捷地利用它来让电脑做一些事情，比如统计下你几年来手机里积累的一万张照片在哪一年，哪一月，哪一天拍的最多。计算机是一个智力辅助工具，增强你的记忆（用支付宝和微信，你可以知道去年的今天上午你花了多少钱买了什么。），增强你的计算能力，将复杂的问题变的简单。
2021/07/26
春秋无义战，那时候就会互相污蔑对方的王族血统，对方的贵族道德败坏，对方的国家危险动荡天灾人祸不断，出不义之师。那么现在世界上的国家的互相攻击行为会是“义”的么？都是互称“不义之师”。
在几年前，我爬山爬到山顶，热的要死，忍痛在山顶上买了一个雪糕，刚扒好，还在喘粗气，一个大概五六岁（大概到我大腿高度）的小孩疯跑撞的我一趔趄，雪糕掉了，我正准备转身找这熊孩子的时候，他妈小跑过来，我以为她准备拉住小孩给叔叔道歉，结果他妈走到跟前白了我一眼，回头喊小孩：“慢点跑”就走了。我知道这样放肆下去小孩早晚要出篓子，看了看地上的雪糕，我毫无愧疚感的没有提醒这位妈妈，好多熊孩子产生原因其实是因为他父母是熊孩子长大了而已。
前段时间，微博的王志安就一事发表看法，底下有一个人评论：“你一个文科生懂个屁啊。”王局转发评论大意是说：“第一：他（王志安）高中的时候是理科并不差；第二：“就事论事”很重要；第三：有些人一生中最辉煌的瞬间，就是在中学文理分科的时候选择了理科，这种优越感贯穿他们苍白的人生”。
绝大多数人“自我实现需求”应该是一种刚需，且需对比才能得到，
#童模被家长当摇钱树#，
童模是不是童工，如果不是童工的法律依据是什么，如果是童工，劳动保障部门为什么没有任何干预？我认为童模明显违反了 中华人民共和国国务院令 第364号 《禁止使用童工规定》啊。还有可不可以引导淘宝等电商禁止使用儿童模特的服装照片？或者防止出现“凉山格斗孤儿”情况，对父母失去劳动能力的家庭进行童模时进行严格管控？（现实的一个情况是，如果初中毕业（15岁左右），无法继续上学，因为正规工厂不收童工，只能去黑作坊或者流落社会。）
当你得知一个你认为很理性、聪明的人，粉蔡徐坤的时候，你就会有点懵逼，不知道是该改变对这种偶像崇拜的定义，还是改变对你这个朋友的认知。
一个人发出：“阿斯顿发ID就发哦if噢爱好”，另一个人是不会也无法抄袭的，因为并没有： “”有 意义 的 信息“”供人 抄袭，但是鲁迅的：“院子中有两棵树，一颗是枣树，一颗也是枣树”，就可以被抄袭，应为文字被整理排序后具有了意义，马哲的第一章：“意识及其能动性”中认为，意识具有影响现实世界的力量，而意识影响现实的力量的主要一种就是对信息的整理，将杂乱无意义的字或者说元素，组合成有意义的信息。我认为抄袭，就是把别人基于自己的认知和经验，对元素加工后产生的信息进行抄袭。但是也有各自基于自己的认知和经验发明出相同的东西的情况，比如，大家都认可牛顿和莱布尼兹基于各自的研究同时发明了微积分，注意啊，这可是同时啊。
正常啊，你不是最后一个，每天都会有无数人进行着这些重复的发现，别说你这些现实世界的造物，即使是想法，也会有无数重复，甚至是孤独
我在看《心是孤独的猎手》时，清晰的感受到作者在描述一种我曾经感受过的一种孤独，
你明白吧，完全不同时空的人会有相同的感受。
更别说这些些灵机一动的想法及造物了。每天都有人在重复。
对于：“你好，妹子，推动一项影响社会和行业的立法需要白左美好的初衷”；
我：你好，“兄弟”称呼确实孟浪，无意冒犯，对不起。 我认为这议员建议类似于：“义务教育”推行至大学阶段，这种，看起来美好，但是稍微一想就知道，培育学生是需要资源，教员的工资及学校的运营也是需要资金，免费并不是真的免费，而是由国家负责管理，国家也不会生产钱，会转嫁给税收，而管理资金也是需要成本的，在管理成本及普及教育带来的效率提升之间还有复杂的博弈。
对于：“也需要反对者提供另一个视角的损失，更需要从业人员基于专业知识提出可行性的措施。”
我：完全同意。
对于：“你应该也不了解一项法案从构想到投票通过(也可能通不过)最终开始实施的整个过程。”
我：大体记不清了，忘记是历史还是政治说的：美国的好像是国会的两院。国内的当然是全国人大了。听说现在美国两党高度极化，难以妥协，否决政治成为常态，提案通过率很低，不如我们国家方便去年就修了个宪。
天狮集团，权健集团、天士力集团、尚赫集团、「无极限」、「如新」、「完美集团」
随着时代发展，电脑及自动化的发展，一个高能力的人创造的价值超过一条街低能力人创造的价值的时候，对于低能力的人来说，传说中不工作也会有吃喝的高福利世界就到来了，对于低能力的人来说存在也失去了价值。
在公司的八点偶尔会出现一种幻觉，就是我梦到我八点在公司编程，然后去打开了一个QQ群。
我记得一个访谈类电视节目，主持人还是嘉宾有个是清华还是北大的教授，一个是淘宝销量前十的卖家，他反复强调自己一年的销售额有多少。
2018/08/26 23:47
从92到今天已经26年了，整整一代人成为留守儿童，2010年的统计数据是6000万，两年前改了统计口径只有900万。这二十六年间前半段是农村物质极其贫乏，基层滥用暴力手段治理的时期，后半段是教育水平滑坡，消费主义盛行，奶头乐肆虐。这样一代即使犯罪率上升0.00000001，恶性治安事件频发也会是大概率 …
为啥找不到对象呢，个人内因很多，归纳起来有三：第一，吝啬。舍不得把自己的心分给别人，哪怕不需要很多，总是活在自己的世界里，怕被别人打扰也害怕自己打扰了别人，宁可被果断的拒绝，也不想被勉强的答应。第二，怀疑。总是在想，他是真的喜欢我吗，还是在应付着呢，这不是最可怕的，最可怕的是自己也不知道自己是在应付还是真的喜欢。抱着怀疑一切的态度，当然也会怀疑所谓的爱情。第三，畏惧。怕自己有所期待，也怕被别人给予很高的期待。姚明的广告说：没有买卖就没有伤害，套过来说，没有期待就没有伤害。外部原因就是认识的人有限，文科院校文科专业，大家懂得，再加上一二三催化作用，就一直单身下去了，一个人时间久了也会有惯性的。
优秀的代码是抽象的逻辑，逻辑的抽象。
狼与狗的区别在与：狼能团结合作而狗不能。而团结合作的基础就是换位思考理解他人。又听说过：弱者攻歼，智者互惠。深以为然。昨天一不小心又变成了一条狗啊，没忍住叫了几声。
2015-07-09
初中学校里老师鱼龙混杂，上学第一天，全班大扫除，我跟一个同学疯闹，被以为在打架，我老老实实接受批评，结果被班主任打了一个大耳光，班主任教英语的，我中考英语40多，高考英语发挥失常27，高考全国卷差二本19分，初中数学老师原是校园超市老板，贿赂学校混进体制内，教我们班数学，自己不会解二元一次方程，不会sin、cos等三角函数，全班数学基本等于自学，那老师混了三年后去教务处工作不再教学，我们是唯一倒霉的一批。我人生的前半段就这样了。
还有个应该不算毁一生的吧，就是高中九个科目唯一真心本能的喜欢的就是历史，是唯一做笔记的学科，但是谁叫理科好工作呢，于是分班就去了理科。
如果一个男的，在知道一位女生有男朋友的话，还会故意接近，制造机会，绝对是渣男，人品有问题，道德缺失，世界观不正，因为我们是人，我们有控制自己的能力，我们知道，去拿一个不属于自己的东西是偷、是窃、是贼。一个东西曾经属于我，我还挺喜欢它，现在它不属于我了，我还可以去偷偷的占有？不能拿感情为卑鄙猥琐的行为作解释开脱，那么做是侮辱爱情！如果一个人这么干了我们有理由怀疑他以后的行为，他是没有底线的，道德原则对他是没有束缚的，女人是会老的。如果我爱一个人，我会努力使她幸福，即使不能属于我了，我也会祝她幸福，即使放不下，我也会正大光明的去争取，让她结束上一段感情后，在去做新的开始，这么做虽然不够坦荡，但也光明磊落，绝不会畏畏缩缩，偷偷摸摸的去窃，去偷。 男人不应该这样为难男人，女人也不应该这样为难女人，小三永远得不到支持，即使是因为爱情，即使那个人够好，够完美，多么偏爱他，都不应该，因为他是属于另一个女人的，是另一个女人应该享有的权利，这是原则、这是责任，这是道德底线。
如果我喜欢一个事情，我会想去做好它，我会认真的去学习，努力的去准备，比较自己的不足，听取别人的意见，付出大量的时间、心力、情感、金钱，即使熬夜通宵，即使疲惫不堪都是值得的，因为 这是 我 想 ！是我喜欢。不是别人要求我的任务，不是我的负担和义务，即使是我为了讨好女神而去这么做，即使是我无聊为了消磨时间而这么做，即使是因为任何愚蠢聪明的原因而这么做，重要的“我想”然后我做与不做都是我自己的事，我讨厌任何违反我意志的绑架，我讨厌别人无缘的想我要去如何。
思维一直在变化，最近由梦中另起体会。 从很小的时候我就知道自己缺乏血气之勇，虽然我很喜欢七进七出的赵云，但如果让我回到三国，我更喜欢当郭嘉。 前几日夜里不得安睡，半夜惊醒，回头巡梦，发现梦里竟把一个小时候有欺负过我的恶霸打的头破血流，也许是粉身碎骨。 我这人好像略有奇怪，就是睡觉基本都uy会做梦，并会觉了。（觉了，梦中清醒）。
答：一命二运三风水，四积阴德五读书，六名七相八敬神，九交贵人十养生，十一择业与择偶，十二趋吉要避凶。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E9%AA%9A%E8%AF%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/-%E9%9A%8F%E7%AC%94/%E9%AA%9A%E8%AF%9D/</guid>
      <description>被过去折磨的死去活来。 这东西，信则有，不信则无，她的世界里从前也许从来没有出现过这个，现在即使出现也因为怀疑考验和她的不信而消失，二元世界观还是有道理的，世界既是物质的，也是虚无的，有太多信则有，不信则无的东西，比如上帝，即使物质世界无，但在精神世界中，它真实的影响了你的认知，你的选择，改变影响你的人生，还能说上帝是虚无的么？ 互联网的出现并没有带来更多的公平，那些强者会更好更有力的利用网络，更好的利用奴役计算机，但网络的出现给那些想变的更强的人带来机会，努力和智力的价值得到了提高。以前出身极大的影响了教育，但现在多了很多机会。但信息现在信息的无限泛滥，对人产生了信息的 DDoS 攻击。 不应将自己置于危险之地，无论是物理上的危险还是因为社会道德水平导致的危险。就比如不要随便穷游，单身女性深夜去偏僻地方，去见陌生人去见不了解的人。蓝星就这科技道德水平，清朝的人民国时的人现在的人都不一样。人与人之间的差距也许比人与狗都大。 当我意识到我变的笨拙，我就意识到我已经被俘虏，我已经沦陷。 dating 一个时代，它的科技程度，思想方式，决定了生产效率，进而也很大一部分决定了进行重复而基础工作的人和进行科学研究的人在人群中的比例，而很多人认为，那只是自己努力的成果。我鄙视那些不努力的人，但我完全不鄙视那些在劳动分工中从事比较简单基础工作的人。 脚趾踢到桌角够痛吧，还有个类似但更痛的，在北京的一个冬天我穿着拖鞋去阳台挂衣服，地上有冰，在我专心致志的挂衣服的时候，突然脚底向前一滑，我感觉我以一个平沙落雁式飞了起来，但最终我屁股并没有受伤，不是我扶住了哪里，在我失去控制，脚滑的尽头，在我一百六七十斤的体重即将起飞时，被我大母脚趾以撞墙的方式止住了。。。 往事不堪回首，现在更是不堪入目啊！兄弟们！！！ 写诗也是一种本能，只不过有些人要脸，把自己的屁话藏起来不说。 别再期待了，我也是烂人一个，我看见了我们之间爱情的消逝，貌似没有变化，一切都在默不作声中崩溃着。现在我的心痛和不舍都是伪善，令人绝望和脆弱不堪一击的伪善。为了避免再伤害，宁愿舍掉那一点欢愉。所以啊 不要对我有一丝丝的期待，反正 我也是个烂人 一个，伤你的时候才不敢手下留情，决绝的一丝心软都不敢有的啊。 别再期待了，我也是烂人一个，我看见了我们之间爱情的消逝，现在我的心痛和不舍都是伪善，令人绝望和脆弱不堪一击的伪善。为了避免再伤害，宁愿舍掉那一点欢愉。所以啊 不要对我有一丝丝的期待，反正 我也是个烂人 一个，伤你的时候才不敢手下留情，决绝的一丝心软都 别再期待了，我也是烂人一个，我看见了我们之间爱情的消逝，现在我的心痛和不舍都是伪善，令人绝望和脆弱不堪一击的伪善。为了避免再伤害，宁愿舍掉那一点欢愉。所以啊 不要对我有一丝丝的期待，反正 我也是个烂人 一个，伤你的时候才不敢手下留情，决绝的一丝心软都不敢有的啊。 这个，与我看到她的第一眼一样吧，仿佛天空中射下来一道光，我知道我完了，我沦陷了，我被改变了，一切都永久的改变了，周围一切那么自然，平静，但又好像每一丝都发生了变化，过去的那个我已经死了，有什么新的东西诞生了，重新跌跌撞撞在新世界中。 我看到她的第一眼，仿佛天空中射下来一道光，我知道我完了，我沦陷了，我被改变了，过去的那个我已经死了，新的我诞生了，永远也回不过去了。 我的愤怒、温柔、柔软、动情、感伤，一切的不能自已的，都倾付给艺术品，都不会轻易流露与展示、诉说。 我的愤怒、温柔、柔软、动情、感伤，一切的不能自已的，不应轻易流露、展示、诉说的。都倾付给艺术品，而在工作、生活还是要如铁石心肠。 我并不是在替那个交警伤心，我没有那么高的道德情操和使命感，我伤心的是为什么会有那么多人在玩世不恭，那么多的人不了解什么是责任。 人们用神灵解释世界和祈求帮助，那么新世纪一定是睡眠和失眠为主神。 丰富的网络世界，侵蚀现实世界 法律是道德的底线，那整个社会都道德败坏呢？如果装傻充愣，蛮不讲理可以获得优势，那么？ 孤独是永恒的，于是我们满世界的拼命寻找那个理解、认可、关注我们的人，只为体会一种不曾体会过的温暖。 孤闷 少年，就是要驰骋啊！放飞自我，惨烈搏杀。 坚韧的灵魂，不拔的意志，忠诚的信仰， 被黑暗凝视侵染， 经历了艰难困苦反复折磨的思维改造才理解了那种美。 世界是什么样的，世界不是我爱的样子，可我还疯狂的爱它啊。 因愚昧而赤诚 很多男生在成长过程中都有所热爱，比如足球篮球网吧游戏，我发现我那时候一直没有，现在我有了，就是编程。 越老心却越柔软 我不明白我是狂热的热爱着个世界，还是充斥着疯狂的贪欲。 我们应该渴望父母的理解，但我们也应该明白不应该被这种渴望过于影响自己的选择，我暂时还没有找到调和这种痛苦的办法，只能反复告知自己是对的，让自己变得坚硬些， 有时候会有悲伤，好似什么破碎消逝的悲伤。怅然若失，一切虚无，好似梦醒了， 身心皆坏，唯皮壳支撑。 我是一个偷偷执着的人。 不自信的一个特点是：被看低、嘲讽，拒绝后内心会非常抵触和敏感、沮丧。 喜欢就改变它，仇恨就超越它 耽溺 放任自己的情绪肆无忌惮的奔驰，是一件很奢侈的事。 他伪装的太成功了，他融洽的消融在这世界里了，没有遇到过多的挫折，他不理解你的，他并不爱你， 世界不适合你深情的活，偏偏在这薄情的世界深情的活。 I’ll try anything once. 人生苦短,何妨一试。 人生苦短,何妨一试 Life is short, why not try it. 也甘愿赴汤蹈火去走它一遍 你对社会的价值越大，社会越不舍舍弃你 我为什么想入 无人之境，现实让人厌弃 性情我最爱也爱你所爱 姿势水平改变才能获得姿势，跟一个姿势水平低的人讨论进化论，量子力学，是讨论不出成果也没有逻辑的 对于那些不容易自己释怀的人来说，告别很重要 凡是不愿意跟生活和解，活的特别用力，坚信命运掌握在自己手里的人，看起来都有点蠢。 人类灵魂本真的层面不会过于受困于这个世界 试探和逃避，审视自己 忘了什么，忘了忘了什么。 不断去接受 理解 感受 很多东西 是需要去改变调整自己身心的。 话说一直不喜欢控制不住情绪的人，但又非常羡慕人家的感情充沛，热烈真挚。 前段时间心情不好，胡思乱想，到是想通了一件事，记得有一句话说：理解是非常非常困难，因为脑海里想到了100%，只能表达出50%，而表达出的，对方只能听懂50%，而对方脑海只能感受到听懂的50%。我对你的爱（感情）（这其实不是爱，只是我曾经那么认为）也一样，爱你有100分，却只能表达出50分，而我格外鲁笨，也许连20分也表达不出，我表达出的，也许连1分也难感受到，毕竟同样是电话，可能是关心，也可能是打扰，同样也是是咳嗽，可能是生病，也可能是噪音。遥遥无期，对于我，你也许不是种子，只是粒顽石，只是我不够努力，没能让顽石开出花。抱歉！制造了这么久的噪音，打扰了这么久！其实也不全是不开心的事，比如：我成功的戒了游戏啦☺️。 在铁屋里醒来，却找不到出口，同情着哪些仍在昏睡的人，但转念一想，他们比自己幸福的多，这样一来，倒宁愿自己就这样永远昏睡着了。 权利与责任 生活总是让弱者觉得无奈，让强者觉得无聊。 一种乐观主义：今天再大的困难，也不是最困难的时候。 「我登上一列露天的火车，但不是车，因为不在地上走；像筏，却又不在水上行；像飞机，却没有机舱，而且是一长列；看来像一条自动化的传送带，很长很长，两侧设有栏杆，载满乘客，在云海里驰行。」 小心翼翼又保留仁慈 我认识到我是个懦夫，如果我不是个懦夫我怎么会苟活于世间的，哦，懦夫是没有勇气自杀的。我是个贪心的人，如果不是，我怎么会总是期望用最小的代价去骗取最大的收获。我是个愚蠢的人，如果不是，怎么会经常自信满满地觉着，我不会只是因为我没有去学。 直到有一天你突然意识到 那个影响你 塑造你 使你之所以成为你的人 再也不会在你的人生 你的未来再出现了 你永远 永远的失去生命的一部分，你会慢慢的模糊她的一切存在痕迹，慢慢的化作一个符号，一种感觉，那些愧疚，自得，那些精心准备的惊喜，义无反顾的誓言，委屈，付出的温柔，心思，统统的不作数了。 聪明人也许更难变的成熟，一个人的成熟变化，会更好的适应这个世界，保护他更少受伤害。 爱情是一场前途未知的孤独冒险，赌上许多、付出许多、经受许多却不知道是否会有明天，有时侯甚至需要捂住双眼，堵上耳朵才会有继续前行的动力，爱情是勇敢者的游戏，爱情里需要智慧却排斥聪明，爱情是两个人在黑暗的孤独中踯躅前行，半途中遇到任何意外都需要努力才可能有相遇的机会。 一次买几样酒，每样喝一口。度数越高越好喝。 那么，祝你幸福，那么恭喜你了。 因为敏感所以痛苦多。 爱情是一场赌博，是互相吐露真诚，不断加码，当一个人不加码的时候，不是她不想玩儿了，就是在她那里你就值她投入这么多。 我现在喜欢那些说话看起来很不正经的人，大大咧咧老是开玩笑，很玩世不恭的样子。其实真正了解他们的心，你才会发现，他们活的比谁都认真，比谁都敏感。只是怎么说呢，人生不如意才是十之八九。任何事摊开了揉碎了说，都透着一股悲凉。珍惜你身边每个逗逼吧，他们只是用幽默感努力对抗世界巨大的荒芜。(后来我背弃了这种观点) 垃圾书顺从你，好书是需要你准备（顺从、改变）自己。 无论如何，孤独逃不脱。 学着放过自己。但凡所发之事，一定有解，时间机缘而已。对着电话里的怒吼也好，争辩罢好，平心静气。（2016/01/20 15:27） 罗曼.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2018/2018716174555/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2018/2018716174555/</guid>
      <description>2018716174555
2018716174555</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2020/2020%E5%B9%B46%E6%9C%8825%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2020/2020%E5%B9%B46%E6%9C%8825%E6%97%A5/</guid>
      <description>2018.12.03 3300 小北次.中介费+定金（1800 + 1500）
2018.12.08 5550 三个月房租+网费（1800*3=5400+150） 800 取暖费
2019.2.20 2820 1月17天房租
2019.4.15 300 续约中介费
2019.6.25 5400 三个月房租
2019.9.25 5400 三个月房租
2019.12.25 5400 三个月房租
2020.4.08 5400 三个月房租
2020.7.1 5400 三个月房租</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B410%E6%9C%8825%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B410%E6%9C%8825%E6%97%A5/</guid>
      <description>价值观或信仰总会影响理性，陷于狂信更会导致偏执和不理智，全无信仰的人对己来说容易迷茫，对他人来说往往不堪信任。有人说：对一般人来说，有信仰比无信仰要好。
好像没主动做过什么需要长期坚持的事，都是 deadline 或者环境（学校、工作）推动自己去行动，这是不是在随波逐流得过且过呢？？？</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B411%E6%9C%8815%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B411%E6%9C%8815%E6%97%A5/</guid>
      <description>价值观分裂：体力劳动和脑力劳动， 劳动光荣，无论体力劳动还是脑力劳动。但让人类在自然的优胜劣汰中胜出的是夸张的大脑，而体力劳动收入已经远远少于脑力劳动收入，一面：脏、累、活、不体面，一面：聪明、优雅
多想想，你40岁，50岁想要什么样子吧。（没有目标可不行）
但是没人care你，你就别可劲care别人了。
老子：千里之行，始于足下。 荀子：不积跬步,无以至千里。 韩非子：千里之堤，毁于蚁穴。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B411%E6%9C%8830%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B411%E6%9C%8830%E6%97%A5/</guid>
      <description>我自己所拥有的时间
要做的事进行优先级排序
三人行，必有我师焉。择其善者而从之，其不善者而改之。
不可与别人攀比，但可以向别人学习。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B412%E6%9C%882%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B412%E6%9C%882%E6%97%A5/</guid>
      <description>我们身处的“倦怠社会”（burnout society），在这个社会中，我们因不可避免的生存需求而精疲力竭和感到沮丧。他还思考了新的娱乐形式和“心理政治”（psychopolitics）——在其中公民顺从地屈服于体制的诱惑，以及情色的消失——韩炳哲将其归咎于当前的“自恋主义”和“展示主义”（narcissism and exhibitionism）潮流。
仪式的消失
仪式”（rituals）是一种支撑结构，仪式给生活带来某种稳定性，在生活中提供心灵的平静。
手机它依靠惊喜的刺激来保持快乐。
无法与周遭建立长久且稳定深入的情感联系。
之前在访谈，一位受访者说：当父母离世，他无妻无子，他觉得，好像他与这个社会的最后一点关联也断了。
我曾匆匆忙忙在一个书店里看过一本书，只是言片语便喜欢上，很多年过去了，好像只在梦中有回到过那个书店，找到过那本书。记忆中还有很多浮光掠影的映像，已经不记得是何时何地。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B412%E6%9C%888%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/2021%E5%B9%B412%E6%9C%888%E6%97%A5/</guid>
      <description>不知不觉的被“成为更好的人”、被“消费主义”洗脑成功，忘我的去追逐去满足一些超过“生存需求”的欲望，不可避免的精疲力竭、沮丧、枯萎、空洞。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/%E5%81%B6%E5%B0%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/%E5%81%B6%E5%B0%94/</guid>
      <description>春秋无义战，那时候就会互相污蔑对方的王族血统，对方的贵族道德败坏，对方的国家危险动荡天灾人祸不断，出不义之师。那么现在世界上的国家的互相攻击行为会是“义”的么？都是互称“不义之师”。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2021/%E7%83%AD%E5%B8%A6%E9%B1%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2021/%E7%83%AD%E5%B8%A6%E9%B1%BC/</guid>
      <description> 时间线： 2021年02月26日 买鱼缸、水草、水草泥、沉木、青龙石、过滤、 ￥ 499 2021年02月26日 俪鱼鱼缸加热棒 ￥ 45 2021年03月05日 森森油膜处理过滤器 ￥ 38 2021年03月08日 硝化细菌 ￥ 97 2021年03月25日 俪鱼鱼缸变频智能加热棒 ￥ 77 2021年03月25日 鱼缸刮藻刀 ￥ 38 2021年03月29日 鱼粮 ￥ 19 2021年04月01日 红绿灯鱼 10条 ￥ 43 2021年04月04日 收鱼； 买红绿灯鱼 10 条，卖家送 1 条 共 11条； 收到时 死透 5 条，3 条游泳姿态异常，3 条游泳姿态无异常，共 6 条存活； 过水后死亡 2 条，剩余 4 条； 24 小时后 死亡 1 条，剩余 3 条游泳姿态无异常； 2021年04月05日 养鱼； 死 1 条，剩余 2 条无异常，无法确定死因，水土不服或运输问题 2021年04月05日 养鱼； 晚上，发现 1 条死亡，发现时在 森森油膜过滤器进水口与鱼缸壁之间卡着， 剩余 1 条。 2021年04月07日 买鱼； 下班后去百度地图上查的最近的花苗鱼虫市场，现场看应该是撤店很久了（现场毫无此店痕迹），发现附近的 大型地下华联超市有卖孔雀鱼，买了 3 条（￥ 10） ； 2021年04月07日 养鱼； 孔雀鱼跳缸了一条 ； 2021年04月11日 换水； 少少的换了一点水，这一夜生怕我的鱼暴毙。 ； </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B41%E6%9C%8811%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B41%E6%9C%8811%E6%97%A5/</guid>
      <description>小的时候我认为我性格不会的方面有：缺乏勇气、虚荣
2016年，想去搞编程，但是房子装修困在那走不开，痛苦； 2017年，上半年去北京找了个培训班，天天睡觉，但是了解了也学到很多；下半年找了个外包入行编程； 2018年，上份外包工作满6个月，跳槽，换了个不是外包的编程工作； 2019年，生活再次稍微的恢复了点正轨，短期外债还清，搬离通勤时间2小时的回龙观，上班通勤时间变为10分钟，极大幸福，但是之前挤了接近一年多的13号地铁，我感觉我精神受到了一些创伤。； 2020年，好像丢失的一年，我确定我确实特别喜欢宅的生活，初步确定无必要不下楼无任何不适，想明白了一些事，把想明白的事去做了； 2021年，丢失了一点的一年，可以肯定我确实特别喜欢宅的生活，这一年除非是理发、医院、上班、喝酒，丢垃圾，几乎没有下过楼，但是也逐渐感觉到人类本能约束着我，必须下楼运动、社交，被疫情影响拖延的搞牙计划正式开始，牙齿初步搞定就去搞鼻塞和耳鸣，最后去看下脑子和精神状态。 2022、2023希望两年后可以步上正规。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B41%E6%9C%886%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B41%E6%9C%886%E6%97%A5/</guid>
      <description>自己给自己 PUA P傻了之：现在一天如果没有学习或者搬很多的砖（工作有很大推进），就，这一天，如果没有弄点“仪式感”或者“自己认可的事”，就会有巨大的空虚感，觉得时光虚度，感觉到恐慌（我觉得有点不对劲）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B43%E6%9C%8817%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B43%E6%9C%8817%E6%97%A5/</guid>
      <description>从去年开始弄牙，就一直备有鲜牛奶，前段时间我看着牛奶和咖啡，想着弄一杯手作拿铁？说干就干，很快搞好，甚至还发了朋友圈，后面一个朋友问我味道怎样，我想了想说：“偶还是喜欢黑咖啡，牛奶+咖啡，模糊了咖啡丰富复杂的苦味，过于柔和了。”</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/2Diary/2022/2022%E5%B9%B45%E6%9C%8810%E6%97%A5/</guid>
      <description>“两年”，想起我们差不多是两年前认识的，想起当时聊天中说的一个疑问：“远方的朋友的意义是什么”，这个疑问一直在我脑中回荡，最近有所心得：先期是一句”不要在网络上建立过于亲密的关系，就像不要在空中建立楼阁“，其实是想说：&amp;ldquo;不要仅在网络上建立亲密关系&amp;rdquo;；人的精神在一个虚拟空间，网络是另一个虚拟空间，但肉体活在物质空间，三个空间互相干扰掺杂拉扯混染；远方的朋友对你物质空间几乎没有影响，但能影响精神空间。
有句和尚的话：“心迷法华转，心悟转法华”，心迷的时候，心情随着环境变化生老病死而喜怒哀乐的流转，心悟的时候，能抽离出来以各种角度看事情，心：心情或者是关注点；法华：周遭环境，世界。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/3Music/Music/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/3Music/Music/</guid>
      <description>Music</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Life/%E8%A1%8C%E4%B8%BA%E8%A6%81%E7%B4%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Life/%E8%A1%8C%E4%B8%BA%E8%A6%81%E7%B4%A0/</guid>
      <description> 行为要素 不停止对另一种人生的可能性的追寻，我究竟想要过怎样的生活，我究竟想体验怎样的人生。 人一旦意识到自己陷入停滞，可能性的消失，会有巨大的痛苦来袭，唯有将心念投入到游戏、抖音、放弃大脑，才能得到片刻喘息。
例子： 待办事项 待办事项 待办事项 电影 待办事项 《死亡诗社》 《真爱至上》 《怦然心动》 《爱在》系列 电视剧 美剧 《生活大爆炸》 《黑吃黑》 《欲望都市》 《老友记》 《使女的故事》 动漫 日本 《派对浪客诸葛孔明》 - 2022/09/12 《鬼灭之刃》 书 书 《身份的焦虑》 阿兰德·波顿 每天 技术 每天阅读/写一篇技术博客 行为要素 行为 做一本书 去东京看花火大会、北海道看雪、看一次歌剧魅影的音乐剧 颐和园七月的荷花 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/Apache_toolkit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/Apache_toolkit/</guid>
      <description>toolkit 工具包
commons-validator（通用验证系统） 验证体系对付用户界面的用户千变万化的输入可能。Apache ShardingSphere（分布式数据库中间件） 一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。Apache Tika Apache Tika™工具箱可从一千多种不同的文件类型（例如PPT，XLS和PDF）中检测并提取元数据和文本。所有这些文件类型都可以通过一个界面进行解析，从而使Tika可用于搜索引擎索引，内容分析，翻译等等。Apache Nutch Nutch是基于Lucene实现的搜索引擎。包括全文搜索和Web爬虫Apache PDFBox® 在Apache PDFBox的®库是与PDF文档工作的一个开源的Java工具。该项目允许创建新的PDF文档，处理现有文档以及从文档中提取内容的能力。Apache PDFBox还包含几个命令行工具。Apache PDFBox在Apache许可证2.0版下发布。	ImageMagick® 使用ImageMagick的®创建，编辑，撰写，或转换位图图像。它可以读取和写入各种格式的图像（超过200种），包括PNG，JPEG，GIF，HEIC，TIFF，DPX，EXR，WebP，Postscript，PDF和SVG。使用ImageMagick调整，翻转，镜像，旋转，扭曲，剪切和变换图像，调整图像颜色，应用各种特殊效果，或绘制文本，线条，多边形，椭圆和贝塞尔曲线。Batik 是一个基于Java技术的SVG(可扩展矢量图)工具包。FOP FOP是由James Tauber发起的一个开源项目，原先的版本是利用xsl-fo将xml文件转换成pdf文件。但最新的版本它可以将xml文件转换成pdf，mif，pcl，txt等多种格式以及直接输出到打印机，并且支持使用SVG描述图形。XML Graphics XML Graphics：发展 XML 与图形进行转换的计划项目axis2c Axis2/c是一个用C语言实现的Web服务引擎，它服从可扩展的，灵活的Axis架构。Axis2/C可以用来提供web服务，也可以作为web服务的客户端。它可以很方便的嵌入到其他软件中，从而使该软件具有web功能。WSS4J WSS4J 是 Web服务安全规范 (OASIS Web Service Security , WS-Security) 的 Java 实现。WSS4J 是一个 Java 的类库用来对 SOAP 消息进行签名和校验，使用 Apache Axis 和 Apache XML-Security 项目。	Apache Forrest Apache Forrest是一个把来自各种不同的输入数据源转换成用一种或多种输出格式(比如HTML,PDF等)来统一显示的发布系统。它基于Apache Cocoon并分离了内容与内容结构,不仅可以生成静态的文档也可以当作一个动态的服务器。Xalan xalan是一套xslt处理器（有C和JAVA语言两种版本），用来将XML文件转换为HTML,TEXT和XML等其他类型文件格式。	Anakia Anakia 是一个XML的转化工具，它使用 JDOM 和 Velocity 来将XML文档转换成你所需要的文档格式。支持在 Ant 中设置转换任务以及使用 XSL 进行XML文件处理。	Roller 是一个全功能的多用户博客平台。采用Java语言开发	Commons-Net Commons项目中封装了各种网络协议的客户端	Sanselan 是一个纯 Java 的图形库，可以读写各种格式的图像文件，包括快速解析图片信息例如大小/颜色/icc以及元数据等jsoup: Java的HTML解析器jsoup是一个用于处理真实世界HTML的Java库。它提供了一个非常方便的API来提取和操作数据，使用最好的DOM，CSS和类似jquery的方法。Quartz: Java的任务调度框架Quartz 具有诸如 JTA 事务和集群等功能，可用于企业级应用程序的支持。Ok HTTP： HTTP 通讯框架Joda Time： 作为 Java 中日期和时间类的一个很好的替代品。XStream 将对象序列化到 XML 中Apache OpenNLP Apache OpenNLP软件支持最常见的NLP任务，例如标记化，句子分段，词性标记，命名实体提取，分块，解析和共指解析。这些任务通常是构建更高级的文本处理服务所必需的。OpenNLP还包括最大熵和基于感知器的机器学习。Apache Camel 骆驼是 开源集成框架 使您能够快速轻松地集成使用或生成数据的各种系统。装满 数百个组件用于访问数据库，消息队列，API或基本上在阳光下的任何东西。帮助您与一切集成。Apache Flink 流处理框架Axure RP Axure RP是一款专业的快速原型设计工具。Apache Trafodion 分布式 SQL 引擎 Apache Trafodion 宣布退役Pulsar Pulsar是一个分布式的消息发布/订阅传递平台，具有非常灵活地消息模型和一个直观的客户端APIMFC 微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。PWA PWA（Progressive Web App）是一种理念，使用多种技术来增强web app的功能Veloren Veloren 是一款受《立方体世界》、《荒野之息》、《我的世界》等游戏启发制作的独立RPG,完全开源免费。游戏致力于打造一个明亮、绚丽、有趣的世界,可以用独特有趣的方式探索FinalShell 是一款免费的国产的集 SSH 工具、服务器管理、远程桌面加速的良心软件，同时支持 Windows、macOS、Linux，它不单单是一个 SSH 工具，完整的说法应该叫一体化的服务器/网络管理软件。Apache APISIX Apache APISIX 是一个基于云原生、高速可扩展的开源微服务网关节点实现，其自身主要优势是高性能和强大的扩展性Meson Meson 旨在开发最具可用性和快速的构建系统。提供简单但强大的声明式语言用来描述构建。原生支持最新的工具和框架，如 Qt5 、代码覆盖率、单元测试和预编译头文件等。利用一组优化技术来快速变异代码，包括增量编译和完全编译。Jaspersoft® Studio Jaspersoft® Studio 是世界上最受欢迎的开源报告引擎。它完全以 Java 编写，能够使用来自任何类型的数据源的数据，并生成可以各种文档格式查看、打印或导出的像素完美文档，包括 HTML、PDF、Excel、OpenOffice、MS Word 和其他文档格式。vert.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/data_authority_managementa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/data_authority_managementa/</guid>
      <description>data_authority_managementa
独立的数据权限控制访问限制、某些数据不允许访问数据清洗、某些数据部分返回业务场景和数据安全级别划分（绝密、高保密、保密、可公开，四个级别）， 主要从“高保密”等级的敏感数据，开始进行梳理。这里我们把敏感数据分成四个维度进行梳理，用户、商家、终端、公司。（用户、业务、公司。）（基础数据标签、业务数据标签）应用动态数据屏蔽有五种可能的技术：1、在数据库中：数据库接收SQL并将重写应用于返回的屏蔽结果集。适用于开发人员和DBA，但不适用于应用程序（因为连接池，应用程序缓存和数据总线会隐藏数据库中的应用程序用户身份，并且还会导致应用程序数据损坏）。2、应用程序和数据库之间的网络代理：捕获SQL并在select请求上应用重写。适用于具有简单&#39;select&#39;requests但不适用于存储过程（代理仅识别exec。）和应用程序的开发人员和DBA（因为连接池，应用程序缓存和数据总线隐藏了数据库中的应用程序用户身份，也可以导致应用程序数据损坏）。3、最终用户和应用程序之间的网络代理：识别文本字符串并替换它们。此方法不适用于复杂的应用程序，因为当无意中应用实时字符串替换时，它很容易导致损坏。4、应用程序和XACML中的代码更改：代码更改难以执行，无法维护且不适用于打包的应用程序。5、在应用程序运行时：通过检测应用程序运行时，定义策略以重写从数据源返回的结果集，同时具有对应用程序用户的完全可见性。此方法是动态屏蔽复杂应用程序的唯一适用方法，因为它可以控制数据请求，数据结果和用户结果。=================================================wota5037的博客================================ 基于资源的权限系统-设计思路 基于资源的权限系统-数据库设计
通用权限管理设计 之 数据权限 基于资源的权限系统-设计思路 概述 权限系统提的最多的就是 RBAC（基于角色的访问控制）。 所谓角色，其实就是权限的集合，某个角色就是某几个权限的结合。其目的是为了简化授权和鉴权的过程。
基于角色的权限控制用在简单的权限环境下没有问题，如果在权限控制比较复杂的系统中，或者说要做通用的权限系统时，基于角色的权限控制会带来以下问题：1、角色可以用来做功能权限，做数据权限的话，会导致角色数量非常多 比如：bug管理系统，一般有 developer, reporter, manager 等一些角色，其中，reporter 可以创建bug，developer 可以解决，回复bug，manager 可以统计bug 等等。 在这个系统中，通过设置 developer，reporter，manager 几个角色，可以使得授权，鉴权更加简单，直观。 但是，如果权限粒度要求更细的话，比如，某些reporter只能创建普通级别的bug，某些reporter可以创建各个级别的bug，或者有更加细粒度的权限要求的话，角色的数量就会激增。 到时候，管理角色本身带来的工作量反而会大于角色带来的好处。2、角色是一维的，不同的角色之间一般都是独立的，而人员之间一般有树状的组织关系。所以，角色就很难与已有的组织关系互相映射。 而授权的时候，经常是上级的组织会自动获取下级创建的数据的一些权限3、对于不确定的系统来说，角色不好定义。如果是bug系统，比较成熟，方便定义角色类型，如果是通用系统的话，用户其实不太容易定义好自己需要的角色。另一种 RBAC（resource base access control）基于资源的权限系统。术语介绍人员 : 实际使用系统的用户，也就是需要进行权限检查的人组织 : 树形结构，但是人员可以属于一个或者多个组织资源 : 需要授权的东西都可以认为是资源，每个功能是资源，每个接口也是资源，每条数据也是资源。 资源树 上的根就是整个系统。动作 : 对资源的操作，比如常用的 创建，删除，更新，查询权限 : 组织 + 资源 + 动作 （什么人对什么资源可以做什么动作）系统初始化权限系统本身提供一个超级用户(admin)，通过此用户来初始化最初需要的信息。初始信息只需要定义：组织的根节点：以后追加的所有人员和组织都在此节点之下（比如就是某个公司）资源的根节点：以后追加的所有资源都在此节点之下（比如就是需要进行权限控制的系统）动作：对资源可能进行的操作（一般就是CURD，增删改查）有了以上信息，就完成了针对某个系统和组织的权限系统的基本初始化。 基本信息初始化之后，可以导入组织/人员，以及资源信息，或者直接在权限系统提供的页面上操作。注意 每个资源只有一个父节点，每个组织也只有一个父组织，但是每个人员可以属于多个组织授权过程授权是权限系统中重要的步骤之一，另一个重要步骤就是鉴权。 授权有2种视图：人员/组织 视图 下的授权流程选择 资源选择 动作确认授权生成权限数据注1 前2步的选择都可以多选。资源 视图 下的授权流程选择 人员/组织选择 动作确认授权生成权限数据鉴权过程鉴权是使用最频繁的步骤，几乎每次请求都会有鉴权的操作。 鉴权就是判断 某人对某资源做某个动作 是否合法，所以鉴权的 input 是 人员/组织，资源，动作； output 则是是否鉴权成功。根据 input 的内容（人员/组织，资源，动作），查看权限表中是否有匹配的数据1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/Markdown/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/Markdown/</guid>
      <description>这是标题、 这是二级标题、 这是三级标题 这是三级标题 这是三级标题 这是三级标题 引用
嵌套引用
三嵌套引用
四嵌套引用
这是加粗的文字 这是倾斜的文字` 这是斜体加粗的文字 这是加删除线的文字 这是换行
- - 2. 1. GitHub
自动生成连接 http://www.github.com/
//代码块 E = mc^2 表格：
header1 header2 row1col1 row1col2 row2col1 row2col2 在这里插入 HTML 内容
目前支持的 HTML 元素有： 等 ，如：
使用 Ctrl+Alt+Del 重启电脑
制作待办事项 To-do Lis
待办事项 待办事项 待办事项 待办事项 绘制：流程图、序列图、甘特图、表格
逻辑示意图类型 流程图 graph TD;A--&amp;gt;B;A--&amp;gt;C;B--&amp;gt;D;C--&amp;gt;D; 序列图 sequenceDiagramparticipant Aliceparticipant BobAlice-&amp;gt;&amp;gt;John: Hello John, how are you?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/Markdown_PlantUML/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/Markdown_PlantUML/</guid>
      <description>Markdown_PlantUML
绘制：流程图、序列图、甘特图、表格 逻辑示意图类型 流程图 graph TD;A--&amp;gt;B;A--&amp;gt;C;B--&amp;gt;D;C--&amp;gt;D; 序列图 sequenceDiagramparticipant Aliceparticipant BobAlice-&amp;gt;&amp;gt;John: Hello John, how are you?loop HealthcheckJohn-&amp;gt;&amp;gt;John: Fight against hypochondriaendNote right of John: Rational thoughts &amp;lt;br/&amp;gt;prevail!John--&amp;gt;&amp;gt;Alice: Great!John-&amp;gt;&amp;gt;Bob: How about you?Bob--&amp;gt;&amp;gt;John: Jolly good! 甘特图 ganttdateFormat YYYY-MM-DDtitle Adding GANTT diagram to mermaidexcludes weekdays 2014-01-10section A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5d 类图 classDiagramClass01 &amp;lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/mdBook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/mdBook/</guid>
      <description>初始化图书
.\mdbook.exe init D:\Projects\GitHubProjects\Sleepless-tonight.github.io\my-first-book
..\mdbook.exe serve &amp;ndash;open
.\mdbook.exe init D:\Projects\GitHubProjects\Sleepless-tonight.github.io\templates
.\mdbook.exe build path/to/book .\mdbook.exe build -d D:\Projects\GitHubProjects\Sleepless-tonight.github.io\templates</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/Toolkit/1-%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/Toolkit/1-%E8%BD%AF%E4%BB%B6/</guid>
      <description>1、软件 1.1、文件 1.1.1、 BitTorrent Sync Resilio Sync（前身为BitTorrent Sync） 是一款免费的文件同步软件！它不需第三方服务器即可让多台电脑之间直接互相同步和共享文件，而且全程AES加密。它采用基于类似BT下载的P2P分布式技术而来，速度快而且可通过密钥文件共享
1.1.2、 Syncthing Syncthing 是一个免费开源的工具，它能在你的各个网络计算机间同步文件 / 文件夹，它的同步数据是直接从一个系统中直接传输到另一个系统的，并且它是安全且私密的。
1.1.3、 CertUtil Certutil.exe是作为证书服务的一部分安装的命令行程序。 可以使用certutil.exe转储和显示证书颁发机构 (CA) 配置信息、配置证书服务、备份和还原 CA 组件，以及验证证书、密钥对和证书链。
CertUtil -hashfile C:\xxx.tar MD51、 此命令不仅可以做MD5哈希算法校验，还支持其他的哈希算法，具体如下：2、 CertUtil -hashfile 文件路径 [算法]3、 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512 1.1.4、 Files Files 是 Windows 平台的第三方文件管理器，功能强大、设计优美且直观，包含多标签、窗格、文件预览、shell 扩展、云文件集成等功能。
1.1.5、 Calibre 功能强大的开源电子书工具
1.1.6、 FFmpeg FFmpeg 是领先的多媒体框架，能够解码、编码、转码、混合、解密、流媒体、过滤和播放人类和机器创造的几乎所有东西。它支持最晦涩的古老格式，直到最尖端的格式。
1.1.7、Czkawka 是一个简单，快速和免费的应用程序，用于从计算机中删除不必要的文件。 可供使用： 重复项 - 根据文件名、大小或哈希查找重复项 空文件夹 - 借助高级算法查找空文件夹 大文件 - 查找给定位置中最大文件的提供数量 空文件 - 在驱动器中查找空文件 临时文件 - 查找临时文件 相似的图像 - 查找不完全相同的图像（不同的分辨率，水印） 相似的视频 - 寻找视觉上相似的视频 相同的音乐 - 搜索具有相同艺术家，专辑等的音乐。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/Toolkit/2-%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/Toolkit/2-%E7%BB%84%E4%BB%B6/</guid>
      <description>2、组件 更接近 jar 的工具类
2.1、Hugo Go 编写的静态网站生成器
2.2、Ghost Ghost 是一个开源建站平台，可以使用它创建自己的网站，有点类似于 WordPress 。案
2.3、Spring-Analysis 这是一个围绕 springframework 进行源码分析的项目。
2.4、JobRunr Java的分布式作业调度程序。
2.5、平行图分析（PGX） PGX 是用于图形分析的工具包，它支持高效的图形算法和快速的类似于SQL的图形模式匹配查询。
2.6、WorldWind Java NASA开发的用于桌面Java的3D虚拟地球API。提供具有高分辨率地形的地理环境，用于以3D和2D可视化地理或地理位置信息。开发人员可以自定义地球的地形和图像。提供一组形状，以显示和与地理数据进行交互并表示一系列几何对象。
2.7、Nacos Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。
2.8、Copilot GitHub原生AI代码生成工具 Copilot
2.9、Apache Guacamole Apache Guacamole 是一个无客户端的远程桌面网关。它支持标准协议，如 VNC、RDP 和 SSH。之所以称它为无客户端，因为它不需要插件或客户端软件。由于 HTML5 的存在，一旦 Guacamole 被安装在服务器上，你只需要一个网络浏览器就能访问你的桌面。
2.10、Apache Flink Apache Flink 是高效和分布式的通用数据处理平台，是一个流批一体分析引擎。 Apache Flink 声明式的数据分析开源系统，结合了分布式 MapReduce 类平台的高效，灵活的编程和扩展性。同时在并行数据库发现查询优化方案
2.11、C4-PlantUML 2.12、Linux Lab 是一套用于 Linux 内核学习、开发和测试的即时实验室，可以极速搭建和使用，功能强大，用法简单！
2.13、Canal Canal 是一款基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库 Binlog 的方式，这样可以从底层知道是哪些数据做了修改。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/Toolkit/3-%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/Toolkit/3-%E6%8A%80%E6%9C%AF/</guid>
      <description> 3、技术 技术关键字
3.1、网络 3.1.1、 内网穿透目前主要由 ngrok 和 frp 两种，都非常好用，国内 ngrok 免费的有 ittun、sunny 和 natapp，这三个都是免费的，前面两个可以自定义域名，后面的需要 vip 版本才可以自定义域名。 3.1.2、 使用 Excelsior JET编译java程序为.exe程序 3.1.3、 约束传播与搜索 constraint propagation and search </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/</guid>
      <description> 个人知识管理（Personal Knowledge Management） 个人知识管理（Personal Knowledge Management）的概念一般指个人通过工具建立知识体系并不断完善，进行知识的收集、消化吸收和创新的过程。
一、学习知识 （知识来源） 知识和信息不能混为一谈，信息是免费的，但毫无目标的获取信息，就无法将信息转化为知识。因此学习必须要有目标，如果你用有限的时间去学无限的知识，你将被知识“淹没”，我们要学习那些给自己带来最大提升的知识。
时间是一个最稀缺的资源，在学习知识的过程中，必须考虑知识获取的“成本”问题，这个成本除了金钱之外，最重要的是时间成本。因此，学习知识的工具需要满足：“花费时间较短，获得价值较高的知识”。
二、保存知识（知识保存） 保存知识的目的是为了在使用的时候能够最快速和准确地查询到相关内容。
三、共享知识（寻找道友） 知识共享和传播，是为了让别人知道你知道的知识，并得到信息的反馈，为什么要分享，不在于你认识什么人，而在于什么人认识你，不在于什么人影响了你，而在于你影响了什么人。因此要添加一些高质量的好友，订阅其分享内容，多争取对方的关注。
四、使用知识（分类归纳终结查询知识） 知识的收集和积累之后，最重要的还是如何利用这些知识资料。
个人信息管理器（通常称为PIM 工具，或者更简单地说，是 PIM）是一种作为个人组织者的应用程序软件。缩写PIM现在更常用于个人信息管理作为研究领域。 作为信息管理工具，PIM 工具的目的是便于记录、跟踪和管理某些类型的&amp;#34;个人信息&amp;#34;。个人信息可以包括以下任何信息：通讯录警报日历日期，例如：纪念日约会生日事件会议教育记录电子邮件地址传真通讯行程即时消息存档法律文件列表（如阅读列表、任务列表）)医疗信息，如医疗保健提供者联系信息、病史、处方密码和登录凭据个人文件收藏（数字和物理）：文档、音乐、照片、视频和类似个人日记/日记/备忘录/笔记项目管理功能食谱参考材料（包括科学参考，感兴趣的网站）RSS/原子源提醒语音信箱通信 日历日历软件信息管理密码管理器个人信息管理个人知识库个人维基 个人知识管理（PKM）是收集信息的过程，一个人用于收集、分类、存储、搜索、检索和分享日常活动中的知识（2007 年格兰德斯彭基斯）以及这些流程支持工作活动的方式（Wright 2005）。这是对知识工作者需要对自己成长和学习负责的想法的回应（Smedley 2009）。这是一种自下而上的知识管理方法（KM）（波拉德2008年）。 时间和任务管理个人层面的时间管理和任务管理都大量使用信息工具和外部信息形式，如要执行列表、日历、时间线和电子邮件交换。这些是另一种要管理的信息形式。多年来，电子邮件，特别是，已以临时的方式用于支持任务管理 内容管理（CM）是一组支持以任何形式或媒介收集、管理和发布信息的流程和技术。当通过计算机存储和访问时，这些信息可能更具体地称为数字内容，或简单地称为内容。数字内容可以采取文本（如电子文档）、图像、多媒体文件（如音频或视频文件）或任何其他文件类型的形式，这些文件类型遵循需要管理的内容生命周期。这个过程非常复杂，足以管理一些大小商业软件供应商，如Interwoven和微软提供内容管理软件，以控制和自动化内容生命周期的重要方面。 知识分类标签： </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/%E5%AD%A6%E4%B9%A0And%E8%B5%84%E6%96%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/%E5%AD%A6%E4%B9%A0And%E8%B5%84%E6%96%99/</guid>
      <description>时间：2019年3月4日10:29:43
学习：
英语、 数学之美、 Spring Cloud、 去B站看完：计算机科学速成课、 系统的计算机科学（所有九个主题，大致按照呈现的顺序，但理想情况下两者。瞄准每个主题100-200小时的学习，在整个职业生涯中重新访问收藏夹。）：https://teachyourselfcs.com/#math、 南京大学 计算机科学与技术系 计算机系统基础 ：https://nju-ics.gitbooks.io/ics2018-programming-assignment/content/、 清华大学计算机系课程攻略：https://github.com/Trinkle23897/THU-CST-Cracker 中国科学技术大学计算机学院课程资源：https://github.com/mbinary/USTC-CS-Courses-Resource 所有算法都用Java实现：https://github.com/TheAlgorithms/Java、 用Java实现的设计模式：https://github.com/iluwatar/java-design-patterns 低级别的编程语言：https://github.com/gurugio/lowlevelprogramming-university 资料：
带视频讲座的计算机科学课程清单：https://github.com/Developer-Y/cs-video-courses 精选的Java框架，库和软件的精选列表：https://github.com/akullpp/awesome-java 技术面试必备基础知识 ：https://github.com/CyC2018/CS-Notes 计算机学科基础知识和主流编程语言相关内容的总结：https://github.com/xuelangZF/CS_Offer 免费的编程中文书籍索引：https://github.com/justjavac/free-programming-books-zh_CN x86架构操作系统内核的实现 http://wiki.0xffffff.org/posts/hurlex-1.html
虚拟内存探究，深入理解进程地址空间 http://blog.coderhuo.tech/2017/10/19/Virtual_Memory_summary/
南京大学 计算机科学与技术系 计算机系统基础 课程实验 2019 https://nju-projectn.github.io/ics-pa-gitbook/ics2019/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description> 文件管理： 文件管理：图片、音频、视频、pdf、网页、文本1、目录标签化、2、文件类型标签化、3、文件属性标签化、4、查重5、给出保留建议6、文本文件关键字索引、全文搜索7、文本文件版本管理8、备份管理9、加密10、文件打开历史、文件夹打开历史、文件变动历史（例如 什么时间创建一个文件）11、文件编辑历史12、Archive、休闲娱乐、教程、电影、音乐、小说、13、标签云14、Data（数据）、Information（信息）、Knowledge（知识）15、序列、关键词、描述16、中国图书馆分类法、标签分类法、杜威十进制图书分类法17、我们把文件分成「工作、学习、生活、兴趣」四个大类、文档、图片、音乐、视频18、文件夹层级控制在了三层以内19、收藏夹和历史记录20、支持模糊搜索、过滤搜索结果21、Spotlight 全文检索功能，它能够自动索引 TXT、Word、Excel、PPT、PDF、EPUB 等文档里的内容22、知识图谱（Knowledge Graph）23、信息检索和推荐、相关性24、中文通用百科知识图谱（CN-DBpedia）25、ImageNet- 图片：1、每个目录随机抽取十几或几十张图缩小合并，形成一张比较直观的印象图。2、色调，tag，宽度什么的3、Image Comparer </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/%E7%89%88%E6%9C%AC%E8%A7%A3%E9%87%8A2.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/%E7%89%88%E6%9C%AC%E8%A7%A3%E9%87%8A2.0/</guid>
      <description>alpha版：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和 测试人员测试和找BUG用的。
beta版：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存 在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。
rc版：全写：Release Candidate（候选版本），该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似 预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。
stable版：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。
商业软件 RTM版：全称为Release to Manufacture。工厂版。改版程序已经固定，就差工厂包装、光盘印图案等工作了。
OEM版：厂商定制版。
EVAL版：评估版。就是有30或者60天等使用期限的版本。
RTL版：Retail.(零售版)，这个版本就是真正发售的版本，有漂亮的包装、光盘、说明书等东西和高昂的价格。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83IDaas%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83IDaas%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</guid>
      <description>用户中心IDaas模块设计 一、IDaaS Identity as a Service ，简称 IDaaS ，是一个基于身份的服务，它是一个认证、认可、访问、管理、统计、维护、管理等服务的集合。
IDaaS ⾃适应⼆次认证、弱密码监测、账号⽣命周期管理、异常账号锁定等众多账号防护能⼒。
提供 IP ⿊⽩名单防护、异常登录锁定、弱密码检测、图⽚验证码、僵⼫账号管理等能⼒，全⾯提⾼身份认证安全⽔位。与此同时，IDaaS 还提供了可视化的图表界⾯，直观展示安全⻛险。
提⾼账户登录的安全性。IDaaS ⽀持 ⾃适应（设备、IP、静默（同一手机短时间多次）） 和 强制 两种⼆次认证类型。
二、用户中心升级原因 对于自有账号体系的应用，都需要对接账号风控，平台建议用户接入淘系账号风控体系，使用淘系账号的应用将默认享有平台提供的账号风控能力，如使用自有账号体系的应用，应具备平台认可的应用身份服务（简称：IDAAS）能力，并开启二次认证等安全策略并回传日志到平台。
三、两种升级方式主要工作 注意：无论是接入淘宝账户风控体系，还是自研对接御城河，都需要调整用户中心认证流程。
3.1、调整认证流程 在修改密码、绑定手机、绑定邮箱、绑定身份证等认证流程时，需要调整认证流程，必须要时需添加二次认证校验。
3.2、接入淘系账号风控体系 购买阿⾥云应⽤身份服务（IDaaS） 对接API，同步账户数据到淘系账号，由 IDaaS 进⾏统⼀认证。 idaas 数据将自动回流计算，无需isv/自研再对接御城河回流。 3.3、自研 对接API，应用需对接御城河 idaas 和二次认证接口回流数据。 四、调整认证所需工作 账户涉及二次认证新增属性（短信或MFA） 二次认证设置页 是否启用、启用模式、启用节点（登录、修改密码、手机、邮箱、身份证？）、启用（账户或组织）范围、认证类型（淘宝、自建） 二次认证方式（默认手机短信） 短信模板 验证码限制逻辑 验证码发送频率限制 同一验证码可以尝试 3 次输入，3 次均失败后，验证码失效。用户需要获取新验证码。 验证码有效期 二次认证弹窗页 当前认证手机号（中间遮掩） 获取验证码按钮（倒计时，防止重复点击） 验证码输入框 提交、取消按钮 后端各触发二次认证校验节点，二次认证校验统一接口 账户同步 选择所需同步账户范围 页 账户增删改等阶段对接阿里云 IDaaS API 上报日志 注意：
如果是自建需要完成除 5 阶段外全部流程，如果对接阿里云 IDaaS ，只需完成 3、4、5 阶段、并对接API，其它由阿里云 IDaaS 控制。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/10Miscellaneous/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/10Miscellaneous/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%E6%96%B9%E6%A1%88/</guid>
      <description>用户中心二次验证方案 平台 平台店铺 处理订单应用（大益源子） 处理订单的我方应用用户（客服） 用户中心（自有账号体系） IDaaS（一个基于用户中心提供二次验证的的服务） 御城河（平台的应用合规服务）
一、原因 近年来国家陆续出台了个人信息保护和数据安全相关的法律法规，对保障消费者个人信息权益、规范数据处理活动提出了更明确的责任要求。为了更好的保障用户信息的安全、提升开发者应用对于用户个人信息的保护及应用自身的安全防护能力，平台因此提出《开发者安全能力标准》。
淘宝平台要求获取消费者个人敏感信息的所有IT类应用对接御城河系统，应用标签包括但不限于：商家后台系统（简称“自研系统”）、国际商家后台系统（简称“自研系统”）、服务商后台系统、订单管理、ERP软件、进销存软件、全渠道ERP，仓储管理系统（WMS）、奇门-商家自研WMS系统等。
二、用户中心升级原因 对于自有账号体系的应用，都需要对接账号风控，平台建议用户接入淘系账号风控体系，使用淘系账号的应用将默认享有平台提供的账号风控能力，如使用自有账号体系的应用，应具备平台认可的应用身份服务（简称：IDAAS）能力，并开启二次认证等安全策略并回传日志到平台。
三、两种升级方式主要工作 注意：无论是接入淘宝账户风控体系，还是自研对接御城河，都需要调整用户中心认证流程。
3.1、调整认证流程 在修改密码、绑定手机、绑定邮箱、绑定身份证等认证流程时，需要调整认证流程，必须要时需添加二次认证校验。
3.2、接入淘系账号风控体系 购买阿⾥云应⽤身份服务（IDaaS） 对接API，同步账户数据到淘系账号，由 IDaaS 进⾏统⼀认证。 idaas 数据将自动回流计算，无需isv/自研再对接御城河回流。 3.3、自研 对接API，应用需对接御城河 idaas 和二次认证接口回流数据。 四、调整认证所需工作 账户涉及二次认证新增属性（短信或MFA） 二次认证设置页 是否启用、启用模式、启用节点（登录、修改密码、手机、邮箱、身份证？）、启用（账户或组织）范围、认证类型（淘宝、自建） 二次认证方式（默认手机短信） 短信模板 验证码限制逻辑 验证码发送频率限制 同一验证码可以尝试 3 次输入，3 次均失败后，验证码失效。用户需要获取新验证码。 验证码有效期 二次认证弹窗页 当前认证手机号（中间遮掩） 获取验证码按钮（倒计时，防止重复点击） 验证码输入框 提交、取消按钮 后端各触发二次认证校验节点，二次认证校验统一接口 账户同步 选择所需同步账户范围 页 账户增删改等阶段对接阿里云 IDaaS API 上报日志 注意：
如果是自建需要完成除 5 阶段外全部流程，如果对接阿里云 IDaaS ，只需完成 3、4、5 阶段、并对接API，其它由阿里云 IDaaS 控制。
五、接入淘系账号风控体系流程说明 对接 阿⾥云应⽤身份服务 IDaaS ，对于我们应用的客户来说，实际上是透明的，他们并不会感知到后端验证的变更。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC10%E7%AB%A0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC10%E7%AB%A0%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%93%8D%E4%BD%9C/</guid>
      <description> Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。
C语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。
本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。
8.1 指针初探 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC11%E7%AB%A0%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC11%E7%AB%A0%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE/</guid>
      <description> Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。
C语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。
本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。
8.1 指针初探 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC12%E7%AB%A0%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC12%E7%AB%A0%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</guid>
      <description> Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。
C语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。
本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。
8.1 指针初探 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC13%E7%AB%A0%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC13%E7%AB%A0%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD/</guid>
      <description> Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。
C语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。
本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。
8.1 指针初探 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC14%E7%AB%A0%E9%AB%98%E7%BA%A7%E4%B8%93%E7%94%A8%E4%B8%BB%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC14%E7%AB%A0%E9%AB%98%E7%BA%A7%E4%B8%93%E7%94%A8%E4%B8%BB%E9%A2%98/</guid>
      <description> Beginning C ,Fifth Edition 第8章：程序的结构 如第1章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。
C语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。
本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。
8.1 指针初探 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC1%E7%AB%A0C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC1%E7%AB%A0C-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/</guid>
      <description>Beginning C ,Fifth Edition 第1章 C 语言编程 程序即一组指令，可以让计算机依指令行事，完成指定的任务。
本章的主要内容
C 语言标准 标准库的概念 如何创建 C 程序 如何组织 C 程序 如何编写在屏幕上显示文本的程序 1.1 C 语言 1.2 标准库 标准库定义了编写C程序时常常需要的常量、符号和函数。它还提供了基本C语言的一些可选扩展，标准库以不依赖机器的形式实现，即相同的C代码在不同的底层硬件上会实现相同的功能。
标准库在一系列文件——头文件中指定。头文件的扩展名总是.h。使用一组标准功能可用于C程序文件，只需要将对应的标准头文件含进来。
1.3 学习 C 1.4 创建 C 程序 C 程序的创建工程有 4 个基本步骤：
编辑 编译 链接 执行 程序要运行起来，必须要经过四个步骤：预处理、编译、汇编和链接。接下来通过几个简单的例子来详细讲解一下这些过程。 对于上边用到的几个选项需要说明一下。
使用 gcc 命令不跟任何的选项的话，会默认执行预处理、编译、汇编、链接这整个过程，如果程序没有错，就会得到一个可执行文件，默认为a.out
-E选项：提示编译器执行完预处理就停下来，后边的编译、汇编、链接就先不执行了。
-S选项：提示编译器执行完编译就停下来，不去执行汇编和链接了。
-c选项：提示编译器执行完汇编就停下来。
所以，这三个选项相当于是限定了编译器执行操作的停止时间，而不是单独的将某一步拎出来执行。
1.4.1 编辑 创建和修改 C 程序的源代码——我们编写的程序指令称之为源代码。
1.4.2 编译 编译器可以将源代码转换成机器语言，在编译过程中，会找到并报告错误。这个阶段的输入是在编译期间产生的包含源代码的文件，常称为源文件。
编译器会检查源文件中的错误。
编译器输出的结果成为对象代码，存放于对象文件它与源文件同名，这些文件在Windows中扩展名通常是 .obj,Linux中通常是.o
若编译器是GUN，编译命令是：
gcc -c main.c 如果省略了 -c 这个参数，程序还会自动链接，生成可执行文件。
编译过程包括两个阶段：第一个阶段称为预处理阶段，在此期间会修改或添加代码。第二阶段是生成对象代码的实际编译过程。源文件可以包含预处理宏，他们用于添加或修改 C 语言程序。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC2%E7%AB%A0%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC2%E7%AB%A0%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5/</guid>
      <description>Beginning C ,Fifth Edition 第2章 编程初步 在程序中仓储数据项的地方是可以变化的，叫做变量(variable)，这是本章的主题。
本章的主要内容：
内存的用法及变量的概念 在 C 中如何计算 变量的不同类型及其用途 强制类型转换的概念及其使用场合 编写一个程序，计算树木的高度 浮点数默认是 double 类型
在数值的末尾添加一个 f，类型为 float
在数字的末尾添加一个大写 L 或小写 l，类型为 long double
2.1 计算机的内存 计算机执行程序时，组成程序的指令和程序操作的数据都必须存储到某个地方。这个地方就是机器的内存，也称之为主内存(main memory)，或随机访问存储器(Random Access Memory, RAM)，RAM是易失性存储器。关闭 PC 后，RAM 的内容就会丢失。PC 把一个或多个磁盘驱动器作为其永久存储器。要在程序结束执行后存储起来的任何数据，都应该写入磁盘。
计算机用二进制存储数据：0 或 1.计算机有时用真(true)和假(false)表示它们：1 是真，0 是假。每一个数据称之为一个位(bit),即二进制数(binary digit)的缩写。
字节的地址(address) 内存中的位以 8 个为一组，每组的 8 位称之为一个字节(byte)。为了使用字节的内容，每个字节用一个数字表示，第一个字节用 0 表示，第二个字节用 1 表示，直到计算机内存的最后一个字节。字节的这个数字标记称之为字节的地址(address)。因此，每个字节的地址都是唯一的。字节的地址唯一地表示计算机内存中的字节。
总之，内存的最小单位是位(bit)，将8个位组合为一组，称之为字节(byte)。每个字节都有唯一的地址。字节的地址从 0 开始。位只能是 0 或 1 ，如图所示：
计算机的内存的常用单位是千字节(KB)、兆字节(MB)、千兆字节(GB)。磁盘驱动器还使用兆兆字节(TB)。这些单位的大小如下：
1KB 是1024 字节。 1MB 是1024 KB，也就是1 048 576 字节。 1GB 是1024 NB，也就是1 072 741 841 字节。 1TB 是1024 GB，也就是1 099 511 627 776 字节。 如果 PC 有 1GB 的 RAM ，字节地址就是0~1 073 741 841 。0 到 1023 共 1024 个数字而在二进制中，1023的十个位刚好全是1：11 1111 1111 ，(1 byte ,8位)，MB 需要 20 个位，GB 需要 30 个位，</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC3%E7%AB%A0%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC3%E7%AB%A0%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</guid>
      <description>Beginning C ,Fifth Edition 第3章 条件判断 本章将在可以编写的程序种类和构建程序的灵活性方面迈出一大步。我们要学习一种非常强大的编程工具:比较表达式的值,根据其结果,选择执行某组语句。也就是说,可以控制程序中语句的执行顺序。
本章的主要内容:
根据算术比较的结果来判断 逻辑运算符的概念及其用法 再谈从键盘上读取数据 编写一个可用作计算器的程序 3.1 判断过程 在程序中做出判断,就是选择执行一组程序语句,而不执行另一组程序语句。在现实生活中,我们总是要做判断。
跟 Java 一样。
3.1.1 算数比较 C中的比较涉及一些运算符。比较两个值有6个关系运算符：
&amp;lt;&amp;lt;===!=&amp;gt;&amp;gt;= 这些运算都会得到 int 类型的值。如果比较结果为真,每个操作的结果都是 1,否则如果比较结果为假,则每个操作的结果都是 0。如上一章所述, stabool.h 头文件为这些值定义了符号 true 和 false,于是 2!=3得到 true, 5L&amp;gt;3L 和 6 &amp;lt;= 12 也得到 true,表达式 2==3、5&amp;lt;4和 1.2&amp;gt;= 1.3 都得到 0,即 false。
这些表达式称为逻辑表达式或布尔表达式,因为每个表达式都会得到两个结果之一: true 或 false,关系运算符生成布尔结果,所以可以把结果存储在 bool 类型的变量中。例如:
bool result =5 &amp;lt;4;1/ result will be false 任何非零数值在转换为 bool 类型时,都得到 true。这表示,可以把算术表达式的结果赋予 bool 变量,如果它是非零值,就存储 true ,否则就存储 false.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC4%E7%AB%A0%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC4%E7%AB%A0%E5%BE%AA%E7%8E%AF/</guid>
      <description>Beginning C ,Fifth Edition 第4章 循环 本章将介绍如何重复执行一个语句块,直到满足某个条件为止,这称为循环。语句块的执行次数可以简单地用一个计数器来控制,语句块重复执行指定的次数,或者还可以更复杂一些,重复执行一个语句块,直到满足某个条件为止,例如用户输入 quit。后者可以编写上一章的计算器示例,使计算过程重复需要的次数,而不必使用goto语句。
本章的主要内容
使语句或语句块重复执行指定的次数 重复执行语句或语句块,直到满足某个条件为止 使用for, while和do-while循环 递增和递减运算符的作用及其用法 编写一个简单的Simon游戏程序 4.1 循环 循环是带有比较数据项功能的一个基本编程工具。循环总是隐含了某种比较,因为它提供了终止循环的方式。典型的循环是使一系列语句重复执行指定的次数,这种循环会存储循环块执行的次数,与需要的重复次数相比较,比较的结果确定何时应终止循环。
4.2 递增和递减运算符 ++ number;-- number; 4.3 for 循环 4.4 for 循环的一般语法 for(int i = 1, j = 2; i&amp;lt;=5; ++i,j = j+2)printf(&amp;#34;%5d&amp;#34;,i*j); 4.5 再谈递增和递减运算符 4.5.1 递增运算符 先看看递增运算符。假如变量的类型是 int ，下面的3调语句有相同的结果：
count = count + 1;count += 1;++count; 这些语句都给变量 count 加 1.最后一致形式最简洁。 也可以在表达式中使用递增运算符。这个运算符在表达式中的动作是递增变量的值,然后,在表达式中使用递增的值。例如,假设count的值是5,执行如下语句:
total = ++count +6; 变量count会递增到6,在计算等号右边的表达式时,会使用这个值。因此变量total的值为12,这个指令改变两个变量count和total.
4.5.2 递增运算符的前置和后置形式。 前面将++运算符放在变量前面,这叫做前置形式。这个运算符也可以写在变量的后面,这称为后置形式。在表达式中使用前置和后置形式的效果大不相同。如果在表达式中编写的是count++,则变量count的值在使用之后才递增。这看起来有点复杂。修改前面的例子:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC5%E7%AB%A0%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC5%E7%AB%A0%E6%95%B0%E7%BB%84/</guid>
      <description>Beginning C ,Fifth Edition 第5章 数组 我们经常需要在程序中存储某种类型的大量数据值。例如,如果编写一个程序,追踪一支篮球队的成绩,就要存储一个赛季的各场分数和各个球员的得分,然后输出某个球员的整季得分,或在赛事进行过程中计算出赛季的平均得分。我们可以利用前面所学的知识编写一个程序,为每个分数使用不同的变量。然而,如果一个赛季里有非常多的赛事,这会非常繁琐,因为有球赛的每个球员都需要许多变量。所有篮球分数的类型都相同,不同的是分值,但它们都是篮球赛的分数。理想情况下,应将这些分值组织在一个名称下,例如球员的名字,这样就不需要为每个数据项定义变量了。
本章将介绍如何在C程序中使用数组,然后探讨程序使用数组时,如何通过一个名称来引用一组数值。
本章的主要内容:
什么是数组 如何在程序中使用数组 数组如何使用内存 什么是多维数组 如何编写程序,计算帽子的尺寸 如何编写井字游戏 5.1 数组简介 说明数组的概念及其作用的最好方法,是通过一个例子,来说明使用数组后程序会变得非常简单。这个例子将计算某班学生的平均分数。
5.1.1 不用数组的程序 非常麻烦
5.1.2 什么是数组 数组是一组数目固定、类型相同的数据项,数组中的数据项称为元素。数组中的元素都是int, long或其他类型。下面的数组声明非常类似于声明一个含有单一数值的正常变量,但要在名称后的方括号中放置一个数。
long numbers [10]; 方括号中的数字定义了要存放在数组中的元素个数,称为数组维(array dimension)。数组有一个类型,它组合了元素的类型和数组中的元素个数。因此如果两个数组的元素个数相同、类型也相同,这两个数组的类型就相同。
存储在数组中的每个数据项都用相同的名称访问,在这个例子中,该名称就是 numbers。要选择某个元素,可以在数组名称后的方括号内使用索引值。索引值是从0开始的连续整数。0是第一个元素的索引值,前面numbers数组的元素索引值是0-9,索引值0表示第一个元素,索引值9表示最后一个元素。因此数组元素可表示为numbers[0]numbers[1]、numbers[2] &amp;hellip;&amp;hellip;numbers[9]。
如图5-1所示: 注意,索引值是从0开始,不是1,第一次使用数组时,这是一个常犯的错误,有时这称为off-by-one错误。在一个十元素数组中,最后一个元素的索引值是9,要访问数组中的第4个值,应使用表达式numbers[3]。数组元素的索引值是与第1个元素的偏移量。第1个元素的偏移量是0,第2个元素与第一个元素的偏移量是1,第3个元素与第一个元素的偏移量是2,依此类推。
要访问numbers数组元素的值,也可以在数组名称后的方括号内放置表达式,该表达式的结果必须是一个整数,对应于一个可能的索引值。例如numbers[i-2]。如果i的值是3,就访问数组中的第2个元素numbers[1]。因此,有两种方法来指定索引值,以访问数组中的某个元素。其一,可以使用一个简单的整数,明确指定要访问的元素。其二,可以使用一个在执行程序期间计算的整数表达式。使用表达式的唯一限制是,它的结果必须是整数,该整数必须是对数组有效的索引值。
注意,如果在程序中使用的索引值超过了这个数组的合法范围,程序将不能正常运作。编译器检查不出这种错误,所以程序仍可以编译,但是执行是有问题的。在最好的情况下,是从某处提取了一个垃圾值,所以结果是错误的,且每次执行的结果都不会相同。在最糟的情况下,程序可能会覆盖重要的信息,且锁死计算机,需要重启计算机。有时,这对程序的影响比较微妙:程序有时能正常工作,有时不能,或者程序看起来工作正常,但结果是错误的,只是不明显。因此,一定要细心检查数组索引是否在合法范围内。
5.1.3 使用数组 跟 Java 一样
#include &amp;lt;stdio.h&amp;gt;int main(void) {int grades[10];unsigned int count = 10;long sum = 0L;float average = 0.0f;printf(&amp;#34;\nEnter the 10 grades:\n&amp;#34;);for (unsigned int i = 0; i &amp;lt; count; ++i) {printf(&amp;#34;%2u&amp;gt;&amp;#34;, i + 1);scanf(&amp;#34;%d&amp;#34;, &amp;amp;grades[i]);sum += grades[i];}average = (float) sum / count;printf(&amp;#34;\nAverage of the ten grades entered is: %.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC6%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC6%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>Beginning C ,Fifth Edition 第6章：字符串和文本的应用 本章将探讨如何使用字符数组,以扩展数组知识。我们经常需要将文本字符串用作个实体,不过C语言没有提供字符串数据类型,而是使用char类型的数组元素存储字符串。本章将介绍如何创建和处理字符串变量,标准库函数如何简化字符串的处理。
本章的主要内容:
如何创建字符串变量 如何连接两个或多个字符串,形成一个字符串 如何比较字符串 如何使用字符串数组 哪些库函数能处理字符串,如何应用它们 6.1 什么是字符串 字符串常量的例子非常常见。字符串常量是放在一对双引号中的一串字符或符号。一对双引号之间的任何内容都会被编译器视为字符串,包括特殊字符和嵌入的空格。每次使用print()显示信息时,就将该信息定义成字符串常量了。以下的语句是用这种方法使用字符串的例子:
printf (&amp;#34;This is a string.&amp;#34;);printf (&amp;#34;This is on\ntwo lines!&amp;#34;);printf (&amp;#34;For \&amp;#34; you write \\\&amp;#34;.&amp;#34;); 这3个字符串例子如图6-1所示。存储在内存中的字符码的十进制值显示在这些字符的下方。
第一个字符串是一系列字符后跟一个句号。printf()函数会把这个字符串输出为:
This is a string. 第二个字符串有一个换行符\n,所以字符串显示在两行上:
This is ontwo lines! ·第三个字符串有点难以理解,但print()函数的输出很清楚:
For &amp;#34; you write \&amp;#34;. 必须把字符串中的双引号写为转义序列&amp;quot;,因为编译器会把双引号看作字符串的结尾。要在字符串中包含反斜杠,也必须使用转义序列\,因为字符串中的反斜杠总是表示转义序列的开头。
如图6-1所示,每个字符串的末尾都添加了代码值为0的特殊字符,这个字符称为空字符,写为\0。C中的字符串总是由\0字符结束,所以字符串的长度永远比字符串中的字符数多1。
注意
空字符不要和 NULL 混淆。空字符是字符串的终止符,而 NULL 是一个符号,表示不引用任何内容的内存地址。
可以自己将 \0 字符添加到字符串的结尾,但是这会使字符串的末尾有两个\0字符。下面的程序说明了空字符是如何运作的:
#include &amp;lt;stdio.h&amp;gt;int main(void){printf (&amp;#34;This is a \0 string.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC7%E7%AB%A0%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC7%E7%AB%A0%E6%8C%87%E9%92%88/</guid>
      <description>Beginning C ,Fifth Edition 第 7 章：指针 第 6 章已提到过指针,还给出使用指针的提示。本章深入探索这个主题,了解指针的功用。本章将介绍许多新概念,所以可能需要多次重复某些内容。本章很长,需要花一些时间学习其内容,用一些例子体验指针。指针的基本概念很简单,但是可以应用它们解决复杂的问题。指针是用C语言高效编程的一个基本元素。
本章的主要内容:
指针的概念及用法 指针和数组的关系 如何将指针用于字符串 如何声明和使用指针数组 如何编写功能更强的计算器程序 7.1 指针初探 指针是 C 语言中最强大的工具之一,它也是最容易令人困惑的主题,所以一定要在开始时正确理解其概念,在深入探讨指针时,要对其操作有清楚的认识。
第 2 和第 5 章讨论内存时,谈到计算机如何为声明的变量分配一块内存。在程序中使用变量名引用这块内存,但是一旦编译执行程序,计算机就使用内存位置的地址来引用它。这是计算机用来引用“盒子(其中存储了变量值)&amp;ldquo;的值。
请看下面的语句:
int number = 5; 这条语句会分配一块内存来存储一个整数,使用 number 名称可以访问这个整数。值 5 存储在这个区域中。计算机用一个地址引用这个区域。存储这个数据的地址取决于所使用的计算机、操作系统和编译器。在源程序中,这个变量名是固定不变的,但地址在不同的系统上是不同的。
可以存储地址的变量称为指针(pointers),存储在指针中的地址通常是另一个变量,如图7-1所示。指针 pnumber 含有另一个变量 number 的地址,变量 number 是一个值为 99 的整数变量。存储在 pnumber 中的地址是 number 第一个字节的地址。“指针”这个词也用于表示一个地址,例如&amp;quot;strcat_s()函数返回一个指针&amp;rdquo;。
首先,知道变量 pnumber 是一个指针是不够的,更重要的是,编译器必须知道它所指的变量类型。没有这个信息,根本不可能知道它占用多少内存,或者如何处理它所指的内存的内容。char 类型值的指针指向占有一个字节的值,而 long 类型值的指针通常指向占有4个字节的值。因此,每个指针都和某个变量类型相关联,也只能用于指向该类型的变量。所以如果指针的类型是 int,就只能指向 int 类型的变量,如果指针的类型是 float,就只能指向 float 类型的变量。一般给定类型的指针写成 type*,其中 type 是任意给定的类型。
每个指针都和某个变量类型相关联
类型名 void 表示没有指定类型,所以 void* 类型的指针可以包含任意类型的数据项地址。类型 void* 常常用做参数类型,或以独立于类型的方式处理数据的函数的返回值类型。任意类型的指针都可以传送为 void* 类型的值,在使用它时,再将其转换为合适的类型。例如, int 类型变量的地址可以存储在 void* 类型的指针变量中。要访问存储在 void* 指针所指地址中的整数值,必须先把指针转换为 int* 类型。本章后面介绍的 malloc() 库函数分配在程序中使用的内存,返回 void* 类型的指针。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC8%E7%AB%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC8%E7%AB%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84/</guid>
      <description>Beginning C ,Fifth Edition 第8章：程序的结构 如第 1 章所述,将程序分成适度的自包含单元是开发任一程序的基本方式。当工作很多时,最明智的做法就是把它分成许多便于管理的部分,使每一小部分能很轻松地完成,并确保正确完成整个工作。如果仔细设计各个代码块,就可以在其他程序中重用其中的一些代码块。
C 语言中的一个重要观念是,每个程序都应切割成许多小的函数。前面的所有例子都编写成一个函数main(),还涉及其他函数,因为这些例子还使用各种标准库函数进行输入输出、数学运算和处理字符串。
本章将介绍如何使程序更有效率,利用更多自己的函数更方便地开发程序。
本章的主要内容:
数据如何传给函数 函数如何返回结果 如何定义自己的函数 函数原型的概念和使用场合 函数使用指针参数的优势 8.1 程序的结构 如概述所言,C 程序是由许多函数组成的,其中最重要的就是函数 main(),它是执行的起点。本书介绍库函数 printf() 或 scanf() 时,说明了一个函数可以调用另一个函数,完成特定的工作,在任务完成后调用函数继续执行。不考虑存储在全局变量(参见第9章)中的数据或者可以通过指针参数访问的数据的负面影响,程序中的每个函数都是一个执行特定操作的自包含单元。调用一个函数时,就执行该函数体内的代码,这个函数执行结束后,控制权就回到调用该函数的地方。如图8-1所示为 C 程序由 5 个函数组成时的执行顺序,它并未显示任何语句细节。
这个程序以正常的方式按顺序执行语句,当遇到调用一个函数的语句时,就把参数值传递给函数,从该函数的起始点开始执行,即该函数体的第一条语句。这个函数会一直执行,在遇到 return 语句或到达这个函数体的结束括号时,就返回调用它的那个位置之后执行。
这些组成程序的函数通过函数调用及其 return 语句链接在一起,完成各种工作,以达到程序的目标。图 8-1 中的每个函数在程序中只执行一次。实际上,每个函数可以执行多次,且可以从程序中的多个地方调用。前面的例子中就多次调用函数 printf() 和 scanf()。
在详细了解如何定义自己的函数之前,必须解释变量的一个重要方面,这个方面一直未提及。
8.1.1 变量的作用域和生存期 在前面所有的例子中,都是在定义 main() 函数体的起始处声明程序的变量。事实上,可以在任何代码块的起始处定义变量。这有什么不同吗?这是绝对不同的。变量只存在于定义它们的块中。它们在声明时创建,在遇到下一个闭括号时就不存在了。
在一个块内的其他块中声明的变量也是这样。在外部块的起始处声明的变量也存在于内部块中。这些变量可以随意访问,只要内部块中没有同名的变量即可。
变量在一个块内声明时创建,在这个块结束时销毁,这种变量称为自动变量,因为它们是自动创建和销毁的。给定变量可以在某个程序代码块中访问和引用,这个程序代码块称为变量的作用域。在作用域内使用变量是没有问题的。但是如果试图在变量的作用域外部引用它,编译程序时就会得到一条错误信息,因为这个变量在它的作用域之外不存在。例如下面的代码:
{ int a = 0; // Create a // Reference to a is OK here // Reference to b is an error here - it hasn&amp;#39;t been created yet { int b= 10; // Create b // Reference to a and b is OK here }// b dies here // Reference to b is an error here - it has been destroyed // Reference to a is OK here }// a dies here 对于在一个块内声明的所有变量,在这个块的结束括号之后它们就不再存在。变量 a 可在内外两个块内访问,因为它是在外部块中声明的。变量 b 只能在内部块中访问,因为它是在内部块中声明的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC9%E7%AB%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition-%E7%AC%AC9%E7%AB%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2/</guid>
      <description>Beginning C ,Fifth Edition 第 9 章：函数再探 学习了第8章后,读者就应具备创建和使用函数的基础知识了。本章将以此为基础,介绍函数的使用和操作,尤其是如何通过指针访问函数。也会使用一些更灵活的方法在函数之间通信。 本章的主要内容:
函数指针的概念及其用法 如何在函数内使用静态变量 如何在函数之间共享变量 函数如何调用自己,而不陷入无限循环 编写一个五子棋游戏(也称为Reversi) 9.1 函数指针 指针对于操作数据和含有数据的变量是一个非常有用的工具。只要一把火钳就可处理所有火热的东西;同样,使用指针也可以操作函数,函数的内存地址存储了函数开始执行的位置(起始地址),存储在函数指针中的内容就是这个地址。
不过,仅有地址还不够。如果函数通过指针来调用,还必须提供变元的类型和个数,以及返回值的类型。编译器不能仅通过函数的地址来推断这些信息。这意味着,声明函数指针比声明数据类型指针复杂一些。指针包含了地址,而且必须定义一个类型;同样,函数指针也包含了地址,也必须定义一个原型。
9.1.1 声明函数指针 函数指针的声明看起来有点奇怪,容易混涌,所以下面从一个简单的例子开始:
int (*pfunction) (int); 这是一个函数指针变量的声明,它不指向任何内容-一该语句只定义了指针变量。这个指针的名称是 pfunction,指向一个参数是 int 类型、返回值是 int 类型的函数。而且,这个指针只能指向有这些特征的函数。如果函数接受 float 变元,返回 float 值,就需要声明另一个有这些特征的指针。图 9-1 说明了声明的各个成分。
在函数指针的声明中有许多括号。在这个例子中,声明的 *pfunction 部分必须放在括号中。如果省略了括号,就变成 pfunction()函数的声明了,这个函数返回一个指向 int 的值,这可不是我们希望的结果。第二对括号包含参数列表,这与标准函数声明相同。函数指针只能指向特定的函数,该函数有特定的返回类型、特定的参数个数和特定类型的参数。函数名称可以随意,与其他指针变量一样。
9.1.2 通过函数指针调用函数 假定定义如下函数原型:
int sum (int a, int b); // Calculates a+b 这个函数有两个 int 类型的参数,返回值的类型是 int,所以可以把它的地址存储在声明如下的函数指针中:
int (*pfun)(int, int)= sum; 这条语句声明了一个函数指针 pfun,它存储函数的地址,该函数有两个 int 类型的参数,返回值的类型是 int。该语句还用 sum()函数的地址初始化 pfun。要提供初始值,只需要使用有所需原型的函数名。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/Beginning-C-Fifth-Edition/</guid>
      <description>Beginning C ,Fifth Edition 译者序 前言 有抱负的程序员必将面对的三重障碍，遍布程序设计语言中的各类术语、理解如何使用语言元素的语法和作用（而不仅仅只是知道它们的概念）、领会如何在实际场景中应用该语言。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/C-Standard-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Beginning-C-Fifth-Edition/C-Standard-Functions/</guid>
      <description>头文件&amp;lt;stdio.h&amp;gt; scanf_s const size_t BUF_SIZE = 100; // Input buffer size char buffer[BUF_SIZE]; // A 100 byte input buffer scanf_s(&amp;#34;%s&amp;#34;, buffer, BUF_SIZE); // Read a string 从各种来源读取数据，根据其解释并将format结果存储到给定位置。
1）从中读取数据 stdin
2）从文件流中读取数据 stream
3）从空终止的字符串中读取数据buffer。到达字符串的末尾等同于达到文件结束条件fscanf</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC10%E7%AB%A0%E7%BB%93%E6%9E%84struct%E4%B8%8E%E6%96%B9%E6%B3%95method/</guid>
      <description> 第10章：结构（struct）与方法（method） 10.1 结构体定义 10.2 使用工厂方法创建结构体实例 10.3 使用自定义包中的结构体 10.4 带标签的结构体 10.5 匿名字段和内嵌结构体 10.6 方法 10.7 类型的 String() 方法和格式化描述符 10.8 垃圾回收和 SetFinalizer </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0%E6%8E%A5%E5%8F%A3interface%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC11%E7%AB%A0%E6%8E%A5%E5%8F%A3interface%E4%B8%8E%E5%8F%8D%E5%B0%84reflection/</guid>
      <description> 第11章：接口（interface）与反射（reflection） 11.1 接口是什么 11.2 接口嵌套接口 11.3 类型断言：如何检测和转换接口变量的类型 11.4 类型判断：type-switch 11.5 测试一个值是否实现了某个接口 11.6 使用方法集与接口 11.7 第一个例子：使用 Sorter 接口排序 11.8 第二个例子：读和写 11.9 空接口 11.10 反射包 11.11 Printf 和反射 11.12 接口与动态类型 11.13 总结：Go 中的面向对象 11.14 结构体、集合和高阶函数 第三部分：Go 高级编程 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC12%E7%AB%A0%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE/</guid>
      <description> 第12章：读写数据 12.1 读取用户的输入 12.2 文件读写 12.3 文件拷贝 12.4 从命令行读取参数 12.5 用 buffer 读取文件 12.6 用切片读写文件 12.7 用 defer 关闭文件 12.8 使用接口的实际例子：fmt.Fprintf 12.9 格式化 JSON 数据 12.10 XML 数据格式 12.11 用 Gob 传输数据 12.12 Go 中的密码学 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC13%E7%AB%A0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC13%E7%AB%A0%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E6%B5%8B%E8%AF%95/</guid>
      <description> 第13章：错误处理与测试 13.1 错误处理 13.2 运行时异常和 panic 13.3 从 panic 中恢复（Recover） 13.4 自定义包中的错误处理和 panicking 13.5 一种用闭包处理错误的模式 13.6 启动外部命令和程序 13.7 Go 中的单元测试和基准测试 13.8 测试的具体例子 13.9 用（测试数据）表驱动测试 13.10 性能调试：分析并优化 Go 程序 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC1%E7%AB%A0Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90%E5%8F%91%E5%B1%95%E4%B8%8E%E6%99%AE%E5%8F%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC1%E7%AB%A0Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E8%B5%B7%E6%BA%90%E5%8F%91%E5%B1%95%E4%B8%8E%E6%99%AE%E5%8F%8A/</guid>
      <description> Go入门指南.mk 1.1 起源与发展 1.2 语言的主要特性与发展的环境和影响因素 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%AB%A0%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%AB%A0%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</guid>
      <description>Go入门指南.mk 第2章：安装与运行环境 2.1 平台与架构 2.2 Go 环境变量 Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：
$GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。 目标机器是指你打算运行你的 Go 应用程序的机器。
Go 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。
为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。
$GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC3%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%85%B6%E5%AE%83%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC3%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%85%B6%E5%AE%83%E5%B7%A5%E5%85%B7/</guid>
      <description>Go入门指南.mk 第3章：编辑器、集成开发环境与其它工具 3.1 Go 开发环境的基本要求 这里有一个可以用来开发 Go 的集成开发环境，你期待有以下哪些特性，从而替代你使用文本编辑器写代码和命令行编译与链接程序的方式？
语法高亮是必不可少的功能，这也是每个开发工具都提供配置文件来实现自定义配置的原因。 可以自动保存代码，至少在每次编译前都会保存。 可以显示代码所在的行数。 拥有较好的项目文件纵览和导航能力，可以同时编辑多个源文件并设置书签，能够匹配括号，能够跳转到某个函数或类型的定义部分。 完美的查找和替换功能，替换之前最好还能预览结果。 可以注释或取消注释选中的一行或多行代码。 当有编译错误时，双击错误提示可以跳转到发生错误的位置。 跨平台，能够在 Linux、Mac OS X 和 Windows 下工作，这样就可以专注于一个开发环境。 最好是免费的，不过有些开发者还是希望能够通过支付一定金额以获得更好的开发环境。 最好是开源的。 能够通过插件架构来轻易扩展和替换某个功能。 尽管集成开发环境本身就是非常复杂的，但一定要让人感觉操作方便。 能够通过代码模版来简化编码过程从而提升编码速度。 使用 Go 项目的概念来浏览和管理项目中的文件，同时还要拥有构建系统的概念，这样才能更加方便的构建、清理或运行我们建立的程序或项目。构建出的程序需要能够通过命令行或 IDE 内部的控制台运行。 拥有断点、检查变量值、单步执行、逐过程执行标识库中代码的能力。 能够方便的存取最近使用过的文件或项目。 拥有对包、类型、变量、函数和方法的智能代码补全的功能。 能够对项目或包中的代码建立抽象语法树视图（AST-view）。 内置 Go 的相关工具。 能够方便完整地查阅 Go 文档。 能够方便地在不同的 Go 环境之间切换。 能够导出不同格式的代码文件，如：PDF，HTML 或格式化后的代码。 针对一些特定的项目有项目模板，如：Web 应用，App Engine 项目，从而能够更快地开始开发工作。 具备代码重构的能力。 集成像 hg 或 git 这样的版本控制工具。 集成 Google App Engine 开发及调试的功能。 3.2 编辑器和集成开发环境 3.3 调试器 如果你不想使用调试器，你可以按照下面的一些有用的方法来达到基本调试的目的：
在合适的位置使用打印语句输出相关变量的值（print/println 和 fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC4%E7%AB%A0%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go入门指南.mk 第二部分：语言的核心结构与技术 第4章：基本结构和基本数据类型 4.1 文件名、关键字与标识符 Go 的源文件以 .go 为后缀名存储在计算机中，这些文件名均由小写字母组成，如 scanner.go 。如果文件名由多个部分组成，则使用下划线 _ 对它们进行分隔，如 scanner_test.go 。文件名不包含空格或其他特殊字符。
一个源文件可以包含任意多行的代码，Go 本身没有对源文件的大小进行限制。
有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头，然后紧跟着 0 个或多个字符或 Unicode 数字
_ 本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。
程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。
如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。
4.2 Go 程序的基本结构和要素 包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。
如同其它一些编程语言中的类库或命名空间的概念，每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。
你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
一个应用程序可以包含不同的包，而且即使你只使用 main 包也不必把所有的代码都写在一个巨大的文件里：你可以用一些较小的文件，并且在每个文件非注释的第一行都使用 package main 来指明这些文件都属于 main 包。如果你打算编译包名不是为 main 的源文件，如 pack1，编译后产生的对象文件将会是 pack1.a 而不是可执行程序。另外要注意的是，所有的包名都应该使用小写字母。
标准库 在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。在 Windows 下，标准库的位置在 Go 根目录下的子目录 pkg\windows_386 中；在 Linux 下，标准库在 Go 根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC5%E7%AB%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC5%E7%AB%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</guid>
      <description> Go入门指南.mk 第5章：控制结构 5.1 if-else 结构 5.2 测试多返回值函数的错误 5.3 switch 结构 5.4 for 结构 5.5 Break 与 continue 5.6 标签与 goto </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC6%E7%AB%A0%E5%87%BD%E6%95%B0function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC6%E7%AB%A0%E5%87%BD%E6%95%B0function/</guid>
      <description> 第6章：函数（function） 6.1 介绍 6.2 函数参数与返回值 6.3 传递变长参数 6.4 defer 和追踪 6.5 内置函数 6.6 递归函数 6.7 将函数作为参数 6.8 闭包 6.9 应用闭包：将函数作为返回值 6.10 使用闭包调试 6.11 计算函数执行时间 6.12 通过内存缓存来提升性能 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC7%E7%AB%A0%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC7%E7%AB%A0%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</guid>
      <description> 第7章：数组与切片 7.1 声明和初始化 7.2 切片 7.3 For-range 结构 7.4 切片重组（reslice） 7.5 切片的复制与追加 7.6 字符串、数组和切片的应用 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC8%E7%AB%A0Map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC8%E7%AB%A0Map/</guid>
      <description> 第8章：Map 8.1 声明、初始化和 make 8.2 测试键值对是否存在及删除元素 8.3 for-range 的配套用法 8.4 map 类型的切片 8.5 map 的排序 8.6 将 map 的键值对调 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0%E5%8C%85package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E7%AC%AC9%E7%AB%A0%E5%8C%85package/</guid>
      <description> 第9章：包（package） 9.1 标准库概述 9.2 regexp 包 9.3 锁和 sync 包 9.4 精密计算和 big 包 9.5 自定义包和可见性 9.6 为自定义包使用 godoc 9.7 使用 go install 安装自定义包 9.8 自定义包的目录结构、go install 和 go test 9.9 通过 Git 打包和安装 9.10 Go 的外部包和项目 9.11 在 Go 程序中使用外部库 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>Go入门指南.mk 标签：Golang、基础、 时间：2020年10月15日6:25:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 第一部分：学习 Go 语言 第1章：Go 语言的起源，发展与普及 1.1 起源与发展 1.2 语言的主要特性与发展的环境和影响因素 第2章：安装与运行环境 2.1 平台与架构 2.2 Go 环境变量 2.3 在 Linux 上安装 Go 2.4 在 Mac OS X 上安装 Go 2.5 在 Windows 上安装 Go 2.6 安装目录清单 2.7 Go 运行时（runtime） 2.8 Go 解释器 第3章：编辑器、集成开发环境与其它工具 3.1 Go 开发环境的基本要求 3.2 编辑器和集成开发环境 3.3 调试器 3.4 构建并运行 Go 程序 3.5 格式化代码 3.6 生成代码文档 3.7 其它工具 3.8 Go 性能说明 3.9 与其它语言进行交互 第二部分：语言的核心结构与技术 第4章：基本结构和基本数据类型 4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/%E6%A0%87%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Go%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/%E6%A0%87%E9%A2%98/</guid>
      <description> Go入门指南 标签：Golang、基础 时间：2020年10月15日00点11分 连接：http://www.saveload.cn/html/GoLang/Go入门指南.mk </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/rust/</guid>
      <description>Rust编程语言 标签：Rust、基础、 时间：2020年8月6日6:25:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 介绍 第 1章 入门 1.1。安装 1.2。你好，世界！ 1.3。您好，货运！ 第 2章 编写猜谜游戏 第 3章 通用编程概念 3.1。变量和可变性 3.2。资料类型 3.3。功能 3.4。注释 3.5。控制流 第 4章 了解所有权 4.1。什么是所有权？ 4.2。参考和借阅 4.3。切片类型 第 5章 使用结构来构造相关数据 5.1。定义和实例化结构 5.2。使用结构的示例程序 5.3。方法语法 第 6章 枚举和模式匹配 6.1。定义枚举 6.2。匹配控制流运算符 6.3。如果让简洁控制流 第 7 章 使用软件包，板条箱和模块管理不断增长的项目 Rust 中有三和重要的组织概念：包、箱、模块。
Packages: A Cargo feature that lets you build, test, and share crates 包装：货运功能，可让您构建，测试和共享包装箱 Crates: A tree of modules that produces a library or executable 板条箱：产生库或可执行文件的模块树 Modules and use: Let you control the organization, scope, and privacy of paths 模块和用途：让您控制路径的组织，范围和隐私 Paths: A way of naming an item, such as a struct, function, or module 路径：一种命名项目的方法，例如结构，函数或模块 7.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-10%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E5%92%8C%E5%AF%BF%E5%91%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-10%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81%E5%92%8C%E5%AF%BF%E5%91%BD/</guid>
      <description> 第 10章 通用类型，特征和寿命 10.1。通用数据类型 10.2。特性：定义共同的行为 10.3。使用生命周期验证参考 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-11%E7%AB%A0-%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-11%E7%AB%A0-%E7%BC%96%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</guid>
      <description> 第 11章 编写自动化测试 11.1。如何编写测试 11.2。控制测试的运行方式 11.3。测试组织 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-12%E7%AB%A0-I_O%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-12%E7%AB%A0-I_O%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F/</guid>
      <description> 第 12章 I_O项目：构建命令行程序 12.1。接受命令行参数 12.2。读取文件 12.3。重构以提高模块化和错误处理 12.4。通过测试驱动开发来开发库的功能 12.5。使用环境变量 12.6。将错误消息写入标准错误而不是标准输出 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-13%E7%AB%A0-%E5%8A%9F%E8%83%BD%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-13%E7%AB%A0-%E5%8A%9F%E8%83%BD%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/</guid>
      <description> 第 13章 功能语言功能：迭代器和闭包 13.1。闭包：可以捕获其环境的匿名函数 13.2。使用迭代器处理一系列项目 13.3。改善我们的I_O项目 13.4。比较性能：循环与迭代器 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-14%E7%AB%A0-%E6%9C%89%E5%85%B3Cargo%E5%92%8CCrates.io%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-14%E7%AB%A0-%E6%9C%89%E5%85%B3Cargo%E5%92%8CCrates.io%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF/</guid>
      <description> 第 14章 有关Cargo和Crates.io的更多信息 14.1。使用发布配置文件自定义构建 14.2。将箱子发布到Crates.io 14.3。货运工作区 14.4。通过商品安装从Crates.io安装二进制文件 14.5。使用自定义命令扩展货物 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-15%E7%AB%A0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description> 第 15章 智能指针 15.1。使用盒子 指向堆上的数据 15.2。使用Deref特性将智能指针视为常规参考 15.3。使用Drop Trait运行清理代码 15.4。钢筋混凝土，参考计数智能指针 15.5。RefCell 和内部可变性模式 15.6。参考周期可能会泄漏内存 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-16%E7%AB%A0-%E6%97%A0%E7%95%8F%E7%9A%84%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-16%E7%AB%A0-%E6%97%A0%E7%95%8F%E7%9A%84%E5%B9%B6%E5%8F%91/</guid>
      <description> 第 16章 无畏的并发 16.1。使用线程同时运行代码 16.2。使用消息传递在线程之间传输数据 16.3。共享状态并发 16.4。具有同步和发送特征的可扩展并发 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-17%E7%AB%A0-Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-17%E7%AB%A0-Rust%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8A%9F%E8%83%BD/</guid>
      <description> 第 17章 Rust的面向对象编程功能 17.1。面向对象语言的特征 17.2。使用允许不同类型值的特性对象 17.3。实施面向对象的设计模式 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-18%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8C%B9%E9%85%8D/</guid>
      <description> 第 18章 模式与匹配 18.1。可以使用所有场所模式 18.2。可引用性：模式是否可能不匹配 18.3。模式语法 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-19%E7%AB%A0-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-19%E7%AB%A0-%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</guid>
      <description> 第 19章 高级功能 19.1。不安全的锈 19.2。高级特质 19.3。高级类型 19.4。高级功能和闭包 19.5。巨集 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-1%E7%AB%A0-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-1%E7%AB%A0-%E5%85%A5%E9%97%A8/</guid>
      <description>第 1章 入门 1.1。安装 单独有写一篇如何安装
更新和卸载 通过安装Rust后rustup，轻松更新到最新版本。在您的外壳中，运行以下更新脚本：
$ rustup update 要卸载Rust和rustup，请从您的外壳运行以下卸载脚本：
$ rustup self uninstall 本地文件 运行rustup doc以在浏览器中打开本地文档。
1.2。你好，世界！ fn main() {println!(&amp;#34;Hello, world!&amp;#34;);} 编译和运行 &amp;gt;$ rustc main.rs&amp;gt;.\main.exe Rust程序剖析 第一行声明一个名为的函数main，该函数不带参数且不返回任何内容。如果有参数，它们将放在括号内()。该main功能很特殊：它始终是每个可执行Rust程序中运行的第一个代码。 函数主体用大括号括起来{}。 println!调用Rust宏。如果改为调用函数，则将其输入为println（不带!）。 我们用分号（;）结束该行，这表明该表达式已结束，下一个表达式可以开始了。Rust代码的大多数行以分号结尾。 Rust风格是缩进四个空格，而不是制表符。
1.3。Hello, Cargo! 您好，货运！ Cargo是Rust的构建系统和包管理器。大多数Rustacean使用此工具来管理他们的Rust项目，因为Cargo会为您处理很多任务，例如:
构建代码， 下载代码所依赖的库以及构建这些库。（我们称库为您的代码需要依赖项。） 请在终端中输入以下内容，检查是否已安装Cargo：
$ cargo --version 用 Cargo 创建项目 $ cargo new hello_cargo$ cd hello_cargo 第一个命令创建一个名为hello_cargo的新目录。我们已将项目命名为hello_cargo，并且Cargo在同名目录中创建其文件。
进入hello_cargo目录并列出文件。您会看到Cargo为我们生成了两个文件和一个目录：一个Cargo.toml文件和一个其中带有main.rs文件的 src目录。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-20%E7%AB%A0-%E6%9C%80%E7%BB%88%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-20%E7%AB%A0-%E6%9C%80%E7%BB%88%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8BWeb%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description> 第 20章 最终项目：构建多线程Web服务器 20.1。构建单线程Web服务器 20.2。将我们的单线程服务器转变为多线程服务器 20.3。正常关机和清理 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-21%E7%AB%A0-%E9%99%84%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-21%E7%AB%A0-%E9%99%84%E5%BD%95/</guid>
      <description> 第 21章 附录 21.1。A-关键字 21.2。B-运算符和符号 21.3。C-可衍生特征 21.4。D-有用的开发工具 21.5。电子版 21.6。F-这本书的翻译 21.7。G-如何制造锈蚀和“夜锈” </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-2%E7%AB%A0-%E7%BC%96%E5%86%99%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-2%E7%AB%A0-%E7%BC%96%E5%86%99%E7%8C%9C%E8%B0%9C%E6%B8%B8%E6%88%8F/</guid>
      <description>第 2章 编写猜谜游戏 use std::io;fn main() {println!(&amp;#34;Guess the number!&amp;#34;);println!(&amp;#34;Please input your guess.&amp;#34;);let mut guess = String::new();io::stdin().read_line(&amp;amp;mut guess).expect(&amp;#34;Failed to read line&amp;#34;);println!(&amp;#34;You guessed: {}&amp;#34;, guess);} 让我们逐行进行介绍。为了获得用户输入，然后将结果打印为输出，我们需要将 io(input/output)库纳入范围。该io库来自标准库（称为std）：
use std::io; Rust 的标准库，有一个 prelude 子模块，这里面包含了默认导入（std 库是默认导入的，然后 std 库中的 prelude 下面的东西也是默认导入的）的所有符号。
use 关键字 use 关键字能够将模块标识符引入当前作用域,这样就解决了局部模块路径过长的问题。 所有的系统库模块都是被默认导入的，所以在使用的时候只需要使用 use 关键字简化路径就可以方便的使用了。 当然，有些情况下存在两个相同的名称，且同样需要导入，我们可以使用 as 关键字为标识符添加别名</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-3%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-3%E7%AB%A0-%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</guid>
      <description> 第 3章 通用编程概念 3.1。变量和可变性 3.2。资料类型 3.3。功能 3.4。注释 3.5。控制流 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-4%E7%AB%A0-%E4%BA%86%E8%A7%A3%E6%89%80%E6%9C%89%E6%9D%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-4%E7%AB%A0-%E4%BA%86%E8%A7%A3%E6%89%80%E6%9C%89%E6%9D%83/</guid>
      <description> 第 4章 了解所有权 4.1。什么是所有权？ 4.2。参考和借阅 4.3。切片类型 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-5%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E6%9E%84%E9%80%A0%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-5%E7%AB%A0-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E6%9D%A5%E6%9E%84%E9%80%A0%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/</guid>
      <description> 第 5章 使用结构来构造相关数据 5.1。定义和实例化结构 5.2。使用结构的示例程序 5.3。方法语法 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-6%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-6%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</guid>
      <description> 第 6章 枚举和模式匹配 6.1。定义枚举 6.2。匹配控制流运算符 6.3。如果让简洁控制流 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-7%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%9D%BF%E6%9D%A1%E7%AE%B1%E5%92%8C%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%B8%8D%E6%96%AD%E5%A2%9E%E9%95%BF%E7%9A%84%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-7%E7%AB%A0-%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%9D%BF%E6%9D%A1%E7%AE%B1%E5%92%8C%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E4%B8%8D%E6%96%AD%E5%A2%9E%E9%95%BF%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid>
      <description>第 7 章 使用软件包，板条箱和模块管理不断增长的项目 Rust 中有三和重要的组织概念：包、箱、模块。
Packages: A Cargo feature that lets you build, test, and share crates 包装：货运功能，可让您构建，测试和共享包装箱 Crates: A tree of modules that produces a library or executable 板条箱：产生库或可执行文件的模块树 Modules and use: Let you control the organization, scope, and privacy of paths 模块和用途：让您控制路径的组织，范围和隐私 Paths: A way of naming an item, such as a struct, function, or module 路径：一种命名项目的方法，例如结构，函数或模块 7.1。Packages and Crates 包装和板条箱 Cargo 是 Rust 的构建系统和包管理器。它可以帮助开发人员下载和管理依赖项，并帮助创建 Rust 包。在 Rust 社区中，Rust 中的“包”通常被称为“crate”（板条箱），因此在安装 Rust 时会得到 Cargo。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-8%E7%AB%A0-%E5%B8%B8%E7%94%A8%E6%94%B6%E8%97%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-8%E7%AB%A0-%E5%B8%B8%E7%94%A8%E6%94%B6%E8%97%8F/</guid>
      <description>第 8章 Common Collections 常用集合 Rust’s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-9%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/The-Rust-Programming-Language-%E7%AC%AC-9%E7%AB%A0-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description> 第 9章 错误处理 9.1。不可挽回的错误与恐慌！ 9.2。结果可恢复错误 9.3。恐慌！还是不要慌！ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/%E6%A0%87%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/The-Rust-Programming-Language/%E6%A0%87%E9%A2%98/</guid>
      <description> Rust编程语言 标签：Rust、基础、 时间：2020年8月6日6:25:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 介绍 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC10%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC10%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F/</guid>
      <description>第10章 Java IO系统 由于存在大量不同的设计方案，所以该任务的困难性是很容易证明的。其中最大的挑战似乎是如何覆盖所有可能的因素。不仅有三种不同的种类的IO需要考虑（文件、控制台、网络连接），而且需要通过大量不同的方式与它们通信（顺序、随机访问、二进制、字符、按行、按字等等）。
Java库的设计者通过创建大量类来攻克这个难题。事实上，Java的IO系统采用了如此多的类，以致刚开始会产生不知从何处入手的感觉（具有讽刺意味的是，Java的IO设计初衷实际要求避免过多的类）。从Java 1.0升级到Java 1.1后，IO库的设计也发生了显著的变化。此时并非简单地用新库替换旧库，Sun的设计人员对原来的库进行了大手笔的扩展，添加了大量新的内容。因此，我们有时不得不混合使用新库与旧库，产生令人无奈的复杂代码。
10.1 输入和输出 装饰者模式，处理不同来源的输入和输出。 直接总结：
1、能读取文件、写入文件、复制文件、利用缓冲区就行。
2、知道完成这些操作有那些步骤就行。
可将Java库的IO类分割为输入与输出两个部分，这一点在用Web浏览器阅读联机Java类文档时便可知道。通过继承，从InputStream（输入流）衍生的所有类都拥有名为read()的基本方法，用于读取单个字节或者字节数组。类似地，从OutputStream衍生的所有类都拥有基本方法write()，用于写入单个字节或者字节数组。然而，我们通常不会用到这些方法；它们之所以存在，是因为更复杂的类可以利用它们，以便提供一个更有用的接口。因此，我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供自己期望的功能。我们之所以感到Java的流库（Stream Library）异常复杂，正是由于为了创建单独一个结果流，却需要创建多个对象的缘故。
很有必要按照功能对类进行分类。库的设计者首先决定与输入有关的所有类都从InputStream继承，而与输出有关的所有类都从OutputStream继承。
10.1.1 InputStream的类型 InputStream的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream子类）：
(1) 字节数组 (2) String对象 (3) 文件 (4) “管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。 (5) 一系列其他流，以便我们将其统一收集到单独一个流内。 (6) 其他起源地，如Internet连接等（将在本书后面的部分讲述）。 除此以外，FilterInputStream也属于InputStream的一种类型，用它可为“破坏器”类提供一个基础类，以便将属性或者有用的接口同输入流连接到一起。 具体哪种类型有何特性，自己查找API吧。
10.1.2 OutputStream的类型 具体哪种类型有何特性，自己查找API吧。
10.2 增添属性和有用的接口 利用层次化对象动态和透明地添加单个对象的能力的做法叫作“装饰器”（Decorator）方案——“方案”属于本书第16章的主题（注释①）。装饰器方案规定封装于初始化对象中的所有对象都拥有相同的接口，以便利用装饰器的“透明”性质——我们将相同的消息发给一个对象，无论它是否已被“装饰”。这正是在Java IO库里存在“过滤器”（Filter）类的原因：抽象的“过滤器”类是所有装饰器的基础类（装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中）。
子类处理要求大量子类对每种可能的组合提供支持时，便经常会用到装饰器——由于组合形式太多，造成子类处理变得不切实际。Java IO库要求许多不同的特性组合方案，这正是装饰器方案显得特别有用的原因。但是，装饰器方案也有自己的一个缺点。在我们写一个程序的时候，装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于Java IO库操作不便，我们必须创建许多类——“核心”IO类型加上所有装饰器——才能得到自己希望的单个IO对象。
FilterInputStream和FilteOutputStream分别是过滤输入流和过滤输出流,他们的作用是为基础流提供一些额外的功能
FilterInputStream和FilterOutputStream（这两个名字不十分直观）提供了相应的装饰器接口，用于控制一个特定的输入流（InputStream）或者输出流（OutputStream）。它们分别是从InputStream和OutputStream衍生出来的。此外，它们都属于抽象类，在理论上为我们与一个流的不同通信手段都提供了一个通用的接口。事实上，FilterInputStream和FilterOutputStream只是简单地模仿了自己的基础类，它们是一个装饰器的基本要求。
10.2.1 通过FilterInputStream从InputStream里读入数据 FilterInputStream类要完成两件全然不同的事情。其中，DataInputStream允许我们读取不同的基本类型数据以及String对象（所有方法都以“read”开头，比如readByte()，readFloat()等等）。伴随对应的DataOutputStream，我们可通过数据“流”将基本类型的数据从一个地方搬到另一个地方。这些“地方”是由表10.1总结的那些类决定的。若读取块内的数据，并自己进行解析，就不需要用到DataInputStream。但在其他许多情况下，我们一般都想用它对自己读入的数据进行自动格式化。 剩下的类用于修改InputStream的内部行为方式：是否进行缓冲，是否跟踪自己读入的数据行，以及是否能够推回一个字符等等。后两种类看起来特别象提供对构建一个编译器的支持（换言之，添加它们为了支持Java编译器的构建），所以在常规编程中一般都用不着它们。
也许几乎每次都要缓冲自己的输入，无论连接的是哪个IO设备。所以IO库最明智的做法就是将未缓冲输入作为一种特殊情况处理，同时将缓冲输入接纳为标准做法。
10.2.2 通过FilterOutputStream向OutputStream里写入数据 与DataInputStream对应的是DataOutputStream，后者对各个基本数据类型以及String对象进行格式化，并将其置入一个数据“流”中，以便任何机器上的DataInputStream都能正常地读取它们。所有方法都以“wirte”开头，例如writeByte()，writeFloat()等等。
若想进行一些真正的格式化输出，比如输出到控制台，请使用PrintStream。利用它可以打印出所有基本数据类型以及String对象，并可采用一种易于查看的格式。这与DataOutputStream正好相反，后者的目标是将那些数据置入一个数据流中，以便DataInputStream能够方便地重新构造它们。System.out静态对象是一个PrintStream。
PrintStream内两个重要的方法是print()和println()。它们已进行了覆盖处理，可打印出所有数据类型。print()和println()之间的差异是后者在操作完毕后会自动添加一个新行。
BufferedOutputStream属于一种“修改器”，用于指示数据流使用缓冲技术，使自己不必每次都向流内物理性地写入数据。通常都应将它应用于文件处理和控制器IO。 表10.4 FilterOutputStream的类型
10.3 本身的缺陷：RandomAccessFile RandomAccessFile用于包含了已知长度记录的文件，以便我们能用seek()从一条记录移至另一条；然后读取或修改那些记录。各记录的长度并不一定相同；只要知道它们有多大以及置于文件何处即可。
首先，我们有点难以相信RandomAccessFile不属于InputStream或者OutputStream分层结构的一部分。除了恰巧实现了DataInput以及DataOutput（这两者亦由DataInputStream和DataOutputStream实现）接口之外，它们与那些分层结构并无什么关系。它甚至没有用到现有InputStream或OutputStream类的功能——采用的是一个完全不相干的类。该类属于全新的设计，含有自己的全部（大多数为固有）方法。之所以要这样做，是因为RandomAccessFile拥有与其他IO类型完全不同的行为，因为我们可在一个文件里向前或向后移动。不管在哪种情况下，它都是独立运作的，作为Object的一个“直接继承人”使用。
从根本上说，RandomAccessFile类似DataInputStream和DataOutputStream的联合使用。其中，getFilePointer()用于了解当前在文件的什么地方，seek()用于移至文件内的一个新地点，而length()用于判断文件的最大长度。此外，构建器要求使用另一个自变量（与C的fopen()完全一样），指出自己只是随机读（&amp;ldquo;r&amp;rdquo;），还是读写兼施（&amp;ldquo;rw&amp;rdquo;）。这里没有提供对“只写文件”的支持。也就是说，假如是从DataInputStream继承的，那么RandomAccessFile也有可能能很好地工作。
还有更难对付的。很容易想象我们有时要在其他类型的数据流中搜索，比如一个ByteArrayInputStream，但搜索方法只有RandomAccessFile才会提供。而后者只能针对文件才能操作，不能针对数据流操作。此时，BufferedInputStream确实允许我们标记一个位置（使用mark()，它的值容纳于单个内部变量中），并用reset()重设那个位置。但这些做法都存在限制，并不是特别有用。
10.4 File类 File类有一个欺骗性的名字——通常会认为它对付的是一个文件，但实情并非如此。它既代表一个特定文件的名字，也代表目录内一系列文件的名字。若代表一个文件集，便可用list()方法查询这个集，返回的是一个字串数组。之所以要返回一个数组，而非某个灵活的集合类，是因为元素的数量是固定的。而且若想得到一个不同的目录列表，只需创建一个不同的File对象即可。事实上，“FilePath”（文件路径）似乎是一个更好的名字。本节将向大家完整地例示如何使用这个类，其中包括相关的FilenameFilter（文件名过滤器）接口。
10.4.1 目录列表器 现在假设我们想观看一个目录列表。可用两种方式列出File对象。若在不含自变量（参数）的情况下调用list()，会获得File对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择File对象来完成显示。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC11%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC11%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A/</guid>
      <description>第11章 运行期类型鉴定 总结:
其实 thinking in java 虽然将 RTTI 和 反射分开讲解，其实本质上我们看Java语言提供的功能：
利用 instanceof 来在运行期检出 对象 的类型 利用 Class.forName() 方法去获得一个未 import 对象的 Class 类 利用 java.lang.reflect.* 来获得对象的 对象信息（接口、属性、方法、修饰符） 本质上是在说明一件事：Java 提供了在运行期 完整且成系统的 创建和利用类和对象。能了解这一点并能利用使程序在运行的过程中能正确的动态的构建对象创建对象就可以了。 另需要知道的一件事是：想在运行期搞这些事情，离不开 Class 对象。因为 Java 是用 Class 对象 表示 在运行期 的 类型信息 .class 文件 ==》 JVM Class 对象 ==》 JVM new()对象 运行期类型鉴定（RTTI）的概念初看非常简单——手上只有基础类型的一个句柄时，利用它判断一个对象的正确类型。 然而，对RTTI的需要暴露出了面向对象设计许多有趣（而且经常是令人困惑的）的问题，并把程序的构造问题正式摆上了桌面。 本章将讨论如何利用Java在运行期间查找对象和类信息。这主要采取两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可在运行期独立查找类信息。首先讨论“传统”的RTTI，再讨论反射问题。
11.1 对RTTI的需要 请考虑下面这个熟悉的类结构例子，它利用了多形性。常规类型是Shape类，而特别衍生出来的类型是Circle，Square和Triangle。
这是一个典型的类结构示意图，基础类位于顶部，衍生类向下延展。面向对象编程的基本目标是用大量代码控制基础类型（这里是Shape）的句柄，所以假如决定添加一个新类（比如Rhomboid，从Shape衍生），从而对程序进行扩展，那么不会影响到原来的代码。在这个例子中，Shape接口中的动态绑定方法是draw()，所以客户程序员要做的是通过一个普通Shape句柄调用draw()。draw()在所有衍生类里都会被覆盖。而且由于它是一个动态绑定方法，所以即使通过一个普通的Shape句柄调用它，也有表现出正确的行为。这正是多形性的作用。
所以，我们一般创建一个特定的对象（Circle，Square，或者Triangle），把它上溯造型到一个Shape（忽略对象的特殊类型），以后便在程序的剩余部分使用匿名Shape句柄。
作为对多形性和上溯造型的一个简要回顾，可以象下面这样为上述例子编码（若执行这个程序时出现困难，请参考第3章3.1.2小节“赋值”）：
//: Shapes.java package c11; import java.util.*; interface Shape { void draw(); } class Circle implements Shape { public void draw() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC12%E7%AB%A0-%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC12%E7%AB%A0-%E4%BC%A0%E9%80%92%E5%92%8C%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</guid>
      <description>第12章 传递和返回对象 到目前为止，读者应对对象的“传递”有了一个较为深刻的认识，记住实际传递的只是一个句柄。
在许多程序设计语言中，我们可用语言的“普通”方式到处传递对象，而且大多数时候都不会遇到问题。但有些时候却不得不采取一些非常做法，使得情况突然变得稍微复杂起来（在C++中则是变得非常复杂）。Java亦不例外，我们十分有必要准确认识在对象传递和赋值时所发生的一切。这正是本章的宗旨。
若读者是从某些特殊的程序设计环境中转移过来的，那么一般都会问到：“Java有指针吗？”有些人认为指针的操作很困难，而且十分危险，所以一厢情愿地认为它没有好处。同时由于Java有如此好的口碑，所以应该很轻易地免除自己以前编程中的麻烦，其中不可能夹带有指针这样的“危险品”。然而准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有“戒心”，运行期系统也不例外。或者换从另一个角度说，Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做“句柄”，但你可以把它想像成“安全指针”。和预备学校为学生提供的安全剪刀类似——除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。
12.1 传递句柄 将句柄传递进入一个方法时，指向的仍然是相同的对象。
可以在调用方法前和在方法中打印对象，可以看出是一个对象。
12.1.1 别名问题 “别名”意味着多个句柄都试图指向同一个对象，就象前面的例子展示的那样。若有人向那个对象里写入一点什么东西，就会产生别名问题。若其他句柄的所有者不希望那个对象改变，恐怕就要失望了。
此时最直接的一个解决办法就是干脆不这样做：不要有意将多个句柄指向同一个作用域内的同一个对象。这样做可使代码更易理解和调试。然而，一旦准备将句柄作为一个自变量或参数传递——这是Java设想的正常方法——别名问题就会自动出现，因为创建的本地句柄可能修改“外部对象”（在方法作用域之外创建的对象）。
方法改变了自己的参数——外部对象。一旦遇到这种情况，必须判断它是否合理，用户是否愿意这样，以及是不是会造成问题。 通常，我们调用一个方法是为了产生返回值，或者用它改变为其调用方法的那个对象的状态（方法其实就是我们向那个对象“发一条消息”的方式）。很少需要调用一个方法来处理它的参数；这叫作利用方法的“副作用”（Side Effect）。所以倘若创建一个会修改自己参数的方法，必须向用户明确地指出这一情况，并警告使用那个方法可能会有的后果以及它的潜在威胁。由于存在这些混淆和缺陷，所以应该尽量避免改变参数。 若需在一个方法调用期间修改一个参数，且不打算修改外部参数，就应在自己的方法内部制作一个副本，从而保护那个参数。本章的大多数内容都是围绕这个问题展开的。
12.2 制作本地副本 Java中的所有自变量或参数传递都是通过传递句柄进行的。也就是说，当我们传递“一个对象”时，实际传递的只是指向位于方法外部的那个对象的“一个句柄”。所以一旦要对那个句柄进行任何修改，便相当于修改外部对象。此外：
■参数传递过程中会自动产生别名问题 ■不存在本地对象，只有本地句柄 ■句柄有自己的作用域，而对象没有 ■对象的“存在时间”在Java里不是个问题 ■没有语言上的支持（如常量）可防止对象被修改（以避免别名的副作用） 若只是从对象中读取信息，而不修改它，传递句柄便是自变量传递中最有效的一种形式。 这种做非常恰当；默认的方法一般也是最有效的方法。然而，有时仍需将对象当作“本地的”对待，使我们作出的改变只影响一个本地副本，不会对外面的对象造成影响。许多程序设计语言都支持在方法内自动生成外部对象的一个本地副本（注释①）。尽管Java不具备这种能力，但允许我们达到同样的效果。
①：在C语言中，通常控制的是少量数据位，默认操作是按值传递。C++也必须遵照这一形式，但按值传递对象并非肯定是一种有效的方式。此外，在C++中用于支持按值传递的代码也较难编写，是件让人头痛的事情。
12.2.1 按值传递 首先要解决术语的问题，最适合“按值传递”的看起来是自变量。“按值传递”以及它的含义取决于如何理解程序的运行方式。最常见的意思是获得要传递的任何东西的一个本地副本，但这里真正的问题是如何看待自己准备传递的东西。对于“按值传递”的含义，目前存在两种存在明显区别的见解：
(1) Java按值传递任何东西。若将基本数据类型传递进入一个方法，会明确得到基本数据类型的一个副本。但若将一个句柄传递进入方法，得到的是句柄的副本。所以人们认为“一切”都按值传递。当然，这种说法也有一个前提：句柄肯定也会被传递。但Java的设计方案似乎有些超前，允许我们忽略（大多数时候）自己处理的是一个句柄。也就是说，它允许我们将句柄假想成“对象”，因为在发出方法调用时，系统会自动照管两者间的差异。 (2) Java主要按值传递（无自变量），但对象却是按引用传递的。得到这个结论的前提是句柄只是对象的一个“别名”，所以不考虑传递句柄的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它“保留但未实现”的关键字之一便是byvalue（按值）。但没人知道那个关键字什么时候可以发挥作用。 尽管存在两种不同的见解，但其间的分歧归根到底是由于对“句柄”的不同解释造成的。我打算在本书剩下的部分里回避这个问题。大家不久就会知道，这个问题争论下去其实是没有意义的——最重要的是理解一个句柄的传递会使调用者的对象发生意外的改变。 12.2.2 克隆对象 若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用clone()方法即可。Clone是“克隆”的意思，即制作完全一模一样的副本。这个方法在基础类Object中定义成“protected”（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为“public”模式。例如，标准库类Vector覆盖了clone()，所以能为Vector调用clone()，
clone()方法产生了一个Object，后者必须立即重新造型为正确类型。这个例子指出Vector的clone()方法不能自动尝试克隆Vector内包含的每个对象——由于别名问题，老的Vector和克隆的Vector都包含了相同的对象。我们通常把这种情况叫作“简单复制”或者“浅层复制”，因为它只复制了一个对象的“表面”部分。实际对象除包含这个“表面”以外，还包括句柄指向的所有对象，以及那些对象又指向的其他所有对象，由此类推。这便是“对象网”或“对象关系网”的由来。若能复制下所有这张网，便叫作“全面复制”或者“深层复制”。
一般来说，由于不敢保证Vector里包含的对象是“可以克隆”（注释②）的，所以最好不要试图克隆那些对象。
②：“可以克隆”用英语讲是cloneable，请留意Java库中专门保留了这样的一个关键字。
12.2.3 使类具有克隆能力 尽管克隆方法是在所有类最基本的Object中定义的，但克隆仍然不会在每个类里自动进行。这似乎有些不可思议，因为基础类方法在衍生类里是肯定能用的。但Java确实有点儿反其道而行之；如果想在一个类里使用克隆方法，唯一的办法就是专门添加一些代码，以便保证克隆的正常进行。
使用protected时的技巧 为避免我们创建的每个类都默认具有克隆能力，clone()方法在基础类Object里得到了“保留”（设为protected）。这样造成的后果就是：对那些简单地使用一下这个类的客户程序员来说，他们不会默认地拥有这个方法；其次，我们不能利用指向基础类的一个句柄来调用clone()（尽管那样做在某些情况下特别有用，比如用多形性的方式克隆一系列对象）。在编译期的时候，这实际是通知我们对象不可克隆的一种方式——而且最奇怪的是，Java库中的大多数类都不能克隆。因此，假如我们执行下述代码： Integer x = new Integer(l); x = x.clone(); 那么在编译期，就有一条讨厌的错误消息弹出，告诉我们不可访问clone()——因为Integer并没有覆盖它，而且它对protected版本来说是默认的）。 但是，假若我们是在一个从Object衍生出来的类中（所有类都是从Object衍生的），就有权调用Object.clone()，因为它是“protected”，而且我们在一个继承器中。基础类clone()提供了一个有用的功能——它进行的是对衍生类对象的真正“按位”复制，所以相当于标准的克隆行动。然而，我们随后需要将自己的克隆操作设为public，否则无法访问。总之，克隆时要注意的两个关键问题是：几乎肯定要调用super.clone()，以及注意将克隆设为public。 有时还想在更深层的衍生类中覆盖clone()，否则就直接使用我们的clone()（现在已成为public），而那并不一定是我们所希望的（然而，由于Object.clone()已制作了实际对象的一个副本，所以也有可能允许这种情况）。protected的技巧在这里只能用一次：首次从一个不具备克隆能力的类继承，而且想使一个类变成“能够克隆”。而在从我们的类继承的任何场合，clone()方法都是可以使用的，因为Java不可能在衍生之后反而缩小方法的访问范围。换言之，一旦对象变得可以克隆，从它衍生的任何东西都是能够克隆的，除非使用特殊的机制（后面讨论）令其“关闭”克隆能力。
实现Cloneable接口 为使一个对象的克隆能力功成圆满，还需要做另一件事情：实现Cloneable接口。这个接口使人稍觉奇怪，因为它是空的！ interface Cloneable {} 之所以要实现这个空接口，显然不是因为我们准备上溯造型成一个Cloneable，以及调用它的某个方法。有些人认为在这里使用接口属于一种“欺骗”行为，因为它使用的特性打的是别的主意，而非原来的意思。Cloneable interface的实现扮演了一个标记的角色，封装到类的类型中。 两方面的原因促成了Cloneable interface的存在。首先，可能有一个上溯造型句柄指向一个基础类型，而且不知道它是否真的能克隆那个对象。在这种情况下，可用instanceof关键字（第11章有介绍）调查句柄是否确实同一个能克隆的对象连接： if(myHandle instanceof Cloneable) // &amp;hellip; 第二个原因是考虑到我们可能不愿所有对象类型都能克隆。所以Object.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC13%E7%AB%A0-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC13%E7%AB%A0-%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%89%87/</guid>
      <description> 第13章 创建窗口和程序片 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>第14章 多线程 利用对象，可将一个程序分割成相互独立的区域。我们通常也需要将一个程序转换成多个独立运行的子任务。
象这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。
这时理解一些定义对以后的学习狠有帮助。“进程”是指一种“自包容”的运行程序，有自己的地址空间。“多任务”操作系统能同时运行多个进程（程序）——但实际是由于CPU分时机制的作用，使每个进程都能循环获得自己的CPU时间片。但由于轮换速度非常快，使得所有程序好象是在“同时”运行一样。“线程”是进程内部单一的一个顺序控制流。因此，一个进程可能容纳了多个同时执行的线程。
多线程的应用范围很广。但在一般情况下，程序的一些部分同特定的事件或资源联系在一起，同时又不想为它而暂停程序其他部分的执行。这样一来，就可考虑创建一个线程，令其与那个事件或资源关联到一起，并让它独立于主程序运行。一个很好的例子便是“Quit”或“退出”按钮——我们并不希望在程序的每一部分代码中都轮询这个按钮，同时又希望该按钮能及时地作出响应（使程序看起来似乎经常都在轮询它）。事实上，多线程最主要的一个用途就是构建一个“反应灵敏”的用户界面。
14.1 反应灵敏的用户界面 作为我们的起点，请思考一个需要执行某些CPU密集型计算的程序。由于CPU“全心全意”为那些计算服务，所以对用户的输入十分迟钝，几乎没有什么反应。在这里，我们用一个合成的applet/application（程序片／应用程序）来简单显示出一个计数器的结果：
//: Counter1.java // A non-responsive user interface package c14; import java.awt.*; import java.awt.event.*; import java.applet.*; public class Counter1 extends Applet { private int count = 0; private Button onOff = new Button(&amp;#34;Toggle&amp;#34;), start = new Button(&amp;#34;Start&amp;#34;); private TextField t = new TextField(10); private boolean runFlag = true; public void init() { add(t); start.addActionListener(new StartL()); add(start); onOff.addActionListener(new OnOffL()); add(onOff); } public void go() { while (true) { try { Thread.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>第15章 网络编程 历史上的网络编程都倾向于困难、复杂，而且极易出错。
程序员必须掌握与网络有关的大量细节，有时甚至要对硬件有深刻的认识。一般地，我们需要理解连网协议中不同的“层”（Layer）。而且对于每个连网库，一般都包含了数量众多的函数，分别涉及信息块的连接、打包和拆包；这些块的来回运输；以及握手等等。这是一项令人痛苦的工作。
但是，连网本身的概念并不是很难。我们想获得位于其他地方某台机器上的信息，并把它们移到这儿；或者相反。这与读写文件非常相似，只是文件存在于远程机器上，而且远程机器有权决定如何处理我们请求或者发送的数据。
Java最出色的一个地方就是它的“无痛苦连网”概念。有关连网的基层细节已被尽可能地提取出去，并隐藏在JVM以及Java的本机安装系统里进行控制。我们使用的编程模型是一个文件的模型；事实上，网络连接（一个“套接字”）已被封装到系统对象里，所以可象对其他数据流那样采用同样的方法调用。除此以外，在我们处理另一个连网问题——同时控制多个网络连接——的时候，Java内建的多线程机制也是十分方便的。
本章将用一系列易懂的例子解释Java的连网支持。
15.1 机器的标识 当然，为了分辨来自别处的一台机器，以及为了保证自己连接的是希望的那台机器，必须有一种机制能独一无二地标识出网络内的每台机器。早期网络只解决了如何在本地网络环境中为机器提供唯一的名字。但Java面向的是整个因特网，这要求用一种机制对来自世界各地的机器进行标识。为达到这个目的，我们采用了IP（互联网地址）的概念。IP以两种形式存在着：
(1) 大家最熟悉的DNS（域名服务）形式。我自己的域名是bruceeckel.com。所以假定我在自己的域内有一台名为Opus的计算机，它的域名就可以是Opus.bruceeckel.com。这正是大家向其他人发送电子函件时采用的名字，而且通常集成到一个万维网（WWW）地址里。
(2) 此外，亦可采用“四点”格式，亦即由点号（.）分隔的四组数字，比如202.98.32.111。 不管哪种情况，IP地址在内部都表达成一个由32个二进制位（bit）构成的数字（注释①），所以IP地址的每一组数字都不能超过255。利用由java.net提供的static InetAddress.getByName()，我们可以让一个特定的Java对象表达上述任何一种形式的数字。结果是类型为InetAddress的一个对象，可用它构成一个“套接字”（Socket），大家在后面会见到这一点。
①：这意味着最多只能得到40亿左右的数字组合，全世界的人很快就会把它用光。但根据目前正在研究的新IP编址方案，它将采用128 bit的数字，这样得到的唯一性IP地址也许在几百年的时间里都不会用完。
作为运用InetAddress.getByName()一个简单的例子，请考虑假设自己有一家拨号连接因特网服务提供者（ISP），那么会发生什么情况。每次拨号连接的时候，都会分配得到一个临时IP地址。但在连接期间，那个IP地址拥有与因特网上其他IP地址一样的有效性。如果有人按照你的IP地址连接你的机器，他们就有可能使用在你机器上运行的Web或者FTP服务器程序。当然这有个前提，对方必须准确地知道你目前分配到的IP。由于每次拨号连接获得的IP都是随机的，怎样才能准确地掌握你的IP呢？ 下面这个程序利用InetAddress.getByName()来产生你的IP地址。为了让它运行起来，事先必须知道计算机的名字。该程序只在Windows 95中进行了测试，但大家可以依次进入自己的“开始”、“设置”、“控制面板”、“网络”，然后进入“标识”卡片。其中，“计算机名称”就是应在命令行输入的内容。
//: WhoAmI.java // Finds out your network address when you&amp;#39;re // connected to the Internet. package c15; import java.net.*; public class WhoAmI { public static void main(String[] args) throws Exception { if(args.length != 1) { System.err.println( &amp;#34;Usage: WhoAmI MachineName&amp;#34;); System.exit(1); } InetAddress a = InetAddress.getByName(args[0]); System.out.println(a); } } ///:~ 就我自己的情况来说，机器的名字叫作“Colossus”（来自同名电影，“巨人”的意思。我在这台机器上有一个很大的硬盘）。所以一旦连通我的ISP，就象下面这样执行程序：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC16%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC16%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/</guid>
      <description>第16章 设计范式 16.1 范式的概念 将保持不变的东西身上发生的变化孤立出来
设计范式：可以说对问题不变的地方抽象总结
变化的影响隔离出来
在最开始，可将范式想象成一种特别聪明、能够自我适应的手法，它可以解决特定类型的问题。也就是说，它类似一些需要全面认识某个问题的人。在了解了问题的方方面面以后，最后提出一套最通用、最灵活的解决方案。具体问题或许是以前见到并解决过的。然而，从前的方案也许并不是最完善的，大家会看到它如何在一个范式里具体表达出来。
尽管我们称之为“设计范式”，但它们实际上并不局限于设计领域。思考“范式”时，应脱离传统意义上分析、设计以及实施的思考方式。相反，“范式”是在一个程序里具体表达一套完整的思想，所以它有时可能出现在分析阶段或者高级设计阶段。这一点是非常有趣的，因为范式具有以代码形式直接实现的形式，所以可能不希望它在低级设计或者具体实施以前显露出来（而且事实上，除非真正进入那些阶段，否则一般意识不到自己需要一个范式来解决问题）。
范式的基本概念亦可看成是程序设计的基本概念：添加一层新的抽象！只要我们抽象了某些东西，就相当于隔离了特定的细节。而且这后面最引人注目的动机就是“将保持不变的东西身上发生的变化孤立出来”。这样做的另一个原因是一旦发现程序的某部分由于这样或那样的原因可能发生变化，我们一般都想防止那些改变在代码内部繁衍出其他变化。这样做不仅可以降低代码的维护代价，也更便于我们理解（结果同样是降低开销）。
为设计出功能强大且易于维护的应用项目，通常最困难的部分就是找出我称之为“领头变化”的东西。这意味着需要找出造成系统改变的最重要的东西，或者换一个角度，找出付出代价最高、开销最大的那一部分。一旦发现了“领头变化”，就可以为自己定下一个焦点，围绕它展开自己的设计。
所以设计范式的最终目标就是将代码中变化的内容隔离开。如果从这个角度观察，就会发现本书实际已采用了一些设计范式。举个例子来说，继承可以想象成一种设计范式（类似一个由编译器实现的）。在都拥有同样接口（即保持不变的东西）的对象内部，它允许我们表达行为上的差异（即发生变化的东西）。合成亦可想象成一种范式，因为它允许我们修改——动态或静态——用于实现类的对象，所以也能修改类的运作方式。
在《Design Patterns》一书中，大家还能看到另一种范式：“继承器”（即Iterator，Java 1.0和1.1不负责任地把它叫作Enumeration，即“枚举”；Java1.2的集合则改回了“继承器”的称呼）。当我们在集合里遍历，逐个选择不同的元素时，继承器可将集合的实施细节有效地隐藏起来。利用继承器，可以编写出通用的代码，以便对一个序列里的所有元素采取某种操作，同时不必关心这个序列是如何构建的。这样一来，我们的通用代码即可伴随任何能产生继承器的集合使用。
16.1.1 单子 单例模式 枚举 是实现单例模式的最佳方法。它不仅能避免多线程同步问题，它更简洁，自动支持序列化机制，绝对防止多次实例化。
或许最简单的设计范式就是“单子”（Singleton），它能提供对象的一个（而且只有一个）实例。单子在Java库中得到了应用，但下面这个例子显得更直接一些：
//: SingletonPattern.java // The Singleton design pattern: you can // never instantiate more than one. package c16; // Since this isn&amp;#39;t inherited from a Cloneable // base class and cloneability isn&amp;#39;t added, // making it final prevents cloneability from // being added in any derived classes: final class Singleton { private static Singleton s = new Singleton(47); private int i; private Singleton(int x) { i = x; } public static Singleton getHandle() { return s; } public int getValue() { return i; } public void setValue(int x) { i = x; } } public class SingletonPattern { public static void main(String[] args) { Singleton s = Singleton.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC17%E7%AB%A0-%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC17%E7%AB%A0-%E9%A1%B9%E7%9B%AE/</guid>
      <description>第17章 项目 17.1 文字处理 17.2 方法查找工具 17.3 复杂性理论 17.4 总结 17.5 练习 附录A 使用非JAVA代码 附录B 对比C++和Java 附录C Java编程规则 附录D 性能 附录E 关于垃圾收集的一些话 附录F 推荐读物 (9) 第9章：违例差错控制 (10) 第10章：Java IO系统 (11) 第11章：运行期类型鉴定 (12) 第12章：传递和返回对象 (13) 第13章：创建窗口和程序片 (14) 第14章：多线程 (15) 第15章 网络编程 (16) 第16章 设计范式 (17) 第17章 项目 (18) 附录A：使用非Java代码 (19) 附录B：对比C++和Java (20) 附录C：Java编程规则 (21) 附录D：性能 (22) 附录E：关于垃圾收集的一些话 (23) 附录F：推荐读物</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC1%E7%AB%A0%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8/</guid>
      <description>第 1 章：对象入门 面向对象编程（OOP）
1.1 抽象的进步 所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。
1.2 对象的接口 我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做哪些事情。
1.3 实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员。
1.4 方案的重复使用 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。
新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。
轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。
1.5 继承：重新使用接口 在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。
1.5.1 改善基础类 改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。
继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；
1.6 多形对象的互换使用 通常，继承最终会以创建一系列类收场，所有类都建立在统一的基础接口上。
对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。
把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。
1.6.1 动态绑定 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）（多态性）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。
1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。
亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。
interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。
备注：这是一段个人的总结：interface（接口）更倾向于表明这个类是能干什么事，也就是说这类的类实现了哪些方法及继承与此接口的类必需要实现哪些方法；接口更像一个规范文件(协议)。abstract（抽象）更倾向于表明一类类的共有特性，由基础类或一个接口衍生的一系列类的共有特性，所以不仅仅表明这个类能干哪些事。也就是说 interface（接口）的方法都可以在接口中无实现，只规定了子类必须需要实现哪些方法，而 abstract（抽象）可以把子类相同实现的方法在抽象类里实现，子类各自特别且必须的方法用抽象方法规定然后在子类里各自实现。abstract（抽象）可以看为一种跟 public、static 同级别的修饰符（修饰了类（class）和方法），而 interface（接口）可以看为一种跟 class 同级别的修饰符，标志着质的改变。interface（接口）可以说是对 abstract（抽象）的抽象。interface（接口）帮助了对象的分层，各组件之间的松耦合。interface 语法要求：1、接口可以包含：静态常量、方法（抽象）、内部类（接口、枚举）、默认方法（类方法）2、接口只可以继承多个父接口（之间用英文逗号“,”隔开），不能继承类。3、接口修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有相同包结构下才可以访问该接口。4、接口内的所有成员都是 public 访问权限，可省略，如果指定则只可使用 public 访问修饰符。5、接口的成员变量均为静态常量，不管是否使用 public static final 修饰符都认为只可做如此修饰。6、接口的方法只能是抽象、类方法、默认方法，如果不是默认方法，系统将自动为普通方法增加 public abstract 修饰符，且不能有方法实现（方法体），类方法、默认方法必须有方法实现（方法体）。7、定义默认方法，需要用 default 修饰且默认添加 public 修饰 ，默认方法不能用 static 修饰，所以不能直接用接口来调用默认方法，由接口的实现类的实例来调用这些默认方法。8、类方法需用 static 修饰 ，可用接口直接调用。9、接口的内部类（接口、枚举）默认采用 public static 修饰符。10、接口可看做为特殊的类，受限于一个源文件只能有一个 public 修饰。11、接口不能创建实例，作为声明引用类型变量时此接口必须有其实现类。abstract 语法要求：1、有抽象方法的类只能是抽象类2、抽象类里可没有抽象方法有普通方法3、抽象类不能被实例化4、抽象类可以包含：成员变量、方法（普通、抽象）、构造器、初始化快、内部类（接口、枚举）、抽象类的构造器不能用于创造实列，主要用于被其子类调用5、抽象不能修饰变量（成员、局部），不能修饰构造器，抽象类里的构造器只能是普通的构造器。总结如下：1、抽象类与普通类相比“一得一失”：1、“得”可包含抽象方法。2、“失”无法被实列化。2、抽象类是用来被它的子类继承的，方法由子类实现。而 final 修饰的类不能被继承， final 修饰的方法不能被重写，所以 final 和 abstract 是互斥的。3、static 修饰方法是属于这个类本身的（类Class和实列Object的区别），如果该方法被定义成抽象方法，通过类调用的时候也会出错，因为调用了一个没有方法实体的方法，所以 static 和 abstract 是互斥的（非绝对，可以同时修饰内部类）。4、abstract 修饰的方法必须被之类重写才有意义，因此 abstract 方法不能是私有的，所以 private 和 abstract 是互斥的。 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC2%E7%AB%A0%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</guid>
      <description>第 2 章：一切都是对象 Java语言首先便假定了我们只希望进行面向对象的程序设计。
2.1 用句柄操纵对象 将一切都“看作”对象，操纵的 标识符 实际是指向一个对象的“句柄”（Handle）。
创建一个String句柄：String s;这里创建的只是句柄，并不是对象。s实际并未与任何东西连接（即“没有实体”）。一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：String s = &amp;#34;asdf&amp;#34;;总结：句柄指向对象，通过句柄操作对象，句柄是句柄，对象是对象。 2.2 所有对象都必须创建 创建句柄时，我们希望它同一个新对象连接。通常用 new 关键字达到这一目的。。new的意思是：“把我变成这些对象的一种新实体”。
2.2.1 保存到什么地方 程序运行时，我们最好对数据保存到什么地方做到心中有数。特别要注意的是内存的分配。有六个地方都可以保存数据：
在Java中是不可能得到真正的内存地址的，也不会提供直接操作“内存地址”的方式。
Java中堆是由JVM管理的不能直接操作。
(1) 寄存器： 位于处理器内部。这是最快的保存区域。 以寄存器是根据需要由编译器分配。 我们对此没有直接的控制权。 (2) 堆栈（stack）： 驻留于常规RAM（随机访问存储器）区域，这是一种特别快、特别有效的数据保存方式，仅次于寄存器。 创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性。 有些Java数据要保存在堆栈里——基本类型数据、对象句柄，但Java对象并不放到其中。 每个线程都有自己独立的栈。 (3) 堆（Heap）： 一种常规用途的内存池（也在RAM区域），在堆里分配存储空间时会花掉更长的时间！ 编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。 保存了Java对象。 堆在整个JVM中只有一个（所以堆中的数据可被多个线程共享），堆里面的内存空间由GC来负责回收。 (4) 静态存储 ： 这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。 程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。 Java对象本身永远都不会置入静态存储空间。 (5) 常数存储 ： 常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。 (6) 非RAM存储 ： 若数据完全独立于一个程序之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。 2.2.2 特殊情况：主要类型 有一系列类需特别对待；可将它们想象成“基本”、“主要”或者“主”（Primitive）类型，进行程序设计时要频繁用到它们。之所以要特别对待，是由于用new创建对象（特别是小的、简单的变量）并不是非常有效，因为new将对象置于“堆”里。对于这些类型，Java采纳了与C和C++相同的方法。也就是说，不是用new创建变量，而是创建一个并非句柄的“自动”变量。这个变量容纳了具体的值，并置于堆栈中，能够更高效地存取。
Java决定了每种主要类型的大小。(8bit=1byte)
主类型 大小 封装器类型 boolean 1-bit Boolean byte 8-bit Byte[11] char 16-bit Character short 16-bit Short int 32-bit Integer long 64-bit Long float 32-bit Float double 64-bit Double 注意：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC3%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC3%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/</guid>
      <description>第3章 控制程序流程 程序必须能操纵自己的世界，在执行过程中作出判断与选择。
3.1 使用Java运算符 几乎所有运算符都只能操作“主类型”（Primitives）（基本类型）。唯一的例外是“=”、“==”和“!=”，它们能操作所有对象（也是对象易令人混淆的一个地方）。除此以外，String类支持“+”和“+=”。
3.1.1 优先级 运算符的优先级决定了存在多个运算符时一个表达式各部分的计算顺序。
3.1.2 赋值 赋值是用等号运算符（=）进行的。它的意思是“取得右边的值，把它复制到左边”。
右边的值可以是任何常数、变量或者表达式，只要能产生一个值就行。但左边的值必须是一个明确的、已命名的变量。
对主数据类型的赋值是非常直接的。由于主类型容纳了实际的值，而且并非指向一个对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。
但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向最初只有D才指向的那个对象。
3.1.3 算术运算符 Java的基本算术运算符与其他大多数程序设计语言是相同的。其中包括加号（+）、减号（-）、除号（/）、乘号（*）以及模数（%，从整数除法中获得余数）。整数除法会直接砍掉小数，而不是进位。
一元加、减运算符 一元减号（-）和一元加号（+）与二元加号和减号都是相同的运算符。
例如： x = -a; 一元减号得到的运算对象的负值。一元加号的含义与一元减号相反，虽然它实际并不做任何事情。
3.1.4 自动递增和递减 两种很不错的快捷运算方式是递增和递减运算符（常称作“自动递增”和“自动递减”运算符）。其中，递减运算符是“&amp;ndash;”，意为“减少一个单位”；递增运算符是“++”，意为“增加一个单位”。举个例子来说，假设A是一个int（整数）值，则表达式++A就等价于（A = A + 1）。
对每种类型的运算符，都有两个版本可供选用；通常将其称为“前缀版”和“后缀版”。。对于前递增和前递减（如++A或&amp;ndash;A），会先执行运算，再生成值。而对于后递增和后递减（如A++或A&amp;ndash;），会先生成值，再执行运算。
3.1.5 关系运算符 关系运算符生成的是一个“布尔”（Boolean）结果。它们评价的是运算对象值之间的关系。若关系是真实的，关系表达式会生成 true（真）；若关系不真实，则生成 false（假）。关系运算符包括小于（&amp;lt;）、大于（&amp;gt;）、小于或等于（&amp;lt;=）、大于或等于（&amp;gt;=）、等于（==）以及不等于（!=）。等于和不等于适用于所有内建的数据类型，但其他比较不适用于 boolean 类型。
1、检查对象是否相等 关系运算符==和!=也适用于所有对象。 ==和!=比较的就是对象句柄。 若想对比两个对象的实际内容是否相同？此时，必须使用所有对象都适用的特殊方法equals()。 于 equals()的默认行为是比较句柄。 多数Java类库都实现了equals()，所以它实际比较的是对象的内容，而非它们的句柄。 3.1.6 逻辑运算符 逻辑运算符AND（&amp;amp;&amp;amp;）、OR（||）以及NOT（!）能生成一个布尔值（true或false）。
短路 操作逻辑运算符时，我们会遇到一种名为“短路”的情况。这意味着只有明确得出整个表达式真或假的结论，才会对表达式进行逻辑求值。因此，一个逻辑表达式的所有部分都有可能不进行求值。
短路就是说，当逻辑运算表达式的结果已经得出，剩余的逻辑表达式将不会得到执行。）
3.1.7 按位运算符 二进制下用 1 表示真，0 表示假
按位运算符允许我们操作一个整数主数据类型中的单个“比特”，即二进制位。按位运算符会对两个自变量中对应的位执行布尔代数，并最终生成一个结果。
若两个输入位都是1，则按位AND运算符（&amp;amp;）在输出位里生成一个1；否则生成0。
1 &amp;amp; 1 = 1 0 &amp;amp; 1 = 0 1 &amp;amp; 0 = 0 0 &amp;amp; 0 = 0 若两个输入位里至少有一个是1，则按位OR运算符（|）在输出位里生成一个1；只有在两个输入位都是0的情况下，它才会生成一个0。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC4%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC4%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E9%99%A4/</guid>
      <description>第4章 初始化和清除 “随着计算机的进步，‘不安全’的程序设计已成为造成编程代价高昂的罪魁祸首之一。”
“初始化”和“清除”是这些安全问题的其中两个。
C++为我们引入了“构建器”的概念。这是一种特殊的方法，在一个对象创建之后自动调用。Java也沿用了这个概念，但新增了自己的“垃圾收集器”，能在资源不再需要的时候自动释放它们。本章将讨论初始化和清除的问题，以及Java如何提供它们的支持。
4.1 用构建器自动初始化 对于方法的创建，可将其想象成为自己写的每个类都调用一次initialize()。这个名字提醒我们在使用对象之前，应首先进行这样的调用。但不幸的是，这也意味着用户必须记住调用方法。在Java中，由于提供了名为“构建器”的一种特殊方法，所以类的设计者可担保每个对象都会得到正确的初始化。若某个类有一个构建器，那么在创建对象时，Java会自动调用那个构建器——甚至在用户毫不知觉的情况下。所以说这是可以担保的！（也叫：构造器）
构建器的名字与类名相同。这样一来，可保证象这样的一个方法会在初始化期间自动调用。
一旦创建一个对象：
new Rock(); 就会分配相应的存储空间，并调用构建器。请注意所有方法首字母小写的编码规则并不适用于构建器。这是由于构建器的名字必须与类名完全相同！ 和其他任何方法一样，构建器也能使用自变量。
利用构建器的自变量，我们可为一个对象的初始化设定相应的参数。
构建器属于一种较特殊的方法类型，因为它没有返回值。这与 void 返回值存在着明显的区别。对于void返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。
4.2 方法过载（overload，也翻译成重载） 我们创建一个对象时，会分配一个名字代表这个类。我们用名字引用或描述所有对象与方法。
在日常生活中，我们用相同的词表达多种不同的含义——即词的“过载”。
大多数程序设计语言（特别是C）要求我们为每个函数都设定一个独一无二的标识符。在Java里，允许方法名出现过载情况。
4.2.1 区分过载方法 规则：每个过载的方法都必须采取独一无二的自变量类型列表。
4.2.2 主类型的过载 主（数据）类型能从一个“较小”的类型自动转变成一个“较大”的类型。涉及过载问题时，这会稍微造成一些混乱。
分两种情况： 1、若我们的数据类型“小于”方法中使用的自变量类型，就会对那种数据类型进行“转型”处理。 2、若我们的数据类型.“大于”过载方法期望的自变量类型，就必须用括号中的类型名将其“强转”处理。这是一种缩小转换”。也就是说，在造型或转型过程中可能丢失一些信息。 4.2.3 返回值过载 我们也可能调用一个方法，同时忽略返回值；
例如： f(); void f() {} int f() {} 所以不能根据返回值类型来区分过载的方法。
4.2.4 默认构建器 创建一个没有构建器的类，则编译程序会帮我们自动创建一个默认无参的构建器，如果已经定义了一个构建器（无论是否有自变量），编译程序都不会帮我们自动合成一个。
4.2.5 this关键字 假定我们在一个方法的内部，并希望获得当前对象的句柄。由于那个句柄是由编译器“秘密”传递的，所以没有标识符可用。然而，针对这一目的有个专用的关键字：this。this关键字（注意只能在方法内部使用）可为已调用了其方法的那个对象生成相应的句柄。
1、在构建器里调用构建器
若为一个类写了多个构建器，那么经常都需要在一个构建器里调用另一个构建器，以避免写重复的代码。可用this关键字做到这一点。
例如： public class Test { private int petalCount = 0; private String s = new String(&amp;#34;null&amp;#34;); Test(int petals) { petalCount = petals; System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC5%E7%AB%A0-%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC5%E7%AB%A0-%E9%9A%90%E8%97%8F%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>第 5 章 隐藏实施过程 “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。”
这一点对于库来说是特别重要的。那个库的用户（客户程序员）必须能依赖自己使用的那一部分，并知道一旦新版本的库出台，自己不需要改写代码。而与此相反，库的创建者必须能自由地进行修改与改进，同时保证客户程序员代码不会受到那些变动的影响。
为达到这个目的，需遵守一定的约定或规则。例如，库程序员在修改库内的一个类时，必须保证不删除已有的方法，因为那样做会造成客户程序员代码出现断点。然而，相反的情况却是令人痛苦的。对于一个数据成员，库的创建者怎样才能知道哪些数据成员已受到客户程序员的访问呢？若方法属于某个类唯一的一部分，而且并不一定由客户程序员直接使用，那么这种痛苦的情况同样是真实的。如果库的创建者想删除一种旧有的实施方案，并置入新代码，此时又该怎么办呢？对那些成员进行的任何改动都可能中断客户程序员的代码。所以库创建者处在一个尴尬的境地，似乎根本动弹不得。
为解决这个问题，Java推出了“访问指示符”的概念，允许库创建者声明哪些东西是客户程序员可以使用的，哪些是不可使用的。这种访问控制的级别在“最大访问”和“最小访问”的范围之间，分别包括：public，“友好的”（无关键字），protected以及private。根据前一段的描述，大家或许已总结出作为一名库设计者，应将所有东西都尽可能保持为“private”（私有），并只展示出那些想让客户程序员使用的方法。这种思路是完全正确的，尽管它有点儿违背那些用其他语言（特别是C）编程的人的直觉，那些人习惯于在没有任何限制的情况下访问所有东西。到这一章结束时，大家应该可以深刻体会到Java访问控制的价值。
然而，组件库以及控制谁能访问那个库的组件的概念现在仍不是完整的。仍存在这样一个问题：如何将组件绑定到单独一个统一的库单元里。这是通过Java的package（打包）关键字来实现的，而且访问指示符要受到类在相同的包还是在不同的包里的影响。所以在本章的开头，大家首先要学习库组件如何置入包里。这样才能理解访问指示符的完整含义。
5.1 包：库单元 我们用import关键字导入一个完整的库时，就会获得“包”（Package）。例如：
import java.util.*; 它的作用是导入完整的实用工具（Utility）库，该库属于标准Java开发工具包的一部分。由于Vector位于java.util里，所以现在要么指定完整名称“java.util.Vector”（可省略import语句），要么简单地指定一个“Vector”（因为import是默认的）。
若想导入单独一个类，可在import语句里指定那个类的名字：
import java.util.Vector; 之所以要进行这样的导入，是为了提供一种特殊的机制，以便管理“命名空间”（Name Space）。我们所有类成员的名字相互间都会隔离起来。位于类A内的一个方法f()不会与位于类B内的、拥有相同“签名”（自变量列表）的f()发生冲突。但类名会不会冲突呢？假设创建一个stack类，将它安装到已有一个stack类（由其他人编写）的机器上，这时会出现什么情况呢？对于因特网中的Java应用，这种情况会在用户毫不知晓的时候发生，因为类会在运行一个Java程序的时候自动下载。
正是由于存在名字潜在的冲突，所以特别有必要对Java中的命名空间进行完整的控制，而且需要创建一个完全独一无二的名字，无论因特网存在什么样的限制
迄今为止，本书的大多数例子都仅存在于单个文件中，而且设计成局部（本地）使用，没有同包名发生冲突（在这种情况下，类名置于“默认包”内）。这是一种有效的做法，而且考虑到问题的简化，本书剩下的部分也将尽可能地采用它。然而，若计划创建一个“对因特网友好”或者说“适合在因特网使用”的程序，必须考虑如何防止类名的重复。 为Java创建一个源码文件的时候，它通常叫作一个“编辑单元”（有时也叫作“翻译单元”）。每个编译单元都必须有一个以.java结尾的名字。而且在编译单元的内部，可以有一个公共（public）类，它必须拥有与文件相同的名字（包括大小写形式，但排除.java文件扩展名）。如果不这样做，编译器就会报告出错。每个编译单元内都只能有一个public类（同样地，否则编译器会报告出错）。那个编译单元剩下的类（如果有的话）可在那个包外面的世界面前隐藏起来，因为它们并非“公共”的（非public），而且它们由用于主public类的“支撑”类组成。
编译一个.java文件时，我们会获得一个名字完全相同的输出文件；但对于.java文件中的每个类，它们都有一个.class扩展名。因此，我们最终从少量的.java文件里有可能获得数量众多的.class文件。如以前用一种汇编语言写过程序，那么可能已习惯编译器先分割出一种过渡形式（通常是一个.obj文件），再用一个链接器将其与其他东西封装到一起（生成一个可执行文件），或者与一个库封装到一起（生成一个库）。但那并不是Java的工作方式。一个有效的程序就是一系列.class文件，它们可以封装和压缩到一个JAR文件里（使用Java 1.1提供的jar工具）。Java解释器负责对这些文件的寻找、装载和解释（注释①）。
①：Java并没有强制一定要使用解释器。一些固有代码的Java编译器可生成单独的可执行文件。
class 文件径打破了C或者C++等语言所遵循的传统，使用这些传统语言写的程序通常首先被编译，然后被连接成单独的、专门支持特定硬件平台和操作系统的二进制文件。通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件。
当编译和连接一个C++程序时，所获得的可执行二进制文件只能在指定的硬件平台和操作系统上运行，因为这个二进制文件包含了对目标处理器的机器语言。而Java编译器把Java源文件的指令翻译成字节码，这种字节码就是Java虚拟机的“机器语言”。
与普通程序不同的是，Java程序（class文件）并不是本地的可执行程序。当运行Java程序时，首先运行JVM（Java虚拟机），然后再把Java class加载到JVM里头运行，负责加载Java class的这部分就叫做Class Loader。
在cmd下使用javac 编译某一java文件则会产生.class文件,用java +类名运行。
“库”也由一系列类文件构成。每个文件都有一个public类（并没强迫使用一个public类，但这种情况最很典型的），所以每个文件都有一个组件。如果想将所有这些组件（它们在各自独立的.java和.class文件里）都归纳到一起，那么package关键字就可以发挥作用）。
若在一个文件的开头使用下述代码：
package mypackage; 那么 package 语句必须作为文件的第一个非注释语句出现。该语句的作用是指出这个编译单元属于名为mypackage的一个库的一部分。或者换句话说，它表明这个编译单元内的public类名位于mypackage这个名字的下面。如果其他人想使用这个名字，要么指出完整的名字，要么与mypackage联合使用import关键字（使用前面给出的选项）。注意根据Java包（封装）的约定，名字内的所有字母都应小写，甚至那些中间单词亦要如此。
每个 .java 文件中只能有一个 public类
现在，如果有人想使用 MyClass，或者想使用 mypackage 内的其他任何 public类，他们必须用 import关键字激活 mypackage内的名字，使它们能够使用。另一个办法则是指定完整的名称：
mypackage.MyClass m = new mypackage.MyClass(); 或者
import mypackage.*; // . . . MyClass m = new MyClass(); 一定要记住 package 和 import 关键字允许我们做的事情就是分割单个全局命名空间，保证我们不会遇到名字的冲突——无论有多少人使用因特网，也无论多少人用Java编写自己的类。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E5%86%8D%E7%94%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E5%86%8D%E7%94%9F/</guid>
      <description>第 6 章 类再生 代码的重复使用
第一个最简单：在新类里简单地创建原有类的对象。我们把这种方法叫作“合成”，因为新类由现有类的对象合并而成。我们只是简单地重复利用代码的功能，而不是采用它的形式。 第二种方法则显得稍微有些技巧。它创建一个新类，将其作为现有类的一个“类型”。我们可以原样采取现有类的形式，并在其中加入新代码，同时不会对现有的类产生影响。这种魔术般的行为叫作“继承”（Inheritance），涉及的大多数工作都是由编译器完成的。对于面向对象的程序设计，“继承”是最重要的基础概念之一。 6.1 合成的语法 为进行合成，我们只需在新类里简单地置入对象句柄即可。对于非基本类型的对象来说，只需将句柄置于新类即可；而对于基本数据类型来说，则需在自己的类中定义它们。
每种非基本类型的对象都有一个toString()方法。若编译器本来希望一个String，但却获得某个这样的对象，就会调用这个方法（意思是说，把对象当 String 用的时候就会调用这个方法）。
在类内作为字段使用的基本数据会初始化成零，就象第2章指出的那样。但对象句柄会初始化成null。而且假若试图为它们中的任何一个调用方法，就会产生一次“违例”。这种结果实际是相当好的（而且很有用），我们可在不丢弃一次违例的前提下，仍然把它们打印出来。
编译器并不只是为每个句柄创建一个默认对象，因为那样会在许多情况下招致不必要的开销。如希望句柄得到初始化，可在下面这些地方进行： 在对象定义的时候。这意味着它们在构建器调用之前肯定能得到初始化。 在那个类的构建器中。 紧靠在要求实际使用那个对象之前。这样做可减少不必要的开销——假如对象并不需要创建的话。 下面向大家展示了所有这三种方法： //: Bath.java // Constructor initialization with composition class Soap { private String s; Soap() { System.out.println(&amp;#34;Soap()&amp;#34;); s = new String(&amp;#34;Constructed&amp;#34;); } public String toString() { return s; } } public class Bath { private String // Initializing at point of definition: s1 = new String(&amp;#34;Happy&amp;#34;), s2 = &amp;#34;Happy&amp;#34;, s3, s4; Soap castille; int i; float toy; Bath() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC7%E7%AB%A0-%E5%A4%9A%E5%BD%A2%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC7%E7%AB%A0-%E5%A4%9A%E5%BD%A2%E6%80%A7/</guid>
      <description>第7章 多形性 “对于面向对象的程序设计语言，多型性是第三种最基本的特征（前两种是数据抽象和继承。”
“多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。利用多形性的概念，代码的组织以及可读性均能获得改善。此外，还能创建“易于扩展”的程序。无论在项目的创建过程中，还是在需要加入新特性的时候，它们都可以方便地“成长”。
通过合并各种特征与行为，封装技术可创建出新的数据类型。通过对具体实施细节的隐藏，可将接口与实施细节分离，使所有细节成为“private”（私有）。这种组织方式使那些有程序化编程背景人感觉颇为舒适。但多形性却涉及对“类型”的分解。通过上一章的学习，大家已知道通过继承可将一个对象当作它自己的类型或者它自己的基础类型对待。这种能力是十分重要的，因为多个类型（从相同的基础类型中衍生出来）可被当作同一种类型对待。而且只需一段代码，即可对所有不同的类型进行同样的处理。利用具有多形性的方法调用，一种类型可将自己与另一种相似的类型区分开，只要它们都是从相同的基础类型中衍生出来的。这种区分是通过各种方法在行为上的差异实现的，可通过基础类实现对那些方法的调用。
在这一章中，大家要由浅入深地学习有关多形性的问题（也叫作动态绑定、推迟绑定或者运行期绑定）。同时举一些简单的例子，其中所有无关的部分都已剥除，只保留与多形性有关的代码。
7.1 上溯造型 在第 6 章，大家已知道可将一个对象作为它自己的类型使用，或者作为它的基础类型的一个对象使用。取得一个对象句柄，并将其作为基础类型句柄使用的行为就叫作“上溯造型”——因为继承树的画法是基础类位于最上方。
7.1.1 为什么要上溯造型 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。这样就不比为每种衍生类都制作对应的方法，节省大量工作。
这正是“多形性”大显身手的地方。
7.2 深入理解 此处有个问题：基于上溯造型，用基础类做方法 自变量时，真正调用方法时传入的自变量类型为基础类的衍生类时。它接收 基础类 句柄。所以在这种情况下，编译器怎样才能知道 基础类 句柄指向的是一个真正的 衍生类，而不是一个其他衍生类呢？编译器无从得知。为了深入了理解这个问题，我们有必要探讨一下“绑定”这个主题。
7.2.1 方法调用的绑定 将一个方法调用 同一个方法主体 连接到一起就称为“绑定”（Binding）。若在程序运行以前执行绑定（由编译器和链接程序，如果有的话），就叫作“早期绑定”。大家以前或许从未听说过这个术语，因为它在任何程序化语言里都是不可能的。C编译器只有一种方法调用，那就是“早期绑定”。
上述程序最令人迷惑不解的地方全与早期绑定有关，因为在只有一个 基础类 句柄的前提下，编译器不知道具体该调用哪个方法。
解决的方法就是“后期绑定”，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。
Java中绑定的所有方法都采用后期绑定技术，除非一个方法已被声明成final。这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。
为什么要把一个方法声明成final呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final方法调用生成效率更高的代码。
7.2.2 产生正确的行为 知道Java里绑定的所有方法都通过后期绑定具有多形性以后，就可以相应地编写自己的代码，令其与基础类沟通。此时，所有的衍生类都保证能用相同的代码正常地工作。或者换用另一种方法，我们可以“将一条消息发给一个对象，让对象自行判断要做什么事情。”
在面向对象的程序设计中，有一个经典的“形状”例子。由于它很容易用可视化的形式表现出来，所以经常都用它说明问题。但很不幸的是，它可能误导初学者认为OOP只是为图形化编程设计的，这种认识当然是错误的。
形状例子有一个基础类，名为Shape；另外还有大量衍生类型：Circle（圆形），Square（方形），Triangle（三角形）等等。大家之所以喜欢这个例子，因为很容易理解“圆属于形状的一种类型”等概念。下面这幅继承图向我们展示了它们的关系：
上溯造型可用下面这个语句简单地表现出来：
Shape s = new Circle(); 当我们调用其中一个基础类方法时（已在衍生类里覆盖）：
s.draw(); 此时实际调用的是Circle.draw()，因为后期绑定已经介入（多形性）。
//: Shapes.java // Polymorphism in Java class Shape { void draw() {} void erase() {} } class Circle extends Shape { void draw() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%B9%E7%BA%B3/</guid>
      <description>第8章 对象的容纳 “如果一个程序只含有数量固定的对象，而且已知它们的存在时间，那么这个程序可以说是相当简单的。”
通常，我们的程序需要根据程序运行时才知道的一些标准创建新对象。若非程序正式运行，否则我们根本不知道自己到底需要多少数量的对象，甚至不知道它们的准确类型。为了满足常规编程的需要，我们要求能在任何时候、任何地点创建任意数量的对象。所以不可依赖一个已命名的句柄来容纳自己的每一个对象， 因为根本不知道自己实际需要多少这样的东西。
为解决这个非常关键的问题，Java提供了容纳对象（或者对象的句柄）的多种方式。其中内建的类型是数组，我们之前已讨论过它，本章准备加深大家对它的认识。此外，Java的工具（实用程序）库提供了一些“集合类”（亦称作“容器类”，但该术语已由AWT使用，所以这里仍采用“集合”这一称呼）。利用这些集合类，我们可以容纳乃至操纵自己的对象。本章的剩余部分会就此进行详细讨论。
8.1 数组 数组只是容纳对象的一种方式。但由于还有其他大量方法可容纳数组，所以是哪些地方使数组显得如此特别呢？ 有两方面的问题将数组与其他集合类型区分开来：效率和类型。对于Java来说，为保存和访问一系列对象（实际是对象的句柄）数组，最有效的方法莫过于数组。数组实际代表一个简单的线性序列，它使得元素的访问速度非常快，但我们却要为这种速度付出代价：创建一个数组对象时，它的大小是固定的，而且不可在那个数组对象的“存在时间”内发生改变。可创建特定大小的一个数组，然后假如用光了存储空间，就再创建一个新数组，将所有句柄从旧数组移到新数组。这属于“矢量”（Vector）类的行为，本章稍后还会详细讨论它。然而，由于为这种大小的灵活性要付出较大的代价，所以我们认为矢量的效率并没有数组高。
C++的矢量类知道自己容纳的是什么类型的对象，但同Java的数组相比，它却有一个明显的缺点：C++矢量类的operator[]不能进行范围检查，所以很容易超出边界（然而，它可以查询vector有多大，而且at()方法确实能进行范围检查）。在Java中，无论使用的是数组还是集合，都会进行范围检查——若超过边界，就会获得一个RuntimeException（运行期违例）错误。正如大家在第9章会学到的那样，这类违例指出的是一个程序员错误，所以不需要在代码中检查它。在另一方面，由于C++的vector不进行范围检查，所以访问速度较快——在Java中，由于对数组和集合都要进行范围检查，所以对性能有一定的影响。
本章还要学习另外几种常见的集合类：Vector（矢量）、Stack（堆栈）以及Hashtable（散列表）。这些类都涉及对对象的处理——好象它们没有特定的类型。换言之，它们将其当作Object类型处理（Object类型是Java中所有类的“根”类）。从某个角度看，这种处理方法是非常合理的：我们仅需构建一个集合，然后任何Java对象都可以进入那个集合（除基本数据类型外——可用Java的基本类型封装类将其作为常数置入集合，或者将其封装到自己的类内，作为可以变化的值使用）。这再一次反映了数组优于常规集合：创建一个数组时，可令其容纳一种特定的类型。这意味着可进行编译期类型检查，预防自己设置了错误的类型，或者错误指定了准备提取的类型。当然，在编译期或者运行期，Java会防止我们将不当的消息发给一个对象。所以我们不必考虑自己的哪种做法更加危险，只要编译器能及时地指出错误，同时在运行期间加快速度，目的也就达到了。此外，用户很少会对一次违例事件感到非常惊讶的。
考虑到执行效率和类型检查，应尽可能地采用数组。然而，当我们试图解决一个更常规的问题时，数组的局限也可能显得非常明显。在研究过数组以后，本章剩余的部分将把重点放到Java提供的集合类身上。
8.1.1 数组和第一类对象 无论使用的数组属于什么类型，数组标识符实际都是指向真实对象的一个句柄。那些对象本身是在内存“堆”里创建的。堆对象既可“隐式”创建（即默认产生），亦可“显式”创建（即明确指定，用一个new表达式）。堆对象的一部分（实际是我们能访问的唯一字段或方法）是只读的length（长度）成员，它告诉我们那个数组对象里最多能容纳多少元素。对于数组对象，“[]”语法是我们能采用的唯一另类访问方法。
下面这个例子展示了对数组进行初始化的不同方式，以及如何将数组句柄分配给不同的数组对象。它也揭示出对象数组和基本数据类型数组在使用方法上几乎是完全一致的。唯一的差别在于对象数组容纳的是句柄，而基本数据类型数组容纳的是具体的数值（若在执行此程序时遇到困难，请参考第3章的“赋值”小节）：
length只告诉我们可将多少元素置入那个数组。换言之，我们只知道数组对象的大小或容量，不知其实际容纳了多少个元素。 尽管如此，由于数组对象在创建之初会自动初始化成null，所以可检查它是否为null，判断一个特定的数组“空位”是否容纳一个对象。类似地，由基本数据类型构成的数组会自动初始化成零（针对数值类型）、null（字符类型）或者false（布尔类型）。
Java 1.1加入了一种新的数组初始化语法，可将其想象成“动态集合初始化”。
hide(new Weeble[] {new Weeble(), new Weeble() }); 对于由基本数据类型构成的数组，它们的运作方式与对象数组极为相似，只是前者直接包容了基本类型的数据值。
集合类只能容纳对象句柄。但对一个数组，却既可令其直接容纳基本类型的数据，亦可容纳指向对象的句柄。
创建和访问一个基本数据类型数组，那么比起访问一个封装数据的集合，前者的效率会高出许多。
当然，假如准备一种基本数据类型，同时又想要集合的灵活性（在需要的时候可自动扩展，腾出更多的空间），就不宜使用数组，必须使用由封装的数据构成的一个集合。大家或许认为针对每种基本数据类型，都应有一种特殊类型的Vector。但Java并未提供这一特性。某些形式的建模机制或许会在某一天帮助Java更好地解决这个问题（注释①）。
①：这儿是C++比Java做得好的一个地方，因为C++通过template关键字提供了对“参数化类型”的支持。
8.1.2 数组的返回 假定我们现在想写一个方法，同时不希望它仅仅返回一样东西，而是想返回一系列东西。此时，象C和C++这样的语言会使问题复杂化，因为我们不能返回一个数组，只能返回指向数组的一个指针。这样就非常麻烦，因为很难控制数组的“存在时间”，它很容易造成内存“漏洞”的出现。
Java采用的是类似的方法，但我们能“返回一个数组”。当然，此时返回的实际仍是指向数组的指针。但在Java里，我们永远不必担心那个数组的是否可用——只要需要，它就会自动存在。而且垃圾收集器会在我们完成后自动将其清除。
返回数组与返回其他任何对象没什么区别——最终返回的都是一个句柄。
8.2 集合 为容纳一组对象，最适宜的选择应当是数组。而且假如容纳的是一系列基本数据类型，更是必须采用数组。
Java提供了四种类型的“集合类”：Vector（矢量）、BitSet（位集）、Stack（堆栈）以及Hashtable（散列表）。与拥有集合功能的其他语言相比，尽管这儿的数量显得相当少，但仍然能用它们解决数量惊人的实际问题。
这些集合类具有形形色色的特征。例如，Stack实现了一个LIFO（先入先出）序列，而Hashtable是一种“关联数组”，允许我们将任何对象关联起来。除此以外，所有Java集合类都能自动改变自身的大小。所以，我们在编程时可使用数量众多的对象，同时不必担心会将集合弄得有多大。
8.2.1 缺点：类型未知 使用Java集合的“缺点”是在将对象置入一个集合时丢失了类型信息。之所以会发生这种情况，是由于当初编写集合时，那个集合的程序员根本不知道用户到底想把什么类型置入集合。若指示某个集合只允许特定的类型，会妨碍它成为一个“常规用途”的工具，为用户带来麻烦。为解决这个问题，集合实际容纳的是类型为Object的一些对象的句柄。这种类型当然代表Java中的所有对象，因为它是所有类的根。当然，也要注意这并不包括基本数据类型，因为它们并不是从“任何东西”继承来的。这是一个很好的方案，只是不适用下述场合：
(1) 将一个对象句柄置入集合时，由于类型信息会被抛弃，所以任何类型的对象都可进入我们的集合——即便特别指示它只能容纳特定类型的对象。举个例子来说，虽然指示它只能容纳猫，但事实上任何人都可以把一条狗扔进来。 (2) 由于类型信息不复存在，所以集合能肯定的唯一事情就是自己容纳的是指向一个对象的句柄。正式使用它之前，必须对其进行造型，使其具有正确的类型。 值得欣慰的是，Java不允许人们滥用置入集合的对象。假如将一条狗扔进一个猫的集合，那么仍会将集合内的所有东西都看作猫，所以在使用那条狗时会得到一个“违例”错误。在同样的意义上，假若试图将一条狗的句柄“造型”到一只猫，那么运行期间仍会得到一个“违例”错误。
这些处理的意义都非常深远。尽管显得有些麻烦，但却获得了安全上的保证。我们从此再难偶然造成一些隐藏得深的错误。若程序的一个部分（或几个部分）将对象插入一个集合，但我们只是通过一次违例在程序的某个部分发现一个错误的对象置入了集合，就必须找出插入错误的位置。当然，可通过检查代码达到这个目的，但这或许是最笨的调试工具。另一方面，我们可从一些标准化的集合类开始自己的编程。尽管它们在功能上存在一些不足，且显得有些笨拙，但却能保证没有隐藏的错误。
错误有时并不显露出来 在某些情况下，程序似乎正确地工作，不造型回我们原来的类型。第一种情况是相当特殊的：String类从编译器获得了额外的帮助，使其能够正常工作。只要编译器期待的是一个String对象，但它没有得到一个，就会自动调用在Object里定义、并且能够由任何Java类覆盖的toString()方法。这个方法能生成满足要求的String对象，然后在我们需要的时候使用。
参数化类型 这类问题并不是孤立的——我们许多时候都要在其他类型的基础上创建新类型。此时，在编译期间拥有特定的类型信息是非常有帮助的。这便是“参数化类型”的概念。在C++中，它由语言通过“模板”获得了直接支持。至少，Java保留了关键字generic，期望有一天能够支持参数化类型。但我们现在无法确定这一天何时会来临。
8.3 枚举器（迭代器） 在任何集合类中，必须通过某种方法在其中置入对象，再用另一种方法从中取得对象。毕竟，容纳各种各样的对象正是集合的首要任务。在Vector中，addElement()便是我们插入对象采用的方法，而elementAt()是提取对象的唯一方法。Vector非常灵活，我们可在任何时候选择任何东西，并可使用不同的索引选择多个元素。
若从更高的角度看这个问题，就会发现它的一个缺陷：需要事先知道集合的准确类型，否则无法使用。乍看来，这一点似乎没什么关系。但假若最开始决定使用Vector，后来在程序中又决定（考虑执行效率的原因）改变成一个List（属于Java1.2集合库的一部分），这时又该如何做呢？ 可利用“反复器”（Iterator）的概念达到这个目的。它可以是一个对象，作用是遍历一系列对象，并选择那个序列中的每个对象，同时不让客户程序员知道或关注那个序列的基础结构。此外，我们通常认为反复器是一种“轻量级”对象；也就是说，创建它只需付出极少的代价。但也正是由于这个原因，我们常发现反复器存在一些似乎很奇怪的限制。例如，有些反复器只能朝一个方向移动。 Java的Enumeration（枚举，注释②）便是具有这些限制的一个反复器的例子。除下面这些外，不可再用它做其他任何事情：
(1) 用一个名为elements()的方法要求集合为我们提供一个Enumeration。我们首次调用它的nextElement()时，这个Enumeration会返回序列中的第一个元素。
(2) 用nextElement()获得下一个对象。
(3) 用hasMoreElements()检查序列中是否还有更多的对象。
②：“反复器”这个词在C++和OOP的其他地方是经常出现的，所以很难确定为什么Java的开发者采用了这样一个奇怪的名字。Java 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC9%E7%AB%A0-%E8%BF%9D%E4%BE%8B%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java-%E7%AC%AC9%E7%AB%A0-%E8%BF%9D%E4%BE%8B%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6/</guid>
      <description>第9章 违例差错控制 通过先进的错误纠正与恢复机制，我们可以有效地增强代码的健壮程度。对我们编写的每个程序来说，错误恢复都属于一个基本的考虑目标。它在Java中显得尤为重要，因为该语言的一个目标就是创建不同的程序组件，以便其他用户（客户程序员）使用。为构建一套健壮的系统，每个组件都必须非常健壮。 在Java里，违例控制的目的是使用尽可能精简的代码创建大型、可靠的应用程序，同时排除程序里那些不能控制的错误。 违例的概念很难掌握。但只有很好地运用它，才可使自己的项目立即获得显著的收益。Java强迫遵守违例所有方面的问题，所以无论库设计者还是客户程序员，都能够连续一致地使用它。
9.1 基本违例 在违例条件的情况下，却无法继续下去，因为当地没有提供解决问题所需的足够多的信息。此时，我们能做的唯一事情就是跳出当地环境，将那个问题委托给一个更高级的负责人。这便是出现违例时出现的情况。
9.1.1 违例自变量 关键字throw
9.2 违例的捕获 为理解违例是如何捕获的，首先必须掌握“警戒区”的概念。它代表一个特殊的代码区域，有可能产生违例，并在后面跟随用于控制那些违例的代码。
9.2.1 try块 可在那个方法内部设置一个特殊的代码块，用它捕获违例。这就叫作“try块”，因为要在这个地方“尝试”各种方法调用。try块属于一种普通的作用域，用一个try关键字开头：
try {// 可能产生违例的代码} 若用一种不支持违例控制的编程语言全面检查错误，必须用设置和错误检测代码将每个方法都包围起来——即便多次调用相同的方法。而在使用了违例控制技术后，可将所有东西都置入一个try块内，在同一地点捕获所有违例。这样便可极大简化我们的代码，并使其更易辨读，因为代码本身要达到的目标再也不会与繁复的错误检查混淆。
9.2.2 违例控制器 当然，生成的违例必须在某个地方中止。这个“地方”便是违例控制器或者违例控制模块。而且针对想捕获的每种违例类型，都必须有一个相应的违例控制器。违例控制器紧接在try块后面，且用catch（捕获）关键字标记。如下所示：
try {// Code that might generate exceptions} catch(Type1 id1) {// Handle exceptions of Type1} catch(Type2 id2) {// Handle exceptions of Type2} catch(Type3 id3) {// Handle exceptions of Type3} 每个catch从句——即违例控制器——都类似一个小型方法，它需要采用一个（而且只有一个）特定类型的自变量。可在控制器内部使用标识符（id1，id2等等），就象一个普通的方法自变量那样。我们有时也根本不使用标识符，因为违例类型已提供了足够的信息，可有效处理违例。但即使不用，标识符也必须就位。 控制器必须“紧接”在try块后面。若“掷”出一个违例，违例控制机制就会搜寻自变量与违例类型相符的第一个控制器。随后，它会进入那个catch从句，并认为违例已得到控制（一旦catch从句结束，对控制器的搜索也会停止）。只有相符的catch从句才会得到执行；它与switch语句不同，后者在每个case后都需要一个break命令，防止误执行其他语句。 在try块内部，请注意大量不同的方法调用可能生成相同的违例，但只需要一个控制器。
中断与恢复 在违例控制理论中，共存在两种基本方法。在“中断”方法中（Java和C++提供了对这种方法的支持），我们假定错误非常关键，没有办法返回违例发生的地方。无论谁只要“掷”出一个违例，就表明没有办法补救错误，而且也不希望再回来。 另一种方法叫作“恢复”。它意味着违例控制器有责任来纠正当前的状况，然后取得出错的方法，假定下一次会成功执行。若使用恢复，意味着在违例得到控制以后仍然想继续执行。在这种情况下，我们的违例更象一个方法调用——我们用它在Java中设置各种各样特殊的环境，产生类似于“恢复”的行为（换言之，此时不是“掷”出一个违例，而是调用一个用于解决问题的方法）。另外，也可以将自己的try块置入一个while循环里，用它不断进入try块，直到结果满意时为止。 从历史的角度看，若程序员使用的操作系统支持可恢复的违例控制，最终都会用到类似于中断的代码，并跳过恢复进程。所以尽管“恢复”表面上十分不错，但在实际应用中却显得困难重重。其中决定性的原因可能是：我们的控制模块必须随时留意是否产生了违例，以及是否包含了由产生位置专用的代码。这便使代码很难编写和维护——大型系统尤其如此，因为违例可能在多个位置产生。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/Thinking-In-Java/</guid>
      <description>Thinking In Java 标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 第 1 章：对象入门 面向对象编程（OOP）
1.1 抽象的进步 所有编程语言的最终目的都是提供一种“抽象”方法。面向对象的程序设计是一大进步，我们将问题空间中的元素以及它们在方案空间的表示物称作“对象”（Object）。所有东西都是对象。程序是一大堆对象的组合。每个对象都有自己的存储空间，可容纳其他对象。每个对象都有一种类型。一个类最重要的特征就是“能将什么消息发给它？”。 同一类所有对象都能接收相同的消息。
1.2 对象的接口 我们向对象发出的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类型”与“接口”的等价或对应关系是面向对象程序设计的基础。接口定义了一类对象能接收的信息，做哪些事情。
1.3 实现方案的隐藏 “接口”（Interface）规定了可对一个特定的对象发出哪些请求。在某个地方存在着一些代码，以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”。“接口”（Interface）重要一点是让牵连到的所有成员都遵守相同的规则。进行访问控制，第一个原因是防止程序员接触他们不该接触的东西。第二个原因是允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。一个继承的类可访问受保护的成员，但不能访问私有成员。
1.4 方案的重复使用 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称作“包含”关系，比如“一辆车包含了一个变速箱”。
新类的“成员对象”通常设为“私有”（Private），使用这个类的客户程序员不能访问它们。这样一来，我们可在不干扰客户代码的前提下，从容地修改那些成员。也可以在“运行期”更改成员，这进一步增大了灵活性。后面要讲到的“继承”并不具备这种灵活性，因为编译器必须对通过继承创建的类加以限制。
轻易的运用继承是非常笨拙的，会大大增加程序的复杂程度。首先应考虑“组织”（类包含）对象；这样做得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。
1.5 继承：重新使用接口 在Java语言中，继承是通过extends关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的接口。也就是说，可向基础类的对象发送的所有消息亦可原样发给衍生类的对象。若只是简单地继承一个类，并不做其他任何事情，来自基础类接口的方法就会直接照搬到衍生类。这意味着衍生类的对象不仅有相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。
1.5.1 改善基础类 改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。
继承只改善原基础类的函数，衍生类型就是与基础类完全相同的类型，都拥有完全相同的接口，此时，我们通常认为基础类和衍生类之间存在一种“等价”关系；但在许多时候，我们必须为衍生类型加入新的接口元素，所以不仅扩展了接口，也创建了一种新类型。我们将其称作“类似”关系；
1.6 多形对象的互换使用 通常，继承最终会以创建一系列类收场，所有类都建立在统一的基础接口上。
对这样的一系列类，我们可以将衍生类的对象当作基础类（完全相同）的一个对象对待。
把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。在面向对象的程序里，通常都要用到上溯造型技术。这是避免去调查准确类型的一个好办法。
1.6.1 动态绑定 将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多形性”（Polymorphism）（多态性）。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。
1.6.2 抽象的基础类和接口 设计程序时，我们经常都希望基础类只为自己的衍生类提供一个接口，而不是实际创建基础类的一个对象，为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。
亦可用abstract关键字描述一个尚未实现的方法，指出：“这是适用于从这个类继承的所有类型的一个接口函数，但目前尚没有对它进行任何形式的实现。抽象方法也许只能在一个抽象类里创建。继承了一个类后，那个方法就必须实现，否则继承的类也会变成“抽象”类。
interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起（不能从多个普通class或abstract class中继承）。
备注：这是一段个人的总结：interface（接口）更倾向于表明这个类是能干什么事，也就是说这类的类实现了哪些方法及继承与此接口的类必需要实现哪些方法；接口更像一个规范文件(协议)。abstract（抽象）更倾向于表明一类类的共有特性，由基础类或一个接口衍生的一系列类的共有特性，所以不仅仅表明这个类能干哪些事。也就是说 interface（接口）的方法都可以在接口中无实现，只规定了子类必须需要实现哪些方法，而 abstract（抽象）可以把子类相同实现的方法在抽象类里实现，子类各自特别且必须的方法用抽象方法规定然后在子类里各自实现。abstract（抽象）可以看为一种跟 public、static 同级别的修饰符（修饰了类（class）和方法），而 interface（接口）可以看为一种跟 class 同级别的修饰符，标志着质的改变。interface（接口）可以说是对 abstract（抽象）的抽象。interface（接口）帮助了对象的分层，各组件之间的松耦合。interface 语法要求：1、接口可以包含：静态常量、方法（抽象）、内部类（接口、枚举）、默认方法（类方法）2、接口只可以继承多个父接口（之间用英文逗号“,”隔开），不能继承类。3、接口修饰符可以是 public 或者省略，如果省略了 public 访问控制符，则默认采用包权限访问控制符，即只有相同包结构下才可以访问该接口。4、接口内的所有成员都是 public 访问权限，可省略，如果指定则只可使用 public 访问修饰符。5、接口的成员变量均为静态常量，不管是否使用 public static final 修饰符都认为只可做如此修饰。6、接口的方法只能是抽象、类方法、默认方法，如果不是默认方法，系统将自动为普通方法增加 public abstract 修饰符，且不能有方法实现（方法体），类方法、默认方法必须有方法实现（方法体）。7、定义默认方法，需要用 default 修饰且默认添加 public 修饰 ，默认方法不能用 static 修饰，所以不能直接用接口来调用默认方法，由接口的实现类的实例来调用这些默认方法。8、类方法需用 static 修饰 ，可用接口直接调用。9、接口的内部类（接口、枚举）默认采用 public static 修饰符。10、接口可看做为特殊的类，受限于一个源文件只能有一个 public 修饰。11、接口不能创建实例，作为声明引用类型变量时此接口必须有其实现类。abstract 语法要求：1、有抽象方法的类只能是抽象类2、抽象类里可没有抽象方法有普通方法3、抽象类不能被实例化4、抽象类可以包含：成员变量、方法（普通、抽象）、构造器、初始化快、内部类（接口、枚举）、抽象类的构造器不能用于创造实列，主要用于被其子类调用5、抽象不能修饰变量（成员、局部），不能修饰构造器，抽象类里的构造器只能是普通的构造器。总结如下：1、抽象类与普通类相比“一得一失”：1、“得”可包含抽象方法。2、“失”无法被实列化。2、抽象类是用来被它的子类继承的，方法由子类实现。而 final 修饰的类不能被继承， final 修饰的方法不能被重写，所以 final 和 abstract 是互斥的。3、static 修饰方法是属于这个类本身的（类Class和实列Object的区别），如果该方法被定义成抽象方法，通过类调用的时候也会出错，因为调用了一个没有方法实体的方法，所以 static 和 abstract 是互斥的（非绝对，可以同时修饰内部类）。4、abstract 修饰的方法必须被之类重写才有意义，因此 abstract 方法不能是私有的，所以 private 和 abstract 是互斥的。 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/%E6%A0%87%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/Thinking-In-Java/%E6%A0%87%E9%A2%98/</guid>
      <description> Thinking In Java 标签：Java、基础、thinking-in-java、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%AC%AC1%E7%AB%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%AC%AC1%E7%AB%A0/</guid>
      <description> 加密与解密 标签：加密与解密、基础 时间：2021年8月30日10点41分 连接：http://www.saveload.cn/html/html/1、Book/Tech/加密与解密/加密与解密-基础篇-第1章.html 加密与解密-基础篇-第1章 1.1 什么是加密与解密 1.1。1 软件的贾母与解密 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0-%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0-%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</guid>
      <description>数据结构与算法（Java 描述） 标签：数据结构、算法、Java 时间：2022年7月13日 17点53分 连接： 来源：数据结构与算法（Java 描述） 邓俊辉 著 第一章 算法及其复杂度 13 §1.1 计算机与算法 14 1.1.1 过指定垂足的直角边 14 1.1.2 三等分线段 15 1.1.3 排序 16 起泡排序算法
最大元素必然就位
只 关注前面的n-1 个元素
1.1.4 算法的定义 19 算法还必须具备以下要素： 输入：待处理的信息，即对具体问题的描述。比如，对于上述三个例子来说，输入分别是“任意给定的直线以及其上的一点”、“任意给定的一条线段”以及“由 n 个可比较元素组成的序列”。 输出：经过处理之后得到的信息，即问题的答案。比如，对于上述三个例子来说，输出分别是我们所要得到的“垂直线”、“三等分点”以及“完全有序的序列”。 确定性：任一算法都可以描述为由若干种基本操作组成的序列。在垂直线算法中，“取等长绳索”、“联结绳索”、“将绳结固定于一点”、“沿特定方向拉直绳索”等操作都属于基本操作。在三等分线段算法中，基本操作就是欧氏作图法所允许的所有尺规操作。而在起泡排序算法中，基本操作就是图灵机所允许的各种操作：“读取某一元素的内容”、“比较两个元素的大小”以及“修改某一元素的内容”等等。 可行性：在相应的计算模型中，每一基本操作都可以实现，且能够在常数时间内完成。 有穷性：对于任何输入，按照算法，经过有穷次基本操作都可以得到正确的输出。 §1.2 算法性能的分析与评价 20 1.2.1 三个层次 20 1.2.2 时间复杂度及其度量 20 1.2.3 空间复杂度 22 §1.3 算法复杂度及其分析 23 1.3.1 O(1)((取非极端元素 23 1.3.2 O(logn)((进制转换 23 1.3.3 O(n)((数组求和 24 1.3.4 O(n2)((起泡排序 25 1.3.5 O(2r)((幂函数 25 §1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/</guid>
      <description>数据结构与算法（Java 描述） 标签：数据结构、算法、Java 时间：2022年7月13日 17点53分 连接： 来源：数据结构与算法（Java 描述） 邓俊辉 著 第一章 算法及其复杂度 13 §1.1 计算机与算法 141.1.1 过指定垂足的直角边 141.1.2 三等分线段 151.1.3 排序 161.1.4 算法的定义 19§1.2 算法性能的分析与评价 201.2.1 三个层次 201.2.2 时间复杂度及其度量 201.2.3 空间复杂度 22§1.3 算法复杂度及其分析 231.3.1 O(1)((取非极端元素 231.3.2 O(logn)((进制转换 231.3.3 O(n)((数组求和 241.3.4 O(n2)((起泡排序 251.3.5 O(2r)((幂函数 25§1.4 计算模型 261.4.1 可解性 261.4.2 有效可解 271.4.3 下界 27§1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0--1Linux-%E7%9A%84-Page-Cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0--1Linux-%E7%9A%84-Page-Cache/</guid>
      <description>文件 I/O 简明概述 转自： Spongecaptain
链接：https://spongecaptain.cool/SimpleClearFileIO/
Linux 的 Page Cache 1. Page Cache 1.1 Page Cache 是什么？ 为了理解 Page Cache，我们不妨先看一下 Linux 的文件 I/O 系统，如下图所示： Figure1. Linux 文件 I/O 系统
VFS 虚拟文件系统(Virtual File System)Device Driver 设备驱动程序I/O Scheduler I/O 调度器Block I/O Layer 块 I/O 层 上图中，红色部分为 Page Cache。可见 Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I/O 将文件读取到内存空间实际上都是读取到 Page Cache 中。
1.2 如何查看系统的 Page Cache？ 通过读取 /proc/meminfo 文件，能够实时获取系统内存情况：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0--2DMA-%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0--2DMA-%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/</guid>
      <description> 文件 I/O 简明概述 转自： Spongecaptain
链接：https://spongecaptain.cool/SimpleClearFileIO/
# 文件 I/O 简明概述 1. Page Cache 1.1 Page Cache 是什么？ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/%E6%96%87%E4%BB%B6-IO-%E7%AE%80%E6%98%8E%E6%A6%82%E8%BF%B0/</guid>
      <description> 文件 I/O 简明概述 转自： Spongecaptain
链接：https://spongecaptain.cool/SimpleClearFileIO/
文件 I/O 简明概述 文件 I/O 性能是后台应用的主要瓶颈之一，一直以来想对文件 I/O 这个偌大的系统进行总结，故写此文。
文件 I/O 内容较多，书籍的意义在于能更系统地说明问题，避免博客文章散乱的问题。
书籍有涉及很大部分非原创内容，相关引用会在 REFERENCE 小节中指出。
书籍内容包括：
1.page cache 2.DMA 与零拷贝技术 3.mmap 4.文件分区 5.Java ByteBuffer与 Channel 6.FileChannel 7.JavaVisual 工具 8.Java ByteBuffer 测试 9.如何实现顺序读写 一些章节可能会需要一定的 Java 语言基础，其中：1~4 小节完全不需要 Java 基础，而 5~9 小节会涉及一定的 Java 代码。读者朋友可以有选择性地阅读。
Figure1.Linux IO Stack Diagram
推荐阅读 On Disk IO, Part 1: Flavors of IO On Disk IO, Part 2: More Flavours of IO Read, write &amp;amp; space amplification - pick 2 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%A0%87%E9%A2%98/</guid>
      <description> 深入理解Java虚拟机 标签：Java、基础、深入理解Java虚拟机 、源码解读、进阶、Java开源框架 时间：2020年8月3日18:13:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-358/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC10%E7%AB%A0-%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-358/</guid>
      <description> 第四部分　程序编译与代码优化 第10章　前端编译与优化 358 10.1　概述 358 10.2　Javac编译器 359 10.2.1　Javac的源码与调试 359 10.2.2　解析与填充符号表 362 10.2.3　注解处理器 363 10.2.4　语义分析与字节码生成 364 10.3　Java语法糖的味道 367 10.3.1　泛型 367 10.3.2　自动装箱、拆箱与遍历循环 375 10.3.3　条件编译 377 10.4　实战：插入式注解处理器 378 10.4.1　实战目标 379 10.4.2　代码实现 379 10.4.3　运行与测试 385 10.4.4　其他应用案例 386 10.5　本章小结 386 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-388/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC11%E7%AB%A0-%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96-388/</guid>
      <description> 第11章　后端编译与优化 388 11.1　概述 388 11.2　即时编译器 389 11.2.1　解释器与编译器 389 11.2.2　编译对象与触发条件 392 11.2.3　编译过程 397 11.2.4　实战：查看及分析即时编译结果 398 11.3　提前编译器 404 11.3.1　提前编译的优劣得失 405 11.3.2　实战：Jaotc的提前编译 408 11.4　编译器优化技术 411 11.4.1　优化技术概览 411 11.4.2　方法内联 415 11.4.3　逃逸分析 417 11.4.4　公共子表达式消除 420 11.4.5　数组边界检查消除 421 11.5　实战：深入理解Graal编译器 423 11.5.1　历史背景 423 11.5.2　构建编译调试环境 424 11.5.3　JVMCI编译器接口 426 11.5.4　代码中间表示 429 11.5.5　代码优化与生成 432 11.6　本章小结 436 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-438/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC12%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-438/</guid>
      <description> 第五部分　高效并发 第12章　Java内存模型与线程 438 12.1　概述 438 12.2　硬件的效率与一致性 439 12.3　Java内存模型 440 12.3.1　主内存与工作内存 441 12.3.2　内存间交互操作 442 12.3.3　对于volatile型变量的特殊规则 444 12.3.4　针对long和double型变量的特殊规则 450 12.3.5　原子性、可见性与有序性 450 12.3.6　先行发生原则 452 12.4　Java与线程 455 12.4.1　线程的实现 455 12.4.2　Java线程调度 458 12.4.3　状态转换 460 12.5　Java与协程 461 12.5.1　内核线程的局限 461 12.5.2　协程的复苏 462 12.5.3　Java的解决方案 464 12.6　本章小结 465 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96-466/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC13%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96-466/</guid>
      <description> 第13章　线程安全与锁优化 466 13.1　概述 466 13.2　线程安全 466 13.2.1　Java语言中的线程安全 467 13.2.2　线程安全的实现方法 471 13.3　锁优化 479 13.3.1　自旋锁与自适应自旋 479 13.3.2　锁消除 480 13.3.3　锁粗化 481 13.3.4　轻量级锁 481 13.3.5　偏向锁 483 13.4　本章小结 485 附录A　在Windows系统下编译OpenJDK 6 486 附录B　展望Java技术的未来（2013年版） 493 附录C　虚拟机字节码指令表 499 附录D　对象查询语言（OQL）简介 506 附录E　JDK历史版本轨迹 512 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%91Java-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC1%E7%AB%A0-%E8%B5%B0%E8%BF%91Java-2/</guid>
      <description>前言 致谢 第一部分　走近Java 第1章　走近Java 2 世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过 程。
1.1　概述 当我们在使用一门技术时，不再依赖书本和他人就能得到这些问题的答案，那才算升华到了“不 惑”的境界。
1.2　Java技术体系 从广义上讲，Kotlin、Clojure、JRuby、Groovy等运行于Java虚拟机上的编程语言及其相关的程序 都属于Java技术体系中的一员。如果仅从传统意义上来看，JCP官方[1]所定义的Java技术体系包括了以 下几个组成部分：
·Java程序设计语言 ·各种硬件平台上的Java虚拟机实现 ·Class文件格式 ·Java类库API ·来自商业机构和开源社区的第三方Java类库 我们可以把Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境，本书中为行文方便，在不产生歧义的地方常以JDK 来代指整个Java技术体系[2]。可以把Java类库API中的Java SE API子集[3]和Java虚拟机这两部分统称为 JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境。
1.3　Java发展史 1998年12月4日，JDK迎来了一个里程碑式的重要版本：工程代号为Playground（竞技场）的JDK 1.2，Sun在这个版本中把Java技术体系拆分为三个方向，分别是面向桌面应用开发的J2SE（Java 2 Platform，Standard Edition）、面向企业级开发的J2EE（Java 2 Platform，Enterprise Edition）和面向手机等移动终端开发的J2ME（Java 2 Platform，Micro Edition）。在这个版本中出现的代表性技术非常多，如EJB、Java Plug-in、Java IDL、Swing等，并且这个版本中Java虚拟机第一次内置了JIT（Just InTime）即时编译器（JDK 1.2中曾并存过三个虚拟机，Classic VM、HotSpot VM和Exact VM，其中Exact VM只在Solaris平台出现过；后面两款虚拟机都是内置了JIT即时编译器的，而之前版本所带的Classic VM只能以外挂的形式使用即时编译器）。在语言和API层面上，Java添加了strictfp关键字，Java类库添加了现在Java编码之中极为常用一系列Collections集合类等。在1999年3月和7月，分别有JDK 1.2.1和JDK 1.2.2两个小升级版本发布。
1999年4月27日，HotSpot 虚拟机诞生。HotSpot最初由一家名为“Longview Techno-logies”的小公司开发，由于HotSpot的优异表现，这家公司在1997年被Sun公司收购。Hot-Spot虚拟机刚发布时是作为JDK 1.2的附加程序提供的，后来它成为JDK 1.3及之后所有JDK版本的默认Java虚拟机。
2000年5月8日，工程代号为Kestrel（美洲红隼）的JDK 1.3发布。相对于JDK 1.2，JDK 1.3的改进主要体现在Java类库上（如数学运算和新的Timer API等），JNDI服务从JDK 1.3开始被作为一项平台级服务提供（以前JNDI仅仅是一项扩展服务），使用CORBA IIOP来实现RMI的通信协议，等等。这个版本还对Java 2D做了很多改进，提供了大量新的Java 2D API，并且新添加了JavaSound类库。JDK1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8-42/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8-42/</guid>
      <description>第二部分　自动内存管理 第2章　Java内存区域与内存溢出异常 42 2.1　概述 42 本章是第二部分的第1章，笔者将从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作 用、服务对象以及其中可能产生的问题，这也是翻越虚拟机内存管理这堵围墙的第一步。
2.2　运行时数据区域 42 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域 有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是 依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存 将会包括以下几个运行时数据区域，如图2-1所示。
2.2.1　程序计数器 43 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里[1]，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。
2.2.2　Java虚拟机栈 43 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或者更多的情况下只是指虚拟机栈中局部变量表部分。
局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。
这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。
在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。
[1] 栈帧是方法运行期很重要的基础数据结构，在本书的第8章中还会对帧进行详细讲解。 [2] HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的，后面的实战中笔者也演示了这种情况。本书第2版时这里的描述是有误的，请阅读过第2版的读者特别注意。 2.2.3　本地方法栈 44 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。
《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。
2.2.4　Java堆 44 对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配[1]”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换[2]优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。
Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词，这些概念在本书后续章节中还会反复登场亮相，在这里笔者想先说明的是这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，更不是《Java虚拟机规范》里对Java堆的进一步细致划分。不少资料上经常写着类似于“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”这样的内容。在十年之前（以G1收集器的出现为分界），作为业界绝对主流的HotSpot虚拟机，它内部的垃圾收集器全部都基于“经典分代”[3]来设计，需要新生代、老年代收集器搭配才能工作，在这种背景下，上述说法还算是不会产生太大歧义。但是到了今天，垃圾收集器技术与十年前已不可同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器，再按照上面的提法就有很多需要商榷的地方了。
如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将会是下一章的主题。
根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。
Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。
[1] 《Java虚拟机规范》中的原文：The heap is the runtime data area from which memory for all class instances and arrays is allocated。 [2] 逃逸分析与标量替换的相关内容，请参见第11章的相关内容。 [3] 指新生代（其中又包含一个Eden和两个Survivor）、老年代这种划分，源自UC Berkeley在20世纪80代中期开发的Berkeley Smalltalk。历史上有多款虚拟机采用了这种设计，包括HotSpot和它的前身Self 和Strongtalk虚拟机（见第1章），原始论文是：https://dl.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-67/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-67/</guid>
      <description>第3章　垃圾收集器与内存分配策略 67 3.1　概述 67 3.2　对象已死？ 68 3.2.1　引用计数算法 68 3.2.2　可达性分析算法 70 3.2.3　再谈引用 71 3.2.4　生存还是死亡？ 72 3.2.5　回收方法区 74 3.3　垃圾收集算法 75 3.3.1　分代收集理论 75 3.3.2　标记-清除算法 77 3.3.3　标记-复制算法 78 3.3.4　标记-整理算法 79 3.4　HotSpot的算法细节实现 81 3.4.1　根节点枚举 81 3.4.2　安全点 82 3.4.3　安全区域 83 3.4.4　记忆集与卡表 84 3.4.5　写屏障 85 3.4.6　并发的可达性分析 87 3.5　经典垃圾收集器 89 3.5.1　Serial收集器 90 3.5.2　ParNew收集器 92 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-138/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7-138/</guid>
      <description> 第4章　虚拟机性能监控、故障处理工具 138 4.1　概述 138 4.2　基础故障处理工具 138 4.2.1　jps：虚拟机进程状况工具 141 4.2.2　jstat：虚拟机统计信息监视工具 142 4.2.3　jinfo：Java配置信息工具 143 4.2.4　jmap：Java内存映像工具 144 4.2.5　jhat：虚拟机堆转储快照分析工具 145 4.2.6　jstack：Java堆栈跟踪工具 146 4.2.7　基础工具总结 148 4.3　可视化故障处理工具 151 4.3.1　JHSDB：基于服务性代理的调试工具 152 4.3.2　JConsole：Java监视与管理控制台 157 4.3.3　VisualVM：多合-故障处理工具 164 4.3.4　Java Mission Control：可持续在线的监控工具 171 4.4　HotSpot虚拟机插件及工具 175 4.5　本章小结 180 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-181/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98-181/</guid>
      <description> 第5章　调优案例分析与实战 181 5.1　概述 181 5.2　案例分析 181 5.2.1　大内存硬件上的程序部署策略 182 5.2.2　集群间同步导致的内存溢出 184 5.2.3　堆外内存导致的溢出错误 185 5.2.4　外部命令导致系统缓慢 187 5.2.5　服务器虚拟机进程崩溃 187 5.2.6　不恰当数据结构导致内存占用过大 188 5.2.7　由Windows虚拟内存导致的长时间停顿 189 5.2.8　由安全点导致长时间停顿 190 5.3　实战：Eclipse运行速度调优 192 5.3.1　调优前的程序运行状态 193 5.3.2　升级JDK版本的性能变化及兼容问题 196 5.3.3　编译时间和类加载时间的优化 200 5.3.4　调整内存设置控制垃圾收集频率 203 5.3.5　选择收集器降低延迟 206 5.4　本章小结 209 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-212/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-212/</guid>
      <description>第三部分　虚拟机执行子系统 第6章　类文件结构 212 6.1　概述 212 6.2　无关性的基石 212 6.3　Class类文件的结构 214 6.3.1　魔数与Class文件的版本 215 6.3.2　常量池 218 6.3.3　访问标志 224 6.3.4　类索引、父类索引与接口索引集合 225 6.3.5　字段表集合 226 6.3.6　方法表集合 229 6.3.7　属性表集合 230 6.4　字节码指令简介 251 6.4.1　字节码与数据类型 251 6.4.2　加载和存储指令 253 6.4.3　运算指令 254 6.4.4　类型转换指令 255 6.4.5　对象创建与访问指令 256 6.4.6　操作数栈管理指令 256 6.4.7　控制转移指令 257 6.4.8　方法调用和返回指令 257 6.4.9　异常处理指令 258 6.4.10　同步指令 258 6.5　公有设计，私有实现 259 6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-262/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-262/</guid>
      <description> 第7章　虚拟机类加载机制 262 7.1　概述 262 7.2　类加载的时机 263 7.3　类加载的过程 267 7.3.1　加载 267 7.3.2　验证 268 7.3.3　准备 271 7.3.4　解析 272 7.3.5　初始化 277 7.4　类加载器 279 7.4.1　类与类加载器 280 7.4.2　双亲委派模型 281 7.4.3　破坏双亲委派模型 285 7.5　Java模块化系统 287 7.5.1　模块的兼容性 288 7.5.2　模块化下的类加载器 290 7.6　本章小结 292 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-293/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-293/</guid>
      <description> 第8章　虚拟机字节码执行引擎 293 8.1　概述 293 8.2　运行时栈帧结构 294 8.2.1　局部变量表 294 8.2.2　操作数栈 299 8.2.3　动态连接 300 8.2.4　方法返回地址 300 8.2.5　附加信息 301 8.3　方法调用 301 8.3.1　解析 301 8.3.2　分派 303 8.4　动态类型语言支持 315 8.4.1　动态类型语言 316 8.4.2　Java与动态类型 317 8.4.3　java.lang.invoke包 318 8.4.4　invokedynamic指令 321 8.4.5　实战：掌控方法分派规则 324 8.5　基于栈的字节码解释执行引擎 326 8.5.1　解释执行 327 8.5.2　基于栈的指令集与基于寄存器的指令集 328 8.5.3　基于栈的解释器执行过程 329 8.6　本章小结 334 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC9%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98-335/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC9%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8A%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A1%88%E4%BE%8B%E4%B8%8E%E5%AE%9E%E6%88%98-335/</guid>
      <description> 第9章　类加载及执行子系统的案例与实战 335 9.1　概述 335 9.2　案例分析 335 9.2.1　Tomcat：正统的类加载器架构 335 9.2.2　OSGi：灵活的类加载器架构 338 9.2.3　字节码生成技术与动态代理的实现 341 9.2.4　Backport工具：Java的时光机器 345 9.3　实战：自己动手实现远程执行功能 348 9.3.1　目标 348 9.3.2　思路 349 9.3.3　实现 350 9.3.4　验证 355 9.4　本章小结 356 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>深入理解Java虚拟机 标签：Java、基础、深入理解Java虚拟机 、源码解读、进阶、Java开源框架 时间：2020年8月3日18:13:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 前言 致谢 第一部分　走近Java 第1章　走近Java 2 1.1　概述 2 1.2　Java技术体系 3 1.3　Java发展史 4 1.4　Java虚拟机家族 12 1.4.1　虚拟机始祖：Sun Classic/Exact VM 12 1.4.2　武林盟主：HotSpot VM 13 1.4.3　小家碧玉：Mobile/Embedded VM 14 1.4.4　天下第二：BEA JRockit/IBM J9 VM 15 1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16 1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17 1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18 1.4.8　百家争鸣 19 1.5　展望Java技术的未来 21 1.5.1　无语言倾向 21 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AC%AC1%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%AC%AC1%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%9C%A8%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>第一部分 基础知识 第1章 算法在计算中的作用 1.1 算法 1.2 作为一种技术的算法</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</guid>
      <description>第一部分 基础知识 第1章 算法在计算中的作用 1.1 算法 1.2 作为一种技术的算法 第2章 算法基础 2.1 插入排序 2.2 分析算法 2.3 设计算法 第3章 函数的增长 3.1 渐进记号 3.2 标准记号与常用函数 第4章 分治策略 4.1 最大子数组问题 4.2 矩阵乘法的Strassen算法 4.3 用代入法求解递归式 4.4 用递归树方法求解递归式 4.5 用主方法求解递归式 *4.6 证明主定理 第5章 概率分析和随机算法 5.1 雇用问题 5.2 指示器随机变量 5.3 随机算法 *5.4 概率分析和指示器随机变量的进一步使用 第二部分 排序和顺序统计量 第6章 堆排序 6.1 堆 6.2 维护堆的性质 6.3 建堆 6.4 堆排序算法 6.5 优先队列 第7章 快速排序 7.1 快速排序的描述 7.2 快速排序的性能 7.3 快速排序的随机化版本 7.4 快速排序分析 第8章 线性时间排序 8.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88/</guid>
      <description>计算机科学导论（原书第3版） 目录 出版者的话 译者序 前言 第1章绪论 1.1图灵模型 1.1.1数据处理器 1.1.2可编程数据处理器 1.1.3通用图灵机 1.2冯·诺依曼模型 1.2.1 4个子系统 1.2.2存储程序概念 1.2.3 指令的顺序执行 1.3计算机组成部分 1.3.1计算机硬件 1.3.2数据 1.3.3计算机软件 1.4历史 1.4.1机械计算机器（1930年以前） 1.4.2 电子计算机的诞生(1930～ 1950年) 1.4.3计算机的诞生（1950年至今） 1.5社会问题和道德问题 1.5.1社会问题 1.5.2道德问题 1.6计算机科学作为一门学科 1.7课程纲要 1.7.1 第一部分：数据的表示与运算 1.7.2第二部分：计算机硬件 1.7.3第三部分：计算机软件 1.7.4第四部分：数据组织与抽象 1.7.5第五部分：高级话题 1.8章末材料 1.9练习 第2章数字系统 2.1引言 2.2位置化数字系统 2.2.1 十进制系统（以10为底） 2.2.2二进制系统（以2为底） 2.2.3 十六进制系统（以16为底） 2.2.4八进制系统（以8为底） 2.2.5 4种位置化数字系统的小结 2.2.6转换 2.3非位置化数字系统 2.4章末材料 2.5练习 第3章数据存储 3.1数据类型 3.2存储数字 3.2.1存储整数 3.2.2 3种系统的比较 3.2.3 实数 3.3存储文本 3.4存储音频 3.4.1．采样 3.4.2量化 3.4.3编码 3.4.4声音编码标准 3.5存储图像 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%8E%9F%E5%88%99-1-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%8E%9F%E5%88%99-1-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA/</guid>
      <description>计算机网络：原理、协议和实践，第三版 第 1 部分：原则 连接两台主机 物理层 数据链路层 框架 从传输错误中恢复 在不完美链路之上实现可靠的数据传输 回溯 n 和选择性重复 连接两台主机 构建网络（甚至是 Internet 等全球网络）的第一步是将两台主机连接在一起。如下图所示。
将两台主机连接在一起
为了使两台主机能够交换信息，它们需要通过某种物理介质链接在一起。计算机网络已经使用各种类型的物理介质来交换信息，特别是：
电缆。信息可以通过不同类型的电缆传输。最常见的是双绞线（用于电话网络，但也用于企业网络）和同轴电缆（仍在有线电视网络中使用，但不再用于企业网络）。某些网络技术通过经典电缆运行。 光纤。当通信设备之间的距离大于一公里时，光纤经常用于公共和企业网络。光纤主要有两种类型：多模和单模。多模比单模光纤便宜得多，因为LED可用于通过多模光纤发送信号，而单模光纤必须由激光驱动。由于光的传播模式不同，多模光纤仅限于几公里的距离，而单模光纤可以在几十公里以上的距离上使用。在这两种情况下，中继器都可用于在光纤的一个端点处再生光信号，以通过另一根光纤发送。 无线。在这种情况下，无线电信号用于对通信设备之间交换的信息进行编码。许多类型的调制技术用于通过无线信道发送信息，并且该领域每年都有很多创新，并且每年都会出现新技术。虽然大多数无线网络依赖于无线电信号，但有些使用激光将光脉冲发送到远程探测器。这些光学技术允许创建点对点链路，而基于无线电的技术可用于构建包含分布在小地理区域的设备的网络。 物理层 一旦这些信息被转换为合适的电信号，这些物理介质就可以用来交换信息。整个电信课程和教科书都致力于将模拟或数字信息转换为电信号的问题，以便可以通过给定的物理链路传输。在本书中，我们只考虑两种非常简单的方案，它们允许通过电缆传输信息。这使我们能够突出通过物理链路传输信息时的关键问题。我们只对允许通过有线传输数字信息的技术感兴趣。在这里，我们将重点介绍位的传输，即0或1。
注意
比特率 (Bit rate)
在计算机网络中，物理层的比特率始终以每秒比特数表示。1 Mbps 是每秒 100 万位，1 Gbps 是 10 亿位/秒。这与通常以字节(bytes)（8 位(bits)）、千字节（1024 字节(bytes)）或兆字节（1048576 字节(bytes)）表示的内存规格形成鲜明对比。通过 1 Mbps 链路传输 1 MByte 可持续 8.39 秒。
Bit rate | Bits per second
1 Kbps | 10^3
1 Mbps | 10^6
1 Gbps | 10^9
1 Tbps | 10^12</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%8E%9F%E5%88%99-2-%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%8E%9F%E5%88%99-2-%E5%BB%BA%E7%AB%8B%E7%BD%91%E7%BB%9C/</guid>
      <description>计算机网络：原理、协议和实践，第三版 转自：Computer Networking : Principles, Protocols and Practice, third edition
链接：https://beta.computer-networking.info/syllabus/default/index.html
第 1 部分：原则 构建网络 数据报组织 计算转发表 平面或分层地址 处理异构数据链层 虚拟线路组织 控制平面 距离矢量路由 链路状态路由 构建网络 在上一节中，我们已经解释了可靠协议如何允许主机可靠地交换数据，即使底层物理层不完善并因此不可靠。通过电线将两台主机连接在一起是构建网络的第一步。然而，这还不够。主机通常需要与其他不通过直接物理层链路直接连接的主机进行交互。这可以通过在数据链路层之上添加一层来实现：网络层。
网络层
网络层的主要目标是:允许连接到不同网络的主机通过称为路由器的中间系统交换信息。网络层的信息单位称为数据包。
在解释网络层的操作之前，记住数据链路层提供的服务的特性是很有用的。数据链路层有许多变体。有些提供可靠的服务，而有些则不提供任何交付保证。可靠的数据链路层服务在传输错误频繁的无线网络等环境中很受欢迎。另一方面，当物理层提供几乎可靠的服务时，通常使用不可靠的服务（即只有极少部分的帧受到传输错误的影响）。这种几乎可靠的服务经常用于有线和光网络。在本章中，我们将假设数据链路层服务提供了一个几乎可靠的服务，因为这既是最通用的服务，也是部署最广泛的服务。
有两种主要类型的数据链路层。最简单的数据链路层是当只有两个通信系统通过物理层直接连接时。当两个通信系统之间存在点对点链路时，使用这种数据链路层。这两个系统可以是主机或路由器。PPP（点对点协议），定义在RFC 1661 是这种点对点数据链路层的示例。数据链路层实体交换帧。左侧数据链路层实体发送的数据链路帧通过物理层传输，可以到达右侧数据链路层实体。点对点数据链路层既可以提供不可靠的服务（帧可能损坏或丢失），也可以提供可靠的服务（在这种情况下，数据链路层包括重传机制）。
第二种类型的数据链路层是在局域网 (LAN) 中使用的层。从概念上讲，LAN 是一组通信设备，因此任何两个设备都可以通过数据链路层直接交换帧。主机和路由器都可以连接到 LAN。有的局域网只连接几个设备，但也有可以连接成百上千台设备的局域网。在本章中，我们关注点对点数据链路层的利用。我们稍后将描述局域网的组织和操作以及它们对网络层的影响。
即使我们只考虑点对点数据链路层，这些层也有一个我们不能忽视的重要特征。没有数据链路层能够发送无限大小的帧。每个数据链路层都有一个最大帧大小。有十多个不同的数据链路层，不幸的是，它们中的大多数使用不同的最大帧大小。当我们需要在连接到不同类型数据链路层的主机之间交换数据时，最大帧大小的这种异质性会导致问题。
作为第一步，让我们假设我们只需要交换少量数据。在这种情况下，帧的最大长度没有问题。但是，还有其他更有趣的问题需要我们解决。为了理解这些问题，让我们考虑下图中表示的网络。
该网络包含两种类型的设备。主机用圆圈表示，路由器用方框表示。主机是一种能够发送和接收数据以供自己使用的设备，而路由器在大多数情况下只是将数据转发到其最终目的地。路由器有多个链接到相邻的路由器或主机。主机通常通过单个链接连接到网络。如今，随着无线网络的发展，越来越多的主机配备了多个物理接口。这些主机通常称为多宿主。尽管如此，同时使用多个接口通常会导致超出本文档范围的实际问题。出于这个原因，我们在这本电子书中只考虑单宿主主机。
要了解网络操作背后的关键原理，让我们分析一下需要执行的所有操作，以允许上述网络中的主机 A 向主机 B 发送一个字节。由于在 A-R1 链路之上使用了数据链路层，主机 A 可以轻松地在一个帧内向路由器 R1 发送一个字节。然而，在接收到这个帧后，路由器 R1 需要知道这个字节是发往主机 B 而不是它自己的。这是网络层的目标。
网络层使不通过中间路由器直接连接的主机之间能够传输信息。这种传输是通过将要传输的信息放入称为数据包的数据结构中来执行的。作为包含有用数据和控制信息的帧，数据包还包含用户提供的数据和控制信息。网络层的一个重要问题是：识别网络内部节点（主机或路由器）的能力。该识别是通过将地址与每个节点相关联来执行的。地址_通常表示为一个比特序列。大多数网络使用固定长度的地址。在这个阶段，让我们简单地假设上述网络中的每个节点都有一个地址，该地址对应于图中其名称的二进制表示。
为了向主机 B 发送一个字节的信息，主机 A 需要将该信息放入一个数据包中。除了正在传输的数据之外，数据包还包含源节点和目标节点的地址，或者指示到达目标需要遵循的路径的信息。
网络层有两种可能的组织：
数据报 虚电路 数据报组织 网络层的第一个也是最流行的组织是数据报组织。该组织的灵感来自邮政服务的组织。每个主机都由一个网络层地址标识。要将信息发送到远程主机，主机会创建一个数据包，其中包含：
目的主机的网络层地址 自己的网络层地址 要发送的信息 为了理解数据报的组织，让我们考虑下图。一个由字母表示的网络层地址已分配给每个主机和路由器。为了向主机J发送一些信息，主机A创建一个包含它自己的地址、目标地址和要交换的信息的数据包。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-4-%E9%83%A8%E5%88%86%E9%99%84%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88-%E7%AC%AC-4-%E9%83%A8%E5%88%86%E9%99%84%E5%BD%95/</guid>
      <description>计算机网络：原理、协议和实践，第三版 转自：Computer Networking : Principles, Protocols and Practice, third edition
链接：https://beta.computer-networking.info/syllabus/default/index.html
附录 词汇表 地址 一串比特，用于标识网络层或数据链路层中的网络接口。大多数地址具有固定长度，例如IPv4为 32 位， IPv6为128 位，以太网和其他相关局域网为 48 位。
AIMD 加法增加，乘法减少。一种速率自适应算法，主要由 TCP 使用，其中主机在网络不拥塞时以加法方式增加其传输速率，并在检测到拥塞时以乘法方式降低其传输速率。
任播 一种传输模式，其中信息从一个源发送到属于指定组的一个接收器
接口 应用程序接口
ARP 地址解析协议是IPv4设备用来获取局域网上一个IPv4地址对应的数据链路层地址的协议。ARP 定义在RFC 826
阿帕 高级研究计划署 (ARPA) 网络是由美国网络科学家在美国国防部 ARPA 的资助下建立的网络。ARPANET 被认为是当今互联网的鼻祖。
ASCII 美国信息交换标准代码 (ASCII) 是一种字符编码方案，它定义了字符的二进制表示。ASCII 表包含可打印字符和控制字符。ASCII 字符以 7 位编码，仅包含用英语编写文本所需的字符。后来开发了其他字符集（例如 Unicode）以支持所有书面语言。
ASN.1 抽象语法符号一 (ASN.1) 由 ISO 和 ITU-T 设计。它是一种标准且灵活的符号，可用于描述数据结构，用于在应用程序之间表示、编码、传输和解码数据。它被设计用于 OSI 参考模型的表示层，但现在用于其他协议，例如SNMP。
自动柜员机 异步传输模式
BGP 边界网关协议是全球互联网中使用的域间路由协议。
BNF Backus-Naur 形式 (BNF) 是一种通过使用句法和词法规则来描述语言的正式方式。BNF 经常用于定义编程语言，也用于定义网络应用程序之间交换的消息。RFC 5234解释了如何编写 BNF 来指定 Internet 协议。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/1Book/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88/</guid>
      <description>计算机网络：原理、协议和实践，第三版 转自：Computer Networking : Principles, Protocols and Practice, third edition
链接：https://beta.computer-networking.info/syllabus/default/index.html
第 1 部分：原则 连接两台主机 物理层 数据链路层 框架 从传输错误中恢复 在不完美链路之上实现可靠的数据传输 回溯 n 和选择性重复 构建网络 数据报组织 计算转发表 平面或分层地址 处理异构数据链层 虚拟线路组织 控制平面 距离矢量路由 链路状态路由 应用 传输层 传输层服务 无连接服务 以连接为导向的服务 请求-响应服务 传输层 无连接运输 连接建立 数据传输 连接版本 命名和寻址 名称的好处 共享资源 共享带宽 网络拥塞 在网络上分配负载 中型访问控制算法 静态分配方法 阿罗哈 载波感应多路访问 带碰撞检测的载波侦测多路访问 具有防撞功能的载波侦听多路访问 确定性介质访问控制算法 拥塞控制 使用基于窗口的传输协议进行拥塞控制 参考模型 五层参考模型 物理层 数据链路层 网络层 传输层 应用层 参考模型 TCP/IP 参考模型 OSI 参考模型 网络安全 威胁 加密基元 加密协议 密钥交换 第 2 部分：协议 应用层 域名系统 电子邮件 简单邮件传输协议 邮局协议 超文本传输协议 使 HTTP 更快 远程过程调用 编码数据 联系被叫方 远程登录 安全外壳 （ssh） 传输层安全性 红绿灯系统握手 TLS 记录协议 改进 TLS 保护域名系统 互联网传输协议 用户数据报协议 传输控制协议 TCP 连接建立 TCP 可靠的数据传输 分段传输策略 TCP 窗口 TCP 的重新传输超时 高级重传策略 TCP 连接释放 拥塞控制 在不丢失数据的情况下控制拥塞 对 TCP 拥塞控制进行建模 网络层 IP 版本 6 IPv6 寻址体系结构 IPv6 数据包格式 ICMP 版本 6 IPv6 子网 IPv6 与数据链层之间的交互 IP 网络中的路由 域内路由 把 OSPF 域间路由 边界网关协议 BGP 决策过程 BGP 收敛 数据链层技术 点对点协议 以太网 以太网交换机 生成树协议 （802.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/1Crash-Course-Computer-Science/Crash-Course-Computer-Science-README/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/1Crash-Course-Computer-Science/Crash-Course-Computer-Science-README/</guid>
      <description>计算机科学速成课 :fire: 2018年5月1号 - 全40集完结撒花 精校版： https://www.bilibili.com/video/av21376839/
## 字幕也放出来了(40集中英字幕) 两个版本： 所有字幕放一个文件里 每一集一个文件，共40个文件 另外，片头总结在 这篇文章的底部
感谢观看，Don&amp;rsquo;t forget to be Awesome!
感谢所有翻译人员！ 不想膨胀的小R - Github, 微博, B站 糖醋陈皮 - Github, 微博, 博客 ZireHao - B站 gilot - B站 晴空 Crazycat Cindy 出门去 TMC - RN LCAR979（推特 _lincr_） 第一版翻译（不推荐观看，看精校版即可）： 1 - 早期的计算 - Early Computing 2 - 电子计算 - Electronic Computing 3 - 布尔逻辑与逻辑电路 - Boolean Logic &amp;amp; Logic Gates 4 - 二进制 - Representing Numbers and Letters with Binary 5 - 算术逻辑单元 - How Computers Calculate - the ALU 6 - 寄存器 &amp;amp; 内存 - Registers and RAM 7 - 中央处理器 - The Central Processing Unit(CPU) 8 - 指令和程序 - Instructions &amp;amp; Programs 9 - 高级 CPU 设计 - Advanced CPU Designs 10 - 编程史话 - Early Programming 11 - 编程语言 - The First Programming Languages 12 - 编程原理：语句和函数 - Programming Basics: Statements &amp;amp; Functions 13 - 算法初步 - Intro to Algorithms 14 - 数据结构 - Data Structures 15 - 阿兰·图灵 - Alan Turing 16 - 软件工程 - Software Engineering 17 - 集成电路、摩尔定律 - Integrated Circuits &amp;amp; Moore’s Law 18 - 操作系统 - Operating Systems 19 - 内存 &amp;amp; 储存介质 - Memory &amp;amp; Storage 20 - 文件系统 - Files &amp;amp; File Systems 21 - 压缩 - Compression 22 - 命令行界面 - Keyboards &amp;amp; Command Line Interfaces 23 - 屏幕 &amp;amp; 2D 图形显示 - Screens &amp;amp; 2D Graphics 24 - 冷战和消费主义 - The Cold War and Consumerism 25 - 个人计算机革命 - The Personal Computer Revolution 26 - 图形用户界面 - Graphical User Interfaces 27 - 3D 图形 - 3D Graphics 28 - 计算机网络 - Computer Networks 29 - 互联网 - The Internet 30 - 万维网 - The World Wide Web 31 - 网络安全 - Cybersecurity 32 - 黑客与攻击 - Hackers &amp;amp; Cyber Attacks 33 - 加密 - Cryptography 34 - 机器学习与人工智能 - Machine Learning &amp;amp; Artificial Intelligence 35 - 计算机视觉 - Computer Vision 36 - 自然语言处理 - Natural Language Processing 37 - 机器人 - Robots 38 - 计算机中的心理学 - Psychology of Computing 39 - 教育型科技 - Educational Technology 40 - (完结) 奇点，天网，计算机的未来 - The Singularity, Skynet, and the Future of Computing 精校版质量更好，建议看精校版，之所以第一版目录不删：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/2Data-Structure-Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/2Data-Structure-Algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Java-%E6%8F%8F%E8%BF%B0/</guid>
      <description>第一章 算法及其复杂度 1.1.4 算法的定义 一个算法还必须具备以下要素： 输入：待处理的信息，即对具体问题的描述。比如，对于上述三个例子来说，输入分别是“任 意给定的直线以及其上的一点”、“任意给定的一条线段”以及“由 n 个可比较元素组成的序 列”。 输出：经过处理之后得到的信息，即问题的答案。比如，对于上述三个例子来说，输出分别 是我们所要得到的“垂直线”、“三等分点”以及“完全有序的序列”。 确定性：任一算法都可以描述为由若干种基本操作组成的序列。在垂直线算法中，“取等长 绳索”、“联结绳索”、“将绳结固定于一点”、“沿特定方向拉直绳索”等操作都属于基本操作。 在三等分线段算法中，基本操作就是欧氏作图法所允许的所有尺规操作。而在起泡排序算法 中，基本操作就是图灵机所允许的各种操作：“读取某一元素的内容”、“比较两个元素的大 小”以及“修改某一元素的内容”等等。 可行性：在相应的计算模型中，每一基本操作都可以实现，且能够在常数时间内完成。 有穷性：对于任何输入，按照算法，经过有穷次基本操作都可以得到正确的输出。 1.2.2 时间复杂度及其度量 时间频度
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度
在时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。 算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。 记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 T (n) = Ο(f (n)) 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C * f(n)。 简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大(小于等于)。也就是说当n趋于正无穷时T (n)的上界是C * f(n)。 其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2n^2+n +1) = O (3n^2+n+3) = O (7n^2 + n) = O ( n^2 ) ，一般都只用O(n^2)表示就可以了。 在时间频度不相同时，时间复杂度有可能相同，如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。 算法中语句执行次数为一个常数，则时间复杂度为O(1) 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log n),线性阶O(n), 线性对数阶O((n * log n),平方阶O(n^2)，立方阶O(n^3),&amp;hellip;， k次方阶O(n^k),指数阶O(2^n)。 复杂度举例：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Design-Patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Design-Patterns/</guid>
      <description> 设计模式 Design Patterns 学习自：
http://www.cyc2018.xyz/
一、前言 设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。（面对相似问题的经典解决方案）
创建型：如何创建对象
结构型：如何将多个对象组件成更大的对象，就像发动机、就像汽车
行为型：如果处理 对象 与 对象的关系，也就是说，当两个分开的对象，如何通过信息沟通，各自处理问题，以及 信息沟通的拓扑结构
Thinking In Java 里面总结：
将保持不变的东西身上发生的变化孤立出来 变化的影响隔离出来 设计范式：可以说对问题不变的地方抽象总结 二、创建型 单例 简单工厂 工厂方法 抽象工厂 生成器 原型模式 三、行为型 责任链 命令 解释器 迭代器 中介者 备忘录 观察者 状态 策略 模板方法 访问者 空对象 四、结构型 适配器 桥接 组合 装饰 外观 享元 代理 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B1%E5%8D%95%E4%BE%8BSingleton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B1%E5%8D%95%E4%BE%8BSingleton/</guid>
      <description>1、单例（Singleton） Intent 确保一个类只有一个实例，并提供该实例的全局访问点。
Class Diagram 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。
私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。
Implementation Ⅰ 懒汉式-线程不安全 以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。
这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance
public class Singleton { private static Singleton uniqueInstance; private Singleton() { } public static Singleton getUniqueInstance() { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } return uniqueInstance; } } Ⅱ 饿汉式-线程安全 线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。
但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。
private static Singleton uniqueInstance = new Singleton(); Ⅲ 懒汉式-线程安全 只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B2%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82Simple-Factory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B2%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82Simple-Factory/</guid>
      <description>2、简单工厂（Simple Factory） Intent 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。
Class Diagram 简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。
这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。
Implementation public interface Product { } public class ConcreteProduct implements Product { } public class ConcreteProduct1 implements Product { } public class ConcreteProduct2 implements Product { } 以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。
public class Client { public static void main(String[] args) { int type = 1; Product product; if (type == 1) { product = new ConcreteProduct1(); } else if (type == 2) { product = new ConcreteProduct2(); } else { product = new ConcreteProduct(); } // do something with the product } } 以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B3%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95Factory-Method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B3%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95Factory-Method/</guid>
      <description> 3、工厂方法（Factory Method） Intent 定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。
Class Diagram 在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。
下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。
Implementation public abstract class Factory { abstract public Product factoryMethod(); public void doSomething() { Product product = factoryMethod(); // do something with the product } } public class ConcreteFactory extends Factory { public Product factoryMethod() { return new ConcreteProduct(); } } public class ConcreteFactory1 extends Factory { public Product factoryMethod() { return new ConcreteProduct1(); } } public class ConcreteFactory2 extends Factory { public Product factoryMethod() { return new ConcreteProduct2(); } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B4%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Abstract-Factory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B4%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82Abstract-Factory/</guid>
      <description>4、抽象工厂（Abstract Factory） Intent 提供一个接口，用于创建 相关的对象家族 。
Class Diagram 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。
抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。
至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。
从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。
Implementation public class AbstractProductA { } public class AbstractProductB { } public class ProductA1 extends AbstractProductA { } public class ProductA2 extends AbstractProductA { } public class ProductB1 extends AbstractProductB { } public class ProductB2 extends AbstractProductB { } public abstract class AbstractFactory { abstract AbstractProductA createProductA(); abstract AbstractProductB createProductB(); } public class ConcreteFactory1 extends AbstractFactory { AbstractProductA createProductA() { return new ProductA1(); } AbstractProductB createProductB() { return new ProductB1(); } } public class ConcreteFactory2 extends AbstractFactory { AbstractProductA createProductA() { return new ProductA2(); } AbstractProductB createProductB() { return new ProductB2(); } } public class Client { public static void main(String[] args) { AbstractFactory abstractFactory = new ConcreteFactory1(); AbstractProductA productA = abstractFactory.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B5%E7%94%9F%E6%88%90%E5%99%A8Builder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B5%E7%94%9F%E6%88%90%E5%99%A8Builder/</guid>
      <description>5、生成器（Builder） Intent 封装一个对象的构造过程，并允许按步骤构造。
Class Diagram Implementation 以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。
public class AbstractStringBuilder { protected char[] value; protected int count; public AbstractStringBuilder(int capacity) { count = 0; value = new char[capacity]; } public AbstractStringBuilder append(char c) { ensureCapacityInternal(count + 1); value[count++] = c; return this; } private void ensureCapacityInternal(int minimumCapacity) { // overflow-conscious code if (minimumCapacity - value.length &amp;gt; 0) expandCapacity(minimumCapacity); } void expandCapacity(int minimumCapacity) { int newCapacity = value.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B6%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FPrototype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%88%9B%E5%BB%BA%E5%9E%8B6%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FPrototype/</guid>
      <description> 6、原型模式（Prototype） Intent 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。
Class Diagram Implementation public abstract class Prototype { abstract Prototype myClone(); } public class ConcretePrototype extends Prototype { private String filed; public ConcretePrototype(String filed) { this.filed = filed; } @Override Prototype myClone() { return new ConcretePrototype(filed); } @Override public String toString() { return filed; } } public class Client { public static void main(String[] args) { Prototype prototype = new ConcretePrototype(&amp;#34;abc&amp;#34;); Prototype clone = prototype.myClone(); System.out.println(clone.toString()); } } abc </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B1-%E9%80%82%E9%85%8D%E5%99%A8Adapter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B1-%E9%80%82%E9%85%8D%E5%99%A8Adapter/</guid>
      <description>1、适配器（Adapter） Intent 把一个类接口转换成另一个用户需要的接口。
Java 的 IO 流设计就有利用适配器模式，将不同来源的数据转为字节流或字符流
Class Diagram Implementation 鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。
要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！
public interface Duck { void quack(); } public interface Turkey { void gobble(); } public class WildTurkey implements Turkey { @Override public void gobble() { System.out.println(&amp;#34;gobble!&amp;#34;); } } public class TurkeyAdapter implements Duck { Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B2-%E6%A1%A5%E6%8E%A5Bridge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B2-%E6%A1%A5%E6%8E%A5Bridge/</guid>
      <description>2、 桥接（Bridge） Intent 将抽象与实现分离开来，使它们可以独立变化。
Class Diagram Abstraction：定义抽象类的接口 Implementor：定义实现类接口 Implementation RemoteControl 表示遥控器，指代 Abstraction。
TV 表示电视，指代 Implementor。
桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。
public abstract class TV { public abstract void on(); public abstract void off(); public abstract void tuneChannel(); } public class Sony extends TV { @Override public void on() { System.out.println(&amp;#34;Sony.on()&amp;#34;); } @Override public void off() { System.out.println(&amp;#34;Sony.off()&amp;#34;); } @Override public void tuneChannel() { System.out.println(&amp;#34;Sony.tuneChannel()&amp;#34;); } } public class RCA extends TV { @Override public void on() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B3-%E7%BB%84%E5%90%88Composite/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B3-%E7%BB%84%E5%90%88Composite/</guid>
      <description>3、 组合（Composite） Intent 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。
Class Diagram 组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。
组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。
Implementation RemoteControl 表示遥控器，指代 Abstraction。
TV 表示电视，指代 Implementor。
桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。
public abstract class Component { protected String name; public Component(String name) { this.name = name; } public void print() { print(0); } abstract void print(int level); abstract public void add(Component component); abstract public void remove(Component component); } public class Composite extends Component { private List&amp;lt;Component&amp;gt; child; public Composite(String name) { super(name); child = new ArrayList&amp;lt;&amp;gt;(); } @Override void print(int level) { for (int i = 0; i &amp;lt; level; i++) { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B4-%E8%A3%85%E9%A5%B0Decorator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B4-%E8%A3%85%E9%A5%B0Decorator/</guid>
      <description>4、 装饰（Decorator） Intent 为对象动态添加功能。
Class Diagram 装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。
Implementation 设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。
下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。
/** * 饮料 */ public interface Beverage { /** * 费用，成本 * @return */ double cost(); } /** * 焦炒咖啡 */ public class DarkRoast implements Beverage { @Override public double cost() { return 1; } } /** * 首选咖啡 */ public class HouseBlend implements Beverage { @Override public double cost() { return 1; } } /** * 调味品装饰 */ public abstract class CondimentDecorator implements Beverage { protected Beverage beverage; } public class Milk extends CondimentDecorator { public Milk(Beverage beverage) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B5-%E5%A4%96%E8%A7%82Facade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B5-%E5%A4%96%E8%A7%82Facade/</guid>
      <description>5、 外观（Facade） Intent 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。
Class Diagram Implementation 观看电影需要操作很多电器，使用外观模式实现一键看电影功能。
public class SubSystem { public void turnOnTV() { System.out.println(&amp;#34;turnOnTV()&amp;#34;); } public void setCD(String cd) { System.out.println(&amp;#34;setCD( &amp;#34; + cd + &amp;#34; )&amp;#34;); } public void startWatching(){ System.out.println(&amp;#34;startWatching()&amp;#34;); } } public class Facade { private SubSystem subSystem = new SubSystem(); public void watchMovie() { subSystem.turnOnTV(); subSystem.setCD(&amp;#34;a movie&amp;#34;); subSystem.startWatching(); } } public class Client { public static void main(String[] args) { Facade facade = new Facade(); facade.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B6-%E4%BA%AB%E5%85%83Flyweight/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B6-%E4%BA%AB%E5%85%83Flyweight/</guid>
      <description>6、 享元（Flyweight） Intent 利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。
Class Diagram Flyweight：享元对象 IntrinsicState：内部状态，享元对象共享内部状态 ExtrinsicState：外部状态，每个享元对象的外部状态不同
Implementation Flyweight：享元对象 IntrinsicState：内部状态，享元对象共享内部状态 ExtrinsicState：外部状态，每个享元对象的外部状态不同 public interface Flyweight { void doOperation(String extrinsicState); } public class ConcreteFlyweight implements Flyweight { private String intrinsicState; public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } @Override public void doOperation(String extrinsicState) { System.out.println(&amp;#34;Object address: &amp;#34; + System.identityHashCode(this)); System.out.println(&amp;#34;IntrinsicState: &amp;#34; + intrinsicState); System.out.println(&amp;#34;ExtrinsicState: &amp;#34; + extrinsicState); } } public class FlyweightFactory { private HashMap&amp;lt;String, Flyweight&amp;gt; flyweights = new HashMap&amp;lt;&amp;gt;(); Flyweight getFlyweight(String intrinsicState) { if (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B7-%E4%BB%A3%E7%90%86Proxy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%89%E7%BB%93%E6%9E%84%E5%9E%8B7-%E4%BB%A3%E7%90%86Proxy/</guid>
      <description>7、 代理（Proxy） Intent 控制对其它对象的访问。
Class Diagram 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。 Implementation 以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。
public interface Image { void showImage(); } public class HighResolutionImage implements Image { private URL imageURL; private long startTime; private int height; private int width; public int getHeight() { return height; } public int getWidth() { return width; } public HighResolutionImage(URL imageURL) { this.imageURL = imageURL; this.startTime = System.currentTimeMillis(); this.width = 600; this.height = 600; } public boolean isLoad() { // 模拟图片加载，延迟 3s 加载完成 long endTime = System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B10-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95Template-Method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B10-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95Template-Method/</guid>
      <description>10、 模板方法（Template Method） Intent 定义算法框架，并将一些步骤的实现延迟到子类。
通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。
Class Diagram Implementation 冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 public abstract class CaffeineBeverage { final void prepareRecipe() { boilWater(); brew(); pourInCup(); addCondiments(); } abstract void brew(); abstract void addCondiments(); void boilWater() { System.out.println(&amp;#34;boilWater&amp;#34;); } void pourInCup() { System.out.println(&amp;#34;pourInCup&amp;#34;); } } public class Coffee extends CaffeineBeverage { @Override void brew() { System.out.println(&amp;#34;Coffee.brew&amp;#34;); } @Override void addCondiments() { System.out.println(&amp;#34;Coffee.addCondiments&amp;#34;); } } public class Tea extends CaffeineBeverage { @Override void brew() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B11-%E8%AE%BF%E9%97%AE%E8%80%85Visitor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B11-%E8%AE%BF%E9%97%AE%E8%80%85Visitor/</guid>
      <description>11、 访问者（Visitor） Intent 为一个对象结构（比如组合结构）增加新能力。
Class Diagram Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor：具体访问者，存储遍历过程中的累计结果 ObjectStructure：对象结构，可以是组合结构，或者是一个集合。 Implementation /** * Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 */ public interface Visitor { /** * 访问，参观； * @param customer 顾客 */ void visit(Customer customer); void visit(Order order); void visit(Item item); } /** * 具体访问者，存储遍历过程中的累计结果 */ public class GeneralReport implements Visitor { private int customersNo; private int ordersNo; private int itemsNo; public void visit(Customer customer) { System.out.println(customer.getName()); customersNo++; } public void visit(Order order) { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B12-%E7%A9%BA%E5%AF%B9%E8%B1%A1Null/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B12-%E7%A9%BA%E5%AF%B9%E8%B1%A1Null/</guid>
      <description>12、 空对象（Null） Intent 使用什么都不做
的空对象来代替 NULL。
一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。
Class Diagram Implementation public abstract class AbstractOperation { abstract void request(); } public class RealOperation extends AbstractOperation { @Override void request() { System.out.println(&amp;#34;do something&amp;#34;); } } public class NullOperation extends AbstractOperation{ @Override void request() { // do nothing } } public class Client { public static void main(String[] args) { AbstractOperation abstractOperation = func(-1); abstractOperation.request(); } public static AbstractOperation func(int para) { if (para &amp;lt; 0) { return new NullOperation(); } return new RealOperation(); } } boilWaterCoffee.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B1%E8%B4%A3%E4%BB%BB%E9%93%BEChain-Of-Responsibility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B1%E8%B4%A3%E4%BB%BB%E9%93%BEChain-Of-Responsibility/</guid>
      <description>1、责任链（Chain Of Responsibility） Intent 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。
Class Diagram Handler：定义处理请求的接口，并且实现后继链（successor） Implementation public abstract class Handler { protected Handler successor; public Handler(Handler successor) { this.successor = successor; } protected abstract void handleRequest(Request request); } public class ConcreteHandler1 extends Handler { public ConcreteHandler1(Handler successor) { super(successor); } @Override protected void handleRequest(Request request) { if (request.getType() == RequestType.TYPE1) { System.out.println(request.getName() + &amp;#34; is handle by ConcreteHandler1&amp;#34;); return; } if (successor != null) { successor.handleRequest(request); } } } public class ConcreteHandler2 extends Handler { public ConcreteHandler2(Handler successor) { super(successor); } @Override protected void handleRequest(Request request) { if (request.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B2%E5%91%BD%E4%BB%A4Command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B2%E5%91%BD%E4%BB%A4Command/</guid>
      <description>2、命令（Command） Intent 将命令封装成对象中，具有以下作用：
使用命令来参数化其它对象 将命令放入队列中进行排队 将命令的操作记录到日志中 支持可撤销的操作 Class Diagram Command：命令 Receiver：命令接收者，也就是命令真正的执行者 Invoker：通过它来调用命令 Client：可以设置命令与命令的接收者 Implementation 设计一个遥控器，可以控制电灯开关。
public interface Command { void execute(); } public class LightOnCommand implements Command { Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.on(); } } public class LightOffCommand implements Command { Light light; public LightOffCommand(Light light) { this.light = light; } @Override public void execute() { light.off(); } } public class Light { public void on() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B3%E8%A7%A3%E9%87%8A%E5%99%A8Interpreter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B3%E8%A7%A3%E9%87%8A%E5%99%A8Interpreter/</guid>
      <description>3、解释器（Interpreter） Intent 为语言创建解释器，通常由语言的语法和语法分析来定义。
Class Diagram TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。 Context：上下文，包含解释器之外的一些全局信息。 Implementation public interface Aggregate { Iterator createIterator(); } public class ConcreteAggregate implements Aggregate { private Integer[] items; public ConcreteAggregate() { items = new Integer[10]; for (int i = 0; i &amp;lt; items.length; i++) { items[i] = i; } } @Override public Iterator createIterator() { return new ConcreteIterator&amp;lt;Integer&amp;gt;(items); } } public interface Iterator&amp;lt;Item&amp;gt; { Item next(); boolean hasNext(); } public class ConcreteIterator&amp;lt;Item&amp;gt; implements Iterator { private Item[] items; private int position = 0; public ConcreteIterator(Item[] items) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B4%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B4%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator/</guid>
      <description>4、迭代器（Iterator） Intent 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
Class Diagram Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator； Iterator 主要定义了 hasNext() 和 next() 方法； Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。 Implementation 以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。
例如一颗解析树为 D And (A Or (B C))，文本 &amp;ldquo;D A&amp;rdquo; 满足该解析树定义的规则。
这里的 Context 指的是 String
public abstract class Expression { public abstract boolean interpret(String str); } public class TerminalExpression extends Expression { private String literal = null; public TerminalExpression(String str) { literal = str; } public boolean interpret(String str) { StringTokenizer st = new StringTokenizer(str); while (st.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B5%E4%B8%AD%E4%BB%8B%E8%80%85Mediator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B5%E4%B8%AD%E4%BB%8B%E8%80%85Mediator/</guid>
      <description>5、中介者（Mediator） Intent 集中相关对象之间复杂的沟通和控制方式。（改变多个对象间的拓扑结构）
Class Diagram Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。 Colleague：同事，相关对象 Implementation Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：
使用中介者模式可以将复杂的依赖结构变成星形结构：
/** * Colleague 同事类 * Mediator 中介物 */ public abstract class Colleague { public abstract void onEvent(Mediator mediator); } public class Alarm extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(&amp;#34;alarm&amp;#34;); } public void doAlarm() { System.out.println(&amp;#34;doAlarm()&amp;#34;); } } public class CoffeePot extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.doEvent(&amp;#34;coffeePot&amp;#34;); } public void doCoffeePot() { System.out.println(&amp;#34;doCoffeePot()&amp;#34;); } } public class Calender extends Colleague { @Override public void onEvent(Mediator mediator) { mediator.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B6%E5%A4%87%E5%BF%98%E5%BD%95Memento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B6%E5%A4%87%E5%BF%98%E5%BD%95Memento/</guid>
      <description>6、备忘录（Memento） Intent 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。
Class Diagram Originator：原始对象 Caretaker：负责保存好备忘录 Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。 Implementation 以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。
/** * Originator Interface */ public interface Calculator { // Create Memento PreviousCalculationToCareTaker backupLastCalculation(); // setMemento void restorePreviousCalculation(PreviousCalculationToCareTaker memento); int getCalculationResult(); void setFirstNumber(int firstNumber); void setSecondNumber(int secondNumber); } /** * Originator Implementation */ public class CalculatorImp implements Calculator { private int firstNumber; private int secondNumber; @Override public PreviousCalculationToCareTaker backupLastCalculation() { // create a memento object used for restoring two numbers return new PreviousCalculationImp(firstNumber, secondNumber); } @Override public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B7%E8%A7%82%E5%AF%9F%E8%80%85Observer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B7%E8%A7%82%E5%AF%9F%E8%80%85Observer/</guid>
      <description>7、观察者（Observer） Intent 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
Class Diagram 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。 Implementation 天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。
/** * 主题 */ public interface Subject { /** * 登记 观察者 * @param o */ void registerObserver(Observer o); /** * 删除 观察者 * @param o */ void removeObserver(Observer o); /** * 通知 观察者 */ void notifyObserver(); } public class WeatherData implements Subject { private List&amp;lt;Observer&amp;gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() { observers = new ArrayList&amp;lt;&amp;gt;(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B8%E7%8A%B6%E6%80%81State/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B8%E7%8A%B6%E6%80%81State/</guid>
      <description>8、状态（State） Intent 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。
Class Diagram Implementation 糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。 public interface State { /** * 投入 25 分钱 */ void insertQuarter(); /** * 退回 25 分钱 */ void ejectQuarter(); /** * 转动曲柄 */ void turnCrank(); /** * 发放糖果 */ void dispense(); } public class HasQuarterState implements State { private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) { this.gumballMachine = gumballMachine; } @Override public void insertQuarter() { System.out.println(&amp;#34;You can&amp;#39;t insert another quarter&amp;#34;); } @Override public void ejectQuarter() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B9-%E7%AD%96%E7%95%A5Strategy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/3Design-Patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BA%8C%E8%A1%8C%E4%B8%BA%E5%9E%8B9-%E7%AD%96%E7%95%A5Strategy/</guid>
      <description>9、策略（Strategy） Intent 定义一系列算法，封装每个算法，并使它们可以互换。
策略模式可以让算法独立于使用它的客户端。
Class Diagram Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。 状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。
状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。
Implementation 设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。
public interface QuackBehavior { void quack(); } public class Quack implements QuackBehavior { @Override public void quack() { System.out.println(&amp;#34;quack!&amp;#34;); } } public class Squeak implements QuackBehavior{ @Override public void quack() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/ASCII/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/ASCII/</guid>
      <description>美国信息交换标准代码 (ASCII) 是一种字符编码方案，它定义了字符的二进制表示。ASCII 表包含可打印字符和控制字符。ASCII 字符以 7 位编码，仅包含用英语编写文本所需的字符。后来开发了其他字符集（例如 Unicode）以支持所有书面语言。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/CMD_diskpart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/CMD_diskpart/</guid>
      <description>DISKPART&amp;gt; list disk磁盘 ### 状态 大小 可用 Dyn Gpt-------- ------------- ------- ------- --- ---磁盘 0 联机 238 GB 0 B *磁盘 1 联机 931 GB 1024 KB ** 磁盘 2 联机 14 TB 1024 KB *磁盘 3 联机 7452 GB 7452 GBDISKPART&amp;gt; list volume卷 ### LTR 标签 FS 类型 大小 状态 信息---------- --- ----------- ----- ---------- ------- --------- --------卷 0 G 系统 NTFS 磁盘分区 237 GB 正常卷 1 FAT32 磁盘分区 300 MB 正常 已隐藏卷 2 NTFS 磁盘分区 596 MB 正常 已隐藏卷 3 C 系统 NTFS 磁盘分区 329 GB 正常 启动卷 4 D 新加卷 NTFS 磁盘分区 599 GB 正常卷 5 NTFS 磁盘分区 596 MB 正常 已隐藏卷 6 FAT32 磁盘分区 300 MB 正常 系统卷 7 NTFS 磁盘分区 597 MB 正常 已隐藏卷 8 E 新加卷 NTFS 磁盘分区 14 TB 正常DISKPART&amp;gt; detail diskJMicron H/W RAID5 SCSI Disk Device磁盘 ID: {FE5CC930-993A-4CF0-96A0-32EE693BD091}类型 : USB状态 : 联机路径 : 0目标 : 0LUN ID : 0位置路径 : UNAVAILABLE当前只读状态: 是只读: 是启动磁盘: 否页面文件磁盘: 否休眠文件磁盘: 否故障转储磁盘: 否群集磁盘 : 否卷 ### LTR 标签 FS 类型 大小 状态 信息---------- --- ----------- ----- ---------- ------- --------- --------卷 8 E 新加卷 NTFS 磁盘分区 14 TB 正常DISKPART&amp;gt; list partition分区 ### 类型 大小 偏移量------------- ---------------- ------- -------* 分区 1 保留 15 MB 17 KB分区 2 主要 14 TB 16 MB新磁盘首次被发现后，即被假定为 MBR 磁盘。在试图创建 GPT 分区之前，必须显式地将磁盘转换为 GPT。建议您将 MSR 创建为每个数据磁盘上的第一个分区以及任何系统或启动盘上的第二个分区（在 ESP 之后）。从 MBR 转换为 GPT 后，MSR 分区将在磁盘上自动创建。创建任何新的分区后，最近创建的分区会得到分区焦点。删除任何分区后，分区焦点也会丢失。磁盘焦点在任何情况下都保持不变。取消只读模式步骤：1、管理员模式打开 CMD；2、输入 diskpart，回车；3、输入 list volume 获得分区列表；4、输入 select volume [number] 指定分区；5、输入 attributes volume set readonly 设置只读模式。5、输入 attributes volume clear readonly 取消只读模式。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/NTFS/NTFS%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BANTFS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/NTFS/NTFS%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%BANTFS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%9B%98%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E6%96%B9%E6%B3%95/</guid>
      <description> NTFS格式化为NTFS后的原盘数据恢复方法 NTFS的安全性能给数据恢复提供了很大的便利，在NTFS上出错后数据恢复的成功率还是不错的。 下面根据我自己的经历谈一谈NTFS格式化为NTFS后原盘数据恢复的方法。 NTFS格式化为NTFS后，在XP系统下只是重写了前32个MFT项，在WIN7系统下重写了前255个MFT项，在这种情况下，用软件扫一般都能恢复，但如果分区比较大，文件比较多的话，第一需要很长时间，第二碎片文件可能不容易恢复成功。所以我谈一下手工恢复的方法。 首先说一下手工恢复的思路，既然只是重写了前32个或前255个MFT，后面的MFT不变，所以只要在0号MFT上修改一下链接指向这些MFT，那么就能够实现原盘恢复了。 具体要修改的地方主要有4处（根据实际情况不同）：MFT起始簇号、80H属性的起始和结束VCN、属性体的分配、实际、初始大小和DATARUN数据。 具体步骤如下： 第一、MFT起始簇号。首先判断现在的MFT起始簇号是不是格式化前的MFT起始簇号。转到31号或是255号MFT，前后看看MFT号是否连续，如果连续，表明格式化前后的MFT起始簇号相同，如果不连续，表明格式化前后的MFT起始簇号不相同。起始簇号相同，则不用管它，记下这个起始簇号，后面要用到它的；起始簇号不相同，就要找原来的MFT起始簇号，也就是把现在的MFT起始簇号向前或向后提一下，同样记下现在的MFT起始簇号。 第二、80H属性的起始和结束VCN。搜索最后一项MFT，依据MFT头标志“46494C45”来搜索。这个地方要注意一些技巧，要先估计MFT的大小（一般300G的分区MFT应该不超过100M，当然特殊情况例外），然后相对0号MFT向后跳转估计大小的扇区，向上搜索最后一项MFT。由最后一项MFT即可确定MFT的簇数，从而确定结束的VCN。 第三、属性体的大小。由簇数×每簇扇区数×每扇区字节数，即可得到属性体的大小。 第四、DATARUN数据。包含簇数和起始簇号，这在前面已经算出来了，只需要转换成16进制填入即可。 当然，为了方便起见，用模板填写更容易。 这四步做完后，保存退出，然后重新加载，即可在winhex中看到找回的数据，原来的MFT记录在31号（XP系统）或255号（WIN7系统）之前是看不到的。当然在分区中还是没有数据，把这些数据导出保存（为了保险起见）。为什么在分区中没有数据呢？因为我们只修改了0号MFT，1——31号或1——255号MFT没有修改，手工修改太麻烦了，这时我们可用磁盘管理工具CHKDSK来帮忙，在运行中输入“CHKDSK G：/F”(G:表示要恢复数据分区的盘符），重新加载后，即可在分区中看到消失的数据又回来了（有一小部分数据没有回来，可在winhex中导出） </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/NTFS/window/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/NTFS/window/</guid>
      <description>偶然发现两个注册表分支中含有当前用户运行过的exe文件名，会在一定程度上造成信息泄露（仅在Windows10系统中测试过）
HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Compatibility AssistantHKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FeatureUsage\AppSwitched chkdsk d: /r
OSK.EXE 屏幕键盘 “osk.exe” 在命令提示符窗口输入&amp;quot;explorer.exe&amp;quot;启动桌面,成功进入SYSTEM账户桌面后按下“微软键+R&amp;quot;打开运行框,点击其中的“浏览&amp;quot; ,在打开的图形化窗口即可进行文件查找、浏览等操作</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/NTFS/Windows-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/NTFS/Windows-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>分区表 转载自：嘿_lele链接：https://www.jianshu.com/p/8471b7f4152a来源：简书 1、硬盘基础知识 硬盘上的一个物理记录块要用三个参数来定位：柱面号、扇区号、磁头号。
磁头数(Heads)： 表示硬盘总共有几个磁头,也就是有几面盘片， 最大为 255 (用 8 个二进制位存储)；
磁道： 当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。
扇区数(Sectors)： 磁盘上的每个磁道被等分为若干个弧段，这些弧段便是磁盘的扇区，表示每一条磁道上有几个扇区, 最大为 63(用 6个二进制位存储)；每个扇区一般是 512个字节，理论上讲这不是必须的，但（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）。距离轴心近的磁道上包含的扇区比远的磁道要少很多
柱面数（Cylinders）： 是指硬盘多个盘片上相同磁道的组合，盘片上的同心圆（磁道）圈数即是柱面数。表示硬盘每一面盘片上有几条磁道；硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。当向一个磁盘读写数据的时候,如果是连续IO,磁盘会比较倾向于按照柱面来进行,因为写完一个盘片的磁道,切换到另外一个盘片的相同磁道,只需要切换磁头就可以了,如果是连续在一个盘片上写几个磁道,就涉及到磁臂换道,这个是机械动作 ,就慢的多了,如果是离散IO,那磁臂基本就像振动的蜜蜂翅膀.
低级格式化: 磁盘生产出来的时候,上面是没有什么磁道,扇区的东西的,低级格式化就是在每个盘片上划分,标明这些东西,而高级格式化,比如 WINDOWS 里面的格式化,他是绝对不会影响一个磁盘的磁道,扇区结构的,这好比低级格式化是造房子,打框架,高级格式化是给房子里面做装潢
磁盘容量计算： 所以磁盘一柱面：512byte x 63 x 255＝8225280bytes ＝7.84423828125 MB
硬盘容量 = 磁头数 × 柱面数（磁道数）× 扇区数 × 512字节，扇区越多，容量越大。
块/簇： 磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。通俗的来讲，在 Windows 下如 NTFS 等文件系统中叫做簇；在 Linux 下如 Ext4 等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区
2、扇区、块/簇、page 的关系 扇区： 硬盘的最小读写单元 块/簇： 是操作系统针对硬盘读写的最小单元 page： 是内存与操作系统之间操作的最小单元。 扇区 &amp;lt;= 块/簇 &amp;lt;= page 3、分区表基础知识 分区表是将大表的数据分成称为分区的许多小的子集，类型有 FAT32, NTFST32,NTFS。另外，分区表的种类划分主要有：range，list，和hash分区。划分依据主要是根据其表内部属性。同时，分区表可以创建其独特的分区索引。倘若硬盘丢失了分区表，数据就无法按顺序读取和写入，导致无法操作。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%BC%80%E5%90%AF%E5%90%AF%E5%8A%A8%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/4Operating-System/%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%BC%80%E5%90%AF%E5%90%AF%E5%8A%A8%E9%A1%B9/</guid>
      <description>注册表开启启动项 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
一、经典的启动——“启动”文件夹
单击“开始→程序”，你会发现一个“启动”菜单，这就是最经典的Windows启动位置，右击“启动”菜单选择“打开”即可将其打开，其中的程序和快捷方式都会在系统启动时自动运行。
二、有名的启动——注册表启动项
注册表是启动程序藏身之处最多的地方，主要有以下几项：
1.Run键
Run键是病毒最青睐的自启动之所，该键位置是[HKEY_CURRENT_ USER\Software\Microsoft\Windows\CurrentVersion\Run]和[HKEY_ LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run]，其下的所有程序在每次启动登录时都会按顺序自动执行。
还有一个不被注意的Run键，位于注册表[HKEY_CURRENT_ USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run]和[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion
Policies\Explorer\Run]，也要仔细查看。
2.RunOnce键
RunOnce位于[HKEY_CURRENT_USER\Software\Microsoft\Windows
CurrentVersion\RunOnce]和[HKEY_LOCAL_MACHINE\Software\Microsoft
Windows\CurrentVersion\RunOnce]键，与Run不同的是，RunOnce下的程序仅会被自动执行一次。
3.RunServicesOnce键
RunServicesOnce键位于[HKEY_CURRENT_USER\Software\Microsoft
Windows\CurrentVersion\RunServicesOnce]和[HKEY_LOCAL_MACHINE
Software\Microsoft\Windows\CurrentVersion\RunServicesOnce]下，其中的程序会在系统加载时自动启动执行一次。
4.RunServices键
RunServices继RunServicesOnce之后启动的程序，位于注册表[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices]和[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion
RunServices]键。
5.RunOnceEx键
该键是Windows XP/2003特有的自启动注册表项，位于[HKEY_ CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx]和[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx]。
6.load键 [HKEY_CURRENT_USER\Software\Microsoft\WindowsNT\CurrentVersion\Windows]下的load键值的程序也可以自启动。
7.Winlogon键
该键位于位于注册表[HKEY_CURRENT_USER\SOFTWARE
Microsoft\Windows NT\CurrentVersion\Winlogon]和[HKEY_LOCAL_MACHINE
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]，注意下面的Notify、Userinit、Shell键值也会有自启动的程序，而且其键值可以用逗号分隔，从而实现登录的时候启动多个程序。
8.其他注册表位置
还有一些其他键值，经常会有一些程序在这里自动运行，如：[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\System\Shell] [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad] [HKEY_CURRENT_USER\Software\Policies\Microsoft\Windows\System\Scripts] [HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\System\Scripts]
小提示：
注册表的[HKEY_LOCAL_MACHINE]和[HKEY_CURRENT_USER]键的区别：前者对所有用户有效，后者只对当前用户有效。
三、古老的启动——自动批处理文件
从DOS时代过来的朋友肯定知道autoexec.bat（位于系统盘根目录）这个自动批处理文件，它会在电脑启动时自动运行，早期许多病毒就看中了它，使用deltree、format等危险命令来破坏硬盘数据。如“C盘杀手”就是用一句“deltree /y c:*.*”命令，让电脑一启动就自动删除C盘所有文件，害人无数。
小提示
★在Windows 98中，Autoexec.bat还有一个哥们——Winstart.bat文件，winstart.bat位于Windows文件夹，也会在启动时自动执行。 ★在Windows Me/2000/XP中，上述两个批处理文件默认都不会被执行。
四、常用的启动——系统配置文件
在Windows的配置文件（包括Win.ini、System.ini和wininit.ini文件）也会加载一些自动运行的程序。
1.Win.ini文件
使用“记事本”打开Win.ini文件，在[windows]段下的“Run=”和“LOAD=”语句后面就可以直接加可执行程序，只要程序名称及路径写在“＝”后面即可。
小提示
“load=”后面的程序在自启动后最小化运行，而“run=”后程序则会正常运行。
2.System.ini文件
使用“记事本”打开System.ini文件，找到[boot]段下“shell=”语句，该语句默认为“shell=Explorer.exe”，启动的时候运行Windows外壳程序explorer.exe。病毒可不客气，如“妖之吻”病毒干脆把它改成“shell=c:\yzw.exe”，如果你强行删除“妖之吻”病毒程序yzw.exe，Windows就会提示报错，让你重装Windows，吓人不？也有客气一点的病毒，如将该句变成“shell=Explorer.exe 其他程序名”，看到这样的情况，后面的其他程序名一定是病毒程序如图2所示。
3.wininit.ini
wininit.ini文件是很容易被许多电脑用户忽视的系统配置文件，因为该文件在Windows启动时自动执后会被自动删除，这就是说该文件中的命令只会自动执行一次。该配置文件主要由软件的安装程序生成，对那些在Windows图形界面启动后就不能进行删除、更新和重命名的文件进行操作。若其被病毒写上危险命令，那么后果与“C盘杀手”无异。
小提示
★如果不知道它们存放的位置，按F3键打开“搜索”对话框进行搜索； ★单击“开始→运行”，输入sysedit回车，打开“系统配置编辑程序”，在这里也可以方便的对上述文件进行查看与修改。
五、智能的启动——开/关机/登录/注销脚本
在Windows 2000/XP中，单击“开始→运行”，输入gpedit.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/5Computer-Networks/Computer-Networks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/5Computer-Networks/Computer-Networks/</guid>
      <description>computer networks</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/6Database/MySQL-%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/6Database/MySQL-%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/6Database/MySql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/6Database/MySql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>MySql 数据类型 一、MySQL的数据类型 主要包括以下五大类：
整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT
浮点数类型：FLOAT、DOUBLE、DECIMAL
字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB
日期类型：Date、DateTime、TimeStamp、Time、Year
其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection 等。
1、整数
类型 说明 存储需求（取值范围） tinyin 很小整数 1字节（[0~255]、[-128~127]）；255 = 2^8-1；127=2^7-1 smallint 小整数 2字节（[0~65535]、[-32768~32767]）；65535 = 2^16-1 mediumint 中等 3字节（[0~16777215]）；16777215 = 2^24-1 int(intege) 普通 4字节（[0~4294967295]）；4294967295 = 2^32-1 bigint 大整数 8字节（[0~18446744073709551615]）；18446744073709551615 = 2^64-1 注： 取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。
2、浮点数&amp;amp;定点数
类型 说明 存储需求（取值范围） float(m,d) 单精度浮点数 4字节(8位精度) m总个数，d小数位 double(m,d) 双精度浮点数 8字节(16位精度) m总个数，d小数位 decimal(m,d) 压缩的“严格”定点数 m&amp;lt;65 ，d&amp;lt;30 注： 定点数以字符串形式存储，对精度要求高时使用decimal较好；尽量避免对浮点数进行减法和比较运算。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/6Database/%E7%BF%BB%E8%AF%91-Mysql-%E7%9A%84-API-%E4%B9%8B%E9%AB%98%E4%BD%8E%E7%89%88%E6%9C%ACMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A-springboot-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/6Database/%E7%BF%BB%E8%AF%91-Mysql-%E7%9A%84-API-%E4%B9%8B%E9%AB%98%E4%BD%8E%E7%89%88%E6%9C%ACMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A-springboot-%E9%85%8D%E7%BD%AE/</guid>
      <description>高低版本MySQL数据库的 springboot 配置 1、概述 MySQL为使用MySQL Connector / J的Java编程语言开发的客户端应用程序提供连接。Connector /J实现了Java数据库连接（JDBC）API，以及它的许多增值扩展。它还支持新的X DevAPI。
MySQL Connector / J是JDBC Type 4驱动程序。可以使用与JDBC 3.0和 JDBC 4.2规范兼容的不同版本 （请参阅 第2章，Connector / J版本以及它们支持的MySQL和Java版本）。Type 4标识表示驱动程序是MySQL协议的纯Java实现，不依赖于MySQL客户端库。
对于使用通用设计模式的数据访问的大型程序，请考虑使用一种流行的持久性框架，如 Hibernate，Spring的JDBC模板或MyBatis SQL Maps，以减少用于调试，调整，保护和调试的JDBC代码量。保持。
2、版本差异 目前有两个MySQL Connector / J版本可用：
Connector / J 8.0（以前的Connector / J 6.0; 有关版本号更改的说明，请参阅 MySQL Connector / J 8.0.7中的更改）是Java 8平台的Type 4纯Java JDBC 4.2驱动程序。它提供了与MySQL 5.5,5.6,5.7和8.0的所有功能的兼容性。Connector / J 8.0提供了易于开发的功能，包括使用Driver Manager自动注册，标准化有效性检查，分类SQLExceptions，支持大量更新计数，支持包中的本地和偏移日期时间变体java.time ，支持JDBC-4 .x XML处理，支持每个连接客户端信息，并支持 NCHAR， NVARCHAR和 NCLOB数据类型。
Connector / J 5.1也是Type 4纯Java JDBC驱动程序，符合JDBC 3.0,4.0,4.1和4.2规范。它提供了与MySQL 5.5,5.6,5.7和8.0的所有功能的兼容性。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/Computer-Science/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/Computer-Science/</guid>
      <description>Computer Science 标签：计算机科学、《数据结构》、《计算机网络》、《计算机组成原理》、《计算机操作系统》、《离散数学》、《线性代数》、《编译原理》、《数据库原理》、《软件工程》、《软件系统设计》 时间：2020年8月7日17:33:00 连接：http://www.saveload.cn/html/templates/Thinking-In-Java.mk 清华课程表</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/Shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/Shell/</guid>
      <description>Shell Shell 的最通用含义是指用户用来键入命令的任何程序。shell 隐藏基础操作系统的详细信息，并管理操作系统的 应用程序编程接口（API） 的技术详细信息，该接口是在该操作系统上运行的程序使用的操作系统的级别。
在类Unix操作系统中，用户通常有许多命令行解释器可供选择，用于交互式会话。当用户以交互方式登录系统时，shell 程序将在会话期间自动执行。shell的类型，可以为每个用户定制，通常存储在用户的配置文件中，例如在本地passwd文件或分布式配置系统（如NIS或LDAP）中;但是，用户可以交互方式执行任何其他可用的 shell。 在具有窗口系统的主机（如 macOS）上，某些用户可能永远不会直接使用 shell。在Unix系统上，shell历来是系统启动脚本的实现语言，包括启动窗口系统，配置网络和许多其他基本功能的程序。但是，一些系统供应商已经用不同的方法（如 systemd）取代了传统的基于 shell 的启动系统（init）。
Shell 在计算中，shell 是一种计算机程序，它将操作系统的服务公开给人类用户或其他程序。通常，操作系统 shell 使用命令行界面 （CLI） 或图形用户界面 （GUI），具体取决于计算机的角色和特定操作。它被命名为shell，因为它是操作系统周围的最外层。
命令行 shell 要求用户熟悉命令及其调用语法，并了解有关特定于 shell 的脚本语言（例如 bash）的概念。
Shell 概述 操作系统为其用户提供各种服务，包括文件管理、进程管理（运行和终止应用程序）、批处理以及操作系统监视和配置。
大多数操作系统 shell 都不是底层内核的直接接口，即使 shell 通过直接连接到计算机的外围设备与用户通信也是如此。Shell 实际上是特殊的应用程序，它们使用内核 API 的方式与其他应用程序使用内核 API 的方式相同。shell 通过提示用户输入、解释其输入，然后处理来自底层操作系统的输出（非常类似于读取-评估-打印循环，REPL）来管理用户与系统的交互。由于操作系统shell实际上是一个应用程序，对于大多数操作系统来说，它可以很容易地被另一个类似的应用程序所取代。
除了在本地系统上运行的 shell 之外，还有不同的方法可以使本地用户可以使用远程系统。这种方法通常称为远程访问或远程管理。最初在多用户大型机上可用，通过串行线路或调制解调器连接到大型机的文本终端同时为每个活动用户提供基于文本的UI，远程访问已扩展到类Unix系统和Microsoft Windows。在类Unix系统上，Secure Shell协议通常用于基于文本的shell，而SSH隧道可用于基于X Window系统的图形用户界面（GUI）。在Microsoft Windows上，Remote Desktop Protocol可用于提供GUI远程访问，并且由于Windows Vista，PowerShell Remote可用于通过WMI，RPC和WS-Management进行基于文本的远程访问。
大多数操作系统 shell 都属于以下两类之一：命令行和图形。命令行 shell 为操作系统提供命令行界面 （CLI），而图形 shell 提供图形用户界面 （GUI）。其他可能性虽然不那么常见，但包括语音用户界面和非 CLI 的基于文本的用户界面 （TUI） 的各种实现。基于 CLI 和 GUI 的 shell 的相对优点经常引起争论。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/SSH/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/SSH/</guid>
      <description>SSH 介绍、基本使用及原理 什么是 SSH ？ 先搬 Wikipedia:
安全外壳协议 （SSH） 是一种加密网络协议，用于在不安全的网络上安全地操作网络服务。 它最值得注意的应用是远程登录和命令行执行。
SSH 应用程序基于客户端-服务器体系结构，将 SSH 客户端实例与 SSH 服务器连接起来。SSH 作为一个分层协议套件运行，由三个主要的分层组件组成：传输层提供服务器身份验证，机密性和完整性;用户身份验证协议验证用户到服务器;并且连接协议将加密隧道多路复用到多个逻辑通信通道中。
SSH 是在类 Unix 操作系统上设计的，作为 Telnet 和不安全的远程 Unix shell 协议的替代品，例如 Berkeley Remote Shell（rsh）以及相关的 rlogin 和 rexec 协议，它们都使用不安全的，明文的身份验证令牌传输。
SSH 最初由芬兰计算机科学家 Tatu Ylönen 于 1995 年设计。协议套件的后续开发在几个开发人员组中进行，产生了几种实现变体。该协议规范区分了两个主要版本，称为 SSH-1 和 SSH-2 。最常实现的软件堆栈是 OpenSSH，由 OpenBSD 开发人员于 1999 年作为开源软件发布。实现适用于常用的所有类型的操作系统，包括嵌入式系统。
定义 SSH 使用公钥加密对远程计算机进行身份验证，并允许它在必要时对用户进行身份验证。 SSH 可用于多种方法。以最简单的方式，通信通道的两端使用自动生成的公钥-私钥对对网络连接进行加密，然后使用密码对用户进行身份验证。
当用户手动生成公钥-私钥对时，身份验证实质上是在创建密钥对时执行的，然后可以在没有密码提示的情况下自动打开会话。在这种情况下，公钥放置在所有计算机上，这些计算机上必须允许访问匹配私钥的所有者，该所有者保持私有。虽然身份验证基于私钥，但在身份验证期间，密钥永远不会通过网络传输。SSH 仅验证提供公钥的同一个人是否也拥有匹配的私钥。
在所有版本的 SSH 中，在接受未知公钥为有效之前，验证未知公钥（即将公钥与身份相关联）非常重要。未经验证接受攻击者的公钥将授权未经授权的攻击者为有效用户。
用法 SSH通常用于登录到远程计算机并执行命令，但它也支持隧道，转发TCP端口和X11连接;它可以使用关联的 SSH 文件传输 （SFTP） 或安全复制 （SCP） 协议传输文件。 SSH 使用客户端-服务器模型。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/2Computer-Science/UnicodeUTF-8UTF-16/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/2Computer-Science/UnicodeUTF-8UTF-16/</guid>
      <description> Unicode、UTF-8、UTF-16 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/About_System_Gc_And_Finalize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/About_System_Gc_And_Finalize/</guid>
      <description>转：关于system.gc()与finalize()方法 注：本文的目的并不是鼓励使用finalize方法，而是大致理清其作用、问题以及GC执行finalize的过程。
1、finalize的作用 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题] 2、finalize的问题 一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法 System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们 Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行 finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) 3、finalize的执行过程(生命周期) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。 具体的finalize流程： 对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下： unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的 finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行 finalized: 表示GC已经对该对象执行过finalize方法 reachable: 表示GC Roots引用可达 finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达 unreachable：对象不可通过上面两种途径可达 状态变迁图： 变迁说明： 新建对象首先处于[reachable, unfinalized]状态(A) 随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态 若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。 在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N) 处于finalizable状态的对象不能同时是unreachable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因 程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为 若JVM检测到finalized状态的对象变成unreachable，回收其内存(I) 若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O） 注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法 4、一些代码示例 对象复活 public class GC { public static GC SAVE_HOOK = null; public static void main(String[] args) throws InterruptedException { SAVE_HOOK = new GC(); SAVE_HOOK = null; System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Apache-Flink/Apache-Flink/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Apache-Flink/Apache-Flink/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Apache-Shiro/Apache-Shiro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Apache-Shiro/Apache-Shiro/</guid>
      <description>Apache Shiro Apache Shiro（发音为“shee-roh”，日语中的&amp;rsquo;castle&amp;rsquo;）是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理，并可用于保护任何应用程序。
核心概念：Subject, SecurityManager, and Realms Subject Subject这个词是一个安全术语，基本上是指“当前正在执行的用户”。它只是不被称为“用户”，因为“用户”这个词通常与人类有关。在安全的世界，术语“主题”可以指一个人，但也有可能是会谈进程，守护进程帐户，或任何类似。它只是意味着“当前与软件交互的东西”。可以将其视为Shiro的“用户”概念。可以在代码中的任何位置轻松获取Shiro Subject。
例如：
import org.apache.shiro.subject.Subject;import org.apache.shiro.SecurityUtils;...Subject currentUser = SecurityUtils.getSubject(); 获得 Subject 后，您可以立即访问当前用户希望使用Shiro执行的所有操作的90％，例如登录，注销，访问其会话，执行授权检查等等
SecurityManager 安全管理器 Subject 的“幕后”对应物是SecurityManager。当Subject表示当前用户的安全操作时，SecurityManager管理所有用户的安全操作。它是Shiro架构的核心，充当一种“伞形”对象，它引用了许多形成对象图的内部嵌套安全组件。但是，一旦配置了SecurityManager及其内部对象图，通常就会将其保留，应用程序开发人员几乎将所有时间花在Subject API上。
Realms Shiro的第三个也是最后一个核心概念是一个领域。Realm充当Shiro与应用程序安全数据之间的“桥接”或“连接器”。也就是说，当实际与安全相关的数据（如用户帐户）进行交互以执行身份验证（登录）和授权（访问控制）时，Shiro会从为应用程序配置的一个或多个领域中查找许多这些内容。
从这个意义上讲，Realm本质上是一个特定于安全性的DAO：它封装了数据源的连接细节，并根据需要使相关数据可用于Shiro。配置Shiro时，必须至少指定一个Realm用于身份验证和/或授权。可以配置多个Realm，但至少需要一个。
Shiro提供了开箱即用的Realms，可以连接到许多安全数据源（也称为目录），如LDAP，关系数据库（JDBC），文本配置源（如INI和属性文件等）。如果默认域不符合您的需要，您可以插入自己的Realm实现来表示自定义数据源。
认证 身份验证是验证用户身份的过程。也就是说，当用户使用应用程序进行身份验证时，他们证明他们实际上是他们所说的人。这有时也被称为“登录”。这通常是一个三步过程。
收集用户的标识信息，称为主体，并支持身份证明，称为凭证。 将主体和凭据提交给系统。 如果提交的凭据与系统对该用户标识（主体）的期望值匹配，则认为该用户已通过身份验证。如果它们不匹配，则不会将用户视为已通过身份验证。 Shiro有一个以 Subject 为中心的API - 几乎所有你在运行时用Shiro做的事都是通过与当前正在执行的 Subject 进行交互来实现的。因此，要登录 Subject ，只需调用其登录方法，传递一个AuthenticationToken实例，该实例表示提交的主体和凭据（在本例中为用户名和密码）。
例如：
//1. Acquire submitted principals and credentials:AuthenticationToken token =new UsernamePasswordToken(username, password);//2. Get the current Subject:Subject currentUser = SecurityUtils.getSubject();//3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/CGLIBCode-Generation-Library-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/CGLIBCode-Generation-Library-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/error/</guid>
      <description>error.md
shardingsphere sql distinct 关键字支持异常， 当一个分库有数据，一个分库无数据时，会有异常。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/FreeMarker/FreeMarker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/FreeMarker/FreeMarker/</guid>
      <description> FreeMarker 什么是 FreeMarker? FreeMarker 是一款 模板引擎： 即一种基于模板和要改变的数据， 并用来生成输出文本(HTML网页，电子邮件，配置文件，源代码等)的通用工具。 它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。
模板编写为FreeMarker Template Language (FTL)。它是简单的，专用的语言， 不是 像PHP那样成熟的编程语言。 那就意味着要准备数据在真实编程语言中来显示，比如数据库查询和业务运算， 之后模板显示已经准备好的数据。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。
模板开发指南 入门 本章内容只是对 FreeMarker 进行简略的介绍，在后续章节中将会详细展开讲述。 不过没有关系，在阅读了本章节的内容后，就能够编写简单，但却很有用的FreeMarker模板程序了。
模板 + 数据模型 = 输出 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Canvas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Canvas/</guid>
      <description>使用 Canvas 画布 总览 JavaFX Canvas API提供了可以写入的自定义纹理。它是由类中定义Canvas并GraphicsContext在javafx.scene.canvas包中。使用此API涉及创建一个Canvas对象，获取其对象，GraphicsContext并调用绘图操作以在屏幕上呈现您的自定义形状。因为Canvas是Node子类，所以可以在JavaFX scene （场景图）中使用它。
Canvas Canvas 是可以使用GraphicsContext。提供的图形命令集绘制的图像。
一个 Canvas节点被构造成具有宽度和高度，指定到其中的画布绘图命令被描绘的图像的大小。所有绘图操作都被裁剪到该图像的边界。
GraphicsContext Canvas canvas = new Canvas(300, 250); GraphicsContext gc = canvas.getGraphicsContext2D(); This class is used to issue draw calls to a Canvas using a buffer. 此类用于使用缓冲区向画布发出绘制调用。 Each call pushes the necessary parameters onto the buffer where they will be later rendered onto the image of the Canvas node by the rendering thread at the end of a pulse.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFx-Cheat-Sheets-JavaFx-%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFx-Cheat-Sheets-JavaFx-%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>JavaFx Cheat Sheets （JavaFx 速查表) 1、舞台(Stage)，场景(Scene)，容器(Container)，布局(Layout )和控件(Controls)之间的关系：
在JavaFX中，Stage是应用程序窗口，其中包含称为Scene的空间。 Scene包含界面的组件，如Button，Text，…或容器。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Scene/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Scene/</guid>
      <description>Scene Graph 总览 Scene Graph (场景图)是一种类似树的数据结构，其中树中的每个项目都有零个或一个父级和零个或多个子级。
此软件包中的两个主要类是：
Scene–定义要渲染的场景。它包含一个fill变量，指定场景的背景，width并height指定场景的大小的变量，以及content包含的“root”的列表序列Nodes将被渲染到场景上。此序列Nodes是为此的场景图Scene。将A Scene呈现到Stage，这是JavaFX内容的顶级容器。 Node–场景图中所有节点的抽象基类。每个节点要么是不具有子节点的“叶”节点，要么是具有零个或多个子节点的“分支”节点。树中的每个节点都有零个或一个父节点。场景图中每个树中只有一个节点将没有父节点，这通常称为“根”节点。场景图中可能有几棵树。有些树可能是的一部分Scene，在这种情况下，它们有资格显示。其他树木可能不属于任何树木Scene。 分支节点是其类型Parent或子类。
叶节点的类，如 Rectangle，Text， ImageView，MediaView，或其他这样的叶类，其不能具有子。
一个节点最多可以在场景图中的任何位置出现一次。具体来说，一个节点在a的子代列表中Parent或作为a的剪辑 必须出现不超过一次Node。有关Node这些限制的更多详细信息，请参见该类。
JavaFX Scene Graph提供了使用CSS（级联样式表）对节点进行样式设置的功能。
Scene JavaFX Scene类是场景图中所有内容的容器。场景的背景按照fill属性指定的方式填充。 应用程序必须Node通过设置root属性来指定场景图的根。如果将a Group用作根，则场景图的内容将被场景的宽度和高度限制，并且更改场景的大小（如果用户调整舞台的大小）将不会更改场景图的布局。如果将可调整大小的节点（布局Region或 Control）设置为根，则根的大小将跟踪场景的大小，从而根据需要中继内容。
场景的大小可以在构建过程中由应用程序初始化。如果未指定大小，则场景将根据其内容的首选大小自动计算其初始大小。如果仅指定一个维度，则考虑到根的内容偏差，使用指定的维度来计算另一个维度。
应用程序可以在创建时请求深度缓冲区支持或场景抗锯齿支持Scene。仅具有2D形状且没有任何3D变换的场景不需要深度缓冲区，也不需要场景抗锯齿支持。包含3D形状或具有3D变换的2D形状的场景可以使用深度缓冲区支持来进行适当的深度排序渲染。为了避免进行深度战斗（也称为Z战斗），请对没有3D变换的2D形状禁用深度测试。请参阅 depthTest以获取更多信息。具有3D形状的场景可以启用场景抗锯齿功能以提高其渲染质量。
depthBuffer和antiAliasing标志是条件功能。分别具有默认值：false和SceneAntialiasing.DISABLED。请参阅ConditionalFeature.SCENE3D 以获取更多信息。
默认的头灯将添加到包含一个或多个Shape3D节点但不包含任何灯光节点的场景中 。该光源 Color.WHITE PointLight放置在相机位置。
Scene可以在任何线程上创建和修改 A ，直到将其附加到Window上showing。之后，必须仅在JavaFX Application Thread上对其进行修改。注意这Scene不是线程安全的。同时修改Scene多个线程上的a 会导致无法预料的结果，因此必须避免。
JavaFX应用程序线程是在JavaFX运行时启动过程中创建的。有关更多信息，请参见Application类和Platform.startup(Runnable)方法。
Group 一个Group节点包含一个ObservableList的子节点，每当渲染该节点时，这些子节点就会按顺序渲染。 A Group将承担其子代的集体责任，并且不能直接调整其大小。
应用于的任何变换，效果或状态Group都将应用于该组的所有子级。此类变换和效果将不包括在该组的布局范围内，但是，如果直接在该组的子级上设置变换和效果，则这些变换和效果将包括在该组的布局范围内。
默认情况下，a Group将在布局遍历期间将其可调整大小的子控件“自动调整大小”到其首选大小，以确保在区域和控件状态改变时调整其大小。如果应用程序需要禁用此自动调整大小行为，则应将其设置 autoSizeChildren为false并了解，如果子级的首选大小发生更改，则它们将不会自动调整大小（因此请当心！）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Stage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Stage/</guid>
      <description>JavaFX Stage 舞台 总览 JavaFX Stage .类是顶级JavaFX容器。初级阶段由平台构建。Application 可以构造Stage对象。
Stage 对象必须在JavaFX Application Thread上构造和修改。
The JavaFX Application Thread is created as part of the startup process for the JavaFX runtime.
JavaFX Application Thread 是在JavaFX运行时启动过程中创建的。
许多 Stage 属性是只读的，因为它们可以由基础平台在外部进行更改，因此不能绑定。
样式 Stage 具有以下样式之一：
StageStyle.DECORATED -具有纯白色背景和平台装饰的舞台。 StageStyle.UNDECORATED -具有纯白色背景且没有装饰的舞台。 StageStyle.TRANSPARENT -具有透明背景且没有装饰的舞台。 StageStyle.UTILITY -具有纯白色背景和最少平台装饰的舞台。 必须先初始化样式，然后才能使舞台可见。
在某些平台上，装饰可能不可用。例如，在某些移动或嵌入式设备上。在这些情况下，将接受对DECORATED或UTILITY窗口的请求，但不会显示任何装饰。
所有者 A stage can optionally have an owner Window. When a window is a stage&amp;rsquo;s owner, it is said to be the parent of that stage.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Transformations-Animations-and-Visual-Effects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX-Transformations-Animations-and-Visual-Effects/</guid>
      <description>JavaFX: Transformations, Animations, and Visual Effects JavaFX：转换，动画和视觉效果
1、转换概述 所有转换都位于javafx.scene.transform 包中，并且是Transform该类的子类。
Introducing Transformations 变换 介绍 转换会根据某些参数更改图形对象在坐标系中的位置。JavaFX支持以下类型的转换：
Translation 转换 Rotation 回转 Scaling 缩放比例 Shearing 剪力 These transformations can be applied to either a standalone node or to groups of nodes. You can apply one transformation at a time or you can combine transformations and apply several transformations to one node. 这些变换可以应用于独立节点或节点组。您可以一次应用一个变换，也可以组合转换并将多个变换应用于一个节点。
The Transform class implements the concepts of affine transformations. The Affine class extends the Transform class and acts as a superclass to all transformations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFx/</guid>
      <description>JavaFX架构 JavaFX公共API下方是运行JavaFX代码的引擎。它由子组件组成，这些子组件包括JavaFX高性能图形引擎Prism；一个小型高效的窗口系统，称为Glass；媒体引擎和Web引擎。尽管这些组件没有公开公开，但是它们的描述可以帮助您更好地了解运行JavaFX应用程序的组件。
Scene Graph 场景图 Java Public APIs for JavaFX Features 用于JavaFX功能的Java公共API Graphics System 图形系统 Glass Windowing Toolkit 玻璃窗工具包 Media and Images 媒体和图片 Web Component Web组件 CSS CSS引擎 UI Controls UI控件 Layout 布局 2-D and 3-D Transformations 2D和3D转换 Visual Effects 视觉效果 JavaFX体系结构图 JavaFX体系结构图显示了堆栈。顶层显示在一个圆形的栗色框中，表示JavaFX公共API和JavaFX场景图。下一层是圆形的蓝色框中的Quantum Toolkit。第三层在一个圆形的蓝色框中具有称为Prism的图形管道，在一个方形的豌豆绿色框中具有一个玻璃窗口工具包（Glass），在一个方形的鲜绿色框中具有媒体引擎，在一个方形的棕色框中具有Web引擎。第四层由圆形的蓝色框中的Java 2D，OpenGL和Direct3D（D3D）组成。均以圆形蓝色框显示的Quantum Toolkit，Prism，Java 2D，OpenGL和D3D组成了JavaFX图形系统。最低层（以浅紫色显示）是Java虚拟机。Java虚拟机位于JavaFX图形系统，Glass Windowing Toolkit，媒体引擎和Web引擎的下面。
Scene Graph 场景图 如图2-1的顶层所示，JavaFX场景图是构建JavaFX应用程序的起点。它是节点的分层树，代表应用程序用户界面的所有可视元素。它可以处理输入并可以呈现。
场景图中的单个元素称为节点。每个节点都有一个ID，样式类和边界量。除了场景图的根节点之外，场景图中的每个节点都有一个父级和零个或多个子级。它还可以具有以下内容：
效果，例如模糊和阴影 不透明度 变身 事件处理程序（例如鼠标，键和输入法） 特定于应用程序的状态 与Swing和Abstract Window Toolkit（AWT）不同，JavaFX场景图除了具有控件，布局容器，图像和媒体之外，还包括图形基元，例如矩形和文本。
对于大多数用途，场景图简化了使用UI的工作，尤其是在使用丰富的UI时。使用javafx.animation API可以快速完成对场景图中的各种图形进行动画处理，并且声明性方法（例如XML doc）也可以很好地工作。
该javafx.scene API允许创建和指定多种类型的内容，例如：
节点：形状（2-D和3-D），图像，媒体，嵌入式Web浏览器，文本，UI控件，图表，组和容器 状态：内容的变换（节点的位置和方向），视觉效果以及其他视觉状态 效果：更改场景图节点外观的简单对象，例如模糊，阴影和颜色调整 有关更多信息，请参见使用JavaFX场景图文档。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%B5%85%E8%B0%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-FX/JavaFX%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%B5%85%E8%B0%88/</guid>
      <description>JavaFX游戏开发效率浅谈 这一段时间没事的时候把基于JavaFX的游戏引擎WJFXGameEngine的效率进行优化了一下(个人博客的示例并未重新上传)，简单的2D游戏，在我PC上运行最快可以达到750-800FPS。下面来简单谈谈JavaFX游戏开发上的一些基本问题。
看过JavaFX官方游戏示例BrickBreak的人都可以发现，这个游戏的绘制和逻辑是在Timeline中进行的。JavaFX中的Timeline根据我使用的经验来看，效率不是很高，而且如果数量过多，会很卡。在我游戏引擎中目前的简单的动画是用Timeline实现的，未来会做大改动。
而且之前的教程中，JavaFX简单的游戏框架中讲的也是是用的Timeline。这实际是个很严重的问题。被JavaFX官方示例误导了。
目前我的改动是，使用双线程，一个线程处理绘制，一个线程处理更新操作(这也是很多游戏引擎常用的做法，例如Android游戏引擎AndEngine)。当然，绘制处理必须要在JavaFX MainThread中运行，所以我们使用Platform.runLater来调用绘制操作。虽然它还是在主线程执行，但更新绘制的速度明显更快。之前做的JavaFX游戏示例中，经常出现子弹卡顿等现场，现在不会出现了。
drawThread = new Thread(new Runnable() {@Overridepublic void run() {while (isRunning) {try {Thread.sleep(waitTime);} catch (Exception e) {}Platform.runLater(new Runnable() {@Overridepublic void run() {draw(getGraphicsContext2D());}});if (fpsMaker != null) {fpsMaker.makeFPS();}}}});updateThread = new Thread(new Runnable() {@Overridepublic void run() {while (isRunning) {try {Thread.sleep(waitTime);} catch (Exception e) {}update();}}}); 这个是我的WScreen类里的代码。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-Lambda-Expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-Lambda-Expressions/</guid>
      <description>Lambda Expressions 匿名类的一个问题是，如果匿名类的实现非常简单（例如仅包含一个方法的接口），则匿名类的语法可能看起来笨拙且不清楚。在这些情况下，您通常试图将功能作为参数传递给另一种方法，例如，当某人单击按钮时应采取什么措施。Lambda表达式使您能够执行此操作，将功能视为方法参数，或将代码视为数据。
一个功能接口仅包含一个抽象方法，因此在实现该方法时可以省略该方法的名称。为此，您可以使用lambda表达式（而不是使用匿名类表达式）
Lambda 表达式 A lambda expression is like a method: it provides a list of formal parameters and a body - an expression or block - expressed in terms of those parameters. lambda表达式类似于一个方法:它提供了一个形式参数列表和一个主体(一个表达式或块)，后者根据这些参数进行表达。
LambdaExpression:LambdaParameters -&amp;gt; LambdaBody Lambda expressions are always poly expressions (§15.2). Lambda表达式总是poly表达式
It is a compile-time error if a lambda expression occurs in a program in someplace other than an assignment context (§5.2), an invocation context (§5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-Method-References/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-Method-References/</guid>
      <description>Java Method References Java 方法参考 使用 lambda表达式创建匿名方法。但是，有时lambda表达式除了调用现有方法外什么也不做。在这种情况下，通常更容易按名称引用现有方法。方法引用使您可以执行此操作；它们是紧凑，易于阅读的lambda表达式，用于已具有名称的方法。
再次考虑Lambda表达式Person部分中讨论的 类 ：
public class Person {public enum Sex {MALE, FEMALE}String name;LocalDate birthday;Sex gender;String emailAddress;public int getAge() {// ...}public Calendar getBirthday() {return birthday;} public static int compareByAge(Person a, Person b) {return a.birthday.compareTo(b.birthday);}} 假设您的社交网络应用程序的成员包含在一个数组中，并且您想按年龄对数组进行排序。您可以使用以下代码（在示例中找到本节中描述的代码摘录 MethodReferencesTest）：
Person[] rosterAsArray = roster.toArray(new Person[roster.size()]);class PersonAgeComparator implements Comparator&amp;lt;Person&amp;gt; {public int compare(Person a, Person b) {return a.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-Regular-Expression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-Regular-Expression/</guid>
      <description> Java Regular Expression 一些简单的就不写了
否定式前瞻 否定式向前查找，对于正则表达式引擎来说，因为它是从文本头部向尾部开始解析的（可以通过正则选项控制解析方向），因此对于文本尾部方向，称为“前”。
解决的问题： 正则表达式匹配不包含某些字符串的技巧
前瞻的语法是：： (?!匹配模式) 表达式如下： ((?!hede).)* 解释一下几个部分： 在正则表达式里， ?! 是否定式向前查找，它帮我们解决了字符串“不包含”匹配的问题。 表达式(?!hede).会往前查找，看看前面是不是没有“hede”字串，如果没有(是其它字符)，那么.(点号)就会匹配这些其它字符。这种正则表达式的“查找”也叫做“zero-width-assertions”(零宽度断言)，因为它不会捕获任何的字符，只是判断。 在上面的例子里，每个空字符都会检查其前面的字符串是否不是‘hede&amp;rsquo;，如果不是，这.(点号)就是匹配捕捉这个字符。表达式(?!hede).只执行一次，所以，我们将这个表达式用括号包裹成组(group)，然后用*(星号)修饰——匹配0次或多次： 以下是一些补充： // 1、多个 否定式前瞻配合 ((?!\})(?!&amp;#34;)(?!,&amp;#34;).)* // 2、多个 否定式前瞻配合，捕获 json 指定 key 的值。&amp;#34;sub_msg&amp;#34;:\s?\&amp;#34;?((?!\})(?!&amp;#34;)(?!,&amp;#34;).)* </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-Tags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-Tags/</guid>
      <description>Java Tags 标签：Java Tags 时间：2018年11月1日14:37:44 连接：http://www.saveload.cn/html/mood/2018/Java Tags.mk equals与==的区别 ==与equals的主要区别是：==常用于比较原生类型，而equals()方法用于检查对象的相等性。另一个不同的点是：如果==和equals()用于比较对象，当两个引用地址相同，==返回true。而equals()可以返回true或者false主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况==和equals()返回不同的结果。equals()方法最重要的一点是，能够根据业务要求去重写，按照自定义规则去判断两个对象是否相等。重写equals()方法的时候，要注意一下hashCode是否会因为对象的属性改变而改变，否则在使用散列集合储存该对象的时候会碰到坑！！理解equals()方法的存在是很重要的。
static： 接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量。 static修饰就表示它属于类的，随的类的加载而存在的，当JVM把字节码加载进JVM的时候，static修饰的成员已经在内存中存在了。 如果是非static的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为static。
final： 接口中不可以定义变量即定义的变量前都要加上final修饰，使之成为常量(没有final修饰的是变量，加上final修饰就会变成常量)。 所以接口的属性默认是public static final 常量，且必须赋初值。（ final修饰就是保证接口定义的常量不能被实现类去修改，如果没有final的话，由子类随意去修改的话，接口建立这个常量就没有意义了。
this： this 这个关键字的最大作用就是让类中的一个方法，访问该类里的另一个方法或变量，
实体类别： Entity接近原始数据，Model接近业务对象～ Entity：是专用于EF的对数据库表的操作， Model：是为页面提供数据和数据校验的，所以两者可以并存 POJO：POJO是Plain OrdinaryJava Object的缩写不错，但是它通指没有使用Entity Beans的普通java对象，可以把POJO作为支持业务逻辑的协助类。
面向对象
面向对象设计：易于扩展、可复用、易维护、易构建复杂系统 （继承 支持了 复用，多态 支持了 扩展，封装 支持了 构建维护复用） “进行面向对象的设计时，一项基本的考虑是：如何将发生变化的东西与保持不变的东西分隔开。” 面向对象的一个主要特性就是隐藏实现（不去暴露非必要暴露的对象成员），即一个对象的成员的可访问范围是必须要进行控制的，而公开的通常是方法，通常的做法是将对象属性私有，通过 get、set 方法来获得对象的属性。 面向对象设计一条基本的准则是“为状态的变化使用数据成员，为行为的变化使用多性形”。（例如用属性记录图形的长宽高或直径，用多形性来指定画圆形还是画方形） 记住多形性只能通过方法调用才能表现出来 “多形性”（Polymorphism）从另一个角度将接口从具体的实施细节中分离出来，亦即实现了“是什么”与“怎样做”两个模块的分离。 “Upcasting”（上溯造型） 我们将从一个 衍生类 句柄转换成一个 基础类 句柄的行为叫作“上溯造型” 把衍生类型（子类）当作它的基本类型（父类）处理的过程叫作“Upcasting”（上溯造型）。 “下溯造型”（Downcasting） 继承、重载(overloaded )、重写、动态绑定 泛型 复用约束 示例：集合的泛型方法 论合成与继承 如果想利用新类内部一个现有类的特性，而不想使用它的接口，通常应选择合成。也就是说，我们可嵌入一个对象，使自己能用它实现新类的特性。但新类的用户会看到我们已定义的接口，而不是来自嵌入对象的接口。考虑到这种效果，我们需在新类里嵌入现有类的private对象。 “属于”或者“类似”关系是用继承来表达的，而“包含”关系是用合成来表达的。 继承 用来表达同一个系列不同种对象的行为间的差异。 句柄在运行期间可以重新与一个不同的对象绑定或结合起来,这样一来，我们在运行期间 通过改变句柄绑定的子类类型 就获得了很大的灵活性。与此相反，我们不能在运行期间换用不同的形式来进行继承；它要求在编译期间完全决定下来。 Logger 大家不要再在方法里写：System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-Util-Concurrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-Util-Concurrent/</guid>
      <description> Java Util Concurrent </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E4%B8%AD-Stream-%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E4%B8%AD-Stream-%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>Java 中 Stream 的用法 1、操作符 Stream的操作符大体上分为两种：中间操作符和终止操作符
1.1、中间操作符 对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。
中间操作符包含8种(排除了parallel,sequential,这两个操作并不涉及到对数据流的加工操作)
map(mapToInt,mapToLong,mapToDouble) 转换操作符，把比如A-&amp;gt;B，这里默认提供了转int，long，double的操作符。 flatmap(flatmapToInt,flatmapToLong,flatmapToDouble) 拍平操作比如把 int[]{2,3,4} 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。 limit 限流操作，比如数据流中有10个 我只要出前3个就可以使用。 distint 去重操作，对重复元素去重，底层使用了equals方法。 filter 过滤操作，把不想要的数据过滤。 peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。 skip 跳过操作，跳过某些元素。 sorted(unordered) 排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。 1.2、终止操作符 数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。
collect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的Collectors 提供了非常多收集器，可以说Stream 的核心在于Collectors。 count 统计操作，统计最终的数据个数。 findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为Optional。 noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为bool 值。 min、max 最值操作，需要自定义比较器，返回数据流中最大最小的值。 reduce 规约操作，将整个数据流的值规约为一个值，count、min、max底层就是使用reduce。 forEach、forEachOrdered 遍历操作，这里就是对最终的数据进行消费了。 toArray 数组操作，将数据流的元素转换成数组。 这里只介绍了Stream，并没有涉及到IntStream、LongStream、DoubleStream，这三个流实现了一些特有的操作符，我将在后续文章中介绍到。
public class Test { public static void main(String[] args) { // 1、对象属性 to Map Map&amp;lt;String, Integer&amp;gt; collect = detailList.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</guid>
      <description>分布式唯一ID生成方案 整个系统ID唯一 ID是数字类型，而且是趋势递增的 ID简短，查询效率快
1、UUID 优点：
代码实现简单。 本机生成，没有性能问题 因为是全球唯一的ID，所以迁移数据容易 缺点：
每次生成的ID是无序的，无法保证趋势递增 UUID的字符串存储，查询效率慢 存储空间大 ID本事无业务含义，不可读 应用场景：
类似生成token令牌的场景 不适用一些要求有趋势递增的ID场景 2、MySQL主键自增 这个方案就是利用了MySQL的主键自增auto_increment，默认每次ID加1。
优点：
数字化，id递增 查询效率高 具有一定的业务可读 缺点：
存在单点问题，如果mysql挂了，就没法生成iD了 数据库压力大，高并发抗不住 3、MySQL多实例主键自增 这个方案就是解决mysql的单点问题，在auto_increment基本上面，设置step步长 每台的初始值分别为1,2,3&amp;hellip;N，步长为N（这个案例步长为4）
优点：
解决了单点问题 缺点：
一旦把步长定好后，就无法扩容；而且单个数据库的压力大，数据库自身性能无法满足高并发 应用场景：
数据不需要扩容的场景 4、雪花 snowflake 算法 这个算法网上介绍了很多。雪花算法生成64位的二进制正整数，然后转换成10进制的数。64位二进制数由如下部分组成： 1位标识符：始终是0 41位时间戳：41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截 )得到的值，这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的 10位机器标识码：可以部署在1024个节点，如果机器分机房（IDC）部署，这10位可以由 5位机房ID + 5位机器ID 组成 12位序列：毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号 优点：
此方案每秒能够产生409.6万个ID，性能快 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序递增 灵活度高，可以根据业务需求，调整bit位的划分，满足不同的需求 缺点：
依赖机器的时钟，如果服务器时钟回拨，会导致重复ID生成 -在分布式场景中，服务器时钟回拨会经常遇到，一般存在10ms之间的回拨；小伙伴们就说这点10ms，很短可以不考虑吧。但此算法就是建立在毫秒级别的生成方案，一旦回拨，就很有可能存在重复ID。 5、Redis生成方案 利用redis的incr原子性操作自增，一般算法为：
年份 + 当天距当年第多少天 + 天数 + 小时 + redis自增
优点：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>Java 动态代理（Dynamic Proxy） 一、什么是代理？ 代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。
简单结构示意图： 为了保持行为的一致性，代理类和委托类通常会实现相同的接口，所以在访问者看来两者没有丝毫的区别。通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。Java 动态代理机制以巧妙的方式近乎完美地实践了代理模式的设计理念。
二、Java 动态代理类 Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个类：
(1)Interface InvocationHandler：该接口中仅定义了一个方法： public object invoke(Object obj,Method method, Object[] args) 在实际使用时，第一个参数obj一般是指代理类，method是被代理的方法，args为该方法的参数数组。这个抽象方法在代理类中动态实现。
(2)Proxy：该类即为动态代理类，其中主要包含以下内容： protected Proxy(InvocationHandler h)：构造函数，用于给内部的h赋值。static Class getProxyClass (ClassLoaderloader, Class[] interfaces)：获得一个代理类，其中loader是类装载器，interfaces是真实类所拥有的全部接口的数组。static Object newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)：返回代理类的一个实例，返回后的代理类（DynamicProxy）可以当作被代理类使用(可使用被代理类的在Subject接口中声明过的方法) 所谓代理类 DynamicProxy 是这样一种class：它是在运行时生成的 class，在生成它时你必须提供一组 interface 给它，然后该 class 就宣称它实现了这些 interface。你当然可以把该 class 的实例当作这些 interface 中的任何一个来用。当然，这 DynamicProxy 其实就是一个 Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个 handler ，由它接管实际的工作。
在使用动态代理类时，我们必须实现InvocationHandler接口
通过这种方式，被代理的对象(RealSubject)可以在运行时动态改变，需要控制的接口(Subject接口)可以在运行时改变，控制的方式(DynamicSubject类)也可以动态改变，从而实现了非常灵活的动态代理关系。
动态代理步骤： 创建一个实现接口InvocationHandler的类，它必须实现invoke方法 创建被代理的类以及接口 通过Proxy的静态方法 newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h)创建一个代理 通过代理调用方法 三、JDK的动态代理怎么使用？ 1、需要动态代理的接口： /*** 需要动态代理的接口*/public interface Subject{/*** 你好** @param name* @return*/public String SayHello(String name);/*** 再见** @return*/public String SayGoodBye();} 2、需要代理的实际对象： /*** 实际对象*/public class RealSubject implements Subject{/*** 你好** @param name* @return*/public String SayHello(String name){return &amp;#34;hello &amp;#34; + name;}/*** 再见** @return*/public String SayGoodBye(){return &amp;#34; good bye &amp;#34;;}} 3、调用处理器实现类（有木有感觉这里就是传说中的AOP啊） /*** 调用处理器实现类* 每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象*/public class InvocationHandlerImpl implements InvocationHandler{/*** 这个就是我们要代理的真实对象*/private Object subject;/*** 构造方法，给我们要代理的真实对象赋初值** @param subject*/public InvocationHandlerImpl(Object subject){this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</guid>
      <description>一、java的六种存储地址及解释1） 寄存器(register)：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。2） 堆栈(stack)：位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其中。 3）堆(heap)：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。 4）静态存储(static storage)：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。 5） 常量存储(constant storage)：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中。6） 非RAM存储：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。二、栈、堆、方法区存储的内容堆区: 1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。栈区: 1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 方法区: 1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 三、在Java语言里堆(heap)和栈(stack)里的区别 1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 3. Java中的数据类型有两种。 一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。 另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义 int a = 3; int b = 3； 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。 4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E5%B1%9E%E6%80%A7%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E8%AE%B0%E5%BD%95/</guid>
      <description>1、对象的内存布局 转载于知乎 刘缙 的回答
1、对象的内存布局： C/C++的内存布局： struct Point {float x;float y;float z;}; bytes field 4 x 4 y 4 z Java 的内存布局： bytes field 12 object header 4 x 4 y 4 z 2、嵌套对象的内存布局： C/C++的内存布局： struct Line {struct Point begin;struct Point end;}; bytes field 4 begin.x 4 begin.y 4 begin.z 4 end.x 4 end.y 4 end.z Java 的内存布局： 3、数组对象的内存布局： C/C++的内存布局： struct Point v[100]; bytes field 4 v[0].</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>Java 引用的是四种方式 java内存管理分为内存分配和内存回收，都不需要程序员负责，垃圾回收的机制主要是看对象是否有引用指向该对象。
java对象的引用包括 强引用，软引用，弱引用，虚引用
Java中提供这四种引用类型主要有两个目的：
第一是可以让程序员通过代码的方式决定某些对象的生命周期；
第二是有利于JVM进行垃圾回收。
下面来阐述一下这四种类型引用的概念：
１．强引用
是指创建一个对象并把这个对象赋给一个引用变量。
比如：
Object object =new Object();String str =&amp;#34;hello&amp;#34;; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
2.软引用（SoftReference）
如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；
如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。
软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。
SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。
也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。
另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。
举个栗子：
MyObject aRef = new MyObject(); SoftReference aSoftRef=new SoftReference(aRef); 此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。
随即，我们可以结束aReference对这个MyObject实例的强引用:
aRef = null; 此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，并不会因为有一个SoftReference对该对象的引用而始终保留该对象。
Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。
也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:
MyObject anotherRef=(MyObject)aSoftRef.get(); 重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。 使用ReferenceQueue清除失去了软引用对象的SoftReference：
使用ReferenceQueue清除失去了软引用对象的SoftReference：
作为一个Java对象，SoftReference对象除了具有保存软引用的特殊性之外，也具有Java对象的一般性。所以，当软可及对象被回收之后，虽然这个SoftReference对象的get()方法返回null,但这个SoftReference对象已经不再具有存在的价值，需要一个适当的清除机制，避免大量SoftReference对象带来的内存泄漏。在java.lang.ref包里还提供了ReferenceQueue。如果在创建SoftReference对象的时候，使用了一个ReferenceQueue对象作为参数提供给SoftReference的构造方法，如:
ReferenceQueue queue = new ReferenceQueue(); SoftReference ref=new SoftReference(aMyObject, queue); 那么当这个SoftReference所软引用的aMyOhject被垃圾收集器回收的同时，ref所强引用的SoftReference对象被列入ReferenceQueue。也就是说，ReferenceQueue中保存的对象是Reference对象，而且是已经失去了它所软引用的对象的Reference对象。另外从ReferenceQueue这个名字也可以看出，它是一个队列，当我们调用它的poll()方法的时候，如果这个队列中不是空队列，那么将返回队列前面的那个Reference对象。
在任何时候，我们都可以调用ReferenceQueue的poll()方法来检查是否有它所关心的非强可及对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。利用这个方法，我们可以检查哪个SoftReference所软引用的对象已经被回收。于是我们可以把这些失去所软引用的对象的SoftReference对象清除掉。常用的方式为:
SoftReference ref = null; while ((ref = (EmployeeRef) q.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E6%8A%80%E6%9C%AF%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E6%8A%80%E6%9C%AF%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>线程相关： 锁(sync和Lock) 、线程池 、异步计算、 一些相关概念： 重入锁 、轻量级锁 、重量级锁、 KClass对象头、 悲观锁 、乐观锁、 AQS原理和相关实现(并发集合/Lock) NIO相关(通信方面一定要了解[IO/NIO/AIO]) ：NIO模型 、NIO选择器、 xxxx 高并发的解决方案、 数据静态化 、缓存、 数据库集群 、负载均衡 、CDN加速、 设计模式和设计原则 、工厂模式、 代理模式 、组合模式、 开闭原则、
相关的分布式框架以及中间件 分布式任务调度框架 消息中间件(各种MQ) 分布式通信 常见的分布式框架 数据结构以及算法相关 没啥好说的，看看JCF就能应付一般的 基本的排序算法(冒泡，快排，归并) 二分查找/Top10/and so on 树的性质和相关操作 Spring相关
《数据结构和算法》：基础的知识
《深入java虚拟机》：同上。
《Java并发编程的艺术》：这本书对并发编程的常用知识点进行了系统的讲解，将的深度还可以，没有具体的案例。
《架构探险》：同上，这本书上对于我们理解Spring中的实现原理，还是有一定的帮助的。书中模仿Spring框架，写的 配置文件加载、类加载器、IOC的实现、AOP的实现还是有参考价值的。
《Redis实战》：现在用的越来越多了，不管用没用过，都可以学习一下。
《大型分布式网站架构设计与实践》：这本书从总体上讲解了大型网站架构常用的技术，不深入，对于从整体上认识 大型分布式网站还是很有参考价值的。如果我们想要在哪一方面深入学习，可以有针对性的进行深入学习。
《大型网站技术架构：核心原理与案例分析》：同上。
《Java程序员面试笔试宝典》：买这本书主要是找工作时，做一些题目，对于笔试来说，有针对性的学习复习一下。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB/</guid>
      <description>Java日志体系 转自： Alben
链接：https://albenw.github.io/posts/854fc091/
概要 本文的目的是搞清楚Java中各种日志Log之间是怎么的关系，如何作用、依赖，好让我们平时在工作中如果遇到“日志打不出”或者“日志jar包冲突”等之类的问题知道该如何入手解决，以及在各种场景下如何调整项目中的各个框架的日志输出，使得输出统一。
Log日志体系 在日常工作中我们可能看到项目中依赖的跟日志相关的jar包有很多，commons-logging.jar、log4j.jar、sl4j-api.jar、logback.jar等等，眼花缭乱。我们要正确的配置，使得jar包相互作用生效之前，就先要理清它们之间的关系。
背景/发展史 那就要从Java Log的发展历程开始说起。
log4j（作者Ceki Gülcü）出来时就等到了广泛的应用（注意这里是直接使用），是Java日志事实上的标准，并成为了Apache的项目 Apache要求把log4j并入到JDK，SUN拒绝，并在jdk1.4版本后增加了 JUL（java.util.logging） 毕竟是JDK自带的，JUL也有很多人用。同时还有其他日志组件，如SimpleLog等。这时如果有人想换成其他日志组件，如log4j换成JUL，因为api完全不同，就需要改动代码。 Apache见此，开发了 JCL（Jakarta Commons Logging），即commons-logging-xx.jar。它只提供一套通用的日志接口api，并不提供日志的实现。很好的设计原则嘛，依赖抽象而非实现。这样应用程序可以在运行时选择自己想要的日志实现组件。 这样看上去也挺美好的，但是log4j的作者觉得JCL不好用，自己开发出 slf4j，它跟JCL类似，本身不替供日志具体实现，只对外提供接口或门面。目的就是为了替代JCL。同时，还开发出 logback，一个比log4j拥有更高性能的组件，目的是为了替代log4j。 Apache参考了logback,并做了一系列优化，推出了 log4j2 关系/依赖 大概了解心路历程后，再详细看看它们之间的关系、依赖。
JCL commons-logging 已经停止更新，最后的状态如下所示：
JCL支持日志组件不多，不过也有很人用的，例如Spring 现在用的也越来越少了，也不多讲了
SLF4J 因为当时Java的日志组件比较混乱繁杂，Ceki Gülcü推出slf4j后，也相应为行业中各个主流日志组件推出了slf4j的适配
图来源于官方文档
图的意思为如果你想用slf4j作为日志门面的话，你如何去配合使用其他日志实现组件，这里说明一下（注意jar包名缺少了版本号，在找版本时也要注意版本之间是否兼容）
slf4j + logback slf4j-api.jar + logback-classic.jar + logback-core.jar slf4j + log4j slf4j-api.jar + slf4j-log4j12.jar + log4j.jar slf4j + jul slf4j-api.jar + slf4j-jdk14.jar 也可以只用slf4j无日志实现 slf4j-api.jar + slf4j-nop.jar SLF4J的适配 slf4j支持各种适配，无论你现在是用哪种日志组件，你都可以通过slf4j的适配器来使用上slf4j。 只要你切换到了slf4j，那么再通过slf4j用上实现组件，即上面说的。
图来源于官方文档
其实总的来说，无论就是以下几种情况
你在用JCL 使用jcl-over-slf4j.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E6%B3%9B%E5%9E%8BGenerics-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E6%B3%9B%E5%9E%8BGenerics-/</guid>
      <description>Java 泛型(Generics ) 1. 概述 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？
顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），
然后在使用/调用时传入具体的类型（类型实参）。
泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，
操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
2. 泛型的使用 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法
2.1. 泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。
泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：
class 类名称 &amp;lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&amp;gt;{private 泛型标识 /*（成员变量类型）*/ var; .....}} 2.1.1 一个最普通的泛型类： 例子：
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&amp;lt;T&amp;gt;{ //key这个成员变量的类型为T,T的类型由外部指定 private T key;public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定this.key = key;}public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定return key;}} 使用：
//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic&amp;lt;Integer&amp;gt; genericInteger = new Generic&amp;lt;Integer&amp;gt;(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic&amp;lt;String&amp;gt; genericString = new Generic&amp;lt;String&amp;gt;(&amp;#34;key_vlaue&amp;#34;);Log.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java-%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java-%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8ESpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description> Java过滤器与SpringMVC拦截器 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Java8%E6%96%B0%E6%8F%90%E4%BE%9B%E6%97%B6%E9%97%B4API/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Java8%E6%96%B0%E6%8F%90%E4%BE%9B%E6%97%B6%E9%97%B4API/</guid>
      <description>Java8新提供时间API Java8新的日期和时间API的设计原则 Java8中新的日期和时间是基于JSR-310实现的,参考了绝大多数的joda-timeApi。
不变性：新的日期/时间API中，所有的类都是不可变的，实现了线程安全； 关注点分离：新的API中将人可读的日期时间和机器时间(unix timestamp)明确分离，它为日期(Date)、时间(Time)、日期时间(DateTime)、时间戳(unix timestamp)以及时区定义了不同的类； 清晰明了：新的API中，方法都被明确定义用以完成相同的行为，例如，想要拿到当前实例，可以用new()方法，在所有的类方法中都实现了formate()和parse()方法，不再是之前用单独一个类去解决，而且新的API中所有的类都使用了工厂模式和策略模式； 实用性：所有新的日期和时间API类都实现了一系列方法用以完成通用的需求，例如：加、减、格式化、解析、从日期或时间中提取单独部分等等； 可扩展性：新的日期/时间API是基于国际标准ISO 8601,其实我们也是可以将其用于非IOS的日历上 Java8中的日期和时间API包含以下包 java.time包：这是新的Java日期/时间API的基础包，所有的主要基础类都是该包的一部分，例如：LocalDate、LocalTime、LocalDateTime、Instant、Period、Duration等类。这些类都是线程安全的 java.time.chrono包：这个包为非ISO的日历标准定义了一些泛化的API，我们可以拓展AbstractChronology来创建自己的日历标准 java.time.formate包：这个包包含能够格式化和解析日期时间对象的类，在绝大数情况下，我们不应该直接使用它，因为java.time包中相应的类已经提供了格式化和解析的方法 java.time.temporal包：这个包包含一些时态对象，可以用其找出关于某个日期/时间对象的某个特定日期或时间，比如说找到某个月的第一天或最后一天，可以根据withXXX的格式进行区分 java.time.zone包：这个包支持不同的时区以及相关规则的类 时间相关类 介绍 LocalDate 时间处理类，最高精确到天，没有时区的日期, LocalDate是不可变并且线程安全的 LocalTime 时间处理类，最高精确到分秒，没有时区的日期, LocalDate是不可变并且线程安全的 LocalDateTime 时间处理类，最高精确到纳秒, LocalDate是不可变并且线程安全的 DateTimeFormatter 时间格式化 ZoneId 时区设置类 Instant 用来表示时间线上的一个点（瞬时） Clock 时钟,用于访问当前时刻、日期、时间，用到时区 Duration 用秒和纳秒表示时间的数量（长短），用于计算两个日期的“时间”间隔 Period 用于计算两个“日期”间隔 获取当前日期、时间 //now LocalDateTime now = LocalDateTime.now(); System.out.println(now); //2020-10-23T19:29:08.064 //localDate LocalDate localDate = now.toLocalDate(); System.out.println(&amp;#34;localDate:&amp;#34;+localDate);//2020-10-23 //localTime LocalTime localTime = now.toLocalTime(); System.out.println(&amp;#34;localTime:&amp;#34; + localTime); //19:29:08.064 //year int year = now.getYear(); System.out.println(&amp;#34;year:&amp;#34; + year); //2020 获取时间戳 Instant timestamp = Instant.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Json/</guid>
      <description>FastJson 1、序列化时过滤字段(属性)
@JSONField(serialize = false)private String name; @JSONField(name = &amp;#34;AGE&amp;#34;)private transient String age; 在实体字段前面，使用transient关键字，表示该字段不参与序列化，转JSON字符串时就可以忽略掉该字段。因为是JAVA关键字所以也会影响该字段其他序列化操作。
SimplePropertyPreFilter filter = new SimplePropertyPreFilter(); filter.getExcludes().add(&amp;#34;PHONE&amp;#34;); System.out.println(JSONObject.toJSONString(u, filter)); FastJson的属性名过滤器
2、序列化时过滤字段(属性)
@JSONField(serialize = false)private String name; 3、
System.out.println(&amp;#34;RefundCollection 的 json: &amp;#34; + JSON.toJSONString(logisticsAddress.getLogisticsAddressDTOList(), SerializerFeature.WriteMapNullValue)); 4、
// 序列化配置对象SerializeConfig config = new SerializeConfig();/*** CamelCase 策略，Java对象属性：personId，序列化后属性：persionId* PascalCase 策略，Java对象属性：personId，序列化后属性：PersonId* SnakeCase 策略，Java对象属性：personId，序列化后属性：person_id* KebabCase 策略，Java对象属性：personId，序列化后属性：person-id*/config.propertyNamingStrategy = PropertyNamingStrategy.CamelCase;;// 序列化对象String json = JSON.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/jvm/jvm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/jvm/jvm/</guid>
      <description> JVM 1、PermGen Space (永久带) 1、在jdk1.7之前，字符串常量存储在方法区的 PermGen Space 2、常量池 常量池在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = &amp;ldquo;java&amp;quot;这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间。 java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间，常量池存在于方法区中。 String类也是java中用得多的类，同样为了创建String对象的方便，也实现了常量池的技术。 在Java语言中不是这样，一切都是动态的。编译时，如果发现对其它类方法的调用或者对其它类字段的引用的语句，记录进class文件中的只能是一个文本形式的符号引用，在连接过程中，虚拟机根据这个文本信息去查找对应的方法或字段。 Java是一种动态链接的语言，常量池的作用非常重要，常量池中除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值外，还包含一些以文本形式出现的符号引用，比如： 类和接口的全限定名； 字段的名称和描述符； 方法的名称和描述符。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/jvm/%E4%BB%8E%E8%A1%A8%E5%88%B0%E9%87%8C%E5%AD%A6%E4%B9%A0JVM%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/jvm/%E4%BB%8E%E8%A1%A8%E5%88%B0%E9%87%8C%E5%AD%A6%E4%B9%A0JVM%E5%AE%9E%E7%8E%B0/</guid>
      <description>从表到里学习JVM实现 转载自：RednaxelaFX链接：https://www.douban.com/doulist/2545443/来源：豆瓣 在社会化分工、软件行业细分专业化的趋势下，会真的参与到底层系统实现的人肯定是越来越少（比例上说）。真的会参与到JVM实现的人肯定是少数。 但如果您对JVM是如何实现的有兴趣、充满好奇，却苦于没有足够系统的知识去深入，那么这个豆列就是为您打好基础而准备的。
如果只想用用Java用用JVM，对深入到实现细节无甚兴趣的话，这个豆列就请不必参考了，免得浪费钱浪费时间精力，呵呵 :-)
本豆列的脉络是：
JVM与Java语言规范 要了解JVM是如何实现的，首先必须要知道JVM到底是什么、不是什么，表面上应该提供怎样的功能。为此，JVM规范必读，而且应该时常放在手边参考。 而JVM的主要服务对象是Java编程语言。虽然JVM也可以支持众多其它语言，但JVM里的“J”仍然最重要，Java的语言特性影响了JVM的原始设计，所以Java语言规范也应该阅读。特别是，JVM关于线程和同步相关的规定都是交由Java语言规范的相关章节定义的。
虚拟机概论 这里选取《Virtual Machines: Versatile Platforms for Systems and Processes》，帮助您了解“虚拟机”一词到底指代什么，有什么不同类型，大概有哪些实现方法，等等。读完这本书有助获得一个清晰的大局观。
为Java程序员从用户的角度介绍JVM的使用经验的几本书 虽然这几本并没有深入到JVM实现的非常细节的角落，但对已经习惯用Java语言编程的程序员来说，有这么几本书带领自己从熟悉的领域进入不熟悉的领域总是件好事。 这几本书中，最深入JVM内部的是《Oracle JRockit: The Definitive Guide》；有丰富调优建议的是《Java Performance》；结合实现大概介绍JVM的抽象概念的是周志明的《深入理解Java虚拟机》。
虚拟机的入门级实现 先通过《Language Implementation Patterns》了解编程语言的一些入门级实现方式，把高级语言编译器与虚拟机两个概念联系起来。
然后通过《プログラミング言語を作る》了解非常简易的、用树遍历式以及字节码式解释器实现虚拟机大概是个怎么回事。虽然这本书没有实现JVM，但它介绍的Diksam与早期JVM的实现颇有相似之处，可参考。
接下来《深入嵌入式Java虚拟机》介绍了一种实际的JVM——KVM的实现细节。KVM是CLDC的参考实现（RI）里的JVM，结构简单，资源消耗小，适合入门阅读。
陈涛的《HotSpot实战》主要介绍了HotSpot VM的核心VM的实现。第一版的内容还不算深，介绍runtime的部分比较多，而介绍GC与动态编译器的具体实现的部分比较少。想对HotSpot VM的实现有初步了解，但担心GC与编译原理的知识太难的同学可以从这本书入手。 （不过请注意自己对着代码确实把知识消化掉，因为这个第一版的内容有不少小错误嗯…）
这部分最后是《The School of Niklaus Wirth》，里面有一章介绍了HotSpot Client Compiler (C1)的原始设计思路。这是个非常简单、但相对来说性能还不错的JIT编译器，可用于对JIT编译器的基本了解。这本书本身就很赞，不为学习虚拟机也可以一读。
需要注意的是从“简易的JVM实现”到“高性能、复杂的JVM实现”跨度非常大；前者的许多部分的实现方式与后者相当不同。先从简易的实现开始入手主要是为了对JVM里大概都有些什么组件有所了解。但如果目标是了解高性能JVM的实现，那就必须在GC、编译原理方面打下更好的基础，重新洗一次脑。
C++基础书 下面要开始逐渐深入JVM的内部实现，如果没有良好的C或（与？）C++基础会比较吃力。虽然也有几乎完全用Java语言实现的高性能JVM，例如Maxine VM与Jikes RVM，但它们都是研究性质的；商用JVM实现仍然是C与C++的天下。
这里我先推荐C++之父自己写的那本书来入门。虽然BS巨巨后来还出过本新书，而近来也渐渐开始有介绍C++11的入门书，但实际上现在多数JVM实现用的还是C99或非常古老的C++（连C++03都不一定用到了），所以用这本老书应该就够了。 然后通过《深度探索C++对象模型》来学习C++对象模型的常见实现方式。这对后面理解Java对象模型的实现很有帮助。
GC与编译原理的入门书 GC书总共就那么几本，倒也没啥可挑的。《The Garbage Collection Handbook》是绝对必读。
编译原理的书就稍微尴尬些。现有的编译原理书大都针对静态编译器、针对像C或C++那样的偏静态、偏native的语言。我还没读到过什么编译原理书是专门介绍JIT编译器或者说动态编译器的。《The Compiler Design Handbook》（http://book.douban.com/subject/2333166/）算是有一章专门讲动态编译，不过也只是很入门的介绍。 静态与动态编译器会有些取舍上、实现策略上的差异，不过还好其核心的原理都是一样的，所以还是可以推荐几本书。龙书用来最初入门，鲸书用来补充一些优化相关的知识，EAC第二版用来学习编译器一种比较良好的逻辑组织方式，最后学一下针对现代机器的优化。《Optimizing Compilers for Modern Architectures》（http://book.douban.com/subject/2126867/）是我比较喜欢的一本。
介绍计算机体系结构的书 实际JVM实现里，如果有JIT编译器或者动态编译器那它们的编译目标多半是底层机器的机器码。这就涉及到计算机体系结构了。 如果您只对Java语言和抽象的JVM有一定了解，那可以用《计算机组成及汇编语言原理》来入门。这本书比较奇葩，用JVM的字节码指令集来当作真实机器介绍体系结构的概念。我并不太喜欢这本书，但感觉它对有Java背景的初学者来说应该有点用。要注意的是千万别只读这本书来入门，请结合CSAPP来重新洗一次脑。 如果对C或C++已经有所了解，那《深入理解计算机系统》（CSAPP）是计算机体系结构入门的最适合的书了。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-3-pom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-3-pom/</guid>
      <description>Maven POM POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。
执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。
POM 中可以指定以下配置：
项目依赖 插件 执行目标 项目构建 profile 项目版本 项目开发者列表 相关邮件列表信息 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。
project 工程的根标签。
modelVersion 模型版本 属性，指定 POM 的版本。模型版本需要设置为 4.0。
groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。
artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。
version 是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。
name 此元素指示用于项目的显示名称
url 此元素指示可以在何处找到项目的网站
&amp;lt;project xmlns = &amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;xmlns:xsi = &amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation = &amp;#34;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt;&amp;lt;!-- 模型版本 --&amp;gt;&amp;lt;modelVersion&amp;gt;4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-4-settings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-4-settings/</guid>
      <description>Maven settings.xml 作者：静默星空
链接：https://www.cnblogs.com/jingmoxukong/p/6050172.html?utm_source=gold_browser_extension
来源：博客园
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
1、settings.xml的作用 它是用来设置 Maven 参数的配置文件。并且，settings.xml是Maven的全局配置文件。settings.xml中包含类似本地仓库、远程仓库和联网使用的代理信息等配置。
二、settings.xml元素详解 &amp;lt;settings xmlns=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0https://maven.apache.org/xsd/settings-1.0.0.xsd&amp;#34;&amp;gt;&amp;lt;localRepository/&amp;gt;&amp;lt;interactiveMode/&amp;gt;&amp;lt;usePluginRegistry/&amp;gt;&amp;lt;offline/&amp;gt;&amp;lt;pluginGroups/&amp;gt;&amp;lt;servers/&amp;gt;&amp;lt;mirrors/&amp;gt;&amp;lt;proxies/&amp;gt;&amp;lt;profiles/&amp;gt;&amp;lt;activeProfiles/&amp;gt;&amp;lt;/settings&amp;gt; 1.1、LocalRepository 作用：该值表示构建系统本地仓库的路径。 其默认值：~/.m2/repository。
&amp;lt;localRepository&amp;gt;${user.home}/.m2/repository&amp;lt;/localRepository&amp;gt; 1.2、InteractiveMode 作用：表示maven是否需要和用户交互以获得输入。 如果maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。
&amp;lt;interactiveMode&amp;gt;true&amp;lt;/interactiveMode&amp;gt; 1.3、UsePluginRegistry 作用：maven是否需要使用plugin-registry.xml文件来管理插件版本。 如果需要让maven使用文件~/.m2/plugin-registry.xml来管理插件版本，则设为true。默认为false。
&amp;lt;usePluginRegistry&amp;gt;false&amp;lt;/usePluginRegistry&amp;gt; 1.4、Offline 作用：这个属性表示在Maven进行项目编译和部署等操作时是否允许Maven进行联网来下载所需要的信息。 如果构建系统需要在离线模式下运行，则为true，默认为false。 当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。
&amp;lt;offline&amp;gt;false&amp;lt;/offline&amp;gt; 1.5、PluginGroups 作用：在pluginGroups元素下面可以定义一系列的pluginGroup元素。表示当通过plugin的前缀来解析plugin的时候到哪里寻找。pluginGroup元素指定的是plugin的groupId。默认情况下，Maven会自动把 org.apache.maven.plugins 和 org.codehaus.mojo 添加到pluginGroups下。
&amp;lt;pluginGroups&amp;gt;&amp;lt;!--plugin的组织Id（groupId） --&amp;gt;&amp;lt;pluginGroup&amp;gt;org.codehaus.mojo&amp;lt;/pluginGroup&amp;gt;&amp;lt;/pluginGroups&amp;gt; 1.6、Servers 作用：一般，仓库的下载和部署是在pom.xml文件中的 repositories 和 distributionManagement 元素中定义的。然而，一般类似用户名、密码（有些仓库访问是需要安全认证的）等信息不应该在pom.xml文件中配置，这些信息可以配置在 settings.xml 中。
&amp;lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&amp;gt;&amp;lt;servers&amp;gt;&amp;lt;!--服务器元素包含配置服务器时需要的信息 --&amp;gt;&amp;lt;server&amp;gt;&amp;lt;!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-5-%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-5-%E4%BB%93%E5%BA%93/</guid>
      <description>Maven 仓库 在 Maven 的术语中，仓库是一个位置（place）。
Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。
在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。
Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。
Maven 仓库有三种类型：
本地（local） 中央（central） 远程（remote） 本地仓库 Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。
运行 Maven 的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库，然后再使用本地仓库的构件。
默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 .m2/repository/ 的仓库目录。
Maven 本地仓库默认被创建在 %USER_HOME% 目录下。要修改默认位置，在 %M2_HOME%\conf 目录中的 Maven 的 settings.xml 文件中 localRepository 定义另一个路径。
&amp;lt;settings xmlns=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0&amp;#34;xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&amp;#34;&amp;gt;&amp;lt;localRepository&amp;gt;C:/MyLocalRepository&amp;lt;/localRepository&amp;gt;&amp;lt;/settings&amp;gt; 当你运行 Maven 命令，Maven 将下载依赖的文件到你指定的路径中。
中央仓库 Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。
中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。
中央仓库的关键概念：
这个仓库由 Maven 社区管理。 不需要配置。 需要通过网络才能访问。
远程仓库 如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-6-%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-6-%E6%8F%92%E4%BB%B6/</guid>
      <description> Maven 插件 Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：
创建 jar 文件 创建 war 文件 编译代码文件 代码单元测试 创建工程文档 创建工程报告 关键概念： 插件是在 pom.xml 中使用 plugins 元素定义的。 每个插件可以有多个目标。 你可以定义阶段，插件会使用它的 phase 元素开始处理。我们已经使用了 clean 阶段。 你可以通过绑定到插件的目标的方式来配置要执行的任务。我们已经绑定了 echo 任务到 maven-antrun-plugin 的 run 目标。 就是这样，Maven 将处理剩下的事情。它将下载本地仓库中获取不到的插件，并开始处理。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-7-%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0jar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-7-%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0jar/</guid>
      <description> Maven 引入本地 jar pom.xml 的 dependencies 列表列出了我们的项目需要构建的所有外部依赖项。
要添加依赖项，我们一般是先在 src 文件夹下添加 lib 文件夹，然后将你工程需要的 jar 文件复制到 lib 文件夹下。
然后添加以下依赖到 pom.xml 文件中：
&amp;lt;dependencies&amp;gt;&amp;lt;!-- 在这里添加你的依赖 --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;ldapjdk&amp;lt;/groupId&amp;gt; &amp;lt;!-- 库名称，也可以自定义 --&amp;gt;&amp;lt;artifactId&amp;gt;ldapjdk&amp;lt;/artifactId&amp;gt; &amp;lt;!--库名称，也可以自定义--&amp;gt;&amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; &amp;lt;!--版本号--&amp;gt;&amp;lt;scope&amp;gt;system&amp;lt;/scope&amp;gt; &amp;lt;!--作用域--&amp;gt;&amp;lt;systemPath&amp;gt;${basedir}\src\lib\ldapjdk.jar&amp;lt;/systemPath&amp;gt; &amp;lt;!--项目根目录下的lib文件夹下--&amp;gt;&amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; pom.xml 文件完整代码如下：
&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&amp;#34;&amp;gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&amp;lt;groupId&amp;gt;com.companyname.bank&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;consumerBanking&amp;lt;/artifactId&amp;gt;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&amp;lt;name&amp;gt;consumerBanking&amp;lt;/name&amp;gt;&amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;&amp;lt;dependencies&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;ldapjdk&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;ldapjdk&amp;lt;/artifactId&amp;gt;&amp;lt;scope&amp;gt;system&amp;lt;/scope&amp;gt;&amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;&amp;lt;systemPath&amp;gt;${basedir}\src\lib\ldapjdk.jar&amp;lt;/systemPath&amp;gt;&amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-8-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-8-%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven-9-%E5%BF%AB%E7%85%A7SNAPSHOT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven-9-%E5%BF%AB%E7%85%A7SNAPSHOT/</guid>
      <description>Maven 快照(SNAPSHOT) 什么是快照? 快照是一种特殊的版本，指定了某个当前的开发进度的副本。不同于常规的版本，Maven 每次构建都会在远程仓库中检查新的快照。 现在 data-service 团队会每次发布更新代码的快照到仓库中，比如说 data-service:1.0-SNAPSHOT 来替代旧的快照 jar 包。
项目快照 vs 版本 对于版本，如果 Maven 以前下载过指定的版本文件，比如说 data-service:1.0，Maven 将不会再从仓库下载新的可用的 1.0 文件。若要下载更新的代码，data-service 的版本需要升到1.1。
快照的情况下，每次 app-ui 团队构建他们的项目时，Maven 将自动获取最新的快照(data-service:1.0-SNAPSHOT)。
SNAPSHOT作用： 标识这个jar是一个不稳定的jar，是一个标识版本的作用。
使用了SNAPSHOT之后，maven会经常去私服或是中央仓库中拉取最新 的这个jar的版本；而没有SNAPSHOT的jar，则会从本地仓库中查找，本地不存在，才去中央仓库中拉取。
更新频率：需要在pom.xml文件中进行配置。 updatePolicy: always代表经常性的去拉取最新的jar， daily代表每天拉取一次，interval： 分钟； nerver： 和正式版本一致，不会去拉取最新的jar。
&amp;lt;repositorys&amp;gt;&amp;lt;repository&amp;gt;&amp;lt;id&amp;gt;****&amp;lt;/id&amp;gt;&amp;lt;url&amp;gt;***&amp;lt;/url&amp;gt;&amp;lt;snapshots&amp;gt;&amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;&amp;lt;updatePolicy&amp;gt;(always/ daliy/ interval/ nrever)&amp;lt;/updatePolicy&amp;gt;&amp;lt;/snapshot&amp;gt;&amp;lt;/repository&amp;gt;&amp;lt;/repository&amp;gt; Maven 中的仓库分为两种，snapshot 快照仓库和 release 发布仓库。 snapshot 快照仓库用于保存开发过程中的不稳定版本， release 正式仓库则是用来保存稳定的发行版本。 定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写) maven2 会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本。如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。
在java开发过程中，我们经常会看到代码仓库中的某些项目版本以release或snapshots结尾,现在说说这两个版本之间有什么区别.
一般来说 snapshots 版本代表正在开发中的版本,release 代表比较稳定的发布版本.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/Maven/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/Maven/</guid>
      <description>Maven 转自：Apache Maven
链接：https://maven.apache.org/index.html
Maven 生命周期
1、clean ：清理上一次构建生成的所有文件；2、validate3、compile ：编译项目的源代码；4、test ：运行测试代码；5、package ：打包成jar或者war或者其他格式的分发包；6、verify7、install ：将打好的包安装到本地仓库，供其他项目使用；8、site ：生成项目的站点文档；9、deploy ：将打好的包安装到远程仓库，供其他项目使用； Maven 目录分析
1:Maven 目录分析bin：含有mvn运行的脚本boot：含有plexus-classworlds类加载器框架conf：含有settings.xml配置文件lib：含有Maven运行时所需要的java类库Settings.xml 中默认的用户库: ${user.home}/.m2/repository[通过maven下载的jar包都会存储到指定的个人仓库中]Maven默认仓库下载地址在: maven的lib目录下maven-model-builder-3.0.4.jar的pom.xml中 IDEA 自带 Maven 配置
标签： Java环境变量在环境变量的系统变量中添加MAVEN_HOME：F:\IntelliJ IDEA 2019.2.3\plugins\maven\lib\maven3（你的maven所在位置）MAVEN_OPTS：-Xms128m -Xmx1024m在环境变量的用户变量中的Path中添加：%MAVEN_HOME%\bin Maven 创建项目目录结构
my-app|-- pom.xml`-- src|-- main| `-- java| `-- com| `-- mycompany| `-- app| `-- App.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/maven/%E6%B8%85%E9%99%A4lastUpdated%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/maven/%E6%B8%85%E9%99%A4lastUpdated%E6%96%87%E4%BB%B6/</guid>
      <description>maven:清除lastUpdated文件 项目使用maven管理jar包，很容易因为各种原因(网速慢、断网)导致jar包下载不下来，出现很多.lastUpdated文件。这些文件一个一个删除太麻烦。下面是全部删除的方法
windows系统
cd %userprofile%\.m2\repositoryfor /r %i in (*.lastUpdated) do del %i linux系统
find /app/maven/localRepository -name &amp;#34;*.lastUpdated&amp;#34; -exec grep -q &amp;#34;Could not transfer&amp;#34; {} \; -print -exec rm {} \; 删除 Maven 下载的半成品
cd %userprofile%\.m2\repository for /r %i in (*.lastUpdated) do del %i 唉，大数据本意是能有效处理巨量信息，比如一个几万人的小区水电煤气、蔬菜、粮食、医药资源、如果被封控了怎么进行资源、运力、人力、调配补给，在哪些地点设置核酸检测点能有效的减少时间资源浪费（几千几万人去检测，他们利用这些时间无论是工作还是休闲娱乐，都比在排队上面有价值），比如卖家通过分析过去一年中的几百万订单货品，在全国各地分配分仓货品设置</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MQ/RabbitMQ/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MQ/RabbitMQ/</guid>
      <description> RabbitMQ 标签：RabbitMQ、基础、RabbitMQ、源码解读、进阶、Java开源框架时间：2018年11月12日18:43:58 以下这些教程介绍了使用RabbitMQ创建消息传递应用程序的基础知识。您需要安装RabbitMQ服务器才能完成教程，请参阅安装指南部分。MQ概述MQ的使用场景大概包括解耦，异步消息，提高峰值处理能力，送达和排序保证，缓冲等。RabbitMQ是一个消息代理：它接受和转发消息。消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上,队列存储消息直到它们被应用程序读走。涉及名称、竞争消费者：在单个渠道上创建多个竞争消费者，以便消费者可以同时处理多个消息。竞争消费者是多个消费者，他们都是为了从单个点对点频道接收消息而创建的。当频道传递消息时，任何消费者都可能接收消息。消息传递系统的实现确定哪个消费者实际接收消息，但实际上消费者彼此竞争成为接收者。消费者收到消息后，可以委托其应用程序的其余部分来帮助处理消息。（此解决方案仅适用于点对点通道 ; 发布 - 订阅通道上的多个使用者只需为每条消息创建更多副本。）工作队列：（又称：任务队列）背后的主要思想是避免立即执行资源密集型任务，并且必须等待它完成。相反，我们安排任务稍后完成。我们将任务封装 为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当您运行许多工作程序时，它们之间将共享任务。生产者：消息发送者，在MQ中被称为生产者（producer），一个发送消息的应用也被叫做生产者，用P表示。消费者：生产者“生产”出消息后，最终由谁消费呢？等待接受消息的应用程序，我们称之为消费者（Consuming ），用C表示。算了！ 算了！直接再读开发文档吧，也花不了多少时间。http://www.rabbitmq.com/getstarted.htmlhttps://www.cnblogs.com/dwlsxj/p/RabbitMQ.html一个 非常重要！！！ 的经验总结：生产者：在 信道 basicPublish 中 需指定 交换器（exchange）和 路由键（routingKey）；消费者：在 信道 basicConsume 中 需指定 队列（queue），所以 消费者 在 basicConsume 之前 要通过 queueBind 绑定： 队列（queue）、交换器（exchange）和 路由键（routingKey）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/Mybatis-%E6%8F%92%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/Mybatis-%E6%8F%92%E4%BB%B6/</guid>
      <description>Mybatis 插件 Mybatis 插件可以在 DAO 层进行拦截，如打印执行的 SQL 语句日志，做一些权限控制，分页等功能；
Mybatis 插件典型适用场景 分页功能 mybatis 的分页默认是基于内存分页的（查出所有，再截取），数据量大的情况下效率较低，不过使用mybatis插件可以改变该行为，只需要拦截 StatementHandler 类的 prepare方法，改变要执行的SQL语句为分页语句即可；
公共字段统一赋值 一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在DAO层统一拦截处理，可以用mybatis插件拦截Executor类的update方法，对相关参数进行统一赋值即可；
性能监控 对于SQL语句执行的性能监控，可以通过拦截 Executor 类的 update, query 等方法，用日志记录每个方法执行的时间；
Mybatis 插件介绍 什么是Mybatis插件 与其称为Mybatis插件，不如叫Mybatis拦截器，更加符合其功能定位，实际上它就是一个拦截器，应用代理模式，在方法级别上进行拦截
支持拦截的方法 执行器Executor（update、query、commit、rollback等方法）； 参数处理器ParameterHandler（getParameterObject、setParameters方法）； 结果集处理器ResultSetHandler（handleResultSets、handleOutputParameters等方法）； SQL语法构建器StatementHandler（prepare、parameterize、batch、update、query等方法）； 拦截阶段 那么这些类上的方法都是在什么阶段被拦截的呢？为理解这个问题，我们先看段简单的代码（摘自 mybatis 源码中的单元测试 SqlSessionTest 类），来了解下典型的 mybatis 执行流程，如下代码所示：
以上代码主要完成以下功能：
读取mybatis的xml配置文件信息 通过SqlSessionFactoryBuilder创建SqlSessionFactory对象 通过SqlSessionFactory获取SqlSession对象 执行SqlSession对象的selectList方法，查询结果 关闭SqlSession 如下是时序图，在整个时序图中，涉及到mybatis插件部分已标红，基本上就是体现在上文中提到的四个类上，对这些类上的方法进行拦截。
Mybatis 插件实现机制 先来看下mybatis是如何加载插件配置的，对应的xml配置信息如下：
对应的解析代码如下，主要做以下工作：
根据解析到的类信息创建 Interceptor 对象； 调用 setProperties 方法设置属性变量； 添加到 Configuration 的 interceptorChain 拦截器链中； 以上逻辑对应的时序图如下：
代理对象的生成 Mybatis 插件的实现机制主要是基于动态代理实现的，其中最为关键的就是代理对象的生成，所以有必要来了解下这些代理对象是如何生成的。
Executor 代理对象 ParameterHandler代理对象 ResultSetHandler代理对象 StatementHandler代理对象 观察源码，发现这些可拦截的类对应的对象生成都是通过InterceptorChain的pluginAll方法来创建的，进一步观察pluginAll方法，如下：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-%E6%95%99%E7%A8%8B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-%E6%95%99%E7%A8%8B1/</guid>
      <description> MyBatis 教程1.md 学习自：
http://www.mybatis.cn/mybatis/28.html
MyBatis 基本功能 1、建立数据库连接，获得 Connection 对象。 2、根据用户的输入组装查询 SQL 语句。 3、根据 SQL 语句建立 Statement 对象 或者 PreparedStatement 对象。 4、用 Connection 对象执行 SQL语句，获得结果集 ResultSet 对象。 5、然后一条一条读取结果集 ResultSet 对象中的数据。 6、根据读取到的数据，按特定的业务逻辑进行计算。 7、根据计算得到的结果再组装更新 SQL 语句。 8、再使用 Connection 对象执行更新 SQL 语句，以更新数据库中的数据。 7、最后依次关闭各个 Statement 对象和 Connection 对象。 MyBatis 工作原理 对JDBC进行了封装
MyBatis 的核心组件 1、SQLSessionFactoryBuilder(构造器):它会根据配置信息或者代码生成SqlSessionFactory。 2、SqlSessionFactory(工厂接口)：依靠工厂生成SqlSession。 3、SqlSession(会话)：是一个既可以发送SQL去执行并且返回结果，也可以获取Mapper接口。 4、SQL Mapper:是由一个JAVA接口和XML文件(或注解)构成，需要给出对应的SQL和映射规则。SQL是由Mapper发送出去，并且返回结果。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-1-select-%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-1-select-%E6%A0%87%E7%AD%BE/</guid>
      <description>在MyBatis中实现SQL映射的常见标签有：
select标签（映射查询语句）、 insert标签（映射插入语句）、 update标签（映射更新语句）、 delete标签（映射删除语句）、 sql标签（可被其他语句引用的可重用语句块） select标签的属性介绍 &amp;lt;selectid=&amp;#34;selectUser&amp;#34;parameterType=&amp;#34;int&amp;#34;resultType=&amp;#34;hashmap&amp;#34;resultMap=&amp;#34;userResultMap&amp;#34;flushCache=&amp;#34;false&amp;#34;useCache=&amp;#34;true&amp;#34;timeout=&amp;#34;10000&amp;#34;fetchsize=&amp;#34;256&amp;#34;statementType=&amp;#34;PREPARED&amp;#34;resultsetType=&amp;#34;FORMARD ONLY&amp;#34;&amp;gt; id：命名空间中唯一的标识符，可以被用来引用这条语句。
parameterType：将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为MyBatis可以通过TypeHandler推断出具体传入语句的参数，默认值为unset。
resultType：从这条语句中返回的期望类型的类的完全限定名或别名。
注意：如果返回值是集合类型，那应该是集合可以包含的类型，而不能是集合本身的类型。返回时可以使用resultType或resultMap，但不能同时使用。
resultMap：外部resultMap的命名引用。结果集的映射是MyBatis最强大的特性，许多复杂映射的情形都能通过resultMap迎刃而解。返回时可以使用resultMap 或resultType，但不能同时使用。
flushCache：如果设置为true，则任何时候只要语句被调用，都会导致本地缓存和二级缓存都被清空，默认值为false。
useCache：如果设置为true，将会导致本条语句的结果被二级缓存，在select标签当中默认值为true。
timeout：驱动程序等待数据库返回请求结果的等待秒数，超时则抛出异常。默认值为unset (依赖驱动)。
fetchSize：驱动程序每次批量返回的结果行数。默认值为unset (依赖驱动)。
statementType：值为STATEMENT、PREPARED 或CALLABLE。这会让MyBatis分别使用JDBC中的Statement、PreparedStatement或CallableStatement，默认值为PREPARED。
resultSetType：结果集的类型，值为FORWARD_ONLY、SCROLL_SENSITIVE 或SCROLLINSENSITIVE，默认值为unset (依赖驱动)。
databaseId：如果配置了databaseIdProvider，MyBatis会加载所有的不带databaseId或匹配当前databaseId的语句。如果带或者不带的语句都有，则不带的会被忽略。
resultOrdered：这个设置仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。
resultSets：这个设置仅对多结果集的情况适用，它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-2-sql-%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-2-sql-%E6%A0%87%E7%AD%BE/</guid>
      <description> MyBatis-2-sql 标签 sql元素可以被用来定义可重用的SQL代码段，可以包含在其他语句中。它可以被静态地(在加载参数时) 参数化。不同的属性值通过包含的实例发生变化。例如:
&amp;lt;sql id=&amp;#34;userColumns&amp;#34;&amp;gt; ${alias}.id,${alias}.username,${alias}.password &amp;lt;/sql&amp;gt; 取值的正确方式是${prop},而不是#{prop}
这个SQL片段可以被包含在其他语句中，例如:
&amp;lt;select id=&amp;#34;selectUsers&amp;#34; resultType=&amp;#34;map&amp;#34;&amp;gt;select&amp;lt;include refid=&amp;#34;userColumns&amp;#34; &amp;gt;&amp;lt;property name=&amp;#34;alias&amp;#34; value=&amp;#34;t1&amp;#34; /&amp;gt;&amp;lt;/include&amp;gt;from some_table tl&amp;lt;/select&amp;gt; 注意观察在include 标签内引用时，通过property标签动态给alias赋值
属性值可以用于包含的refid属性或者包含的字句里面的属性，例如:
&amp;lt;sql id=&amp;#34;sometable&amp;#34;&amp;gt;${prefix}Table&amp;lt;/sql&amp;gt;&amp;lt;sql id=&amp;#34;someinclude&amp;#34;&amp;gt;from&amp;lt;include refid=&amp;#34;${include_target}&amp;#34;/&amp;gt;&amp;lt;/sql&amp;gt;&amp;lt;select id=&amp;#34;select&amp;#34; resultType=&amp;#34;map&amp;#34;&amp;gt;selectfieldl,field2,field3&amp;lt;include refid=&amp;#34;someinclude&amp;#34;&amp;gt;&amp;lt;property name=&amp;#34;prefix&amp;#34; value=&amp;#34;some&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34; include_target &amp;#34;value=&amp;#34;sometable&amp;#34; /&amp;gt;&amp;lt;/include&amp;gt;&amp;lt;/select&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-3-Transaction-%E4%BA%8B%E5%8A%A1%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-3-Transaction-%E4%BA%8B%E5%8A%A1%E6%8E%A5%E5%8F%A3/</guid>
      <description> MyBatis Transaction 事务接口 Mybatis提供了一个事务接口Transaction以及两个实现类jdbcTransaction和ManagedTransaction。
JdbcTransaction：单独使用Mybatis时，默认的事务管理实现类，就和它的名字一样，它就是我们常说的JDBC事务的极简封装，和编程使用mysql-connector-java-5.1.38-bin.jar事务驱动没啥差别。其极简封装，仅是让connection支持连接池而已。
ManagedTransaction：含义为托管事务，空壳事务管理器，皮包公司。仅是提醒用户，在其它环境中应用时，把事务托管给其它框架，比如托管给Spring，让Spring去管理事务。
事务工厂 TransactionFactory SpringManagedTransaction 当Spring与Mybatis一起使用时，Spring提供了一个实现类 SpringManagedTransaction。它其实也是通过使用JDBC来进行事务管理的，当Spring的事务管理有效时，不需要操作commit、rollback、close，Spring事务管理会自动帮我们完成。
配置事务管理方式 mybatis-config.xml 配置文件内，可配置事务管理类型。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;!DOCTYPE configuration PUBLIC &amp;#34;-//mybatis.org//DTD Config 3.0//EN&amp;#34; &amp;#34;http://mybatis.org/dtd/mybatis-3-config.dtd&amp;#34;&amp;gt;&amp;lt;configuration&amp;gt;&amp;lt;environments default=&amp;#34;development&amp;#34;&amp;gt;&amp;lt;environment id=&amp;#34;development&amp;#34;&amp;gt;&amp;lt;!--配置事务的管理方式--&amp;gt;&amp;lt;transactionManager type=&amp;#34;JDBC&amp;#34; /&amp;gt;&amp;lt;!-- 配置数据库连接信息 --&amp;gt;&amp;lt;dataSource type=&amp;#34;POOLED&amp;#34;&amp;gt;&amp;lt;property name=&amp;#34;driver&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt;&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;jdbc:mysql://localhost:3306/mybatis&amp;#34; /&amp;gt;&amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt;&amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;root&amp;#34; /&amp;gt;&amp;lt;/dataSource&amp;gt;&amp;lt;/environment&amp;gt;&amp;lt;/environments&amp;gt; &amp;lt;/configuration&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-4-SqlSessionFactory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-4-SqlSessionFactory/</guid>
      <description>MyBatis SqlSessionFactory 1、SqlSessionFactory 简介 SqlSessionFactory是MyBatis中的一个重要的对象，它是用来创建SqlSession对象的，而SqlSession用来操作数据库的。
2、SqlSessionFactory 生成 SqlSessionFactory对象可以通过SqlSessionFactoryBuilder来获得，而SqlSessionFactoryBuildr则可以从XML配置文件或预先定制的Configuration实例构建出SqlSessionFactory的实例。
SqlSessionFactory是线程安全的，它一旦被创建，应该在应用执行期间都存在。在应用运行期间不要重复创建多次，建议使用单例模式。
关于SqlSessionFactory和SqlSession两个对象给一个具体的使用过程:
import java.io.IOException; import java.io.InputStream; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import com.cn.entity.User; public class MyBatisTest { public static void main(String[] args) { try { //读取mybatis-config.xml文件 InputStream resourceAsStream = Resources.getResourceAsStream(&amp;#34;mybatis-config.xml&amp;#34;); //初始化mybatis,创建SqlSessionFactory类的实例 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); //创建session实例 SqlSession session = sqlSessionFactory.openSession(); /* * 接下来在这里做很多事情,到目前为止,目的已经达到得到了SqlSession对象.通过调用SqlSession里面的方法, * 可以测试MyBatis和Dao层接口方法之间的正确性,当然也可以做别的很多事情,在这里就不列举了 */ //插入数据 User user = new User(); user.setC_password(&amp;#34;123&amp;#34;); user.setC_username(&amp;#34;123&amp;#34;); user.setC_salt(&amp;#34;123&amp;#34;); //第一个参数为方法的完全限定名:位置信息+映射文件当中的id session.insert(&amp;#34;com.cn.dao.UserMapping.insertUserInformation&amp;#34;, user); //提交事务 session.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-5-SqlSession/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-5-SqlSession/</guid>
      <description>MyBatis SqlSession SqlSession 是 MyBatis 的关键对象，通过这个接口可以操作命令，管理事务等。
注意：虽然SqlSession提供select/insert/update/delete方法，在旧版本中使用使用SqlSession接口的这些方法，但是新版的Mybatis中就会建议使用Mapper接口的方法。
1.1、SqlSession旧版本用法： Person p = session.selectOne(&amp;#34;cn.mybatis.mydemo.mapper.PersonMapper.selectPersonById&amp;#34;, 1); 1.2、SqlSession新版本用法（推荐用法）： // 获得mapper接口的代理对象PersonMapper pm = session.getMapper(PersonMapper.class);// 直接调用接口的方法，查询id为1的Peson数据Person p = pm.selectPersonById(1); 2、MyBatis的SqlSession与JDBC的Connection对比 SqlSession对象，该对象中包含了执行SQL语句的所有方法，类似于JDBC里面的Connection。这种“类似”体现在以下几个方面：
（1）在JDBC中，Connection不直接执行SQL方法，而是生成Statement或者PrepareStatement对象，利用Statement或者PrepareStatement来执行增删改查方法。 （2）在MyBatis中，SqlSession可以直接执行增删改查方法，例如： T selectOne(String statement);int insert(String statement, Object parameter);等，也可以获取映射器Mapper： T getMapper(Class type);然后通过映射器来执行增删改查操作。如下代码所示： // 获得mapper接口的代理对象PersonMapper pm = session.getMapper(PersonMapper.class);// 直接调用接口的方法，查询id为1的Peson数据Person p = pm.selectPersonById(1); 3、SqlSession 线程安全性分析 SqlSession 是应用程序与持久存储层之间执行交互操作的一个单线程对象，也是MyBatis执行持久化操作的关键对象。
SqlSession 对象完全包含以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用 SqlSession 实例来直接执行已映射的SQL语句。
SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-6-MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%9B%E5%BB%BASession-%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-6-MyBatis%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B%E5%88%9B%E5%BB%BASession-%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>MyBatis初始化过程：创建Session 实例的过程 我们知道MyBatis的持久化操作离不开SqlSessionFactory对象，该对象由SqlSessionFactoryBuilde加载MyBatis的配置文件产生。SqlSessionFactory对象的openSession方法可以打开SqlSession对象。具体代码如下所示:
// 读取mybatis-config.xml 文件Inputstream inputStream= Resources.getResourceAsStream(&amp;#34;mybatis-config.xml&amp;#34;);// 初始化mybatis// 创建SqlSessionFactory 类的实例SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 创建Session 实例SqlSession session= sqlSessionFactory.openSession(); 上述代码的功能是根据配置文件mybatis-config.xml，创建SqlSessionFactory 对象，然后产生SqlSession，执行SQL语句。而MyBatis的初始化就发生在第三句:
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
现在就让我们看看第三句到底发生了什么。
MyBatis初始化基本过程: SqlSessionFactoryBuilder 根据传入的数据流生成 Configuration 对象，然后根据 Configuration 对象创建默认的 SqlSessionFactory 实例。
初始化的基本过程如下图所示： 由上图所示，我们可以得知MyBatis初始化要经过以下几步：
（1）调用SqlSessionFactoryBuilder 对象的 build(inputStream)方法。 （2）SqlSessionFactoryBuilder 会根据输入流 inputStream 等信息创建XMLConfigBuilder 对象。 （3）SqlSessionFactoryBuilder 调用 XMLConfigBuilder 对象的parse()方法。 （4）XMLConfigBuilder 对象解析 XML 配置文件返回 Configuration 对象。 （5）SqlSessionFactoryBuilder 根据 Configuration 对象创建一个DefaultSessionFactory 对象，供客户端使用。 （6）SqlSessionFactoryBuilder 返回 DefaultSessionFactory 对象给客户端，由此可见，SqlSessionFactory 是根据 MyBatis 的配置文件 mybatis-config.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-7-MyBatis-ObjectFactory-%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis-%E6%95%99%E7%A8%8B/MyBatis-7-MyBatis-ObjectFactory-%E5%AF%B9%E8%B1%A1%E5%B7%A5%E5%8E%82/</guid>
      <description>MyBatis ObjectFactory 对象工厂 ObjectFactory 简介 MyBatis每次创建结果对象的新实例时，它都会使用一个对象工厂(ObjectFactory) 实例来完成。默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。
// 自定义对象工厂public class ExampleObjectFactory extends DefaultObjectFactory {public Object create(Class type) {return super.create (type) ;}public object create (Class type,List&amp;lt;Class&amp;gt; constructorArgTypes,List&amp;lt;Object&amp;gt; constructorArgs) {return super.create (type,constructorargTypes,constructorArgs) ;}public void setProperties (Properties properties) {super.setProperties(properties) ;}public &amp;lt;T&amp;gt; boolean isCollection (Class&amp;lt;T&amp;gt; type){return Collection.class.isAssignableFrom(type);} 在MyBatis配置文件中配置自定义对象工厂，如下所示：
&amp;lt;objectFactory type=&amp;#34;cn.mybatis.factory.ExampleObjectFactory&amp;lt;Property names=&amp;#34;someProperty&amp;#34; value=&amp;#34;100&amp;#34; /&amp;gt;&amp;lt;/objectFactory&amp;gt; ObjectFactory接口很简单，它包含两个创建对象的方法：一个是默认构造方法的；另外一个是处理带参数的构造方法的。setProperties方法可以被用来配置ObjctFactory，在初始化 ObjectFactory 实例后，ObjectFactory 元素体中定义的属性会被传递给 setProperties 方法。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis3/</guid>
      <description>标题：MyBatis3
标签：Java、基础、MyBatis、源码解读、进阶、Java开源框架 时间：2018年7月17日19:20:24 连接：http://www.saveload.cn/html/technology/MyBatis3.txt</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis%E5%9B%9B%E5%A4%A7%E6%8E%A5%E5%8F%A3%E4%B9%8B-Executor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/MyBatis%E5%9B%9B%E5%A4%A7%E6%8E%A5%E5%8F%A3%E4%B9%8B-Executor/</guid>
      <description> MyBatis四大接口之 Executor </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/MyBatis/%E4%B8%80%E4%BA%9BMyBatis%E5%8F%8ASQL%E7%9A%84%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/MyBatis/%E4%B8%80%E4%BA%9BMyBatis%E5%8F%8ASQL%E7%9A%84%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description> 1、test 属性的值可以转义为Java代码 例如：可以.size、可以.toString() 传入参数是 list 在 mapper.xml 中 2、自定义排序 通过 order by instr (a,b) 方法对 b 字段按 a 展示顺序排序 3、复杂对象在 mapper.xml 文件中取值、 传入参数是 List&amp;lt;Map&amp;lt;String,String&amp;raquo; 在mapper.xml 文件中通过get方法取值、（另可以 item.sourecSysid 形式通过属性取值。） 在 mapper.xml 文件中通过 orderBys 对象自定义排序 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Base64/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Base64/</guid>
      <description>final Base64.Decoder decoder = Base64.getDecoder();final Base64.Encoder encoder = Base64.getEncoder();final String text = &amp;#34;字串文字&amp;#34;;final byte[] textByte = text.getBytes(&amp;#34;UTF-8&amp;#34;);//编码final String encodedText = encoder.encodeToString(textByte);System.out.println(encodedText);//解码System.out.println(new String(decoder.decode(encodedText), &amp;#34;UTF-8&amp;#34;));final Base64.Decoder decoder = Base64.getDecoder();final Base64.Encoder encoder = Base64.getEncoder();final String text = &amp;#34;字串文字&amp;#34;;final byte[] textByte = text.getBytes(&amp;#34;UTF-8&amp;#34;);//编码final String encodedText = encoder.encodeToString(textByte);System.out.println(encodedText);//解码System.out.println(new String(decoder.decode(encodedText), &amp;#34;UTF-8&amp;#34;)); </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/logback-spring-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/logback-spring-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</guid>
      <description>logback-spring 基本配置说明 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&amp;lt;configuration&amp;gt;&amp;lt;!-- 此xml在spring-boot-1.5.3.RELEASE.jar里 --&amp;gt;&amp;lt;include resource=&amp;#34;org/springframework/boot/logging/logback/defaults.xml&amp;#34; /&amp;gt;&amp;lt;include resource=&amp;#34;org/springframework/boot/logging/logback/console-appender.xml&amp;#34; /&amp;gt;&amp;lt;!-- 开启后可以通过jmx动态控制日志级别(springboot Admin的功能) --&amp;gt;&amp;lt;!--&amp;lt;jmxConfigurator/&amp;gt;--&amp;gt;&amp;lt;!-- RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&amp;gt;&amp;lt;!-- 以下的大概意思是：1.先按日期存日志，日期变了，将前一天的日志文件名重命名为XXX%日期%索引，新的日志仍然是demo.log --&amp;gt;&amp;lt;!-- 2.如果日期没有发生变化，但是当前日志的文件大小超过10MB时，对当前日志进行分割 重命名--&amp;gt;&amp;lt;appender name=&amp;#34;FILE&amp;#34; class=&amp;#34;ch.qos.logback.core.rolling.RollingFileAppender&amp;#34;&amp;gt;&amp;lt;File&amp;gt;${LOG_PATH}${LOG_FILE}&amp;lt;/File&amp;gt;&amp;lt;encoder&amp;gt;&amp;lt;!-- pattern节点，用来设置日志的输入格式 --&amp;gt;&amp;lt;pattern&amp;gt;%date [%level] [%thread] %logger{60} [%file : %line] %msg%n&amp;lt;/pattern&amp;gt;&amp;lt;!-- 记录日志的编码:此处设置字符集 - --&amp;gt;&amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&amp;lt;/encoder&amp;gt;&amp;lt;!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 --&amp;gt;&amp;lt;!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 --&amp;gt;&amp;lt;rollingPolicy class=&amp;#34;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;#34;&amp;gt;&amp;lt;!-- 添加.gz 历史日志会启用压缩 大大缩小日志文件所占空间 --&amp;gt;&amp;lt;!-- 文件名：logs/daily/guns.log.2017-12-05.0.gz --&amp;gt;&amp;lt;fileNamePattern&amp;gt;${LOG_PATH}daily/${LOG_FILE}.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot-Security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot-Security/</guid>
      <description>Hello World Spring Boot Security 创建Spring Security配置：
configureGlobal方法的名称并不重要。然而，仅在与任何注释的类配置AuthenticationManagerBuilder是很重要的@EnableWebSecurity，@EnableGlobalMethodSecurity或@EnableGlobalAuthentication。否则会产生不可预测的结果。
自定义身份验证管理器：AuthenticationManagerBuilder 非常适合设置内存，JDBC或LDAP用户详细信息，或用于添加自定义UserDetailsService。以下是配置全局（父）的应用程序示例AuthenticationManager：
认证
身份验证的主要策略接口 AuthenticationManager 只有一个方法：authenticate
@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {@Overrideprotected void configure(HttpSecurity http) throws Exception {http.authorizeRequests().antMatchers(&amp;#34;/css/**&amp;#34;, &amp;#34;/index&amp;#34;).permitAll()	.antMatchers(&amp;#34;/user/**&amp;#34;).hasRole(&amp;#34;USER&amp;#34;)	.and().formLogin().loginPage(&amp;#34;/login&amp;#34;).failureUrl(&amp;#34;/login-error&amp;#34;);	}@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {auth.inMemoryAuthentication().withUser(&amp;#34;user&amp;#34;).password(&amp;#34;password&amp;#34;).roles(&amp;#34;USER&amp;#34;);}} 请注意，它AuthenticationManagerBuilder是@Autowired一个方法@Bean- 这是使它构建全局（父）的方法AuthenticationManager。相反，如果我们这样做：
@Configurationpublic class ApplicationSecurity extends WebSecurityConfigurerAdapter {@AutowiredDataSource dataSource;... // web stuff here@Overridepublic configure(AuthenticationManagerBuilder builder) {builder.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E6%B3%A8%E8%A7%A3/</guid>
      <description> SpringBoot 注解 @Value List .yml 文件配置：
test:list:- aaa- bbb- ccc .properties 文件配置：
test.list[0]=aaatest.list[1]=bbbtest.list[2]=ccc 取值：
@Value(&amp;#34;${test.list}&amp;#34;)private String[] list; 加默认值取值：
@Value(&amp;#34;${test.list:}&amp;#34;)private String[] list; EL 表达式：
设置:
test:list: aaa,bbb,ccc 取值：
@Value(&amp;#34;#{&amp;#39;${test.list}&amp;#39;.split(&amp;#39;,&amp;#39;)}&amp;#34;)private List&amp;lt;String&amp;gt; testList; 加默认值取值：
@Value(&amp;#34;#{&amp;#39;${test.list:}&amp;#39;.split(&amp;#39;,&amp;#39;)}&amp;#34;)private List&amp;lt;String&amp;gt; testList; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-1-%E7%AB%A0Spring-Boot-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-1-%E7%AB%A0Spring-Boot-%E5%85%A5%E9%97%A8/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-2-%E7%AB%A0Spring-Boot-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-2-%E7%AB%A0Spring-Boot-%E9%85%8D%E7%BD%AE/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-3-%E7%AB%A0Spring-Boot-%E6%97%A5%E5%BF%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-3-%E7%AB%A0Spring-Boot-%E6%97%A5%E5%BF%97/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-4-%E7%AB%A0Spring-Boot-Web-%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-4-%E7%AB%A0Spring-Boot-Web-%E5%BC%80%E5%8F%91/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-5-%E7%AB%A0Spring-Boot-Docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-5-%E7%AB%A0Spring-Boot-Docker/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-6-%E7%AB%A0Spring-Boot-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-6-%E7%AB%A0Spring-Boot-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-7-%E7%AB%A0Spring-Boot-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-7-%E7%AB%A0Spring-Boot-%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-8-%E7%AB%A0Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89starters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot-%E7%AC%AC-8-%E7%AB%A0Spring-Boot-%E8%87%AA%E5%AE%9A%E4%B9%89starters/</guid>
      <description> Spring Boot-第 1 章：Spring Boot 入门 1、 Spring Boot 简介 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot/Spring-Boot/</guid>
      <description>SpringBoot 分布式/版本化配置，服务注册和发现，负载均衡，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</guid>
      <description>Spring Boot配置文件-多配置文件 1.properties多环境配置 1、第一种：利用@PropertySource注解既可以引入配置文件，需要引入多个时，可使用@PropertySources设置数组，引入多个文件。
@SpringBootApplication@PropertySource(value= &amp;#34;classpath:application-my.properties&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;)@ComponentScan(basePackages = {&amp;#34;com.nostyling&amp;#34;})@ServletComponentScan(value = &amp;#34;com.nostyling&amp;#34;)@MapperScan(basePackages = {&amp;#34;com.nostyling.create.modular.dao&amp;#34;})//将项目中对应的mapper类的路径加进来就可以了public class DemoApplication {private static Logger logger = LoggerFactory.getLogger(DemoApplication.class);public static void main(String[] args) {SpringApplication.run(DemoApplication.class, args);logger.info(&amp;#34;成功启动！&amp;#34;);}} 2、第二种：配置激活选项
我们将多个资源文件放入到resource目录下
application.propertiesapplication-dev.propertiesapplication-test.propertiesapplication-master.properties 在 application.properties文件中做如下配置：
#激活哪一个环境的配置文件spring.profiles.active=dev#公共配置spring.jackson.date-format=yyyy-MM-dd HH:mm:ss: 2.YAML多环境配置 注意：@PropertySource注解只支持properties文件。而不支持yml文件。
1、第一种：使用yml的配置文件，名称一定以application-开头，例如：application-dev.yml，application-pro.yml，application-redis.yml文件等你等。
我们将多个资源文件放入到resource目录下
application.ymlapplication-dev.ymlapplication-test.ymlapplication-master.yml 在 application.yml 文件中配置激活选项：
spring:profiles:# （这里只写application-之后的名称。多个之间用逗号分隔）active: dev 2、第二种：在配置文件添加三个英文状态下的短横线即可区分
例如：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-Cloud/Spring-Cloud/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-Cloud/Spring-Cloud/</guid>
      <description>Hello World Spring Cloud 分布式/版本化配置，服务注册和发现，负载均衡，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁定，领导选举，分布式会话，集群状态</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-%E6%B3%A8%E8%A7%A3/</guid>
      <description>Spring 注解 @Value 注入 String yml populate:string: stringValue 注入 @Value(&amp;#34;${populate.string2:}&amp;#34;)	// 默认值是空字符串“”private String stringV;@Value(&amp;#34;${populate.string:null}&amp;#34;)	// 默认值是nullprivate String stringV2;@Value(&amp;#34;${populate.string:defaultValue}&amp;#34;)	// 默认值是“defaultValue”private String stringV3;@Value(&amp;#34;#{&amp;#39;${allowNameRepetitionPlatformCode:0}&amp;#39;.split(&amp;#39;,&amp;#39;)}&amp;#34;)private List&amp;lt;String&amp;gt; allowNameRepetitionPlatformCode;private List&amp;lt;Long&amp;gt; allowNameRepetitionPlatformCode;// 在 yml 文件未对 allowNameRepetitionPlatformCode 配置时，allowNameRepetitionPlatformCode 属性加载默认值，[0], 在 yml 做了相应配置时，属性值为 配置结果，不加载默认值。 注入 Array yml populate:array: array1,array2,array3 注入 @Value(&amp;#34;${populate.array:}&amp;#34;) // 默认值是[]private String[] array;@Value(&amp;#34;${populate.array:a1,a2,a3}&amp;#34;) // 默认值是[a1,a2,a3]private String[] array1; 注入 List yml populate:list: list1,list2,list3 注入 #{&amp;rsquo;${populate.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring-1-%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring-1-%E6%A6%82%E5%BF%B5/</guid>
      <description>设计理念 提供各个层面的选择。Spring 允许您尽可能推迟设计决策。例如，可以通过配置切换持久性提供程序，而无需更改代码。对于许多其他基础架构问题以及与第三方 API 的集成也是如此。 核心技术 Ioc 和 DI 和 POI Ioc DI POI Ioc 和 DI 框架的一个重要特征是用户定义的用于定制框架的方法通常从框架本身调用，而不是从用户的应用程序代码调用。该框架通常在协调和排序应用程序活动中扮演主要程序的角色。这种控制反转使框架具有作为可扩展骨架的能力。用户提供的方法定制框架中为特定应用程序定义的通用算法。
库本质上是一组可以调用的函数。
框架体现了一些抽象设计，内置了更多行为。为了使用它，您需要通过子类化或插入自己的类将行为插入到框架中的各个位置。然后框架的代码在这些点上调用您的代码。
我将方法的控制权交给了框架系统。然后根据我对框架所做的设定，决定何时调用我的方法。控制被颠倒了 - 它叫我而不是我调用框架。这种现象是控制倒置（也称为好莱坞原则 - “不要打电话给我们，我们会打电话给你”）。
它执行调用，您的代码作出反应 - 所以再次控制被反转。
（个人总结：将 控制反转 称为 反向控制 就容易理解的多了。。。）
Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。
控制的什么被反转了？就是：获得依赖对象的方式反转了。
传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。
IoC 的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过 DI（Dependency Injection，依赖注入）来实现的。
DI 是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。
来自：https://www.martinfowler.com/bliki/InversionOfControl.html
Ioc 和 DI 和 POI 控制反转和依赖注入是框架的特性，而 spring 的核心的精神是依赖注入！！！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/springMVC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/springMVC/</guid>
      <description>springMVC HandlerMethod 类：
简单来说HandlerMethod包含的信息包括类、方法和参数的一个信息类。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/Spring%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/Spring%E4%BA%8B%E5%8A%A1/</guid>
      <description>SpringAOP 代理的实现过程；事务管理也是AOP的一个重要的功能。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8-Spring-Cloud-Stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8-Spring-Cloud-Stream/</guid>
      <description> 消息驱动—— Spring Cloud Stream 标签：Java、业务模型、进阶、Java框架 时间：2019年10月11日10:39:53 连接：http://www.saveload.cn/html/technology/消息驱动—— Spring Cloud Stream.mk 我们与世界的互动并不是同步的、线性的、严格按照提问-回应的模式进行的，而是消息驱动，不断的接发信息。当我们接收到消息，会对这些消息做出反应，当然，我们也经常会被打断正在执行的主要工作。 通过异步消息与其它微服务互相交互的微服务。使用异步消息在应用间互相通信并不是什么新概念，新的概念是使用消息来传达事件状态的改变——Event Driven Architecture(EDA)，即事件驱动架构，也可以称为Message Driven Architecture(MDA)，消息驱动架构。基于事件驱动架构，我们可以构建高度解耦的系统，需要互相通信的服务不用通过特定的库或其它服务紧密耦合在一起。当与微服务结合时，我们只需让服务监听应用程序发出的事件(消息)流，接收到事件(消息)后作出对应的响应，就可以在应用程序中快速添加新功能。 Spring Cloud的子项目Spring Cloud Stream，能让基于消息驱动的应用开发变得更加简单，使用它，我们可以很容易地就能实现“消息发布和消费”，而且会对底层消息传递平台(后文会介绍)屏蔽服务（包括发布者和消费者）的实现细节。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/%E8%B7%AF%E7%94%B1%E6%95%B0%E6%8D%AE%E6%BA%90/</guid>
      <description>1、定义多个数据源，有不同的ID
&amp;lt;!-- Druid --&amp;gt;&amp;lt;bean id=&amp;#34;dataSource&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34;&amp;gt;&amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;${dataSource.driverClassName}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${dataSource.url}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;${dataSource.username}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;${dataSource.password}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;initialSize&amp;#34; value=&amp;#34;${dataSource.initialSize}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;maxIdle&amp;#34; value=&amp;#34;${dataSource.maxIdle}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;maxActive&amp;#34; value=&amp;#34;${dataSource.maxActive}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;maxWait&amp;#34; value=&amp;#34;${dataSource.maxWait}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;validationQuery&amp;#34; value=&amp;#34;SELECT 1 FROM DUAL&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;testWhileIdle&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;testOnBorrow&amp;#34; value=&amp;#34;false&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;testOnReturn&amp;#34; value=&amp;#34;true&amp;#34;/&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;bean id=&amp;#34;dataSourceHanaJCZC&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34;&amp;gt;&amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;${hana.driverClassName}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${hanaJCZC.url}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;${hanaJCZC.username}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;${hanaJCZC.password}&amp;#34;/&amp;gt;&amp;lt;/bean&amp;gt;&amp;lt;bean id=&amp;#34;dataSourceHanaSJCK&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34;&amp;gt;&amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;${hana.driverClassName}&amp;#34;/&amp;gt;&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${hanaSJCK.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Spring/%E9%AB%98%E6%80%A7%E8%83%BDJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0HikariCP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Spring/%E9%AB%98%E6%80%A7%E8%83%BDJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0HikariCP/</guid>
      <description>1、使用方法： datasource:hikari:minimum-idle: 5maximum-pool-size: 15auto-commit: trueidle-timeout: 30000pool-name: testmax-lifetime: 1800000connection-timeout: 30000connection-test-query: select 1driver-class-name: com.mysql.jdbc.Driverjdbc-url: jdbc:mysql://192.168.2.100:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;allowMultiQueries=trueusername: adminpassword: d12h.Po(_f HikariConfig config = new HikariConfig();config.setMaximumPoolSize(100);config.setDataSourceClassName(&amp;#34;com.mysql.jdbc.jdbc2.optional.MysqlDataSource&amp;#34;);config.addDataSourceProperty(&amp;#34;serverName&amp;#34;, &amp;#34;localhost&amp;#34;);config.addDataSourceProperty(&amp;#34;port&amp;#34;, &amp;#34;3306&amp;#34;);config.addDataSourceProperty(&amp;#34;databaseName&amp;#34;, &amp;#34;mydb&amp;#34;);config.addDataSourceProperty(&amp;#34;user&amp;#34;, &amp;#34;bart&amp;#34;);config.addDataSourceProperty(&amp;#34;password&amp;#34;, &amp;#34;51mp50n&amp;#34;);HikariDataSource ds = new HikariDataSource(config); 或者 /**connectionTestQuery=SELECT 1dataSourceClassName=org.postgresql.ds.PGSimpleDataSourcedataSource.user=testdataSource.password=testdataSource.databaseName=mydbdataSource.serverName=localhost*/HikariConfig config = new HikariConfig(&amp;#34;some/path/hikari.properties&amp;#34;);HikariDataSource ds = new HikariDataSource(config); 或者 &amp;lt;!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Thread/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Thread/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description>Java并发编程：Synchronized 同步并实现原理 一、Synchronized 的基本使用 修饰普通方法
对方法的同步本质上是对对象的同步（方法本质上是属于对象的方法），所以同一同的对象，只能顺序的执行，不能并发执行。 修饰静态方法
对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使方法属于不同的对象，但是它们都属于类的实例，所以也只能顺序的执行，不能并发执行。 修饰代码块
对于代码块的同步实质上需要获取Synchronized关键字后面括号中对象的monitor jvm用monitorenter和monitorexit指令对同步提供显式支持。而java常用sychronized方法。sychronized“方法”通常不是用monitorenter和monitorexit指令实现的。往往是由“方法调用指令”检查常数池里的ACC_SYCHRONIZED标志但monitorenter和monitorexit指令是为了支持sychronized“语句”而存在的。注意这里的方法和语句的区别。语句实例如下：test.javapublic class test {public test() {}public static void main(String[] args) {synchronized(new Object()){int i = 0;}}}编译完的结果：C:\JBuilderX\bin&amp;gt;javap -c -classpath &amp;#34;d:/epm40/classes&amp;#34; testCompiled from &amp;#34;test.java&amp;#34;public class test extends java.lang.Object{public test();Code:0: aload_01: invokespecial #1; //Method java/lang/Object.&amp;#34;&amp;#34;:()V4: nop5: returnpublic static void main(java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/Thread/Java-%E7%BA%BF%E7%A8%8BThread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/Thread/Java-%E7%BA%BF%E7%A8%8BThread/</guid>
      <description>Java线程的讲解 标签：Java、线程、Thread 时间：2020年7月8日15点42分 内容：对 Java 线程及设计的相关知识点做记录及讲解 一、Java 线程的状态 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 运行(RUNNABLE)：Java线程中将就绪（可运行）（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 终止(TERMINATED)：表示该线程已经执行完毕。线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 二、线程的状态图 1. 初始状态 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。
2.1. 就绪状态 就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。 调用线程的start()方法，此线程进入就绪状态。 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。 锁池里的线程拿到对象锁后，进入就绪状态。 2.2. 运行中状态 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。
3. 阻塞状态 所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。
阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。（线程试图得到一个锁，而该锁正被其他线程持有） 当前线程T调用Thread.sleep()方法，当前线程进入阻塞状态。 运行在当前线程里的其它线程t2调用join()方法，当前线程进入阻塞状态。 等待用户输入的时候，当前线程进入阻塞状态。（线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者） 4. 等待 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。
5. 超时等待 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。
6. 终止状态 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。 在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 三、等待队列(本是Object里的方法，但影响了线程) 调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。 与等待队列相关的步骤和图： 1.线程1获取对象A的锁，正在使用对象A。 2.线程1调用对象A的wait()方法。 3.线程1释放对象A的锁，并马上进入等待队列。 4.锁池里面的对象争抢对象A的锁。 5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/XStream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/XStream/</guid>
      <description> XStream 1、string =&amp;gt; boolean /** * 是否重试,1-true:重试、0-false:不重试 */ @XStreamConverter(value= BooleanConverter.class, booleans={false}, strings={&amp;#34;1&amp;#34;, &amp;#34;0&amp;#34;}) @XStreamAsAttribute @XStreamAlias(&amp;#34;isretry&amp;#34;) private boolean isRetry; &amp;lt;error code=&amp;#34;1&amp;#34; analytical=&amp;#34;请登录后再操作&amp;#34; isretry=&amp;#34;0&amp;#34;/&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/%E5%87%A0%E7%A7%8D%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%8E%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/%E5%87%A0%E7%A7%8D%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%E4%B8%8E%E7%AE%80%E4%BB%8B/</guid>
      <description>几种无损压缩算法整理与简介 转自： 小川CD
链接：https://m.weibo.cn/profile/1202332555
压缩算法分为无损压缩和有损压缩。简单来说无损压缩要求压缩后的数据，经过解压能够得到和压缩前一模一样的数据。例如winrar和或者zip就是一种无损压缩。有损压缩，比如视频、图像，并不要求解压后的数据和原始数据一模一样，要求的是肉眼看上去图像是差不多一样即可，例如常见的H.264、H.265算法。
在存储系统中，要求的是无损压缩，即压缩后再解压能够得到原来的二进制数据。例如：snappy、zlib、zstd、lz4等。这几种算法也是CEPH中可选的压缩算法。一般来说衡量一种压缩算法的优劣，主要从压缩率、压缩速度、解压速度等方面来考虑。
下面分别来看看这几种压缩算法的简介和特点。 性能评测：lzbench，详见GitHub。
比较基准：（压缩速度、解压速度、压缩率）
以memcpy为参考，性能指标为：（10362 MB/s, 10790 MB/s, 100.00）
Snappy ，详见GitHub，谷歌开源。
性能指标：（591 MB/s, 1868 MB/s, 48.19）
Snappy 是一个 C++ 的用来压缩和解压缩的开发包。其目标不是最大限度压缩或者兼容其他压缩格式，而是旨在提供高速压缩速度和合理的压缩率。Snappy 比 zlib 更快，但文件相对要大 20% 到 100%。在 64位模式的 Core i7 处理器上，可达每秒 250~500兆的压缩速度。Snappy 在 Google 内部被广泛的使用，从 BigTable 到 MapReduce 以及内部的 RPC 系统。Google极力赞扬Snappy的各种优点，Snappy从一开始就被“设计为即便遇到损坏或者恶意的输入文件都不会崩溃”，而且被Google在生产环境中用于压缩PB级的数据。其健壮性和稳定程度可见一斑。
Zstd，详见GitHub，facebook开源。 性能指标：（1级：480 MB/s, 1203 MB/s, 34.68），压缩级别可选，级别越高，压缩率越好，但是性能越差。
Ztsd，全称Zstandard，其设计目的是提供一个高压缩比，但更快，特别是解压缩快的算法。它的压缩级别从负5级（最快）到22级（压缩速度最慢，但是压缩比最高）可以调节。压缩速度在最快和最慢级别之间可以相差20倍或更多，而解压缩速度统统很快，在最快和最慢级别之间相差不到20%。Zstandard命令行有一个“自适应”（&amp;ndash;adapt）模式，根据I/O条件改变压缩级别，主要是写入输出的速度。Zstd在其最大压缩级别下的压缩比接近lzma、lzham和ppmx，并且比lza或bzip2性能更好。 Zstandard达到了当前的Pareto边界，因为它解压缩的速度比任何其他当前可用的算法都要快，并且有类似的或者更好的压缩比。
Lz4，详见GitHub。 性能指标：（lz4 1.9.2 737 MB/s, 4448 MB/s, 47.60），lz4提供不同的参数以及压缩级别，可以达到不同的压缩率和压缩速度。
LZ4是一种无损压缩算法，提供超过单核500MB/s的压缩速度，并且支持多核扩展。它的特点是解压速度非常块，可以达到单核心数GB/s，在多核系统上可以达到内存（RAM）的速度限制。和Zstd一样，它的压缩速度是可以调节的，那么如何在压缩率与压缩速度之间做权衡，这个是需要考虑的。
Zlib，详见GitHub。 性能指标：（lz4 1.9.2 119 MB/s, 383 MB/s, 36.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/3Java/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E9%89%B4%E6%9D%83%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/3Java/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%89%8D%E5%90%8E%E7%AB%AF%E9%89%B4%E6%9D%83%E6%96%B9%E5%BC%8F/</guid>
      <description>常见的前后端鉴权方式 转自：阮一峰
链接：http://www.ruanyifeng.com/blog/
Session-Cookie Token 验证(包括JWT，SSO) OAuth2.0（开放授权） 什么是认证（Authentication） 通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功） 互联网中的认证： 用户名密码登录 邮箱发送登录链接 手机号接收验证码 只要你能收到邮箱/验证码，就默认你是账号的主人 什么是授权（Authorization） 赋予某个认证访问某些资源的权限 实现授权的方式有：cookie、session、token、OAuth 什么是凭证（Credentials） 实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份 通过[认证]——&amp;gt;进行[授权]——&amp;gt;发放给被认证角色[凭证] 什么是 Cookie HTTP 是无状态的协议 cookie 存储在客户端 cookie 是不可跨域的 什么是 Session 服务器端为每个对话对象（浏览器）创建一个会话对象（session对象）
session 是另一种记录服务器和客户端会话状态的机制
session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中
session 认证流程：
用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 反正就是客户端（浏览器）和服务端（服务器）通过 Cookie 和 Session，标记了你是谁，我是谁，我知道你是谁，这几个信息。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/4Other-Language/C/C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/4Other-Language/C/C/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/4Other-Language/GoLang/GoLang/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/4Other-Language/GoLang/GoLang/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/4Other-Language/JavaScript/JavaScript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/4Other-Language/JavaScript/JavaScript/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/4Other-Language/rust/Rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/4Other-Language/rust/Rust/</guid>
      <description>变量 首先必须说明，Rust 是强类型语言，但具有自动判断变量类型的能力。
声明变量，需要使用 let 关键字
let a = 123; a 就被确定为整型数字，不能把字符串类型的值赋给它。
使变量变得&amp;quot;可变&amp;quot;（mutable）只需一个 mut 关键字。
let mut a = 123;a = 456; 变量的值可以&amp;quot;重新绑定&amp;quot;，但在&amp;quot;重新绑定&amp;quot;以前不能私自被改变，
重影（Shadowing） 重影就是刚才讲述的所谓&amp;quot;重新绑定&amp;quot;，重影就是指变量的名称可以被重新使用的机制。
fn main() {let x = 5;let x = x + 1;let x = x * 2;println!(&amp;#34;The value of x is: {}&amp;#34;, x);// The value of x is: 12} 重影与可变变量的赋值不是一个概念，重影是指用同一个名字重新代表另一个变量实体，其类型、可变属性和值都可以变化。但可变变量赋值仅能发生值的变化。
常量 const a: i32 = 123; 比那辆可以允许重影</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/4Other-Language/Vue/Vue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/4Other-Language/Vue/Vue/</guid>
      <description>Vue 学习笔记 1、node.js下载、安装略过 cnpm cache clear -force 清空缓存
根据install.js，脚本通过http.get下载chromediriver二进制文件。 但是zip文件已被移动，脚本不处理这种情况。
npm install chromedriver &amp;ndash;chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver
npm audit npm audit fix
(use npm audit fix --force to install breaking changes; or refer to npm audit for steps to fix these manually)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/English-Learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/English-Learning/</guid>
      <description>标题：English Learning
标签：英语学习 时间：2019年2月15日16:35:13 连接：http://www.saveload.cn/html/technology/English Learning.txt 备注：我决定将自己当一个弱逼的人工智能，付出时间和艰辛解决英语问题。
title：打卡格式time：2020年2月25日16:33:29content：about 关于title：打卡第一天time：2019年2月15日16:36:40content：学发音咩。。。其实就是下了一堆App屁事没干。title：打卡第2天time：2019年2月25日10:29:56content：学发音咩。。。艹，过去了这么久。。。音标共48个：元音20个：单元音12个：前元音4个：[i:]衣...;sheep;e me even\ee beef deep\ea meat reason tea\ie believe achieve\ei deceive conceive[i]A;fish;i sit picture\u build business\y many dictionary\e pretty blanket\a village private\ui quick guitar对比：[i:] 音拉长，[i] 小腹绷紧，[e]哎（短促）;very;e never forget\ea bread heaven\a marry many[æ]哎阿;apple black cat ;e pen ten\ea bread heaven\a marry many对比：就像哎啊一样，[e]稍微含着点，上牙堂前面使劲，[æ] 嘴的张开角度更大，上牙堂后面使劲中元音3个：[ɝ:]阿儿（儿化音那个意思）;sir;or work worm\ir girl bird\er person term\ur turn burn\ear early pearl[ɚ]阿额;dollar;a banana away\er teacher under\or doctor forget \o together lesson\ure picture\ur saturday对比：一个发音感觉，就是一个带儿化音[ʌ]阿;cup dump;u luck butter\o monk onion\ou trouble flourish\oo blood flood后元音5个[u:]屋;school;oo school fool\o woman wolf\ou soup group \u pollute blue \oe shoe canoe\ui fruit juice[u]屋;双元音8个：开合双元音5个：集合双元音3个：辅音28个：爆破音15个：清辅音8个：浊辅音7个：破擦音6个：清辅音3个：浊辅音3个：鼻音3个：舌则音2个：半元音2个：title：打卡第3天time：2020年2月25日16:05:01content：1、词类：英语词类分十种：名词、形容词、代词、数词、冠词、动词、副词、介词、连词、感叹词。1、名词(n.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/OrterWordsBook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/OrterWordsBook/</guid>
      <description>Ambition 雄心\野心\抱负\志向
salary 工资、薪水、薪金、薪资</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/WordsBook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/WordsBook/</guid>
      <description>excuse me
yes of course
today is monday
give
please
cup
tea
student
Marie
no problem</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/animal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/animal/</guid>
      <description>animal /ˈænɪm(ə)/ n. 动物；兽类；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/food/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/food/</guid>
      <description>food /fuːd/ n. （植物生长的）养料；食物，食品
botany /ˈbɑːtəni/ n. 植物学；（特定地区的）植物（生态）
flower /ˈflaʊər/ n. 花；花朵
tree /triː/ n. 树；木料；树状物
grass /ɡræs/ n. 草；草地，草坪；&amp;lt;非正式&amp;gt;大麻；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/people/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/people/</guid>
      <description>people /ˈpiːp(ə)l/ 人
hair /her/ 毛发，（尤指）头发；些微；（植物叶茎上的）茸毛
head /hed/ 头；头脑，智力；顶部；排头；领导人，负责人；
forehead /fɔːrhed/ 前额
fore /fɔːr/ n. （尤指船）船头，前桅；前面部分 adj. （船、飞行器或动物）前部的，前面的 adv. 在（或向）船头，在（或向）飞行器头部 prep. 在……之前（before 的非标准形式）
eye /aɪ/ 眼睛；目光，所看之处；眼力，鉴赏力；眼光，视角；观点，态度；
eyebrow /ˈaɪbraʊ/ 眉，眉毛
ear /ɪr/ 耳朵；灵敏的听力；倾听
nose /noʊz/ 鼻子；
mouth /maʊθ/ 嘴，口腔；需要供养的人，食客；入口，开口；
tooth /tuːθ/ 牙，齿；（工具边缘、梳子、锯、拉链等的）齿状物，齿；
lip /lɪp/ 嘴唇；（伤口或洞口）边缘；容器边缘，开口；
tongue /tʌŋ/ 舌，舌头；（供食用的动物的）舌头，口条；语言，方言；
throat /θroʊt/ 喉咙，咽喉；喉部，颈前部；咽喉状部分（尤指狭窄通道、进出管路）；
face /feɪs/ 脸，面部；面部表情，脸色；
neck /nek/ n. 颈项，脖子；衣领，领口；
shoulder /ˈʃoʊldər/ n. 肩，肩膀；双肩，上背部（shoulders）； v. 承担，担负；挤，闯；
arm /ɑːrm/ n. 手臂，上肢；武器，军备；扶手；袖子 v. 武装，备战；提供，配备；
elbow /ˈelboʊ/ n.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/surroundings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/make-progress-every-day/surroundings/</guid>
      <description>environ /ɪnˈvaɪrən/ v. 环绕；包围；围住
surround /səˈraʊnd/ v. 围绕，环绕；（军队，警察等）包围；与……紧密相连（或相关）；喜欢结交（某类人），身边总有（某类东西） n. （物品的）边，饰边；周围的事物，环境
surroundings /səˈraʊndɪŋz/ n. 周围环境，周围事物
environment /ɪnˈvaɪrənmənt/ n. 自然环境，生态环境；周围状况，条件；工作平台，软件包
brook /brʊk/ n. 小溪，小河
river /ˈrɪvər/ n. 河，江
lake /leɪk/ n. 湖，湖泊；大量的液体
sea /siː/ n. 海洋；内海；海（指月球或火星表面的一片广阔平原）；海面情况，海浪状况；大量，茫茫一片；（用于海名）海（Sea）；巨浪（seas）
hill /hɪl/ n. 山丘，小山；（道路的）斜坡；土堆，小堆；&amp;lt;美，非正式&amp;gt;国会山,山坡 v. 使成堆
mountain /ˈmaʊnt(ə)n/ n. 山，高山；许多，大量（a mountain/mountains of）；（食物的）过剩，积压
road /roʊd/ n. 路，公路，马路，街； 途径，方法，路子；</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/Lesson1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/Lesson1/</guid>
      <description>Lesson1
Excuse
Excuse me
excuse me,is this you pen
excuse me ,what time is it
me
give me that book
please tell me more
yes
yes it is
are a student ,yes ,i am
can i have a cup of tea ,yes of course.
is
is this your handbag?
today is monday
this car is mine
this
is this your book
pardon
pardon me
pardon ,will you say again
it</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/Lesson2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E6%96%B0%E6%A6%82%E5%BF%B51/Lesson2/</guid>
      <description>lesson 2
pen
is this your pen
may i borrow your pen
this pen made in China
pencil
it this your pencil
the pencil on the desk is mine
whose pencil is this
book
is this your book
i am reading a book
he has a lots of book
watch
is this your watch
my watch has stopped
this watch is too dear
coat
is this your coat
How much is this coat</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E9%9F%B3%E6%A0%87/%E9%9F%B3%E6%A0%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/5English-Learning/%E6%96%B0%E6%A6%82%E5%BF%B5/%E9%9F%B3%E6%A0%87/%E9%9F%B3%E6%A0%87/</guid>
      <description> 音标共48个：元音20个：单元音12个：前元音4个：[i:]衣...;sheep;e me even\ee beef deep\ea meat reason tea\ie believe achieve\ei deceive conceive[i]A;fish;i sit picture\u build business\y many dictionary\e pretty blanket\a village private\ui quick guitar对比：[i:] 音拉长，[i] 小腹绷紧，[e]哎（短促）;very;e never forget\ea bread heaven\a marry many[æ]哎阿;apple black cat ;e pen ten\ea bread heaven\a marry many对比：就像哎啊一样，[e]稍微含着点，上牙堂前面使劲，[æ] 嘴的张开角度更大，上牙堂后面使劲中元音3个：[ɝ:]阿儿（儿化音那个意思）;sir;or work worm\ir girl bird\er person term\ur turn burn\ear early pearl[ɚ]阿额;dollar;a banana away\er teacher under\or doctor forget \o together lesson\ure picture\ur saturday对比：一个发音感觉，就是一个带儿化音[ʌ]阿;cup dump;u luck butter\o monk onion\ou trouble flourish\oo blood flood后元音5个[u:]屋;school;oo school fool\o woman wolf\ou soup group \u pollute blue \oe shoe canoe\ui fruit juice[u]屋;双元音8个：开合双元音5个：集合双元音3个：辅音28个：爆破音15个：清辅音8个：浊辅音7个：破擦音6个：清辅音3个：浊辅音3个：鼻音3个：舌则音2个：半元音2个：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/1Math/%E5%9F%BA%E7%A1%801/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/1Math/%E5%9F%BA%E7%A1%801/</guid>
      <description>1、基础 自然数 自然数 又称非负整数性，分为偶数奇数，合数质数
自然数集是全体非负整数组成的集合，常用 N 来表示。自然数有无穷无尽的个数。自然数有有序性，无限性。分为偶数和奇数，合数和质数等。
自然数是整数（自然数包括正整数和零），但整数不全是自然数，例如：-1 -2 -3&amp;hellip;&amp;hellip;是整数 而不是自然数。自然数是无限的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/2%E5%89%8D%E7%AB%AF/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/2%E5%89%8D%E7%AB%AF/html%E5%92%8Ccss%E7%AC%94%E8%AE%B0/</guid>
      <description>html和css笔记
&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-html和css&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- 一、HTML的基本概念 1、HTML(Hyper Text Markup Language) 超文本标记语言 2、静态页面&amp;mdash;为后续的动态页面服务（JSP） 3、IP:在因特网(Internet)中唯一标识一台主机 公网IP：在整个互联网中唯一 局域网IP：在同一个局域网中唯一，不同的局域网之间可能重复。 4、URL：统一资源定位符 www.baidu.com 5、HTTP协议：超文本协议，通常是字符串 http://192.168.0.3:8989/xxx
二、HTML的内容： 1、文件的创建及运行 .html、.htm后缀，只需浏览器就能运行。 2、HTML的语法特点： 内容都是以标签的形式，这些标签一般由前标签和后标签构成 我的第一个网页 Hello World 3、语法不严格：大小写不区分 一般情况成对出现，特殊，没有标签体的标签可以只有前标签 标签可以嵌套，但是不能交叉
三、具体的语法： 1、head部分：在网页中不见 1)title 网页的标题 2)meta 标签 ：定义网页中信息、特点 设置网页的编码格式
&amp;lt;META name=&amp;quot;author&amp;quot; content=&amp;quot;zpark&amp;quot;&amp;gt; 定义网页作者 &amp;lt;META name=&amp;quot;keywords&amp;quot; content=&amp;quot;云计算,,...&amp;quot;&amp;gt; 定义网页关键字 &amp;lt;META http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;1&amp;quot;&amp;gt; &amp;lt;META http-equiv=&amp;quot;refresh&amp;quot; content=&amp;quot;2;url=http://www.taobao.com&amp;quot;&amp;gt; 定义网页2秒后自动刷新到&amp;quot;淘宝 3)script标签 :引入或者开发javascript代码 4)link标签 ：引入css文件 2、body：在网页中可见 1)body标签 &amp;lt;BODY bgcolor=&amp;quot;#FFCCFF“ background=&amp;quot;back_image.GIF&amp;quot; text=&amp;quot;#FF0000&amp;quot;&amp;gt; bgcolor=	背景颜色 background=	背景图片 text=	前景颜色(字体颜色) 2)注释 &amp;lt;!--注释内容--&amp;gt; 3)特殊的符号： 空格：	&amp;amp;nbsp; &amp;gt;:	&amp;amp;gt; &amp;lt;:	&amp;amp;lt; 换行：	&amp;lt;br/&amp;gt;; 水平线：&amp;lt;hr size=&amp;quot;30px&amp;quot; color=&amp;quot;green&amp;quot; width=&amp;quot;300px&amp;quot; align=&amp;quot;right&amp;quot;/&amp;gt; size :垂直高度 width：水平宽度 color：水平线的颜色 取值：英文值 RGB值 align：水平线的对其方式 left|center(默认)|right 版权符号：&amp;amp;copy; 水平线：&amp;lt;hr size=&amp;quot;30px&amp;quot; color=&amp;quot;green&amp;quot; width=&amp;quot;300px&amp;quot; align=&amp;quot;right&amp;quot;/&amp;gt; size :垂直高度(线的厚度) width：水平宽度(线的颜色) color：水平线的颜色 取值：英文值 RGB值 align：水平线的对其方式 left|center(默认)|right 4、body标签中的元素 1、文本相关 1)标题标签&amp;lt;H1&amp;gt;&amp;lt;H6&amp;gt; 说明：&amp;lt;H1&amp;gt;到&amp;lt;H6&amp;gt;字体大小依次递减 如果需要更大或者更小的字号借助CSS 2)&amp;lt;font&amp;gt;标签 &amp;lt;font size = &amp;quot;2&amp;quot; color = &amp;quot;red&amp;quot; face = &amp;quot;黑体&amp;quot;&amp;gt; .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/3IDEA/IDEA-jvm%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/3IDEA/IDEA-jvm%E9%85%8D%E7%BD%AE/</guid>
      <description> 默认配置 -Xms128m-Xmx750m-XX:ReservedCodeCacheSize=240m-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=&amp;#34;&amp;#34;-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow 一种复杂的未验证配置 -server-Xms2g-Xmx2g-XX:NewRatio=3-Xss16m-XX:+UseConcMarkSweepGC-XX:+CMSParallelRemarkEnabled-XX:ConcGCThreads=4-XX:ReservedCodeCacheSize=240m-XX:+AlwaysPreTouch-XX:+TieredCompilation-XX:+UseCompressedOops-XX:SoftRefLRUPolicyMSPerMB=50-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djsse.enableSNIExtension=false-ea 关于字段的意义 #-Xmx Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；#-Xms Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；#-Xmn Java Heap Young区大小，不熟悉最好保留默认值；#-Xss 每个线程的Stack大小，不熟悉最好保留默认值；#-XX:NewRatio	新生代内存容量与老生代内存容量的比例#-XX:ReservedCodeCacheSize	保留代码占用的内存容量#-XX:+UseConcMarkSweepGC	对老生代采用并发标记交换算法进行GC </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/4Flutter/Flutter-mark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/4Flutter/Flutter-mark/</guid>
      <description>Flutter 相关网站： 官网： https://flutter.dev/
CN官网： https://flutter.cn/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/4Flutter/Flutter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/4Flutter/Flutter/</guid>
      <description> Flutter </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/5WorkflowEngine/BPMN2.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/5WorkflowEngine/BPMN2.0/</guid>
      <description>BPMN 2.0 3.1. BPMN 2.0是什么呢？ 业务流程模型注解（Business Process Modeling Notation - BPMN）是 业务流程模型的⼀种标准图形注解。这个标准 是由对象管理组（Object Management Group - OMG）维护的。
基本上，BPMN规范定义了任务看起来怎样的，哪些结构可以 与其他进⾏连接，等等。这就意味着 意思不会被误解。
标准的早期版本（1.2版以及之前）仅仅限制在模型上， ⽬标是在所有的利益相关者之间形成通⽤的理解， 在⽂档，讨论和实现业务流程之上。 BPMN标准证明了它⾃⼰，现在市场上许多建模⼯具 都使⽤了BPMN标准中的元素和结构。实际上，现在的jPDL设计器也使⽤了 BPMN元素。
BPMN规范的2.0版本，当前已经处于最终阶段了， 已经计划不就就会完成，允许添加精确的技术细节 在BPMN的图形和元素中， 同时制定BPMN元素的执行语法。 通过使用XML语言来指定业务流程的可执行语法， BPMN规范已经演变为业务流程的语言， 可以执行在任何兼容BPMN2的流程引擎中， 同时依然可以使用强大的图形注解。
3.2. 历史和目标 jBPM BPMN2的实现是在jBPM 4.0发布之后 在2009年8月，在与社区进行了紧密协作之后启动的。 而后，我们决定了第一个发布版（比如，文档/QA） 涉及一部分BPMN2规范，将在jBPM 4.3发布。
我们的目标是建立一个原生BPMN2运行引擎 （或者说实现&amp;rsquo;可执行的BPMN2&amp;rsquo;）基于流程虚拟机 （Process Virtual Machine - PVM）。 注意，这个版本的主要目标是原生可执行， 不是图形注解 - 但是我们清楚 对于未来的版本是很重要的。
如果用户已经了解了jBPM，就会发现
配置结构保持不变 API与已经存在的完全一样或者很类似 测试BPMN2流程也可以使用常用的java测试框架 数据库表结构保持不变 所以，总体来说，我们的主要目标是保持所有在jBPM上好的事情， 加强它们，使用一个标准的流程语言。
3.3. JPDL vs BPMN 2.0 第一个问题可能是，很正当的，映入脑海的是， 为什么已经有了jPDL还要实现BPMN2。它们两个语言 的目标都是定义可执行的业务流程。从高层次来看， 两个语言是等效的。主要的区别是 BPMN2是“厂商中立”的，你可以使用标准， 而jPDL是绑定在jBPM上的（虽然会有一些争论 绑定在开源语言厂商比如jPDL 和绑定在闭源产品）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/6Technical-Topics/Hugo/Hugo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/6Technical-Topics/Hugo/Hugo/</guid>
      <description> Hugo hugo new site demositecd demositehugo server -D </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/7Security/TheHackerPlaybook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/7Security/TheHackerPlaybook/</guid>
      <description> TheHackerPlaybook 第一章：环境建设 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/chrom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/chrom/</guid>
      <description>手动强制同步 地址栏输入：chrome://sync-internals中间那列中下方，点击“Stop Sync (Keep Data)”，之后点击“Request Start”两个设备上的Chrome都进行一次这个操作更新：如果不行，重启chrome再重复以上操作</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Cmake/Cmake/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Cmake/Cmake/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-Dockerfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-Dockerfile/</guid>
      <description>Docker Dockerfile 什么是 Dockerfile？ Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。
使用 Dockerfile 定制镜像 FROM nginxRUN echo &amp;#39;这是一个本地构建的nginx镜像&amp;#39; &amp;gt; /usr/share/nginx/html/index.html 2、FROM 和 RUN 指令的作用 FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。
RUN：用于执行后面跟着的命令行命令。有以下俩种格式：
shell 格式：
RUN &amp;lt;命令行命令&amp;gt;# &amp;lt;命令行命令&amp;gt; 等同于，在终端操作的 shell 命令。 exec 格式：
RUN [&amp;#34;可执行文件&amp;#34;, &amp;#34;参数1&amp;#34;, &amp;#34;参数2&amp;#34;]# 例如：# RUN [&amp;#34;./test.php&amp;#34;, &amp;#34;dev&amp;#34;, &amp;#34;offline&amp;#34;] 等价于 RUN ./test.php dev offline 注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：
FROM centosRUN yum -y install wgetRUN wget -O redis.tar.gz &amp;#34;http://download.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-1-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-1-%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</guid>
      <description>Docker 命令大全 容器生命周期管理 run start/stop/restart kill rm pause/unpause create exec Docker run 命令 docker run ：创建一个新的容器并运行一个命令
语法 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS说明：
-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； &amp;ndash;name=&amp;ldquo;nginx-lb&amp;rdquo;: 为容器指定一个名称； &amp;ndash;dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； &amp;ndash;dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h &amp;ldquo;mars&amp;rdquo;: 指定容器的hostname； -e username=&amp;ldquo;ritchie&amp;rdquo;: 设置环境变量； &amp;ndash;env-file=[]: 从指定文件读入环境变量； &amp;ndash;cpuset=&amp;ldquo;0-2&amp;rdquo; or &amp;ndash;cpuset=&amp;ldquo;0,1,2&amp;rdquo;: 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； &amp;ndash;net=&amp;ldquo;bridge&amp;rdquo;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； &amp;ndash;link=[]: 添加链接到另一个容器； &amp;ndash;expose=[]: 开放一个端口或一组端口； &amp;ndash;volume , -v: 绑定一个卷 &amp;ndash;ulimit , 生成的进程的资源进行限制 实例 使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-2-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-2-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</guid>
      <description> Docker 命令大全 容器操作 ps inspect top attach events logs wait export port Docker rm 命令 docker rm ：删除一个或多个容器。
语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：
-f :通过 SIGKILL 信号强制删除一个运行中的容器。
-l :移除容器间的网络连接，而非容器本身。
-v :删除与容器关联的卷。
实例 强制删除容器 db01、db02：
docker rm -f db01 db02 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-3-%E5%AE%B9%E5%99%A8rootfs%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-3-%E5%AE%B9%E5%99%A8rootfs%E5%91%BD%E4%BB%A4/</guid>
      <description> Docker 命令大全 容器rootfs命令 commit cp diff Docker rm 命令 docker rm ：删除一个或多个容器。
语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：
-f :通过 SIGKILL 信号强制删除一个运行中的容器。
-l :移除容器间的网络连接，而非容器本身。
-v :删除与容器关联的卷。
实例 强制删除容器 db01、db02：
docker rm -f db01 db02 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-4-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-4-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</guid>
      <description> Docker 命令大全 镜像仓库 login pull push search Docker rm 命令 docker rm ：删除一个或多个容器。
语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：
-f :通过 SIGKILL 信号强制删除一个运行中的容器。
-l :移除容器间的网络连接，而非容器本身。
-v :删除与容器关联的卷。
实例 强制删除容器 db01、db02：
docker rm -f db01 db02 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-5-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-5-%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</guid>
      <description> Docker 命令大全 本地镜像管理 images rmi tag build history save load import Docker rm 命令 docker rm ：删除一个或多个容器。
语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：
-f :通过 SIGKILL 信号强制删除一个运行中的容器。
-l :移除容器间的网络连接，而非容器本身。
-v :删除与容器关联的卷。
实例 强制删除容器 db01、db02：
docker rm -f db01 db02 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-6-info-version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4-6-info-version/</guid>
      <description> Docker 命令大全 info|version info version Docker rm 命令 docker rm ：删除一个或多个容器。
语法 docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTIONS说明：
-f :通过 SIGKILL 信号强制删除一个运行中的容器。
-l :移除容器间的网络连接，而非容器本身。
-v :删除与容器关联的卷。
实例 强制删除容器 db01、db02：
docker rm -f db01 db02 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker-%E5%91%BD%E4%BB%A4/Docker-%E5%91%BD%E4%BB%A4/</guid>
      <description> Docker 命令大全 转自：菜鸟教程
链接：https://www.runoob.com/docker/docker-command-manual.html
容器生命周期管理 run start/stop/restart kill rm pause/unpause create exec 容器操作 ps inspect top attach events logs wait export port 容器rootfs命令 commit cp diff 镜像仓库 login pull push search 本地镜像管理 images rmi tag build history save load import info|version info version </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/Docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/Docker/</guid>
      <description>Docker 应知应会 1、关于 Docker 1.1、关于 Docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。
容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。
1.1.1、Docker 的应用场景 Web 应用的自动化打包和发布。
自动化测试和持续集成、发布。
在服务型环境中部署和调整数据库或其他的后台应用。
从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境
1.1.2、相关链接 Docker 官网：https://www.docker.com
Github Docker 源码：https://github.com/docker/docker-ce
1.2、Docker 架构 Docker 包括三个基本概念:
镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker 容器。
Docker 容器通过 Docker 镜像来创建。
容器与镜像的关系类似于面向对象编程中的对象与类。
概念 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。 Docker 容器(Container) 容器是独立运行的一个或一组应用，是镜像运行时的实体。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs-1-Docker-%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs-1-Docker-%E6%A6%82%E8%BF%B0/</guid>
      <description>Docker Docs 转自：Docker 官网
链接：https://docs.docker.com/get-started/overview/
Docker 概述 Docker 是一个用于开发、发布和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分离，以便您可以快速交付软件。使用 Docker，您可以像管理应用程序一样管理基础架构。通过利用 Docker 的快速发布、测试和部署代码的方法，您可以显著减少编写代码和在生产环境中运行代码之间的延迟。
Docker 平台 Docker 提供了在松散隔离的环境中打包和运行应用程序（称为容器）的功能。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的所有内容，因此您无需依赖主机上当前安装的内容。您可以在工作时轻松共享容器，并确保与之共享的每个人都能获得以相同方式工作的相同容器。
Docker 提供了工具和平台来管理容器的生命周期：
使用容器开发应用程序及其支持组件。 容器将成为分发和测试应用程序的单元 准备就绪后，将应用程序作为容器或编排服务部署到生产环境中。无论您的生产环境是本地数据中心、云提供商还是两者的混合体，这都是一样的。 我可以使用 Docker 做什么？ 快速、一致地交付您的应用程序 Docker 允许开发人员使用提供应用程序和服务的本地容器在标准化环境中工作，从而简化了开发生命周期。容器非常适合持续集成和持续交付 （CI/CD） 工作流。
请考虑以下示例方案：
您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。 他们使用 Docker 将其应用程序推送到测试环境中，并执行自动和手动测试。 当开发人员发现 Bug 时，他们可以在开发环境中修复它们，并将其重新部署到测试环境中进行测试和验证。 测试完成后，将修复程序推送到生产环境非常简单。. 响应式部署和扩展 Docker 基于容器的平台允许高度可移植的工作负载。Docker 容器可以在开发人员的本地笔记本电脑、数据中心的物理机或虚拟机、云提供商或混合环境中运行。
Docker 的可移植性和轻量级特性还使得能够近乎实时地动态管理工作负载、根据业务需求扩展或拆除应用程序和服务变得容易。
在同一硬件上运行更多工作负载 Docker 是轻量级和快速的。它为基于虚拟机管理程序的虚拟机提供了一种可行且经济高效的替代方案，因此您可以使用更多的计算容量来实现业务目标。Docker 非常适合高密度环境以及需要用更少资源完成更多工作的中小型部署。
Docker 体系结构 Docker 使用 客户端-服务器 体系结构。Docker 客户端与 Docker 守护程序通信，后者负责构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护程序可以在同一系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护程序。Docker 客户端和守护程序使用 REST API、UNIX 套接字或网络接口进行通信。另一个 Docker 客户端是 Docker Compose，它允许您使用由一组容器组成的应用程序。 Docker 守护程序 Docker daemon Docker 守护程序（） 侦听 Docker API 请求并管理 Docker 对象，如映像、容器、网络和卷。守护程序还可以与其他守护程序通信以管理 Docker 服务。dockerd</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs-2-%E8%8E%B7%E5%8F%96-Docker/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs-2-%E8%8E%B7%E5%8F%96-Docker/</guid>
      <description> Docker Docs 转自：Docker 官网
链接：https://docs.docker.com/get-started/overview/
获取 Docker 单独有写一篇如何安装
docker run hello-world </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs-3-%E7%AB%8B%E5%8D%B3%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs-3-%E7%AB%8B%E5%8D%B3%E5%BC%80%E5%A7%8B/</guid>
      <description>Docker Docs 转自：Docker 官网
链接：https://docs.docker.com/get-started/overview/
立即开始 第 1 部分：入门 方向和设置 欢迎！我们很高兴您想学习 Docker。
本页包含有关如何开始使用 Docker 的分步说明。在本教程中，您将学习如何：
将映像作为容器生成和运行 使用 Docker Hub 共享映像 使用多个容器和一个数据库部署 Docker 应用程序 使用 Docker Compose 运行应用程序 此外，您还将了解构建映像的最佳做法，包括有关如何扫描映像以查找安全漏洞的说明。
下载并安装 Docker 建议在 Linux 系统上安装 Docker。
开始教程 如果您已经运行了该命令以开始使用本教程，那么恭喜您！如果没有，请打开命令提示符或 bash 窗口，然后运行以下命令：
docker run -d -p 80:80 docker/getting-started 您会注意到正在使用一些标志。以下是有关它们的更多信息：
-d- 在分离模式下运行容器（在后台） -p 80:80- 将主机的端口 80 映射到容器中的端口 80 docker/getting-started- 要使用的图像 提示
您可以组合单个字符标志以缩短完整命令。例如，上面的命令可以写成：
docker run -dp 80:80 docker/getting-started Docker 仪表板 Docker Dashboard 在走得太远之前，我们想突出显示 Docker 仪表板，它让你可以快速查看计算机上运行的容器。Docker Dashboard 适用于 Mac 和 Windows。它使您可以快速访问容器日志，让您在容器内获得一个shell，并允许您轻松管理容器生命周期（停止，删除等）。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Docker/DockerDocs/DockerDocs/</guid>
      <description> Docker Docs 转自：Docker 官网
链接：https://docs.docker.com/get-started/overview/
Docker 概述 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Git/Git-%E5%91%BD%E4%BB%A4/Git-%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Git/Git-%E5%91%BD%E4%BB%A4/Git-%E5%91%BD%E4%BB%A4/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Git/IDEA-Git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Git/IDEA-Git-%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</guid>
      <description>IDEA Git 配置代理
idea需要git操作的这样配置代理，在当前项目目录进入命令行：
配置全局参数：&amp;ndash;global
代理 ：git config &amp;ndash;global http.proxy http://127.0.0.1:7890 代理 ：git config http.proxy http://127.0.0.1:7890 取消代理： git config &amp;ndash;global &amp;ndash;unset http.proxy 取消代理： git config &amp;ndash;unset http.proxy 查询是否使用：git config &amp;ndash;global http.proxy 查询是否使用：git config http.proxy</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Git/Pro-Git-Simple/Pro-Git-Simple-1-%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Git/Pro-Git-Simple/Pro-Git-Simple-1-%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E5%B9%B6/</guid>
      <description> Pro Git Simple-1-分支和合并 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Git/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%A3%80%E5%87%BA%E5%AE%A1%E6%A0%B8%E5%92%8C%E5%90%88%E5%B9%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Git/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%A3%80%E5%87%BA%E5%AE%A1%E6%A0%B8%E5%92%8C%E5%90%88%E5%B9%B6/</guid>
      <description>第 1 步. 获取并查看此合并请求的分支
git fetch origingit checkout -b &amp;#34;feature-快递停发&amp;#34; &amp;#34;origin/feature-快递停发&amp;#34; 第 2 步. 在本地查看更改 第 3 步. 合并分支并解决出现的任何冲突
git fetch origingit checkout &amp;#34;test&amp;#34;git merge --no-ff &amp;#34;feature-快递停发&amp;#34; 第 4 步. 将合并结果推送到GitLab
git push origin &amp;#34;test&amp;#34; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Ubuntu/Ubuntu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Ubuntu/Ubuntu/</guid>
      <description>Docker 应知应会 1、Ubuntu 镜像文件下载 官方下载地址（不推荐）https://www.ubuntu.com/download中国官网（推荐）https://cn.ubuntu.com/中科大源http://mirrors.ustc.edu.cn/ubuntu-releases/16.04/阿里云开源镜像站http://mirrors.aliyun.com/ubuntu-releases/16.04/兰州大学开源镜像站http://mirror.lzu.edu.cn/ubuntu-releases/16.04/北京理工大学开源http://mirror.bit.edu.cn/ubuntu-releases/16.04/浙江大学http://mirrors.zju.edu.cn/ubuntu-releases/16.04/不知名镜像网站http://mirror.pnl.gov/releases/xenial/各个版本下载网址：http://mirrors.melbourne.co.uk/ubuntu-releases/ Ubuntu忘记密码的解决办法 ubuntu忘记root密码怎么办？如果普通用户忘记了怎么办
第一种方法：无论你是否申请了root帐号，或是普通账号密码忘记了都没有问题的！1、重启ubuntu，随即长按shift进入grub菜单；2、选择第二个高级模式recovery mode进入3、进入Recovery Menu界面，选择root Drop to root shell prompt ,也就是获取root权限4、在命令行# 后面敲入 cat /etc/shadow 查看用户名（如果连用户名都忘记的话）5、敲入：passwd &amp;#34;用户名&amp;#34; 之后再敲两次密码就可以修改用户名密码了。另外想修改root密码可使用下面的方法：修改root密码操作：#passwd输入新密码：# 再输入一遍密码：#这是设置root密码，如果是设置其它用户密码使用命令：passwd 用户名 即可6、按ctrl+alt+del重启系统，完成。 Linux RPM和DEB包的区别 关于rpm和deb RPM(Red Hat Package Manager)，是基于Red hat的Linux Distribution的包管理系统，同时也指rpm包本身，RPM用于rpm包的管理（诸如安装、卸载、升级等），像Mandrake和SuSE这些基于RPM的发行版通常有自己特定的rpm包，如果混合安装可能不会正常工作，而对于第三方发行的rpm包一般都能在基于RPM的系统上正常安装。 对于基于Debian的系统使用deb格式的包，有包转换工具使rpm与deb及其他文件之间互相转换(Alien Package Converter），其安装和升级可用dpkg，不过它不能很方便地处理包的依赖关系，比较省事的有dselect和apt-get, Ubunut是debian的变种, 其软件以deb包或者源文件的形式出现. deb软件包的格式和使用 (1).deb软件包命令遵行如下约定： soft_ver-rev_arch.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Window10%E4%B8%8B-%E6%90%AD%E5%BB%BA-Rust-%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Window10%E4%B8%8B-%E6%90%AD%E5%BB%BA-Rust-%E7%8E%AF%E5%A2%83/</guid>
      <description>Window10下 搭建 Rust 环境 首先要说明的是，本文是介绍 windows + MSYS2 + Rust ，非 MSVC。
Windows作业系统中的Rust程式，预设会使用MSVC来编译的。但是如果Rust程式有使用到GNU相关的函式库(例如GTK)时，就得搭配MinGW来编译了。MSYS2 是一套整合MinGW和POSIX环境的工具，可以在Windows作业系统上模拟出Linux作业系统的开发环境，且能利用MinGW直接编译出在Windows作业系统上执行的程式。
1、安装和设定 MSYS2 已经有其他博文做过介绍，参考即可
2、安在Windows作业系统安装Rust开发环境 现在官方推荐使用 rustup 来安装 Rust 环境。
首先在MSYS2的终端机上执行以下指令：
curl https://sh.rustup.rs -sSf | sh 注意，在 Windows 上面，Rust 编译需要 Visual C++ Build Tools。请先安装这个之后再安装 rustup。
安装程式可能会提示说需要微软的Visual C++ Build Tools。不要理它，输入「y」继续。
选择第二个选项，自定义Rust要如何安装
host triple的部份，输入「x86_64-pc-windows-gnu」，也就是我们的Rust编译器预设使用的目标(target)名称。
接着输入Rust的版本，建议使用「stable」，如果有nightly需求的话就用「nightly」吧！
概要文件(要安装哪些工具和数据)?(最小/违约/完成) Profile (which tools and data to install)? (minimal/default/complete)
default
接着设定是否要修改「PATH」环境变数，输入「y」。
然后回到选单，选择第一项，开始用我们刚才的设定来安装Rust。
更新与卸载 更新所有 Rust，运行：
rustup update 校验Rust编译环境
rustc --versioncargo --version 检查 rustup 自身是否有更新：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/Windward-C-%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/Windward-C-%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid>
      <description>Windward C 语言开发环境配置 1、下载安装 MSYS2 MSYS2官方网站：http://www.msys2.org/
清华大学开源镜像：https://mirrors.tuna.tsinghua.edu.cn/help/msys2/
中国科学技术大学源 https://mirrors.ustc.edu.cn/help/msys2.html
2、修改软件源： 可修改 中科大源 或者 清华大学 源
3、配置更新 执行 pacman -Sy 刷新软件包数据即可。 执行 pacman-key &amp;ndash;init
pacman -Syu
更新软件，更新过程中可能要求重新打开终端，另外更新的时候，pacman的软件源可能恢复到默认，需要手动再修改一次。 gpg: 警告：服务器 ‘gpg-agent’ 比我们的版本更老 （2.2.19-unknown &amp;lt; 2.2.20-unknown） gpg: 注意： 过时的服务器可能缺少重要的安全修复。 gpg: 注意： 使用 “gpgconf &amp;ndash;kill all” 来重启他们。
4、安装工具链 pacman -S mingw-w64-x86_64-cmake mingw-w64-x86_64-extra-cmake-modules pacman -S mingw-w64-x86_64-make pacman -S mingw-w64-x86_64-gdb pacman -S mingw-w64-x86_64-toolchain 命令出错可重新执行。
5、安装GTK3及其依赖项 运行： pacman -S mingw-w64-x86_64-gtk3 pacman -S mingw-w64-x86_64-gtk4
步骤5（可选）：安装构建工具 如果要用其他语言（例如C，C ++，Fortran等）开发GTK3应用程序，则需要像gcc和其他开发工具这样的编译器： pacman -S mingw-w64-x86_64-toolchain base-devel</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/WSL/WSL2-1%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/WSL/WSL2-1%E6%A6%82%E8%BF%B0/</guid>
      <description>WSL2 概述 什么是 WSL？ 适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。
您可以：
在 Microsoft Store 中选择你偏好的 GNU/Linux 分发版。 运行常用的命令行软件工具（例如 grep、sed、awk）或其他 ELF-64 二进制文件。 运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括： 工具：vim、emacs、tmux 语言：NodeJS、Javascript、Python、Ruby、C/C++、C# 与 F#、Rust、Go 等 服务：SSHD、MySQL、Apache、lighttpd、MongoDB、PostgreSQL。 使用自己的 GNU/Linux 分发包管理器安装其他软件。 使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。 在 Windows 上调用 GNU/Linux 应用程序。 WSL 的基本命令 安装 PowerShell 命令：
wsl --install 安装特定的 Linux 发行版 PowerShell 命令：
wsl --install --distribution &amp;lt;Distribution Name&amp;gt; 通过将 替换为发行版名称，指定除默认发行版 (Ubuntu) 之外的 Linux 发行版进行安装。 此命令也可输入为：wsl -d 。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/WSL/WSL2-2%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/WSL/WSL2-2%E5%AE%89%E8%A3%85/</guid>
      <description>WSL2 安装 安装？ https://docs.microsoft.com/zh-cn/windows/wsl/install</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/WSL/WSL2-3%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/WSL/WSL2-3%E6%95%99%E7%A8%8B/</guid>
      <description> WSL2 教程 入门？ 更新和升级包 Bash 命令：
sudo apt update &amp;amp;&amp;amp; sudo apt upgrade 建议使用发行版的首选包管理器定期更新和升级包。 对于 Ubuntu 或 Debian，请使用以下命令：
文件存储 若要在 Windows 文件资源管理器中打开 WSL 项目，请输入：explorer.exe . 请确保在命令的末尾添加句点以打开当前目录。 将项目文件与计划使用的工具存储在相同的操作系统上。 若想获得最快的性能速度，请将文件存储在 WSL 文件系统中，前提是使用 Linux 工具在 Linux 命令行（Ubuntu、OpenSUSE 等）中处理这些文件。 如果是使用 Windows 工具在 Windows 命令行（PowerShell、命令提示符）中工作，请将文件存储在 Windows 文件系统中。 可以跨操作系统访问文件，但这可能会显著降低性能。 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/x64dbg/x64dbg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/x64dbg/x64dbg/</guid>
      <description> x64dbg </description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/8IDE/%E6%82%A8%E7%9A%84%E6%9C%AC%E5%9C%B0-Git-%E6%8F%90%E4%BA%A4%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%9C%AA%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%82%A8%E7%9A%84%E5%B8%90%E6%88%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/8IDE/%E6%82%A8%E7%9A%84%E6%9C%AC%E5%9C%B0-Git-%E6%8F%90%E4%BA%A4%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80%E6%9C%AA%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%82%A8%E7%9A%84%E5%B8%90%E6%88%B7/</guid>
      <description>在 Git 中设置您的提交电子邮件地址 您可以使用 git config 命令更改与 Git 提交关联的电子邮件地址。 您设置的新电子邮件地址将在从命令行推送到 GitHub.com 的任何未来提交中显示。 在您更改提交电子邮件地址之前进行的任何提交仍与之前的电子邮件地址关联。
为计算机上的每个仓库设置电子邮件地址 打开 Git Bash。 在 Git 中设置电子邮件地址。 您可以使用 GitHub 提供的 no-reply 电子邮件地址或任何电子邮件地址。 $ git config &amp;ndash;global user.email &amp;ldquo;email@example.com&amp;rdquo; 确认在 Git 中正确设置了电子邮件地址： $ git config &amp;ndash;global user.email email@example.com 将电子邮件地址添加到您在 GitHub 上的帐户，以便您的提交归因于您并且出现在您的贡献图中。 更多信息请参阅“添加电子邮件地址到 GitHub 帐户”。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://www.saveload.cn/Tech/9Archive/CPU-%E9%AB%98%E8%B4%9F%E8%BD%BD%E6%8E%92%E6%9F%A5%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.saveload.cn/Tech/9Archive/CPU-%E9%AB%98%E8%B4%9F%E8%BD%BD%E6%8E%92%E6%9F%A5%E5%AE%9E%E8%B7%B5/</guid>
      <description>CPU 高负载排查实践 作者：crossoverJie
segmentfault.com/a/1190000019507028
问题分析 1、首先利用 top -c 将系统资源使用情况实时显示出来 （-c 参数可以完整显示命令）。获得Java应用 pid 接着输入大写 P 将应用按照 CPU 使用率排序，第一个就是使用率最高的程序。 常规操作第二步自然是得知道这个应用中最耗 CPU 的线程到底再干嘛。 2、利用 top -Hp pid 然后输入 P 依然可以按照 CPU 使用率将线程排序。**** pid 是第一步获得的，获得3步所需pid**** 3、这时我们只需要记住线程的 ID 将其转换为 16 进制存储起来，通过 jstack pid &amp;gt;pid.log 生成日志文件，利用刚才保存的 16 进制进程 ID 去这个线程快照中搜索即可知道消耗 CPU 的线程在干啥了。4856 如果你嫌麻烦，我也强烈推荐阿里开源的问题定位神器 arthas 来定位问题。 比如上述操作便可精简为一个命令 thread -n 3 即可将最忙碌的三个线程快照打印出来，非常高效。 最忙绿的线程是一个 GC 线程，也就意味着它在忙着做垃圾回收。 GC 查看 排查到这里，有经验的老司机一定会想到：多半是应用内存使用有问题导致的。 于是我通过 jstat -gcutil pid 200 50 将内存使用、gc 回收状况打印出来（每隔 200ms 打印 50次）。 内存分析 既然是初步定位是内存问题，所以还是得拿一份内存快照分析才能最终定位到问题。 通过命令 jmap -dump:live,format=b,file=dump.</description>
    </item>
    
  </channel>
</rss>
